<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Amazon Computing Service</title>
    <url>/2024/01/09/Amazon-Computing-Service/</url>
    <content><![CDATA[<h1 id="无服务器计算">无服务器计算</h1>
<p><strong>无法访问底层基础设备，运维工作交给服务提供者(AWS)解决</strong></p>
<p>“无服务器”一词是指代码在服务器上运行，但无需预置或管理这些服务器。借助无服务器计算，您可以将更多精力放在新产品和功能创新上，而不是放在维护服务器上。</p>
<p>无服务器计算的另一项优势在于可以灵活地自动扩展无服务器应用程序。无服务器计算可以通过修改使用单位（例如吞吐量和内存）来调整应用程序的容量。</p>
<p>AWS 的无服务器计算服务是 <strong>AWS Lambda</strong>。</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20240109145955273.png" alt=" " style="zoom:50%;" /></p>
<p><strong>AWS Lambda的工作原理</strong></p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20240109150049431.png" style="zoom:50%;" /></p>
<ul>
<li>将代码上传到 Lambda。</li>
<li>将代码设置为从事件源（例如 AWS 服务、移动应用程序或 HTTP 终端节点）触发。</li>
<li>Lambda 仅在触发时才运行代码。</li>
<li>只需为使用的计算时间付费。</li>
</ul>
<p>事件触发类似于Webhook(GitLab -&gt; Jenkins)</p>
<h1 id="amazon-elastic-container-service-amazon-ecs"><strong>Amazon Elastic Container Service (Amazon ECS)</strong></h1>
<p><a href="https://aws.amazon.com/ecs/"><strong>Amazon Elastic Container Service (Amazon ECS)</strong>(opens in a new tab)</a> 是一种高度可扩展的高性能容器管理系统，可以在 AWS 上运行和扩展容器化应用程序。</p>
<p>Amazon ECS 支持 Docker 容器。<a href="https://www.docker.com/">Docker(opens in a new tab)</a> 是一种软件平台，让您能够快速构建、测试和部署应用程序。AWS 支持使用开源 Docker 社区版和基于订阅的 Docker 企业版。借助 Amazon ECS，您可以使用 API 调用来启动和停止支持 Docker 的应用程序。</p>
<h1 id="amazon-elastic-kubernetes-service-amazon-eks"><strong>Amazon Elastic Kubernetes Service (Amazon EKS)</strong></h1>
<p><a href="https://aws.amazon.com/eks/"><strong>Amazon Elastic Kubernetes Service (Amazon EKS)</strong>(opens in a new tab)</a> 是一项完全托管式服务，可用于在 AWS 上运行 Kubernetes。</p>
<p><a href="https://kubernetes.io/">Kubernetes(opens in a new tab)</a> 是一款开源软件，让您能够大规模部署和管理容器化应用程序。Kubernetes 由一个大型志愿者社区维护，而 AWS 积极地与 Kubernetes 社区展开合作。随着 Kubernetes 应用程序的新功能特性发布，您可以轻松地将这些更新应用到由 Amazon EKS 管理的应用程序中。</p>
<h1 id="aws-fargate"><strong>AWS Fargate</strong></h1>
<p><a href="https://aws.amazon.com/fargate/"><strong>AWS Fargate</strong>(opens in a new tab)</a> 是一种适用于容器的无服务器计算引擎。它可与 Amazon ECS 和 Amazon EKS 一起使用。</p>
<p>使用 AWS Fargate 时，无需预置或管理服务器。AWS Fargate 为您管理服务器基础设施。您可以更加专注于应用程序的创新和开发，并且只需为运行容器所需的资源付费。</p>
]]></content>
      <categories>
        <category>AWS</category>
        <category>AWS Cloud Practitioner Essentials</category>
      </categories>
      <tags>
        <tag>Cloud Computing</tag>
        <tag>AWS</tag>
        <tag>AWS Cloud Practitioner Essentials</tag>
      </tags>
  </entry>
  <entry>
    <title>Amazon EC2 Auto Scaling</title>
    <url>/2024/01/09/AWS-Cloud-Practitioner-Essentials/</url>
    <content><![CDATA[<h1 id="amazon-ec2-auto-scaling">Amazon EC2 Auto Scaling</h1>
<h2 id="介绍">介绍</h2>
<p>利用 <strong>Amazon EC2 Auto Scaling</strong>自动添加或删除 Amazon EC2 实例，以响应不断变化的应用程序需求。根据需要<strong>自动缩减</strong>和<strong>扩展</strong>实例，能够保持更好的应用程序可用性。</p>
<p><strong>EC2 Auto Scaling与Kubernetes中的HPA，deployments(滚动更新)十分相似 </strong></p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20240109143130508.png" /></p>
<h2 id="拓展方案动态拓展和预测性拓展">拓展方案：动态拓展和预测性拓展</h2>
<ol type="1">
<li><em>动态扩展</em>可以响应不断变化的需求</li>
<li><em>预测性扩展</em>根据预测的需求自动安排合适数量的 Amazon EC2 实例</li>
</ol>
<p>预测性拓展使用场景：业务量根据时间(比如限时活动)或者季节有比较大的浮动</p>
<p><strong>建议可以结合使用动态扩展和预测性扩展</strong></p>
<h2 id="示例">示例</h2>
<p>在云中，计算能力是一种编程资源，因此可以采取更灵活的方法来解决扩展问题。通过向应用程序添加 Amazon EC2 Auto Scaling 功能，可以在需要时向应用程序添加新实例，并在不再需要这些实例时终止它们。</p>
<p>假设在 Amazon EC2 实例上启动一个应用程序。在配置 Auto Scaling 组的大小时，您可以将 Amazon EC2 实例的最小数量设置为 1。这意味着在任何时候都必须至少运行一个 Amazon EC2 实例。</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20240109143759290.png" /></p>
]]></content>
      <categories>
        <category>AWS</category>
        <category>AWS Cloud Practitioner Essentials</category>
      </categories>
      <tags>
        <tag>Cloud Computing</tag>
        <tag>AWS</tag>
        <tag>AWS Cloud Practitioner Essentials</tag>
      </tags>
  </entry>
  <entry>
    <title>gap between me and top algorithm experts</title>
    <url>/2023/11/18/gap-between-me-and-top-algorithm-experts/</url>
    <content><![CDATA[<p>距离上一次打比赛要追溯到上个月<code>leetcode cup 367</code>，虽然第二题意外WA了四次，还是成功AK。秋招拿了4个offer，休息了一个多月。</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20231118104812521.png" /></p>
<p>今天无聊做了做每日一题，看完数据范围，设计好方法后，感觉我真是个天才，ac后看了灵神的题解，自愧不如。。。</p>
<h2 id="数位和相等数对的最大和"><a href="https://leetcode.cn/problems/max-sum-of-a-pair-with-equal-sum-of-digits/">2342. 数位和相等数对的最大和</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20231118105114138.png" /></p>
<h3 id="my-proposed-method">my proposed method</h3>
<p><strong>要求数位和(digit sum)相等的数组元素中最大的数组元素和</strong>，看数据范围，<span class="math inline">\(nums[i] \in [1, 10^9]\)</span>，那么极限范围是999999999，数位和最大<strong>81</strong>，那我创建82个treemap，遍历完数组后，降序从treemap中找答案不就行了，easy</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximumSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length, res = -<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// nums最大1e9,9个9相加是81</span><br>        <span class="hljs-comment">// treemap中存放数位和相同的数组元素</span><br>        TreeMap&lt;Integer, Integer&gt;[] maps = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>[<span class="hljs-number">82</span>];<br>        Arrays.setAll(maps, e -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : nums) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">bitSum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, num = x;<br>             <span class="hljs-keyword">while</span> (num &gt; <span class="hljs-number">0</span>) &#123;<br>                 bitSum += num % <span class="hljs-number">10</span>;<br>                 num /= <span class="hljs-number">10</span>;<br>             &#125;<br>             TreeMap&lt;Integer, Integer&gt; map = maps[bitSum];<br>             map.put(x, map.getOrDefault(x, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">81</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            TreeMap&lt;Integer, Integer&gt; map = maps[i];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">key1</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> key : map.descendingKeySet()) &#123;<br>                <span class="hljs-keyword">if</span> (key1 == -<span class="hljs-number">1</span> &amp;&amp; map.get(key) &gt;= <span class="hljs-number">2</span>) &#123;<br>                    res = Math.max(res, key * <span class="hljs-number">2</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key1 == -<span class="hljs-number">1</span> &amp;&amp; map.get(key) == <span class="hljs-number">1</span>)<br>                    key1 = key;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key1 != -<span class="hljs-number">1</span>) &#123;<br>                    res = Math.max(res, key1 + key);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span>  res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="expert-solution">expert solution</h3>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20231118105554033.png" /></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maximumSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        ans = -<span class="hljs-number">1</span><br>        mx = [<span class="hljs-number">0</span>] * <span class="hljs-number">82</span>  <span class="hljs-comment"># 至多 9 个 9 相加</span><br>        <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums:<br>            <span class="hljs-comment"># s = sum(map(int, str(num)))</span><br>            <span class="hljs-comment"># 不转成 str，效率更高</span><br>            s = <span class="hljs-number">0</span><br>            x = num<br>            <span class="hljs-keyword">while</span> x:  <span class="hljs-comment"># 枚举 num 的每个数位</span><br>                s += x % <span class="hljs-number">10</span><br>                x //= <span class="hljs-number">10</span><br>            <span class="hljs-keyword">if</span> mx[s]:  <span class="hljs-comment"># 说明左边也有数位和等于 s 的元素</span><br>                ans = <span class="hljs-built_in">max</span>(ans, mx[s] + num)  <span class="hljs-comment"># 更新答案的最大值</span><br>            mx[s] = <span class="hljs-built_in">max</span>(mx[s], num)  <span class="hljs-comment"># 维护数位和等于 s 的最大元素</span><br>        <span class="hljs-keyword">return</span> ans<br>	<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>.*</category>
      </categories>
      <tags>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title>lcp366</title>
    <url>/2023/10/09/lcp366/</url>
    <content><![CDATA[<h2 id="分类求和并作差"><a href="https://leetcode.cn/problems/divisible-and-non-divisible-sums-difference/">2894. 分类求和并作差</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20231009184520360.png" /></p>
<h3 id="方法一求和公式">方法一：求和公式</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">differenceOfSums</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m)</span> &#123;<br>        <span class="hljs-comment">// 能被m整除的和 s1 = m + 2m + 3m + ... + n / m * m</span><br>        <span class="hljs-comment">// = m(1 + 2 + 3 + ... + n / m) = m * (n / m * (1 + n / m) / 2)</span><br>        <span class="hljs-comment">// 不能被m整除的和 s2 = n * (1 + n) / 2 - s1</span><br>        <span class="hljs-comment">// res = s2 - s1 </span><br>        <span class="hljs-keyword">return</span> n * (<span class="hljs-number">1</span> + n) / <span class="hljs-number">2</span> - n / m * m * (<span class="hljs-number">1</span> + n / m);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="最小处理时间"><a href="https://leetcode.cn/problems/minimum-processing-time/">2895. 最小处理时间</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20231009184556133.png" /></p>
<h3 id="方法一贪心">方法一：贪心</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minProcessingTime</span><span class="hljs-params">(List&lt;Integer&gt; processorTime, List&lt;Integer&gt; tasks)</span> &#123;<br>        Collections.sort(processorTime);<br>        Collections.sort(tasks, ((o1, o2) -&gt; o2 - o1));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> processorTime.size(), res = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span> * n; i += <span class="hljs-number">4</span>) &#123;<br>            res = Math.max(res, processorTime.get(index) + tasks.get(i));<br>            index++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="执行操作使两个字符串相等"><a href="https://leetcode.cn/problems/apply-operations-to-make-two-strings-equal/">2896. 执行操作使两个字符串相等</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20231009192344128.png" /></p>
<h3 id="方法一记忆化搜索">方法一：记忆化搜索</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minOperations</span><span class="hljs-params">(String s1, String s2, <span class="hljs-type">int</span> x)</span> &#123;<br>        n = s1.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, cnt2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (s1.charAt(i) == <span class="hljs-string">&#x27;1&#x27;</span>)<br>                ++cnt1;<br>            <span class="hljs-keyword">if</span> (s2.charAt(i) == <span class="hljs-string">&#x27;1&#x27;</span>)<br>                ++cnt2;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (cnt1 % <span class="hljs-number">2</span> != cnt2 % <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">this</span>.s1 = s1;<br>        <span class="hljs-built_in">this</span>.s2 = s2;<br>        <span class="hljs-built_in">this</span>.x = x;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n + <span class="hljs-number">1</span>][<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[][] a : dp)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] b : a)<br>                Arrays.fill(b, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> key, <span class="hljs-type">boolean</span> reverse)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &gt;= n)<br>            <span class="hljs-keyword">return</span> key == <span class="hljs-number">0</span> &amp;&amp; !reverse ? <span class="hljs-number">0</span> : inf;<br>        <span class="hljs-keyword">if</span> (dp[index][key][reverse ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[index][key][reverse ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>];<br>        <span class="hljs-type">char</span> <span class="hljs-variable">ch1</span> <span class="hljs-operator">=</span> s1.charAt(index), ch2 = s2.charAt(index);<br>        <span class="hljs-keyword">if</span> ((ch1 == ch2) == !reverse)<br>            <span class="hljs-keyword">return</span> dp[index][key][reverse ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>] = dfs(index + <span class="hljs-number">1</span>, key, <span class="hljs-literal">false</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Math.min(dfs(index + <span class="hljs-number">1</span>, key + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>) + x, dfs(index + <span class="hljs-number">1</span>, key, <span class="hljs-literal">true</span>) + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (key &gt; <span class="hljs-number">0</span>)<br>            res = Math.min(res, dfs(index + <span class="hljs-number">1</span>, key - <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>));<br>        <span class="hljs-keyword">return</span> dp[index][key][reverse ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>] = res;<br>    &#125;<br><br>    String s1, s2;<br>    <span class="hljs-type">int</span> x, inf = Integer.MAX_VALUE &gt;&gt; <span class="hljs-number">1</span>, n;<br>    <span class="hljs-type">int</span>[][][] dp;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Contest</category>
        <category>LCP</category>
      </categories>
      <tags>
        <tag>力扣杯</tag>
      </tags>
  </entry>
  <entry>
    <title>lcpBi114</title>
    <url>/2023/10/01/lcpBi114/</url>
    <content><![CDATA[<h2 id="收集元素的最少操作次数"><a href="https://leetcode.cn/problems/minimum-operations-to-collect-elements/">8038. 收集元素的最少操作次数</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20231001145031365.png" /></p>
<h3 id="方法一hashset">方法一：HashSet</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minOperations</span><span class="hljs-params">(List&lt;Integer&gt; nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.size();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> nums.get(i);<br>            set.add(x);<br>            ++res;<br>            <span class="hljs-keyword">if</span> (check(set, k))<br>                <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(Set&lt;Integer&gt; set, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= k; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (!set.contains(i))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="使数组为空的最少操作次数"><a href="https://leetcode.cn/problems/minimum-number-of-operations-to-make-array-empty/">100032. 使数组为空的最少操作次数</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20231001145133115.png" /></p>
<h2 id="方法一hashmap">方法一：HashMap</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minOperations</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Map&lt;Integer, Integer&gt; cnt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : nums)<br>            cnt.put(x, cnt.getOrDefault(x, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : cnt.values()) &#123;<br>            <span class="hljs-keyword">if</span> (x == <span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> x / <span class="hljs-number">3</span>;<br>            <span class="hljs-keyword">if</span> (x % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>)<br>                res += a;<br>            <span class="hljs-keyword">else</span> &#123;<br>                res += a + <span class="hljs-number">1</span>;<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="将数组分割成最多数目的子数组"><a href="https://leetcode.cn/problems/split-array-into-maximum-number-of-subarrays/">100019. 将数组分割成最多数目的子数组</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20231001150049088.png" /></p>
<h3 id="方法一二分查找-贪心">方法一：二分查找 + 贪心</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubarrays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">//二分</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt0</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, cur = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : nums) &#123;<br>            <span class="hljs-keyword">if</span> (flag) &#123;<br>                cur = x;<br>                flag = <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                cur &amp;= x;<br>            <span class="hljs-keyword">if</span> (cur == <span class="hljs-number">0</span>) &#123;<br>                ++cnt0;<br>                flag = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> cnt0, r = n;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : nums)<br>            target &amp;= x;<br>        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (check(nums, mid, target))<br>                l = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                r = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, cur = nums[<span class="hljs-number">0</span>], cnt = <span class="hljs-number">0</span>, n = nums.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> nums[i];<br>            cur &amp;= x;<br>            <span class="hljs-keyword">if</span> (cur &lt;= target &amp;&amp; sum + cur &lt;= target) &#123;<br>                ++cnt;<br>                sum += cur;<br>                <span class="hljs-keyword">if</span> (i == n - <span class="hljs-number">1</span>)<br>                    <span class="hljs-keyword">break</span>;<br>                cur = nums[i + <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt &gt;= k &amp;&amp; sum == target;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="可以被-k-整除连通块的最大数目"><a href="https://leetcode.cn/problems/maximum-number-of-k-divisible-components/">2872. 可以被 K 整除连通块的最大数目</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20231001151059365.png" /></p>
<h3 id="方法一树形dp">方法一：树形DP</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxKDivisibleComponents</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] edges, <span class="hljs-type">int</span>[] values, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-built_in">this</span>.k = k;<br>        <span class="hljs-built_in">this</span>.values = values;<br>        g = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[n];<br>        Arrays.setAll(g, e -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] e : edges) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> e[<span class="hljs-number">0</span>], b = e[<span class="hljs-number">1</span>];<br>            g[a].add(b);<br>            g[b].add(a);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>];<br>    &#125;<br>    List&lt;Integer&gt;[] g;<br>    <span class="hljs-type">int</span> k;<br>    <span class="hljs-type">int</span>[] values;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] dfs(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> p) &#123;<br>        <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>        arr[<span class="hljs-number">1</span>] = values[x];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> next : g[x]) &#123;<br>            <span class="hljs-keyword">if</span> (next != p) &#123;<br>                <span class="hljs-type">int</span>[] temp = dfs(next, x);<br>                arr[<span class="hljs-number">0</span>] += temp[<span class="hljs-number">0</span>];<br>                arr[<span class="hljs-number">1</span>] += temp[<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (arr[<span class="hljs-number">1</span>] % k == <span class="hljs-number">0</span>) &#123;<br>            arr[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>            arr[<span class="hljs-number">0</span>]++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Contest</category>
        <category>LCP</category>
      </categories>
      <tags>
        <tag>力扣杯</tag>
      </tags>
  </entry>
  <entry>
    <title>lcp365</title>
    <url>/2023/10/01/lcp365/</url>
    <content><![CDATA[<h2 id="有序三元组中的最大值-i"><a href="https://leetcode.cn/problems/maximum-value-of-an-ordered-triplet-i/">100088. 有序三元组中的最大值 I</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20231001140026281.png" /></p>
<h3 id="方法一暴力">方法一：暴力</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">maximumTripletValue</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length, res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> j + <span class="hljs-number">1</span>; k &lt; n; ++k) &#123;<br>                    res = Math.max(res, (<span class="hljs-type">long</span>) (nums[i] - nums[j]) * nums[k]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.max(res, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="有序三元组中的最大值-ii"><a href="https://leetcode.cn/problems/maximum-value-of-an-ordered-triplet-ii/">100086. 有序三元组中的最大值 II</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20231001140117899.png" /></p>
<h3 id="方法一滑动窗口">方法一：滑动窗口</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">maximumTripletValue</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length, l = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, diff = <span class="hljs-number">0</span>, preMax = Integer.MIN_VALUE, maxK = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n - <span class="hljs-number">1</span>; ++i) &#123;<br>            diff = nums[l] - nums[i];<br>            <span class="hljs-keyword">if</span> (nums[l] &lt; nums[i])<br>                l = i;<br>            <span class="hljs-keyword">if</span> (preMax &lt; diff) <br>                preMax = diff;<br>            res = Math.max(res, preMax * nums[i + <span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.max(res, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二维护左右最大值">方法二：维护左右最大值</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">maximumTripletValue</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, max = nums[n - <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span>[] l = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        l[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; ++i)<br>            l[i] = Math.max(nums[i], l[i - <span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            res = Math.max(res, (l[i] - nums[i]) * max);<br>            max = Math.max(max, nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.max(res, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="无限数组的最短子数组"><a href="https://leetcode.cn/problems/minimum-size-subarray-in-infinite-array/">100076. 无限数组的最短子数组</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20231001140913602.png" /></p>
<h3 id="方法二滑动窗口">方法二：滑动窗口</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSizeSubarray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length, res = Integer.MAX_VALUE / <span class="hljs-number">2</span>, sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : nums)<br>            sum += x;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> target / sum;<br>        target = target % sum;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span> * n; ++i) &#123;<br>            s += nums[i % n];<br>            <span class="hljs-keyword">while</span> (s &gt; target) &#123;<br>                s -= nums[l % n];<br>                ++l;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (s == target)<br>                res = Math.min(res, i - l + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res == Integer.MAX_VALUE / <span class="hljs-number">2</span> ? -<span class="hljs-number">1</span> : res + cnt * n;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法一前缀和-hashmap">方法一：前缀和 + HashMap</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSizeSubarray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> t)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE / <span class="hljs-number">2</span>;<br>        Map&lt;Long, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span> * n];<br>        <span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, target = t;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span> * n; ++i) &#123;<br>            arr[i] = nums[i % n];<br>            <span class="hljs-keyword">if</span> (i &lt; n)<br>                sum += nums[i];<br>        &#125;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">extra</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (target &gt;= <span class="hljs-number">2</span> * sum) &#123;<br>            extra = target / sum * n;<br>            target %= sum;<br>            flag = <span class="hljs-literal">true</span>;<br>        &#125;<br>        sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">find</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span> * n; ++i) &#123;<br>            sum += arr[i];<br>            map.put(sum, i);<br>            <span class="hljs-keyword">if</span> (map.containsKey(sum - target)) &#123;<br>                find = <span class="hljs-literal">true</span>;<br>                res = Math.min(res, i - map.get(sum - target));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (flag)<br>            res += extra;<br>        <span class="hljs-keyword">return</span> !find ? -<span class="hljs-number">1</span> : (<span class="hljs-type">int</span>) res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="有向图访问计数"><a href="https://leetcode.cn/problems/count-visited-nodes-in-a-directed-graph/">2876. 有向图访问计数</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20231003221818802.png" /></p>
<h3 id="方法一拓扑排序-反向图">方法一：拓扑排序 + 反向图</h3>
<p>注意<strong>内向基环图</strong>可以包含多个环！！！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] countVisitedNodes(List&lt;Integer&gt; g) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> g.size();<br>        <span class="hljs-type">int</span>[] degree = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        List&lt;Integer&gt;[] rg = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[n];<br>        Arrays.setAll(rg, e -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">from</span> <span class="hljs-operator">=</span> i, to = g.get(i);<br>            degree[to]++;<br>            rg[to].add(from);<br>        &#125;<br>        Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            <span class="hljs-keyword">if</span> (degree[i] == <span class="hljs-number">0</span>)<br>                queue.offer(i);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> g.get(node);<br>            <span class="hljs-keyword">if</span> (--degree[next] == <span class="hljs-number">0</span>)<br>                queue.offer(next);<br>        &#125;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (degree[i] &lt;= <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            List&lt;Integer&gt; ring = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                ring.add(j);<br>                degree[j] = -<span class="hljs-number">1</span>;<br>                j = g.get(j);<br>                <span class="hljs-keyword">if</span> (j == i)<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : ring)<br>                dfs(x, ring.size(), rg, res, degree);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> size, List&lt;Integer&gt;[] rg, <span class="hljs-type">int</span>[] res, <span class="hljs-type">int</span>[] degree)</span> &#123;<br>        res[x] = size;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> next : rg[x]) &#123;<br>            <span class="hljs-keyword">if</span> (degree[next] == <span class="hljs-number">0</span>)<br>                dfs(next, size + <span class="hljs-number">1</span>, rg, res, degree);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Contest</category>
        <category>LCP</category>
      </categories>
      <tags>
        <tag>力扣杯</tag>
      </tags>
  </entry>
  <entry>
    <title>lcp364</title>
    <url>/2023/09/24/lcp364/</url>
    <content><![CDATA[<h2 id="最大二进制奇数"><a href="https://leetcode.cn/problems/maximum-odd-binary-number/">8048. 最大二进制奇数</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230924140325370.png" /></p>
<h3 id="方法一贪心">方法一：贪心</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">maximumOddBinaryNumber</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length(), cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">&#x27;1&#x27;</span>)<br>                ++cnt;<br>        <span class="hljs-keyword">if</span> (cnt == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> s;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; cnt - <span class="hljs-number">1</span>; ++i)<br>            sb.append(<span class="hljs-string">&#x27;1&#x27;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - cnt; ++i)<br>            sb.append(<span class="hljs-string">&#x27;0&#x27;</span>);<br>        sb.append(<span class="hljs-string">&#x27;1&#x27;</span>);<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="美丽塔-i"><a href="https://leetcode.cn/problems/beautiful-towers-i/">100049. 美丽塔 I</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230924140426094.png" /></p>
<h3 id="方法一暴力on2">方法一：暴力<span class="math inline">\(O(n^2)\)</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">maximumSumOfHeights</span><span class="hljs-params">(List&lt;Integer&gt; nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.size();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> nums.get(i), pre = x;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> x;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; --j) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> nums.get(j);<br>                <span class="hljs-keyword">if</span> (y &gt; pre)<br>                    y = pre;<br>                sum += y;<br>                pre = y;<br>            &#125;<br>            pre = x;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> nums.get(j);<br>                <span class="hljs-keyword">if</span> (y &gt; pre)<br>                    y = pre;<br>                sum += y;<br>                pre = y;<br>            &#125;<br>            res = Math.max(res, sum);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="美丽塔-ii"><a href="https://leetcode.cn/problems/beautiful-towers-ii/">100048. 美丽塔 II</a></h2>
]]></content>
      <categories>
        <category>Contest</category>
        <category>LCP</category>
      </categories>
      <tags>
        <tag>力扣杯</tag>
      </tags>
  </entry>
  <entry>
    <title>lcpBi113</title>
    <url>/2023/09/17/lcpBi113/</url>
    <content><![CDATA[<h2 id="使数组成为递增数组的最少右移次数"><a href="https://leetcode.cn/problems/minimum-right-shifts-to-sort-the-array/">8039. 使数组成为递增数组的最少右移次数</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230917142543913.png" /></p>
<h3 id="方法一模拟">方法一：模拟</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumRightShifts</span><span class="hljs-params">(List&lt;Integer&gt; nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.size();<br>        <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            arr[i] = nums.get(i);<br>        &#125;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (nums.get(i) &lt; nums.get(i - <span class="hljs-number">1</span>))<br>                flag = <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (flag)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br><br>        <span class="hljs-type">int</span>[] temp = arr.clone();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                arr[(j + <span class="hljs-number">1</span>) % n] = temp[j];<br>            &#125;<br>            flag = <span class="hljs-literal">true</span>;<br>           <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; ++j) &#123;<br>               <span class="hljs-keyword">if</span> (arr[j] &lt; arr[j - <span class="hljs-number">1</span>]) &#123;<br>                   flag = <span class="hljs-literal">false</span>;<br>                   <span class="hljs-keyword">break</span>;<br>               &#125;<br>           &#125;<br>           <span class="hljs-keyword">if</span> (flag)<br>               <span class="hljs-keyword">return</span> i;<br>           temp = arr;<br>           arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二on">方法二：O(n)</h3>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230917151451481.png" /></p>
<h2 id="删除数对后的最小数组长度"><a href="https://leetcode.cn/problems/minimum-array-length-after-pair-removals/">2856. 删除数对后的最小数组长度</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230917142633225.png" /></p>
<h3 id="方法一treemap二分">方法一：TreeMap二分</h3>
<p><strong>同lcp334 t3</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minLengthAfterRemovals</span><span class="hljs-params">(List&lt;Integer&gt; nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.size();<br>        TreeMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n / <span class="hljs-number">2</span> + (n % <span class="hljs-number">2</span>); i &lt; n; ++i)<br>            map.put(nums.get(i), map.getOrDefault(nums.get(i), <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> n;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n / <span class="hljs-number">2</span>; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> nums.get(i);<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">ceil</span> <span class="hljs-operator">=</span> map.higherKey(x);<br>            <span class="hljs-keyword">if</span> (ceil == <span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">else</span> &#123;<br>                res -= <span class="hljs-number">2</span>;<br>                map.put(ceil, map.get(ceil) - <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span> (map.get(ceil) == <span class="hljs-number">0</span>)<br>                    map.remove(ceil);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="统计距离为-k-的点对"><a href="https://leetcode.cn/problems/count-pairs-of-points-with-distance-k/">6988. 统计距离为 k 的点对</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230917142733384.png" /></p>
<h3 id="方法一前缀和-hashmap">方法一：前缀和 + HashMap</h3>
<p><strong>两数之和</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countPairs</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; coordinates, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Map&lt;Long, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (List&lt;Integer&gt; arr : coordinates) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> arr.get(<span class="hljs-number">0</span>), y = arr.get(<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; ++i) &#123;<br>                <span class="hljs-type">long</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> x ^ i, t2 = y ^ (k - i);<br>                res += map.getOrDefault((t1 &lt;&lt; <span class="hljs-number">32</span>) | t2, <span class="hljs-number">0</span>);<br>            &#125;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> ((<span class="hljs-type">long</span>) x &lt;&lt; <span class="hljs-number">32</span>) | y;<br>            map.put(key, map.getOrDefault(key, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        System.out.println();<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) res;<br>    &#125; <br><br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Contest</category>
        <category>LCP</category>
      </categories>
      <tags>
        <tag>力扣杯</tag>
      </tags>
  </entry>
  <entry>
    <title>lcp363</title>
    <url>/2023/09/17/lcp363/</url>
    <content><![CDATA[<h2 id="计算-k-置位下标对应元素的和"><a href="https://leetcode.cn/problems/sum-of-values-at-indices-with-k-set-bits/">100031. 计算 K 置位下标对应元素的和</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230917140405727.png" /></p>
<h3 id="方法一模拟">方法一：模拟</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumIndicesWithKSetBits</span><span class="hljs-params">(List&lt;Integer&gt; nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.size(), res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> Integer.bitCount(i);<br>            <span class="hljs-keyword">if</span> (x == k)<br>                res += nums.get(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="让所有学生保持开心的分组方法数"><a href="https://leetcode.cn/problems/happy-students/">100040. 让所有学生保持开心的分组方法数</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230917140444055.png" /></p>
<h3 id="方法一排序-贪心">方法一：排序 + 贪心</h3>
<p><strong>判断起初和结束位置：即全不选和全选</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countWays</span><span class="hljs-params">(List&lt;Integer&gt; nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.size(), res = <span class="hljs-number">0</span>;<br>        Collections.sort(nums);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (nums.get(<span class="hljs-number">0</span>) != <span class="hljs-number">0</span>)<br>            res++;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++i) &#123;<br>            ++cnt;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> nums.get(i), y = nums.get(i + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (cnt &gt; x &amp;&amp; cnt &lt; y)<br>                ++res;<br>        &#125;<br>        ++cnt;<br>        <span class="hljs-keyword">if</span> (cnt &gt; nums.get(n - <span class="hljs-number">1</span>))<br>            ++res;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="最大合金数"><a href="https://leetcode.cn/problems/maximum-number-of-alloys/">100033. 最大合金数</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230917140542495.png" /></p>
<h3 id="方法一二分查找">方法一：二分查找</h3>
<p><strong>以后二分r都用1e18！！！</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxNumberOfAlloys</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> budget, List&lt;List&lt;Integer&gt;&gt; composition, List&lt;Integer&gt; stock, List&lt;Integer&gt; cost)</span> &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (List&lt;Integer&gt; comp : composition) &#123;<br>                <span class="hljs-type">long</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = Integer.MAX_VALUE;<br>                <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>                    <span class="hljs-type">long</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">if</span> (check(mid, n, budget, comp, stock, cost))<br>                        l = mid + <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">else</span><br>                        r = mid - <span class="hljs-number">1</span>;<br>                &#125;<br>                res = Math.max(res, r);<br>            &#125;<br>            <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) res;<br>        &#125;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">long</span> cnt, <span class="hljs-type">int</span> n, <span class="hljs-type">long</span> budget, List&lt;Integer&gt; comp, List&lt;Integer&gt; stock,List&lt;Integer&gt; cost)</span> &#123;<br>            <span class="hljs-type">long</span>[] <span class="hljs-keyword">requires</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>                <span class="hljs-keyword">requires</span>[i] = Math.max(comp.get(i) * cnt - stock.get(i), <span class="hljs-number">0</span>);<br>                budget -= <span class="hljs-keyword">requires</span>[i] * cost.get(i);<br>            &#125;<br>            <span class="hljs-keyword">return</span> budget &gt;= <span class="hljs-number">0</span>;<br>        &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="完全子集的最大元素和"><a href="https://leetcode.cn/problems/maximum-element-sum-of-a-complete-subset-of-indices/">8041. 完全子集的最大元素和</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230917140814731.png" /></p>
<h3 id="方法一">方法一：</h3>
]]></content>
      <categories>
        <category>Contest</category>
        <category>LCP</category>
      </categories>
      <tags>
        <tag>力扣杯</tag>
      </tags>
  </entry>
  <entry>
    <title>lcp362</title>
    <url>/2023/09/10/lcp362/</url>
    <content><![CDATA[<h2 id="与车相交的点"><a href="https://leetcode.cn/problems/points-that-intersect-with-cars/">8029. 与车相交的点</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230910154508491.png" /></p>
<h3 id="方法一差分数组">方法一：差分数组</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numberOfPoints</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.size(), cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] diff = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">103</span>];<br>        <span class="hljs-keyword">for</span> (List&lt;Integer&gt; list : nums) &#123;<br>            diff[list.get(<span class="hljs-number">0</span>)]++;<br>            diff[list.get(<span class="hljs-number">1</span>) + <span class="hljs-number">1</span>]--;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; diff.length; ++i) &#123;<br>            s += diff[i];<br>            <span class="hljs-keyword">if</span> (s &gt; <span class="hljs-number">0</span>)<br>                ++cnt;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="判断能否在给定时间到达单元格"><a href="https://leetcode.cn/problems/determine-if-a-cell-is-reachable-at-a-given-time/">8049. 判断能否在给定时间到达单元格</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230910161027422.png" /></p>
<h3 id="方法一数学">方法一：数学</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isReachableAtTime</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> fx, <span class="hljs-type">int</span> fy, <span class="hljs-type">int</span> t)</span> &#123;<br>        <span class="hljs-keyword">if</span> (x == fx &amp;&amp; y == fy &amp;&amp; t == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> Math.abs(fx - x), b = Math.abs(fy - y), min = Math.min(a, b);<br>        t -= min;<br>        a -= min;<br>        b -= min;<br>        t = t - a - b;<br>        <span class="hljs-keyword">return</span> t &gt;= <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">List&lt;<span class="hljs-type">int</span>[]&gt; map0 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(), map2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-type">int</span> n, m;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumMoves</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">0</span>)<br>                map0.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, j, <span class="hljs-number">0</span>&#125;);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (grid[i][j] &gt; <span class="hljs-number">1</span>)<br>                map2.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, j, grid[i][j]&#125;);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (map0.isEmpty())<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    n = map2.size();<br>    m = map0.size();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    Queue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-type">boolean</span>[][] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>];<br>    <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, visited);<br><br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">boolean</span>[][] visited)</span> &#123;<br>    <span class="hljs-keyword">if</span> (i == map2.size())<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (j == map0.size())<br>        <span class="hljs-keyword">return</span> map2.get(i)[<span class="hljs-number">2</span>] == <span class="hljs-number">1</span> ? <span class="hljs-number">0</span> : Integer.MAX_VALUE / <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span>[] x = map2.get(i), y = map0.get(j);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pass</span> <span class="hljs-operator">=</span> dfs(i, j + <span class="hljs-number">1</span>, visited), choose = Integer.MAX_VALUE / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (x[<span class="hljs-number">2</span>] &gt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (visited[y[<span class="hljs-number">0</span>]][y[<span class="hljs-number">1</span>]])<br>            choose = dfs(i, j + <span class="hljs-number">1</span>, visited);<br>        <span class="hljs-keyword">else</span> &#123;<br>            visited[y[<span class="hljs-number">0</span>]][y[<span class="hljs-number">1</span>]] = <span class="hljs-literal">true</span>;<br>            map2.get(i)[<span class="hljs-number">2</span>]--;<br>            choose = dfs(i, j + <span class="hljs-number">1</span>, visited) + Math.abs(x[<span class="hljs-number">0</span>] - y[<span class="hljs-number">0</span>]) + Math.abs(x[<span class="hljs-number">1</span>] - y[<span class="hljs-number">1</span>]);<br>            map2.get(i)[<span class="hljs-number">2</span>]++;<br>            visited[y[<span class="hljs-number">0</span>]][y[<span class="hljs-number">1</span>]] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x[<span class="hljs-number">2</span>] == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">xx</span> <span class="hljs-operator">=</span> dfs(i + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, visited);<br>        choose += xx;<br>        pass += xx;<br>    &#125;<br>    <span class="hljs-keyword">return</span> Math.min(pass, choose);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <span class="hljs-keyword">return</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; <span class="hljs-number">3</span> &amp;&amp; j &lt; <span class="hljs-number">3</span>;<br>&#125;<br><br><span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Contest</category>
        <category>LCP</category>
      </categories>
      <tags>
        <tag>力扣杯</tag>
      </tags>
  </entry>
  <entry>
    <title>广联达笔试</title>
    <url>/2023/09/06/%E5%B9%BF%E8%81%94%E8%BE%BE%E7%AC%94%E8%AF%95/</url>
    <content><![CDATA[<h3 id="方法线性二分-dp">方法：线性二分 + DP</h3>
<p>可以将三行输入放在一个大小为n * 3的二维数组nums中，nums[i][0]表示<strong>起始时间startTime</strong>，nums[i][1]表示送完这单的<strong>结束时间endTime</strong>，nums[i][2]表示获得的<strong>报酬profit</strong>。</p>
<p>定义 f[i + 1]表示按照结束时间排序后处理(接单或不接单)<strong>前</strong> <em>i</em> 个订单的最大报酬</p>
<p>对于一个外卖订单有两种选择：1.接单 2.不接单</p>
<p>对于第<code>i</code>个订单，</p>
<ul>
<li>不接单：f[i + 1] = f[i]</li>
<li>接单，f[i + 1] = f[j + 1] + nums[i][2](报酬)，其中j是满足最大的<code>endTime[j]</code> &lt;= <code>startTime[i]</code></li>
<li>取 <strong>接单</strong>与<strong>不接单</strong>所能获得的的最大值,<span class="math inline">\(f[i + 1] = Math.max(f[i], f[j + 1] + nums[i][2])\)</span></li>
</ul>
<p>如果从i往后面遍历，找到符合条件的j，时间复杂度是<span class="math inline">\(O(n^2)\)</span>，数据有50000，一定会超时。可以通过<strong>二分</strong>来找到j，时间复杂度为<span class="math inline">\(O(nlogn)。\)</span></p>
<h3 id="举例">举例</h3>
<figure class="highlight txt"><table><tr><td class="code"><pre><code class="hljs txt">5<br>1 3 6 7 11<br>4 3 4 3 9<br>2 5 5 3 4<br></code></pre></td></tr></table></figure>
<p>大概长这个样子</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230906203428394.png" /></p>
<table>
<thead>
<tr class="header">
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>[1,5,2]</td>
<td>[3,6,5]</td>
<td>[6,10,5]</td>
<td>[7,10,4]</td>
<td>[11,20,4]</td>
</tr>
</tbody>
</table>
<p>手动计算一下，按照结束时间排序后：</p>
<ol type="1">
<li>对于前1个订单，能获得的最大报酬是2</li>
<li>对于前2个订单，能获得的最大报酬是5</li>
<li>对于前3个订单，能获得的最大报酬是: 前2个订单最大报酬 + 5 = 5 + 5 = 10</li>
<li>对于前4个订单，能获得的最大报酬是10: 选择第4个订单获得的最大报酬 &lt; 不选择第4个订单获得的最大报酬</li>
<li>对于前5个订单，能获得的最大报酬是14</li>
</ol>
<h3 id="代码">代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> 秋招笔试.广联达<span class="hljs-number">0906.</span>第<span class="hljs-number">1</span>题;<br><br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        scanner.nextLine();<br>        <span class="hljs-type">int</span>[][] nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][<span class="hljs-number">3</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            nums[i][<span class="hljs-number">0</span>] = scanner.nextInt();<br>        scanner.nextLine();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            nums[i][<span class="hljs-number">1</span>] = nums[i][<span class="hljs-number">0</span>] + scanner.nextInt();<br>        scanner.nextLine();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            nums[i][<span class="hljs-number">2</span>] = scanner.nextInt();<br>        Arrays.sort(nums, (o1, o2) -&gt; o1[<span class="hljs-number">1</span>] - o2[<span class="hljs-number">1</span>]);<br>        <span class="hljs-type">long</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            f[i + <span class="hljs-number">1</span>] = f[i];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> bisearch(nums, i, nums[i][<span class="hljs-number">0</span>]);<br>            f[i + <span class="hljs-number">1</span>] = Math.max(f[i + <span class="hljs-number">1</span>], f[j + <span class="hljs-number">1</span>] + nums[i][<span class="hljs-number">2</span>]);<br>        &#125;<br>        System.out.println(f[n]);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">bisearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] nums, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid][<span class="hljs-number">1</span>] &lt;= start)<br>                l = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                r = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>lcp361</title>
    <url>/2023/09/03/lcp361/</url>
    <content><![CDATA[<h2 id="统计对称整数的数目"><a href="https://leetcode.cn/problems/count-symmetric-integers/">7020. 统计对称整数的数目</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230903145237789.png" /></p>
<h3 id="方法一枚举">方法一：枚举</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countSymmetricIntegers</span><span class="hljs-params">(<span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> low; i &lt;= Math.min(high, <span class="hljs-number">99</span>); ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> i % <span class="hljs-number">10</span>, r = i / <span class="hljs-number">10</span>;<br>            <span class="hljs-keyword">if</span> (l == r)<br>                ++res;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (high &gt; <span class="hljs-number">1000</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> Math.max(low, <span class="hljs-number">1000</span>); i &lt;= Math.min(high, <span class="hljs-number">10000</span>); ++i) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, suff = <span class="hljs-number">0</span>;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> i;<br>                pre += (l % <span class="hljs-number">10</span>);<br>                l /= <span class="hljs-number">10</span>;<br>                pre += (l % <span class="hljs-number">10</span>);<br>                <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> i / <span class="hljs-number">100</span>;<br>                suff += (r % <span class="hljs-number">10</span>);<br>                r /= <span class="hljs-number">10</span>;<br>                suff += (r % <span class="hljs-number">100</span>);<br>                <span class="hljs-keyword">if</span> (pre == suff)<br>                    ++res;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="生成特殊数字的最少操作"><a href="https://leetcode.cn/problems/minimum-operations-to-make-a-special-number/">8040. 生成特殊数字的最少操作</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230903145315765.png" /></p>
<h3 id="方法一贪心">方法一：贪心</h3>
<p>从后往前找，找到子序列25， 50， 75， 00，统计最少需要删除的个数；如果没找到，那么如果字符串中没有0，那么全部删除；如果有0，则删除n-1个字符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumOperations</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt0</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">&#x27;0&#x27;</span>)<br>                cnt0++;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">101</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;0&#x27;</span>)<br>                    flag = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span><br>                    ++cnt;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;0&#x27;</span> || ch == <span class="hljs-string">&#x27;5&#x27;</span>)<br>                    flag = <span class="hljs-number">2</span>;<br>                <span class="hljs-keyword">else</span><br>                    ++cnt;<br>            &#125; <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">2</span>)<br>            res = Math.min(res, cnt);<br>        flag = <span class="hljs-number">0</span>;<br>        cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;5&#x27;</span>)<br>                    flag = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span><br>                    ++cnt;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;2&#x27;</span> || ch == <span class="hljs-string">&#x27;7&#x27;</span>)<br>                    flag = <span class="hljs-number">2</span>;<br>                <span class="hljs-keyword">else</span><br>                    ++cnt;<br>            &#125; <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">2</span>)<br>            res = Math.min(res, cnt);<br>        <span class="hljs-keyword">if</span> (res == <span class="hljs-number">101</span>) &#123;<br>            res = cnt0 == <span class="hljs-number">0</span> ? n : n - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="统计趣味子数组的数目"><a href="https://leetcode.cn/problems/count-of-interesting-subarrays/">6952. 统计趣味子数组的数目</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230903145357072.png" /></p>
<h3 id="方法一前缀和-hashmap-公式转换">方法一：前缀和 + HashMap + 公式转换</h3>
<p>类似两数之和</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">countInterestingSubarrays</span><span class="hljs-params">(List&lt;Integer&gt; nums, <span class="hljs-type">int</span> modulo, <span class="hljs-type">int</span> k)</span> &#123;<br>    Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    map.put(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>    <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : nums) &#123;<br>        <span class="hljs-keyword">if</span> (x % modulo == k)<br>            s = (s + <span class="hljs-number">1</span>) % modulo;<br>        res += map.getOrDefault((s - k + modulo) % modulo, <span class="hljs-number">0</span>);<br>        map.put(s, map.getOrDefault(s, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230903143223806.png" /></p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230903152140069.png" /></p>
]]></content>
      <categories>
        <category>Contest</category>
        <category>LCP</category>
      </categories>
      <tags>
        <tag>力扣杯</tag>
      </tags>
  </entry>
  <entry>
    <title>lcpBi112</title>
    <url>/2023/09/02/lcpBi112/</url>
    <content><![CDATA[<h2 id="判断通过操作能否让字符串相等-i"><a href="https://leetcode.cn/problems/check-if-strings-can-be-made-equal-with-operations-i/">2839. 判断通过操作能否让字符串相等 I</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230908152217756.png" /></p>
<h3 id="方法一模拟">方法一：模拟</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canBeEqual</span><span class="hljs-params">(String s1, String s2)</span> &#123;<br>        <span class="hljs-keyword">if</span> (s1.equals(s2))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">boolean</span>[] flag = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">4</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; ++i) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch1</span> <span class="hljs-operator">=</span> s1.charAt(i), ch2 = s2.charAt(i);<br>            <span class="hljs-keyword">if</span> (flag[i]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (ch1 == ch2) &#123;<br>                flag[i] = <span class="hljs-literal">true</span>;<br>                ++cnt;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> ((i == <span class="hljs-number">0</span> || i == <span class="hljs-number">1</span>) &amp;&amp; s1.charAt(i + <span class="hljs-number">2</span>) == ch2 &amp;&amp; s2.charAt(i + <span class="hljs-number">2</span>) == ch1) &#123;<br>                flag[i] = <span class="hljs-literal">true</span>;<br>                flag[i + <span class="hljs-number">2</span>] = <span class="hljs-literal">true</span>;<br>                cnt += <span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt == <span class="hljs-number">4</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="判断通过操作能否让字符串相等-ii"><a href="https://leetcode.cn/problems/check-if-strings-can-be-made-equal-with-operations-ii/">2840. 判断通过操作能否让字符串相等 II</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230908152234337.png" /></p>
<h3 id="方法一计数">方法一：计数</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkStrings</span><span class="hljs-params">(String s1, String s2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s1.length();<br>        <span class="hljs-type">int</span>[] cntEven = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>], cntOdd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch1</span> <span class="hljs-operator">=</span> s1.charAt(i), ch2 = s2.charAt(i);<br>            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>                ++cntEven[ch1 - <span class="hljs-string">&#x27;a&#x27;</span>];<br>                --cntEven[ch2 - <span class="hljs-string">&#x27;a&#x27;</span>];<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                ++cntOdd[ch1 - <span class="hljs-string">&#x27;a&#x27;</span>];<br>                --cntOdd[ch2 - <span class="hljs-string">&#x27;a&#x27;</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (cntEven[i] != <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span> (cntOdd[i] != <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="几乎唯一子数组的最大和"><a href="https://leetcode.cn/problems/maximum-sum-of-almost-unique-subarray/">2841. 几乎唯一子数组的最大和</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230908152315684.png" /></p>
<h3 id="方法一滑动窗口">方法一：滑动窗口</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">maxSum</span><span class="hljs-params">(List&lt;Integer&gt; nums, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, s = <span class="hljs-number">0</span>;<br>        Map&lt;Integer, Integer&gt; cnt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.size(); ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> nums.get(i);<br>            s += x;<br>            cnt.put(x, cnt.getOrDefault(x, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (i &gt;= k - <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">if</span> (cnt.size() &gt;= m)<br>                    res = Math.max(res, s);<br>                <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> nums.get(i - k + <span class="hljs-number">1</span>);<br>                s -= y;<br>                cnt.put(y, cnt.get(y) - <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span> (cnt.get(y) == <span class="hljs-number">0</span>)<br>                    cnt.remove(y);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="统计一个字符串的-k-子序列美丽值最大的数目"><a href="https://leetcode.cn/problems/count-k-subsequences-of-a-string-with-maximum-beauty/">2842. 统计一个字符串的 k 子序列美丽值最大的数目</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230908150421707.png" /></p>
<h3 id="方法一组合数学-快速幂">方法一：组合数学 + 快速幂</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countKSubsequencesWithMaxBeauty</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span>[] cnt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            cnt[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        <span class="hljs-type">var</span> <span class="hljs-variable">cc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;Integer, Integer&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> c : cnt)<br>            <span class="hljs-keyword">if</span> (c &gt; <span class="hljs-number">0</span>)<br>                cc.put(c, cc.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br><br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : cc.descendingMap().entrySet()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> entry.getKey(), count = entry.getValue();<br>            <span class="hljs-keyword">if</span> (count &gt;= k)<br>                <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) ((res * comb(count, k) % MOD ) % MOD * pow(num, k) % MOD);<br>            res = res * pow(num, count) % MOD;<br>            k -= count;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-title function_">pow</span><span class="hljs-params">(<span class="hljs-type">long</span> x, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (; n &gt; <span class="hljs-number">0</span>; n /= <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> &gt; <span class="hljs-number">0</span>)<br>                res = res * x % MOD;<br>            x = x * x % MOD;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">// 适用于 n 和 k 都比较小的场景（本题至多 26）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-title function_">comb</span><span class="hljs-params">(<span class="hljs-type">long</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> n;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= k; i++)<br>            res = res * --n / i; <span class="hljs-comment">// n,n-1,n-2,... 中的前 i 个数至少有一个因子 i</span><br>        <span class="hljs-keyword">return</span> res % MOD;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Contest</category>
        <category>LCP</category>
      </categories>
      <tags>
        <tag>力扣杯</tag>
      </tags>
  </entry>
  <entry>
    <title>lcp329</title>
    <url>/2023/09/01/lcp329/</url>
    <content><![CDATA[<h2 id="交替数字和"><a href="https://leetcode.cn/problems/alternating-digit-sum/">交替数字和</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230901102639629.png" /></p>
<h3 id="方法一模拟">方法一：模拟</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">alternateDigitSum</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> String.valueOf(n);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> str.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> len % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> n % <span class="hljs-number">10</span>;<br>            n /= <span class="hljs-number">10</span>;<br>            <span class="hljs-keyword">if</span> (flag)<br>                res += x;<br>            <span class="hljs-keyword">else</span><br>                res -= x;<br>            flag = !flag;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="根据第-k-场考试的分数排序"><a href="https://leetcode.cn/problems/sort-the-students-by-their-kth-score/">根据第 K 场考试的分数排序</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230901103348479.png" /></p>
<h3 id="方法一排序">方法一：排序</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] sortTheStudents(<span class="hljs-type">int</span>[][] score, <span class="hljs-type">int</span> k) &#123;<br>        Arrays.sort(score, (o1, o2) -&gt; o2[k] - o1[k]);<br>        <span class="hljs-keyword">return</span> score;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="执行逐位运算使字符串相等"><a href="https://leetcode.cn/problems/apply-bitwise-operations-to-make-strings-equal/">执行逐位运算使字符串相等</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230901104203797.png" /></p>
<h3 id="方法一贪心">方法一：贪心</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">makeStringsEqual</span><span class="hljs-params">(String s, String target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cntS</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, cntT = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">&#x27;1&#x27;</span>) ++cntS;<br>            <span class="hljs-keyword">if</span> (target.charAt(i) == <span class="hljs-string">&#x27;1&#x27;</span>) ++ cntT;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (cntT == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> cntS == <span class="hljs-number">0</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> cntS &gt; <span class="hljs-number">0</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="拆分数组的最小代价"><a href="https://leetcode.cn/problems/minimum-cost-to-split-an-array/">拆分数组的最小代价</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230901111314735.png" /></p>
<h3 id="方法一dp">方法一：DP</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCost</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        Arrays.fill(f, Integer.MAX_VALUE &gt;&gt; <span class="hljs-number">1</span>);<br>        f[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>            <span class="hljs-type">int</span>[] cnt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; --j) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> ++cnt[nums[j]];<br>                <span class="hljs-keyword">if</span> (x == <span class="hljs-number">2</span>) t += <span class="hljs-number">2</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">2</span>) t += <span class="hljs-number">1</span>;<br>                f[i] = Math.min(f[i], t + f[j] + k);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Contest</category>
        <category>LCP</category>
      </categories>
      <tags>
        <tag>力扣杯</tag>
      </tags>
  </entry>
  <entry>
    <title>lcp330</title>
    <url>/2023/08/31/lcp330/</url>
    <content><![CDATA[<h2 id="统计桌面上的不同数字"><a href="https://leetcode.cn/problems/count-distinct-numbers-on-board/">统计桌面上的不同数字</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230831162120560.png" /></p>
<h3 id="方法一-queue-hashset">方法一: Queue + HashSet</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">distinctIntegers</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.offer(n);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; size; ++k) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> queue.poll();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>                    <span class="hljs-keyword">if</span> (!set.contains(i) &amp;&amp; x % i == <span class="hljs-number">1</span>) &#123;<br>                        queue.offer(i);<br>                        set.add(i);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> set.size() + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="猴子碰撞的方法数"><a href="https://leetcode.cn/problems/count-collisions-of-monkeys-on-a-polygon/">猴子碰撞的方法数</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230831163021780.png" /></p>
<h3 id="方法一-快速幂">方法一: 快速幂</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">monkeyMove</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// 只有所有猴子沿着顺时针或者逆时针走，才不会发生碰撞，所以猴子至少发生 一次碰撞 的移动方法数为 Math.pow(2,n) - 2，考察快速幂</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, x = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)<br>                res = res * x % MOD;<br>            x = x * x % MOD;<br>            n /= <span class="hljs-number">2</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) ((res - <span class="hljs-number">2</span> + MOD) % MOD);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="将珠子放入背包中"><a href="https://leetcode.cn/problems/put-marbles-in-bags/">将珠子放入背包中</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230831165533627.png" /></p>
<h3 id="方法一">方法一:</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure>
<h2 id="统计上升四元组"><a href="https://leetcode.cn/problems/count-increasing-quadruplets/">统计上升四元组</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230831171510586.png" /></p>
<h3 id="方法一-1">方法一:</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Contest</category>
        <category>LCP</category>
      </categories>
      <tags>
        <tag>力扣杯</tag>
      </tags>
  </entry>
  <entry>
    <title>lcpBi97</title>
    <url>/2023/08/30/lcpBi97/</url>
    <content><![CDATA[<h2 id="分割数组中数字的数位"><a href="https://leetcode.cn/problems/separate-the-digits-in-an-array/">分割数组中数字的数位</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230830215005478.png" /></p>
<h3 id="方法一双端队列">方法一：双端队列</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] separateDigits(<span class="hljs-type">int</span>[] nums) &#123;<br>        Deque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : nums) &#123;<br>            <span class="hljs-keyword">while</span> (x != <span class="hljs-number">0</span>) &#123;<br>                deque.offerFirst(x % <span class="hljs-number">10</span>);<br>                x /= <span class="hljs-number">10</span>;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (!deque.isEmpty())<br>                list.add(deque.pollFirst());<br>        &#125;<br>        <span class="hljs-keyword">return</span> list.stream().mapToInt(i-&gt;i).toArray();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="从一个范围内选择最多整数-i"><a href="https://leetcode.cn/problems/maximum-number-of-integers-to-choose-from-a-range-i/">从一个范围内选择最多整数 I</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230830215705433.png" /></p>
<h3 id="方法一hashset">方法一：HashSet</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxCount</span><span class="hljs-params">(<span class="hljs-type">int</span>[] banned, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> maxSum)</span> &#123;<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : banned)<br>            set.add(x);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (set.contains(i))<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (sum + i &lt;= maxSum) &#123;<br>                sum += i;<br>                ++res;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="两个线段获得的最多奖品"><a href="https://leetcode.cn/problems/maximize-win-from-two-segments/">两个线段获得的最多奖品</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230830220237567.png" /></p>
<h3 id="方法一同向双指针">方法一：同向双指针</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximizeWin</span><span class="hljs-params">(<span class="hljs-type">int</span>[] pos, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> pos.length, res = <span class="hljs-number">0</span>, l = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] pre = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">while</span> (pos[i] - pos[l] &gt; k)<br>                ++l;<br>            res = Math.max(res, pre[l] + i - l + <span class="hljs-number">1</span>);<br>            pre[i + <span class="hljs-number">1</span>] = Math.max(pre[i], i - l + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="二进制矩阵中翻转最多一次使路径不连通"><a href="https://leetcode.cn/problems/disconnect-path-in-a-binary-matrix-by-at-most-one-flip/">二进制矩阵中翻转最多一次使路径不连通</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230831155400405.png" /></p>
<h3 id="方法一两次dfs">方法一：两次DFS</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPossibleToCutPath</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        m = grid.length;<br>        n = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-built_in">this</span>.grid = grid;<br>        <span class="hljs-keyword">return</span> !dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>) || !dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i == m - <span class="hljs-number">1</span> &amp;&amp; j == n - <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        grid[i][j] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], col = j + dir[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (isValid(row, col) &amp;&amp; grid[row][col] == <span class="hljs-number">1</span> &amp;&amp; dfs(row, col))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br><br>    <span class="hljs-type">int</span> m, n;<br>    <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;, grid;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &lt; m &amp;&amp; j &lt; n;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Contest</category>
        <category>LCP</category>
      </categories>
      <tags>
        <tag>力扣杯</tag>
      </tags>
  </entry>
  <entry>
    <title>lcp331</title>
    <url>/2023/08/29/lcp331/</url>
    <content><![CDATA[<h2 id="从数量最多的堆取走礼物"><a href="https://leetcode.cn/problems/take-gifts-from-the-richest-pile/">从数量最多的堆取走礼物</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230829091239486.png" /></p>
<h3 id="方法一大根堆">方法一：大根堆</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">pickGifts</span><span class="hljs-params">(<span class="hljs-type">int</span>[] gifts, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> gifts.length;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        PriorityQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(((o1, o2) -&gt; o2 - o1));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : gifts)<br>            queue.add(x);<br>        <span class="hljs-keyword">while</span> (k-- &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> queue.poll(), sqrt = (<span class="hljs-type">int</span>) Math.sqrt(x);<br>            queue.add(sqrt);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : queue)<br>            res += x;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="统计范围内的元音字符串数"><a href="https://leetcode.cn/problems/count-vowel-strings-in-ranges/">统计范围内的元音字符串数</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230829092727315.png" /></p>
<h3 id="方法一前缀和-预处理">方法一：前缀和 + 预处理</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] vowelStrings(String[] words, <span class="hljs-type">int</span>[][] queries) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> queries.length, n = words.length;<br>        <span class="hljs-type">boolean</span>[] check = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n];<br>        Set&lt;Character&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        set.add(<span class="hljs-string">&#x27;a&#x27;</span>);<br>        set.add(<span class="hljs-string">&#x27;e&#x27;</span>);<br>        set.add(<span class="hljs-string">&#x27;i&#x27;</span>);<br>        set.add(<span class="hljs-string">&#x27;o&#x27;</span>);<br>        set.add(<span class="hljs-string">&#x27;u&#x27;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (String word : words) &#123;<br>            check[index] = (set.contains(word.charAt(<span class="hljs-number">0</span>)) &amp;&amp; set.contains(word.charAt(word.length() - <span class="hljs-number">1</span>))) ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>            ++index;        <br>        &#125;<br>        <span class="hljs-type">int</span>[] preSum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            preSum[i + <span class="hljs-number">1</span>] = preSum[i] + (check[i] ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m];<br>        index = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] query : queries) &#123;<br>            res[index] = preSum[query[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>] - preSum[query[<span class="hljs-number">0</span>]];<br>            ++index;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="打家劫舍-iv"><a href="https://leetcode.cn/problems/house-robber-iv/">打家劫舍 IV</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230829092747437.png" /></p>
<h3 id="方法一二分-记忆化搜索">方法一：二分 + 记忆化搜索</h3>
<p>枚举nums中的数字limit作为小偷的窃取能力，换句话说，小偷只能偷价值小于等于limit的房屋，如果在这个limit下，能偷大于等于k个房屋，limit可以尝试更小的数；否则limit需要尝试更大的数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCapability</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-built_in">this</span>.nums = nums;<br>        n = nums.length;<br>        <span class="hljs-type">int</span>[] temp = nums.clone();<br>        Arrays.sort(temp);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (check(mid, temp, k))<br>                r = mid - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> temp[l];<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span> mid, <span class="hljs-type">int</span>[] temp, <span class="hljs-type">int</span> k)</span> &#123;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Arrays.fill(dp, -<span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">limit</span> <span class="hljs-operator">=</span> temp[mid];<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, limit) &gt;= k ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> limit)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == n)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (dp[index] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[index];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pass</span> <span class="hljs-operator">=</span> dfs(index + <span class="hljs-number">1</span>, limit), rob = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (nums[index] &lt;= limit)<br>            rob = dfs(index + <span class="hljs-number">2</span>, limit) + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> dp[index] = Math.max(pass, rob);<br>    &#125;<br><br>    <span class="hljs-type">int</span>[] nums, dp;<br>    <span class="hljs-type">int</span> n;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二记忆化搜索转dp">方法二：记忆化搜索转DP</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCapability</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-built_in">this</span>.nums = nums;<br>        n = nums.length;<br>        <span class="hljs-type">int</span>[] temp = nums.clone();<br>        Arrays.sort(temp);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (check(mid, temp, k))<br>                r = mid - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> temp[l];<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span> mid, <span class="hljs-type">int</span>[] temp, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">limit</span> <span class="hljs-operator">=</span> temp[mid];<br>        <span class="hljs-comment">// dp[i]：从房屋0~i，做多能偷的房屋数量</span><br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; n + <span class="hljs-number">2</span>; ++i) &#123;<br>            dp[i] = dp[i - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (nums[i - <span class="hljs-number">2</span>] &lt;= limit)<br>                dp[i] = Math.max(dp[i], dp[i - <span class="hljs-number">2</span>] + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n + <span class="hljs-number">1</span>] &gt;= k;<br>    &#125;<br><br>    <span class="hljs-type">int</span>[] nums, dp;<br>    <span class="hljs-type">int</span> n;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法三滚动数组">方法三：滚动数组</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCapability</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-built_in">this</span>.nums = nums;<br>        n = nums.length;<br>        <span class="hljs-type">int</span>[] temp = nums.clone();<br>        Arrays.sort(temp);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (check(mid, temp, k))<br>                r = mid - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> temp[l];<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span> mid, <span class="hljs-type">int</span>[] temp, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">limit</span> <span class="hljs-operator">=</span> temp[mid];<br>        <span class="hljs-comment">// dp[i]：从房屋0~i，做多能偷的房屋数量</span><br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; n + <span class="hljs-number">2</span>; ++i) &#123;<br>            dp[i % <span class="hljs-number">3</span>] = dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">3</span>];<br>            <span class="hljs-keyword">if</span> (nums[i - <span class="hljs-number">2</span>] &lt;= limit)<br>                dp[i % <span class="hljs-number">3</span>] = Math.max(dp[i % <span class="hljs-number">3</span>], dp[(i - <span class="hljs-number">2</span>) % <span class="hljs-number">3</span>] + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[(n + <span class="hljs-number">1</span>) % <span class="hljs-number">3</span>] &gt;= k;<br>    &#125;<br><br>    <span class="hljs-type">int</span>[] nums, dp;<br>    <span class="hljs-type">int</span> n;<br><br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Contest</category>
        <category>LCP</category>
      </categories>
      <tags>
        <tag>力扣杯</tag>
      </tags>
  </entry>
  <entry>
    <title>lcp332</title>
    <url>/2023/08/28/lcp332/</url>
    <content><![CDATA[<h2 id="找出数组的串联值"><a href="https://leetcode.cn/problems/find-the-array-concatenation-value/">找出数组的串联值</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230828163102945.png" /></p>
<h3 id="方法一模拟">方法一：模拟</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">findTheArrayConcVal</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n / <span class="hljs-number">2</span>; ++i) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> String.valueOf(nums[i]) + String.valueOf(nums[n - i - <span class="hljs-number">1</span>]);<br>            res += Long.parseLong(s);<br>        &#125;<br>        res += n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> ? Long.parseLong(String.valueOf(nums[n / <span class="hljs-number">2</span>])) : <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="统计公平数对的数目"><a href="https://leetcode.cn/problems/count-the-number-of-fair-pairs/">统计公平数对的数目</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230828163517680.png" /></p>
<h3 id="方法一二分查找">方法一：二分查找</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">countFairPairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> lower, <span class="hljs-type">int</span> upper)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        Arrays.sort(nums);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">ceiling</span> <span class="hljs-operator">=</span>  ceiling(nums, lower - nums[i], i + <span class="hljs-number">1</span>);<span class="hljs-comment">// 大于等于lower - nums[i]的最小值</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">floor</span> <span class="hljs-operator">=</span> floor(nums, upper - nums[i], i + <span class="hljs-number">1</span>);  <span class="hljs-comment">// 小于等于upper - nums[i]的最大值</span><br>            res += floor - ceiling + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">floor</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> i, r = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &lt;= x)<br>                l = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                r = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ceiling</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> i, r = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &gt;= x)<br>                r = mid - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> l;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="子字符串异或查询"><a href="https://leetcode.cn/problems/substring-xor-queries/">子字符串异或查询</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230828170839784.png" /></p>
<h3 id="方法一位运算预处理-s-中的所有数字">方法一：位运算预处理 s 中的所有数字</h3>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230828224344350.png" /></p>
<p>当x不存在map中或者当前子串长度小于之前存的子串长度，更新map</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] substringXorQueries(String s, <span class="hljs-type">int</span>[][] queries) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length(), m = queries.length;<br>        Map&lt;Integer, <span class="hljs-type">int</span>[]&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; Math.min(i + <span class="hljs-number">30</span>, n); ++j) &#123;<br>                x = x &lt;&lt; <span class="hljs-number">1</span> | (s.charAt(j) - <span class="hljs-string">&#x27;0&#x27;</span>);<br>                <span class="hljs-keyword">if</span> (!map.containsKey(x) || map.get(x)[<span class="hljs-number">1</span>] - map.get(x)[<span class="hljs-number">0</span>] &gt; j - i)<br>                    map.put(x, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, j&#125;);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][<span class="hljs-number">2</span>];<br>        <span class="hljs-type">int</span>[] NOTFOUND = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> queries[i][<span class="hljs-number">0</span>] ^ queries[i][<span class="hljs-number">1</span>];<br>            res[i] = map.getOrDefault(val, NOTFOUND);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="section"></h2>
]]></content>
      <categories>
        <category>Contest</category>
        <category>LCP</category>
      </categories>
      <tags>
        <tag>力扣杯</tag>
      </tags>
  </entry>
  <entry>
    <title>lcp360</title>
    <url>/2023/08/27/lcp360/</url>
    <content><![CDATA[<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230827103018374.png" /></p>
<h3 id="方法一暴力">方法一：暴力</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">furthestDistanceFromOrigin</span><span class="hljs-params">(String moves)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> moves.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cntL</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, cntR = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> moves.charAt(i);<br>            <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;L&#x27;</span>)<br>                ++cntL;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;R&#x27;</span>)<br>                ++cntR;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.abs(cntL - cntR) + n - (cntL + cntR);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230827104055629.png" /></p>
<h3 id="方法一hashset">方法一：HashSet</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">minimumPossibleSum</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        HashSet&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, i = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (cnt &lt; n) &#123;<br>            <span class="hljs-keyword">if</span> (set.contains(target - i)) &#123;<br>                ++i;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            set.add(i);<br>            res += i++;<br>            cnt++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Contest</category>
        <category>LCP</category>
      </categories>
      <tags>
        <tag>力扣杯</tag>
      </tags>
  </entry>
  <entry>
    <title>lcp333</title>
    <url>/2023/08/25/lcp333/</url>
    <content><![CDATA[<h2 id="合并两个二维数组---求和法"><a href="https://leetcode.cn/problems/merge-two-2d-arrays-by-summing-values/">合并两个二维数组 - 求和法</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230825091631429.png" /></p>
<h3 id="方法二归并排序">方法二：归并排序</h3>
<p>注意边界条件是i == m, j == n</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] mergeArrays(<span class="hljs-type">int</span>[][] nums1, <span class="hljs-type">int</span>[][] nums2) &#123;<br>        List&lt;<span class="hljs-type">int</span>[]&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, m = nums1.length, n = nums2.length;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">if</span> (i == m) &#123;<br>                <span class="hljs-keyword">while</span> (j &lt; n)<br>                    list.add(nums2[j++]);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (j == n) &#123;<br>                <span class="hljs-keyword">while</span> (i &lt; m)<br>                    list.add(nums1[i++]);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (nums1[i][<span class="hljs-number">0</span>] &lt; nums2[j][<span class="hljs-number">0</span>])<br>                list.add(nums1[i++]);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums1[i][<span class="hljs-number">0</span>] &gt; nums2[j][<span class="hljs-number">0</span>])<br>                list.add(nums2[j++]);<br>            <span class="hljs-keyword">else</span> &#123;<br>                nums1[i][<span class="hljs-number">1</span>] += nums2[j++][<span class="hljs-number">1</span>];<br>                list.add(nums1[i++]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> list.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[list.size()][]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法一treemap">方法一：TreeMap</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] mergeArrays(<span class="hljs-type">int</span>[][] nums1, <span class="hljs-type">int</span>[][] nums2) &#123;<br>        TreeMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : nums1)<br>            map.put(arr[<span class="hljs-number">0</span>], map.getOrDefault(arr[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>) + arr[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : nums2)<br>            map.put(arr[<span class="hljs-number">0</span>], map.getOrDefault(arr[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>) + arr[<span class="hljs-number">1</span>]);<br>        <span class="hljs-type">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[map.size()][<span class="hljs-number">2</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;<br>            res[index][<span class="hljs-number">0</span>] = entry.getKey();<br>            res[index++][<span class="hljs-number">1</span>] = entry.getValue();<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="将整数减少到零需要的最少操作数"><a href="https://leetcode.cn/problems/minimum-operations-to-reduce-an-integer-to-0/">将整数减少到零需要的最少操作数</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230825092004004.png" /></p>
<h3 id="方法二记忆化搜索">方法二：记忆化搜索</h3>
<p>考虑将每个lowerbit +1或者-1操作，取最小值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minOperations</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[Integer.toBinaryString(num).length()];<br>        <span class="hljs-keyword">return</span> dfs(num);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-keyword">if</span> (Integer.bitCount(num) == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">lowerbit</span> <span class="hljs-operator">=</span> num &amp; -num;<br>        <span class="hljs-keyword">return</span> Math.min(dfs(num + lowerbit), dfs(num - lowerbit)) + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span>[] dp;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>base case 可以换成以下形式，如果num &amp; (num - 1)) == 0,那么num是2的幂次，等价于Integer.bitCount(num) == 1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> ((num &amp; (num - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>
<h3 id="方法一贪心">方法一：贪心</h3>
<p>从前往后遍历(遍历顺序无所谓)，将连续的1分段加入treemap中，</p>
<ul>
<li>如果一段后一段第一个元素与前一段最后一个元素的下标差为2（前一个1与后一个1中间只隔了1个0），先++res
<ul>
<li>如果前一段只有一个元素，不与下一段合并</li>
<li>否则，与下一段合并，把flag置为true</li>
</ul></li>
<li>如果一段后一段第一个元素与前一段最后一个元素的下标差&gt;2
<ul>
<li>如果第一段只有一个元素，并且前一段不和当前第一段合并，那么++res</li>
<li>否则，上一段是需要和这一段合并的，res+=2（将最低位+1，比如111 -&gt; 1000，再将这个1减去，两次操作），并将flag还原为false</li>
</ul></li>
</ul>
<p>最开始 s = s + "000";是为了最后遍历的时候，不用再考虑最后一段</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minOperations</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-keyword">if</span> (num == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> Integer.toBinaryString(num);<br>        s = s + <span class="hljs-string">&quot;000&quot;</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, n = s.length();<br><br>        TreeMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">preIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++i) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch1</span> <span class="hljs-operator">=</span> s.charAt(i), ch2 = s.charAt(i + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (ch1 == <span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; preIndex == i)<br>                map.put(i, i);<br>            <span class="hljs-keyword">if</span> (ch1 == <span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; ch2 == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                map.put(preIndex, i + <span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch1 == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>                preIndex = i + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span>[][] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[map.size() + <span class="hljs-number">1</span>][<span class="hljs-number">2</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;<br>            arr[index][<span class="hljs-number">0</span>] = entry.getKey();<br>            arr[index++][<span class="hljs-number">1</span>] = entry.getValue();<br>        &#125;<br>        <span class="hljs-type">int</span> i;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; ++i) &#123;<br>            <span class="hljs-type">int</span>[] a = arr[i], b = arr[i + <span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">len1</span> <span class="hljs-operator">=</span> a[<span class="hljs-number">1</span>] - a[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">if</span> (b[<span class="hljs-number">0</span>] - a[<span class="hljs-number">1</span>] == <span class="hljs-number">2</span>) &#123;<br>                ++res;<br>                <span class="hljs-keyword">if</span> (len1 &gt; <span class="hljs-number">0</span>)<br>                    flag = <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (len1 == <span class="hljs-number">0</span> &amp;&amp; !flag)<br>                    ++res;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    res += <span class="hljs-number">2</span>;<br>                    flag = <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="无平方子集计数"><a href="https://leetcode.cn/problems/count-the-number-of-square-free-subsets/">无平方子集计数</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230825092611669.png" /></p>
<h2 id="找出对应-lcp-矩阵的字符串"><a href="https://leetcode.cn/problems/find-the-string-with-lcp/">找出对应 LCP 矩阵的字符串</a></h2>
<h3 id="方法一">方法一：</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Contest</category>
        <category>LCP</category>
      </categories>
      <tags>
        <tag>力扣杯</tag>
      </tags>
  </entry>
  <entry>
    <title>lcpBi99</title>
    <url>/2023/08/23/lcpBi99/</url>
    <content><![CDATA[<h2 id="最小和分割"><a href="https://leetcode.cn/problems/split-with-minimum-sum/">最小和分割</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230823153728224.png" /></p>
<h3 id="方法一hashmap">方法一：HashMap</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">splitNum</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> String.valueOf(num);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span>[] cnt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); ++i)<br>            cnt[s.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>]++;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(), sb2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>            <span class="hljs-keyword">while</span> (cnt[i]-- &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (flag)<br>                    sb2.append(i);<br>                <span class="hljs-keyword">else</span><br>                    sb1.append(i);<br>                flag = !flag;<br>            &#125;<br>        &#125;<br>        System.out.println();<br>        <span class="hljs-keyword">return</span> Integer.parseInt(sb1.toString()) + Integer.parseInt(sb2.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="统计染色格子数"><a href="https://leetcode.cn/problems/count-total-number-of-colored-cells/">统计染色格子数</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230823153704148.png" /></p>
<h3 id="方法一等差数列">方法一：等差数列</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">long</span>[] sum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[<span class="hljs-number">100002</span>];<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        sum[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">diff</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; sum.length; ++i) &#123;<br>            sum[i] = sum[i - <span class="hljs-number">1</span>] + diff;<br>            diff += <span class="hljs-number">4</span>;<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">coloredCells</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">return</span> sum[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="统计将重叠区间合并成组的方案数"><a href="https://leetcode.cn/problems/count-ways-to-group-overlapping-ranges/">统计将重叠区间合并成组的方案数</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230823154853415.png" /></p>
<h3 id="方法一贪心-快速幂">方法一：贪心 + 快速幂</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countWays</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] ranges)</span> &#123;<br>        Arrays.sort(ranges, (o1,o2)-&gt;o1[<span class="hljs-number">0</span>] - o2[<span class="hljs-number">0</span>]);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>, r = ranges[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] range : ranges) &#123;<br>            <span class="hljs-keyword">if</span> (range[<span class="hljs-number">0</span>] &gt; r)<br>                res = res * <span class="hljs-number">2</span> % MOD;<br>            r = Math.max(r, range[<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="统计可能的树根数目"><a href="https://leetcode.cn/problems/count-number-of-possible-root-nodes/">统计可能的树根数目</a></h2>
<h3 id="方法一">方法一：</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Contest</category>
        <category>LCP</category>
      </categories>
      <tags>
        <tag>力扣杯</tag>
      </tags>
  </entry>
  <entry>
    <title>lcp359</title>
    <url>/2023/08/20/lcp359/</url>
    <content><![CDATA[<h2 id="判别首字母缩略词"><a href="https://leetcode.cn/contest/weekly-contest-359/problems/check-if-a-string-is-an-acronym-of-words/">判别首字母缩略词</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230820103020780.png" /></p>
<h3 id="方法一暴力">方法一：暴力</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAcronym</span><span class="hljs-params">(List&lt;String&gt; words, String s)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (String word : words)<br>            sb.append(word.charAt(<span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">return</span> s.equals(sb.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="k-avoiding-数组的最小总和"><a href="https://leetcode.cn/contest/weekly-contest-359/problems/determine-the-minimum-sum-of-a-k-avoiding-array/">k-avoiding 数组的最小总和</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230820103323049.png" /></p>
<h3 id="方法一hashset">方法一：HashSet</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumSum</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (!set.contains(k - i)) &#123;<br>                set.add(i);<br>                sum += i;<br>                --n;<br>            &#125;<br>            ++i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="销售利润最大化"><a href="https://leetcode.cn/contest/weekly-contest-359/problems/maximize-the-profit-as-the-salesman/">销售利润最大化</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230820104054745.png" /></p>
<h3 id="方法一线性dp">方法一：线性DP</h3>
<p>相似题目</p>
<ul>
<li><p><a href="https://leetcode.cn/problems/maximum-earnings-from-taxi/">2008. 出租车的最大盈利</a>（和本题几乎一样）</p></li>
<li><p><a href="https://leetcode.cn/problems/maximum-profit-in-job-scheduling/">1235. 规划兼职工作</a>（数据范围更大的情况，<a href="https://leetcode.cn/problems/maximum-profit-in-job-scheduling/solution/dong-tai-gui-hua-er-fen-cha-zhao-you-hua-zkcg/">我的题解</a>）</p></li>
<li><p><a href="https://leetcode.cn/problems/maximum-number-of-events-that-can-be-attended-ii/">1751. 最多可以参加的会议数目 II</a>（区间个数限制）</p></li>
<li><p><a href="https://leetcode.cn/problems/two-best-non-overlapping-events/">2054. 两个最好的不重叠活动</a></p></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximizeTheProfit</span><span class="hljs-params">(<span class="hljs-type">int</span> n, List&lt;List&lt;Integer&gt;&gt; offers)</span> &#123;<br>        List&lt;<span class="hljs-type">int</span>[]&gt;[] list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[n];<br>        Arrays.setAll(list, e -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        <span class="hljs-keyword">for</span> (List&lt;Integer&gt; offer : offers) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> offer.get(<span class="hljs-number">0</span>), end = offer.get(<span class="hljs-number">1</span>), val = offer.get(<span class="hljs-number">2</span>);<br>            list[end].add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;start, val&#125;);<br>        &#125;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>            dp[i] = dp[i - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : list[i - <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>], val = arr[<span class="hljs-number">1</span>];<br>                dp[i] = Math.max(dp[i], dp[start] + val);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二二分-dp">方法二：二分 + DP</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximizeTheProfit</span><span class="hljs-params">(<span class="hljs-type">int</span> n, List&lt;List&lt;Integer&gt;&gt; offers)</span> &#123;<br>        Collections.sort(offers, (o1, o2) -&gt; o1.get(<span class="hljs-number">1</span>) - o2.get(<span class="hljs-number">1</span>));<br>        <span class="hljs-comment">// 处理标号为0~i的房子能获得的最大利润</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[offers.size() + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; offers.size(); ++i) &#123;<br>            dp[i + <span class="hljs-number">1</span>] = dp[i];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> bisearch(offers, i, offers.get(i).get(<span class="hljs-number">0</span>));<br>            dp[i + <span class="hljs-number">1</span>] = Math.max(dp[i + <span class="hljs-number">1</span>], (j &gt;= -<span class="hljs-number">1</span> ? dp[j + <span class="hljs-number">1</span>] : <span class="hljs-number">0</span>) + offers.get(i).get(<span class="hljs-number">2</span>));<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[offers.size()];<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">bisearch</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; offers, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (offers.get(mid).get(<span class="hljs-number">1</span>) &lt; start)<br>                l = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                r = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="找出最长等值子数组"><a href="https://leetcode.cn/contest/weekly-contest-359/problems/find-the-longest-equal-subarray/">找出最长等值子数组</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230820111728081.png" /></p>
<h3 id="方法一滑动窗口-同向双指针">方法一：滑动窗口 同向双指针</h3>
<ol type="1">
<li><p>将每个值的下标存到List中，例如对于nums = [1,3,2,3,1,3], k = 3</p>
<p>list[1]: [0, 4]</p>
<p>list[2] : [4]</p>
<p>list[3]: [1, 3, 5]</p></li>
<li><p>枚举每个list，即把元素替换成1或2或3，例如枚举list[3]: [1, 3, 5]，l = 0, r = 1时，nums数组有list.get(r) - list.get(0) + 1 = 3 - 1 + 1 = 3个数：[3，2，3]，这个子数组中有r - l + 1 = 1 - 0 + 1 = 2个3，所以需要删除3 - 2 = 1个数</p></li>
<li><p>当需要删除的数大于k时，将左端点右移，直到满足需要删除的元素小于等于k</p></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestEqualSubarray</span><span class="hljs-params">(List&lt;Integer&gt; nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.size();<br>        List&lt;Integer&gt;[] pos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[n + <span class="hljs-number">1</span>];<br>        Arrays.setAll(pos, e -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            pos[nums.get(i)].add(i);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (List&lt;Integer&gt; list : pos) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; r &lt; list.size(); ++r) &#123;<br>                <span class="hljs-keyword">while</span> (list.get(r) - list.get(l) + <span class="hljs-number">1</span> - (r - l + <span class="hljs-number">1</span>) &gt; k)<br>                    ++l;<br>                res = Math.max(res, r - l + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Contest</category>
        <category>LCP</category>
      </categories>
      <tags>
        <tag>力扣杯</tag>
      </tags>
  </entry>
  <entry>
    <title>lcpBi111</title>
    <url>/2023/08/19/lcpBi111/</url>
    <content><![CDATA[<h2 id="统计和小于目标的下标对数目"><a href="https://leetcode.cn/contest/biweekly-contest-111/problems/count-pairs-whose-sum-is-less-than-target/">统计和小于目标的下标对数目</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230819223029875.png" /></p>
<h3 id="方法一暴力">方法一：暴力</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countPairs</span><span class="hljs-params">(List&lt;Integer&gt; nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, n = nums.size();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (nums.get(i) + nums.get(j) &lt; target)<br>                    ++res;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="循环增长使字符串子序列等于另一个字符串"><a href="https://leetcode.cn/contest/biweekly-contest-111/problems/make-string-a-subsequence-using-cyclic-increments/">循环增长使字符串子序列等于另一个字符串</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230819223334652.png" /></p>
<h3 id="方法一模拟">方法一：模拟</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canMakeSubsequence</span><span class="hljs-params">(String str1, String str2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> str1.length(), n = str2.length();<br>        <span class="hljs-keyword">if</span> (m &lt; n)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        Map&lt;Character, Character&gt; next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span>; i &lt; <span class="hljs-string">&#x27;z&#x27;</span>; ++i)<br>            next.put(i, (<span class="hljs-type">char</span>) (i + <span class="hljs-number">1</span>));<br>        next.put(<span class="hljs-string">&#x27;z&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (l &lt; m &amp;&amp; r &lt; n) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch1</span> <span class="hljs-operator">=</span> str1.charAt(l), ch2 = str2.charAt(r);<br>            <span class="hljs-keyword">if</span> (ch1 == ch2 || next.get(ch1) == ch2) &#123;<br>                ++l;<br>                ++r;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                ++l;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> r == n;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="将三个组排序"><a href="https://leetcode.cn/contest/biweekly-contest-111/problems/sorting-three-groups/">将三个组排序</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230819224240828.png" /></p>
<h3 id="方法一n---最长非递减子序列">方法一：n - 最长非递减子序列</h3>
<p>https://leetcode.cn/submissions/detail/460143737/</p>
<p>算出最长非递减子序列，修改剩余的元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumOperations</span><span class="hljs-params">(List&lt;Integer&gt; nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.size(), res = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Arrays.fill(dp, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (nums.get(j) &lt;= nums.get(i)) &#123;<br>                    dp[i] = Math.max(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>                    res = Math.max(res, dp[i]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> n - res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二状态机dp">方法二：状态机DP</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumOperations</span><span class="hljs-params">(List&lt;Integer&gt; nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.size();<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][<span class="hljs-number">4</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">3</span>; ++j) &#123;<br>                dp[i + <span class="hljs-number">1</span>][j] = Integer.MAX_VALUE;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; k &lt;= j; ++k) &#123;<br>                    dp[i + <span class="hljs-number">1</span>][j] = Math.min(dp[i + <span class="hljs-number">1</span>][j], dp[i][k]);<br>                &#125;<br>                dp[i + <span class="hljs-number">1</span>][j] += (nums.get(i) == j ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> dp[n][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= <span class="hljs-number">3</span>; ++i)<br>            min = Math.min(min, dp[n][i]);<br>        <span class="hljs-keyword">return</span> min;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Contest</category>
        <category>LCP</category>
      </categories>
      <tags>
        <tag>力扣杯</tag>
      </tags>
  </entry>
  <entry>
    <title>lcp335</title>
    <url>/2023/08/19/lcp335/</url>
    <content><![CDATA[<h2 id="递枕头"><a href="https://leetcode.cn/problems/pass-the-pillow/">递枕头</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230819162654490.png" /></p>
<h3 id="方法一模拟">方法一：模拟</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">passThePillow</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> time)</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">reverse</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (time-- &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (i == n)<br>                reverse = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span>)<br>                reverse = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span> (reverse) &#123;<br>                i--;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                i++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="二叉树中的第-k-大层和"><a href="https://leetcode.cn/problems/kth-largest-sum-in-a-binary-tree/">二叉树中的第 K 大层和</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230819164532723.png" /></p>
<h3 id="方法一bfs">方法一：BFS</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">kthLargestLevelSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> k)</span> &#123;<br>        List&lt;Long&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.offer(root);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>            <span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>                sum += node.val;<br>                <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>)<br>                    queue.offer(node.left);<br>                <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>)<br>                    queue.offer(node.right);<br>            &#125;<br>            res.add(sum);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (k &gt; res.size())<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        Collections.sort(res);<br>        <span class="hljs-keyword">return</span> res.get(res.size() - k);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="分割数组使乘积互质"><a href="https://leetcode.cn/problems/split-the-array-to-make-coprime-products/">分割数组使乘积互质</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230819164553345.png" /></p>
<h3 id="方法一">方法一：</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure>
<h2 id="获得分数的方法数"><a href="https://leetcode.cn/problems/number-of-ways-to-earn-points/">获得分数的方法数</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230819164801464.png" /></p>
<h3 id="方法一记忆化搜索分组背包">方法一：记忆化搜索(分组背包)</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br>    <span class="hljs-type">int</span> n ;<br>    <span class="hljs-type">int</span>[][] types, dp;<br>    Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">waysToReachTarget</span><span class="hljs-params">(<span class="hljs-type">int</span> target, <span class="hljs-type">int</span>[][] types)</span> &#123;<br>        <span class="hljs-built_in">this</span>.types = types;<br>        n = types.length;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][<span class="hljs-number">1002</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dp)<br>            Arrays.fill(arr, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, target);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == n)<br>            <span class="hljs-keyword">return</span> target == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (dp[index][target] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[index][target];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, count = types[index][<span class="hljs-number">0</span>], marks = types[index][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= Math.min(target / marks, count); ++i)<br>            res = (res + (dfs(index + <span class="hljs-number">1</span>, target - i * marks) % MOD)) % MOD;<br>        <span class="hljs-keyword">return</span> dp[index][target] = res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Contest</category>
        <category>LCP</category>
      </categories>
      <tags>
        <tag>力扣杯</tag>
      </tags>
  </entry>
  <entry>
    <title>lcp336</title>
    <url>/2023/08/19/lcp336/</url>
    <content><![CDATA[<h2 id="统计范围内的元音字符串数"><a href="https://leetcode.cn/problems/count-the-number-of-vowel-strings-in-range/">统计范围内的元音字符串数</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230819145424173.png" /></p>
<h3 id="方法一hashset">方法一：HashSet</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">vowelStrings</span><span class="hljs-params">(String[] words, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Set&lt;Character&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        set.add(<span class="hljs-string">&#x27;a&#x27;</span>);<br>        set.add(<span class="hljs-string">&#x27;e&#x27;</span>);<br>        set.add(<span class="hljs-string">&#x27;i&#x27;</span>);<br>        set.add(<span class="hljs-string">&#x27;o&#x27;</span>);<br>        set.add(<span class="hljs-string">&#x27;u&#x27;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> left; i &lt;= right; ++i) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> words[i];<br>            <span class="hljs-keyword">if</span> (set.contains(str.charAt(<span class="hljs-number">0</span>)) &amp;&amp; set.contains(str.charAt(str.length() - <span class="hljs-number">1</span>)))<br>                ++res;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="重排数组以得到最大前缀分数"><a href="https://leetcode.cn/problems/rearrange-array-to-maximize-prefix-score/">重排数组以得到最大前缀分数</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230819145817664.png" /></p>
<h3 id="方法一贪心">方法一：贪心</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxScore</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length, res = <span class="hljs-number">0</span>;<br>        Arrays.sort(nums);<br>        <span class="hljs-type">long</span>[] preSum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            preSum[i] = preSum[i + <span class="hljs-number">1</span>] + nums[i];<br>            <span class="hljs-keyword">if</span> (preSum[i] &gt; <span class="hljs-number">0</span>)<br>                ++res;<br>            <span class="hljs-keyword">else</span> <br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="统计美丽子数组数目"><a href="https://leetcode.cn/problems/count-the-number-of-beautiful-subarrays/">统计美丽子数组数目</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230819150506728.png" /></p>
<h3 id="方法一求异或和等于0-的子数组个数">方法一：求异或和等于0 的子数组个数</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">beautifulSubarrays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            s[i + <span class="hljs-number">1</span>] = s[i] ^ nums[i];<br>        Map&lt;Integer, Integer&gt; cnt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : s) &#123;<br>            res += cnt.getOrDefault(x, <span class="hljs-number">0</span>);<br>            cnt.put(x, cnt.getOrDefault(x, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="完成所有任务的最少时间"><a href="https://leetcode.cn/problems/minimum-time-to-complete-all-tasks/">完成所有任务的最少时间</a></h2>
<h3 id="方法一">方法一：</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Contest</category>
        <category>LCP</category>
      </categories>
      <tags>
        <tag>力扣杯</tag>
      </tags>
  </entry>
  <entry>
    <title>lcp337</title>
    <url>/2023/08/18/lcp337/</url>
    <content><![CDATA[<h2 id="奇偶位数"><a href="https://leetcode.cn/problems/number-of-even-and-odd-bits/">奇偶位数</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230818195227123.png" /></p>
<h3 id="方法一暴力">方法一：暴力</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] evenOddBit(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">odd</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, even = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> Integer.toBinaryString(n);<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(str);<br>        sb.reverse();<br>        str = sb.toString();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; str.length(); ++i) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> str.charAt(i);<br>            <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>                    even++;<br>                <span class="hljs-keyword">else</span><br>                    odd++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;even, odd&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="检查骑士巡视方案"><a href="https://leetcode.cn/problems/check-knight-tour-configuration/">检查骑士巡视方案</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230818200357787.png" /></p>
<h3 id="方法一dfs">方法一：dfs</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkValidGrid</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-keyword">if</span> (grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-built_in">this</span>.grid = grid;<br>        n = grid.length;<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> step)</span> &#123;<br>        <span class="hljs-keyword">if</span> (step == n * n - <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> grid[i][j] == n * n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], col = j + dir[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (isValid(row, col) &amp;&amp; grid[row][col] == step + <span class="hljs-number">1</span> &amp;&amp; dfs(row, col, step + <span class="hljs-number">1</span>))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col)</span> &#123;<br>        <span class="hljs-keyword">return</span> row &gt;= <span class="hljs-number">0</span> &amp;&amp; col &gt;= <span class="hljs-number">0</span> &amp;&amp; row &lt; n &amp;&amp; col &lt; n;<br>    &#125;<br><br>    <span class="hljs-type">int</span>[][] grid, dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>&#125;, &#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">1</span>, -<span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>&#125;, &#123;-<span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;&#125;;<br>    <span class="hljs-type">int</span> n;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="美丽子集的数目"><a href="https://leetcode.cn/problems/the-number-of-beautiful-subsets/">美丽子集的数目</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230818202726046.png" /></p>
<h3 id="方法一backtrack">方法一：backtrack</h3>
<p><strong>不能用containsKey判断，数量为0就好！</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    Map&lt;Integer, Integer&gt; cnt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">beautifulSubsets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        dfs(nums, k, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i == nums.length) &#123;<br>            ans++;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        dfs(nums, k, i + <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> nums[i];<br>        <span class="hljs-keyword">if</span> (cnt.getOrDefault(x - k, <span class="hljs-number">0</span>) == <span class="hljs-number">0</span> &amp;&amp; cnt.getOrDefault(x + k, <span class="hljs-number">0</span>) == <span class="hljs-number">0</span>) &#123;<br>            cnt.put(x, cnt.getOrDefault(x, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            dfs(nums, k, i + <span class="hljs-number">1</span>);<br>            cnt.put(x, cnt.get(x) - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="执行操作后的最大-mex"><a href="https://leetcode.cn/problems/smallest-missing-non-negative-integer-after-operations/">执行操作后的最大 MEX</a></h2>
<h3 id="方法一">方法一：</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Contest</category>
        <category>LCP</category>
      </categories>
      <tags>
        <tag>力扣杯</tag>
      </tags>
  </entry>
  <entry>
    <title>lcp334</title>
    <url>/2023/08/17/lcp334/</url>
    <content><![CDATA[<h2 id="左右元素和的差值"><a href="https://leetcode.cn/problems/left-and-right-sum-differences/">左右元素和的差值</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230817210841786.png" /></p>
<h3 id="方法一模拟">方法一：模拟</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] leftRightDifference(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n], leftSum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n], rightSum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; ++i) <br>            leftSum[i] = leftSum[i - <span class="hljs-number">1</span>] + nums[i - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; --i)<br>            rightSum[i] = rightSum[i + <span class="hljs-number">1</span>] + nums[i + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            res[i] = Math.abs(leftSum[i] - rightSum[i]);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="找出字符串的可整除数组"><a href="https://leetcode.cn/problems/find-the-divisibility-array-of-a-string/">找出字符串的可整除数组</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230817210855711.png" /></p>
<h3 id="方法一">方法一：</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] divisibilityArray(String s, <span class="hljs-type">int</span> m) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">long</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> pre * <span class="hljs-number">10</span> + s.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            pre = cur % m;<br>            res[i] = pre == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="求出最多标记下标"><a href="https://leetcode.cn/problems/find-the-maximum-number-of-marked-indices/">求出最多标记下标</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230817210913670.png" /></p>
<h3 id="方法一贪心-treemap">方法一：贪心 + TreeMap</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxNumOfMarkedIndices</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, n = nums.length;<br>        Arrays.sort(nums);<br>        TreeMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> (n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> nums[i];<br>            map.put(x, map.getOrDefault(x, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> nums[i];<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">floor</span> <span class="hljs-operator">=</span> map.ceilingKey(<span class="hljs-number">2</span> * left);<br>            <span class="hljs-keyword">if</span> (floor == <span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">else</span> &#123;<br>                res += <span class="hljs-number">2</span>;<br>                map.put(floor, map.get(floor) - <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span> (map.get(floor) == <span class="hljs-number">0</span>)<br>                    map.remove(floor);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="在网格图中访问一个格子的最少时间"><a href="https://leetcode.cn/problems/minimum-time-to-visit-a-cell-in-a-grid/">在网格图中访问一个格子的最少时间</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230817210925572.png" /></p>
<h3 id="二刷-dijkstra">二刷 dijkstra</h3>
<p>无需visited数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumTime</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length, n = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">if</span> (grid[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] &gt; <span class="hljs-number">1</span> &amp;&amp; grid[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] &gt; <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span>[][] dist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dist)<br>            Arrays.fill(arr, Integer.MAX_VALUE &gt;&gt; <span class="hljs-number">1</span>);<br>        dist[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">boolean</span>[][] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n];<br>        PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((o1, o2) -&gt; o1[<span class="hljs-number">2</span>] - o2[<span class="hljs-number">2</span>]);<br>        q.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">int</span>[] node = q.poll();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> node[<span class="hljs-number">0</span>], j = node[<span class="hljs-number">1</span>], d = node[<span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">if</span> (i == m - <span class="hljs-number">1</span> &amp;&amp; j == n - <span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">return</span> d;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], col = j + dir[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span> (isValid(row, col, m, n)) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">nd</span> <span class="hljs-operator">=</span> Math.max(d, grid[row][col]);<br>                    nd += (nd + row + col) % <span class="hljs-number">2</span>;<br>                    <span class="hljs-keyword">if</span> (nd &lt; dist[row][col]) &#123;<br>                        dist[row][col] = nd;<br>                        q.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;row, col, nd&#125;);<br>                    &#125;<br>                &#125;<br>            &#125; <br>        &#125;<br>    &#125;<br><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &lt; n;<br>    &#125;<br><br>    <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;, &#123;-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;&#125;;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法一堆优化的dijkstra">方法一：堆优化的dijkstra</h3>
<p><strong>dist[i][j]与 i + j 同奇偶</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumTime</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-built_in">this</span>.grid = grid;<br>        m = grid.length;<br>        n = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">if</span> (grid[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] &gt; <span class="hljs-number">1</span> &amp;&amp; grid[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] &gt; <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span>[][] dist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">inf</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dist)<br>            Arrays.fill(arr, inf);<br>        dist[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">boolean</span>[][] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n];<br>        PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(((o1, o2) -&gt; o1[<span class="hljs-number">0</span>] - o2[<span class="hljs-number">0</span>]));<br>        queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span>[] arr = queue.poll();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>], i = arr[<span class="hljs-number">1</span>], j = arr[<span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">if</span> (i == m - <span class="hljs-number">1</span> &amp;&amp; j == n - <span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">return</span> d;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], col = j + dir[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span> (isValid(row, col)) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">nd</span> <span class="hljs-operator">=</span> Math.max(d + <span class="hljs-number">1</span>, grid[row][col]);<br>                    nd += (nd - row - col) % <span class="hljs-number">2</span>;<br>                    <span class="hljs-keyword">if</span> (nd &lt; dist[row][col]) &#123;<br>                        dist[row][col] = nd;<br>                        queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;nd, row, col&#125;);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dist[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-type">int</span>[][] grid, dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-type">int</span> m, n;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &lt; n;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二二分-bfs">方法二：二分+ BFS</h3>
<h4 id="双数组">双数组</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumTime</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-built_in">this</span>.grid = grid;<br>        m = grid.length;<br>        n = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">if</span> (grid[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] &gt; <span class="hljs-number">1</span> &amp;&amp; grid[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] &gt; <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> Math.max(m + n - <span class="hljs-number">2</span>, grid[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>]), right = (<span class="hljs-type">int</span>) <span class="hljs-number">1e5</span> + m + n;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (check(mid))<br>                right = mid - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left + (left + m + n) % <span class="hljs-number">2</span>; <span class="hljs-comment">// 答案要与 m + n - 2同奇偶</span><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span> limit)</span> &#123;<br>        <span class="hljs-type">boolean</span>[][] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n];<br>        visited[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>        List&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> limit - <span class="hljs-number">1</span>;<br>        queue.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;m - <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>&#125;);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            List&lt;<span class="hljs-type">int</span>[]&gt; temp = queue;<br>            queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : temp) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>], j = arr[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], col = j + dir[<span class="hljs-number">1</span>];<br>                    <span class="hljs-keyword">if</span> (isValid(row, col) &amp;&amp; !visited[row][col] &amp;&amp; grid[row][col] &lt;= t) &#123;<br>                        <span class="hljs-keyword">if</span> (row == <span class="hljs-number">0</span> &amp;&amp; col == <span class="hljs-number">0</span>)<br>                            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                        visited[row][col] = <span class="hljs-literal">true</span>;<br>                        queue.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;row, col&#125;);<br>                    &#125;<br>                &#125;<br>            &#125;<br>            --t;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br><br><br>    <span class="hljs-type">int</span>[][] grid, dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-type">int</span> m, n;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &lt; n;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="queue">Queue</h4>
<p>q.offer(new int[]{m - 1, n - 1, limit - 1});表示终点在limit时访问过，邻居的grid值要小于limit - 1</p>
<p>从limit - 1开始</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumTime</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length, n = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">if</span> (grid[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] &gt; <span class="hljs-number">1</span> &amp;&amp; grid[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] &gt; <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> Math.max(m + n - <span class="hljs-number">2</span>, grid[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>]), r = (<span class="hljs-type">int</span>) <span class="hljs-number">1e5</span>;<br>        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (check(mid, grid, m, n))<br>                r = mid - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <br>                l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> l + (l + m + n - <span class="hljs-number">2</span>) % <span class="hljs-number">2</span>; <span class="hljs-comment">// 答案需要和重点坐标[m - 1, n - 1]之和同奇偶</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span> limit, <span class="hljs-type">int</span>[][] grid, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">boolean</span>[][] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n];<br>        Queue&lt;<span class="hljs-type">int</span>[]&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        q.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;m - <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>, limit - <span class="hljs-number">1</span>&#125;);<br>        visited[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">while</span> (!q.isEmpty()) &#123;<br>            <span class="hljs-type">int</span>[] node = q.poll();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> node[<span class="hljs-number">0</span>], j = node[<span class="hljs-number">1</span>], t = node[<span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> &amp;&amp; j == <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], col = j + dir[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span> (isValid(row, col, m, n) &amp;&amp; !visited[row][col] &amp;&amp; t &gt;= grid[row][col]) &#123;<br>                    q.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;row, col, t - <span class="hljs-number">1</span>&#125;);<br>                    visited[row][col] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &lt; n;<br>    &#125;<br><br>    <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;, &#123;-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;&#125;;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Contest</category>
        <category>LCP</category>
      </categories>
      <tags>
        <tag>力扣杯</tag>
      </tags>
  </entry>
  <entry>
    <title>lcpBi101</title>
    <url>/2023/08/17/lcpBi101/</url>
    <content><![CDATA[<h2 id="从两个数字数组里生成最小数字"><a href="https://leetcode.cn/problems/form-smallest-number-from-two-digit-arrays/">从两个数字数组里生成最小数字</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230817094941724.png" /></p>
<h3 id="方法二位运算">方法二：位运算</h3>
<p>Integer.numberOfTrailingZeros(m)表示m的二进制串中，最低为1后面0的个数</p>
<p><strong>举例</strong></p>
<p>nums1 = [1， 3]， nums2 = [2, 3]</p>
<p>mask1 = 1010, mask2 = 1100</p>
<p>m = mask1 &amp; mask2 = 1000</p>
<p>Integer.numberOfTrailingZeros(m) = 3</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mask1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, mask2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : nums1) mask1 |= <span class="hljs-number">1</span> &lt;&lt; x;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : nums2) mask2 |= <span class="hljs-number">1</span> &lt;&lt; x;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> mask1 &amp; mask2;<br>        <span class="hljs-keyword">if</span> (m &gt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> Integer.numberOfTrailingZeros(m);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> Integer.numberOfTrailingZeros(mask1), y = Integer.numberOfTrailingZeros(mask2);<br>        <span class="hljs-keyword">return</span> Math.min(x * <span class="hljs-number">10</span> + y, x + y * <span class="hljs-number">10</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法一排序-hashset">方法一：排序 + HashSet</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2)</span> &#123;<br>        Arrays.sort(nums1);<br>        Arrays.sort(nums2);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> nums1[<span class="hljs-number">0</span>] &lt; nums2[<span class="hljs-number">0</span>] ? nums1[<span class="hljs-number">0</span>] * <span class="hljs-number">10</span> + nums2[<span class="hljs-number">0</span>] : nums2[<span class="hljs-number">0</span>] * <span class="hljs-number">10</span> + nums1[<span class="hljs-number">0</span>];<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : nums1)<br>            set.add(x);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : nums2)<br>            <span class="hljs-keyword">if</span> (set.contains(x))<br>                <span class="hljs-keyword">return</span> x;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="找到最大开销的子字符串"><a href="https://leetcode.cn/problems/find-the-substring-with-maximum-cost/">找到最大开销的子字符串</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230817095344815.png" /></p>
<h3 id="方法一最大子数组和">方法一：最大子数组和</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximumCostSubstring</span><span class="hljs-params">(String s, String chars, <span class="hljs-type">int</span>[] vals)</span> &#123;<br>        <span class="hljs-type">int</span>[] map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; ++i)<br>            map[i] = i + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; chars.length(); ++i) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> chars.charAt(i);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> vals[i];<br>            map[ch - <span class="hljs-string">&#x27;a&#x27;</span>] = val;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); ++i) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> map[ch - <span class="hljs-string">&#x27;a&#x27;</span>];<br>            sum += val;<br>            res = Math.max(res, sum);<br>            <span class="hljs-keyword">if</span> (sum &lt; <span class="hljs-number">0</span>)<br>                sum = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="使子数组元素和相等"><a href="https://leetcode.cn/problems/make-k-subarray-sums-equal/">使子数组元素和相等</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230817100404803.png" /></p>
<h3 id="方法一转换中位数贪心裴蜀定理pythonjavacgo">方法一：【转换】中位数贪心+裴蜀定理（Python/Java/C++/Go）</h3>
<h2 id="图中的最短环"><a href="https://leetcode.cn/problems/shortest-cycle-in-a-graph/">图中的最短环</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230817101649329.png" /></p>
<h3 id="不需要visited数组">不需要Visited数组</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findShortestCycle</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] edges)</span> &#123;<br>        List&lt;Integer&gt;[] g = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[n];<br>        Arrays.setAll(g, o -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] edge : edges) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">from</span> <span class="hljs-operator">=</span> edge[<span class="hljs-number">0</span>], to = edge[<span class="hljs-number">1</span>];<br>            g[from].add(to);<br>            g[to].add(from);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            res = Math.min(res, bfs(i, n, g));<br>        <span class="hljs-keyword">return</span> res == Integer.MAX_VALUE ? -<span class="hljs-number">1</span> : res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> n, List&lt;Integer&gt;[] g)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        Queue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, -<span class="hljs-number">1</span>&#125;);<br>        <span class="hljs-type">int</span>[] dist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Arrays.fill(dist, -<span class="hljs-number">1</span>);<br>        dist[i] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span>[] arr = queue.poll();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>], pre = arr[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> next : g[node]) &#123;<br>                <span class="hljs-keyword">if</span> (dist[next] == -<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 没有被访问过</span><br>                    dist[next] = dist[node] + <span class="hljs-number">1</span>;<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;next, node&#125;);<br>                &#125; <br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (next != pre) <span class="hljs-comment">// 被访问过，且不是父节点</span><br>                    res = Math.min(res,  dist[next] + dist[node] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法一bfs">方法一：BFS</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findShortestCycle</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] edges)</span> &#123;<br>        List&lt;Integer&gt;[] g = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[n];<br>        Arrays.setAll(g, o -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] edge : edges) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">from</span> <span class="hljs-operator">=</span> edge[<span class="hljs-number">0</span>], to = edge[<span class="hljs-number">1</span>];<br>            g[from].add(to);<br>            g[to].add(from);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            Queue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>            queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, -<span class="hljs-number">1</span>&#125;);<br>            Set&lt;Integer&gt; visited=  <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>            <span class="hljs-type">int</span>[] dist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>            dist[i] = <span class="hljs-number">0</span>;<br>            visited.add(i);<br>            <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; size; ++j) &#123;<br>                    <span class="hljs-type">int</span>[] arr = queue.poll();<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>], pre = arr[<span class="hljs-number">1</span>];<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> next : g[node]) &#123;<br>                        <span class="hljs-keyword">if</span> (next == pre)<br>                            <span class="hljs-keyword">continue</span>;<br>                        <span class="hljs-keyword">if</span> (visited.contains(next)) &#123;<br>                            res = Math.min(res, dist[next] + dist[node] + <span class="hljs-number">1</span>);<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                        visited.add(next);<br>                        queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;next, node&#125;);<br>                        dist[next] = dist[node] + <span class="hljs-number">1</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res == Integer.MAX_VALUE ? -<span class="hljs-number">1</span> : res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Contest</category>
        <category>LCP</category>
      </categories>
      <tags>
        <tag>力扣杯</tag>
      </tags>
  </entry>
  <entry>
    <title>lcp338</title>
    <url>/2023/08/16/lcp338/</url>
    <content><![CDATA[<h2 id="k-件物品的最大和">K 件物品的最大和</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230816142210961.png" /></p>
<h3 id="方法一模拟">方法一：模拟</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">kItemsWithMaximumSum</span><span class="hljs-params">(<span class="hljs-type">int</span> numOnes, <span class="hljs-type">int</span> numZeros, <span class="hljs-type">int</span> numNegOnes, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-keyword">if</span> (k &lt;= numOnes)<br>            <span class="hljs-keyword">return</span> k;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k &gt; numOnes &amp;&amp; k &lt;= numOnes + numZeros)<br>            <span class="hljs-keyword">return</span> numOnes;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> numOnes - (k - numOnes - numZeros);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="质数减法运算">质数减法运算</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230816142859114.png" alt="　" />　</p>
<h3 id="方法一treeset">方法一：TreeSet</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> TreeSet&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-type">boolean</span>[] notPrime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[MAX + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; MAX; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (!notPrime[i]) &#123;<br>                set.add(i);<br>                <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span>) i * i &lt; MAX) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i * i; j &lt; MAX; j+=i)<br>                        notPrime[j] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">primeSubOperation</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">1</span>; --i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> nums[i - <span class="hljs-number">1</span>], next = nums[i];<br>            <span class="hljs-keyword">if</span> (pre &gt;= next) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">diff</span> <span class="hljs-operator">=</span> pre - next;<br>                <span class="hljs-type">Integer</span> <span class="hljs-variable">higher</span> <span class="hljs-operator">=</span> set.higher(diff);<br>                <span class="hljs-keyword">if</span> (higher == <span class="hljs-literal">null</span> || higher &gt;= pre)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                nums[i - <span class="hljs-number">1</span>] -= higher;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="使数组元素全部相等的最少操作次数">使数组元素全部相等的最少操作次数</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230816145955648.png" /></p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230816212759083.png" /></p>
<h3 id="方法一排序-前缀和-二分">方法一：排序 + 前缀和 + 二分</h3>
<p><strong>long long long!!!!!</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Long&gt; <span class="hljs-title function_">minOperations</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span>[] queries)</span> &#123;<br>        Arrays.sort(nums);<br>        List&lt;Long&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">long</span>[] preSum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[nums.length + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i)<br>            preSum[i + <span class="hljs-number">1</span>] = preSum[i] + nums[i];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> q : queries) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> lower(q, nums);<br>            <span class="hljs-type">long</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> index * (<span class="hljs-type">long</span>) q - preSum[index];<br>            <span class="hljs-type">long</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> preSum[nums.length] - preSum[index] - (<span class="hljs-type">long</span>) q * (nums.length - index);<br>            res.add(left + right);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lower</span><span class="hljs-params">(<span class="hljs-type">int</span> q, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &gt;= q)<br>                r = mid - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> l;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二和lcp339那题类似的做法">方法二：和lcp339那题类似的做法</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Long&gt; <span class="hljs-title function_">minOperations</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span>[] queries)</span> &#123;<br>        Arrays.sort(nums);<br>        List&lt;Long&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, q1 = queries[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">long</span>[] preSum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[nums.length + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : nums) &#123;<br>            s += Math.abs(x - q1);<br>            preSum[index] = preSum[index++ - <span class="hljs-number">1</span>] + x;<br>        &#125;<br>        res.add(s);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; queries.length; ++j) &#123;<br>            <span class="hljs-comment">// 找到 &gt;= q的nums下标</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> findIndex2(queries[j - <span class="hljs-number">1</span>], nums);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> findIndex(queries[j], nums);<br>            <span class="hljs-type">long</span> <span class="hljs-variable">middleSum</span> <span class="hljs-operator">=</span> preSum[k] - preSum[i + <span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> k - i - <span class="hljs-number">1</span>;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">diff</span> <span class="hljs-operator">=</span>  ((<span class="hljs-type">long</span>) queries[j] * size - middleSum) - (middleSum - (<span class="hljs-type">long</span>) queries[j - <span class="hljs-number">1</span>] * size);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - k;<br>            s += (left - right) * ((<span class="hljs-type">long</span>) queries[j] - queries[j - <span class="hljs-number">1</span>]) + diff;<br>            res.add(s);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> q, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &gt;= q)<br>                r = mid - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> l;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findIndex2</span><span class="hljs-params">(<span class="hljs-type">int</span> q, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &gt; q)<br>                r = mid - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="收集树中金币"><a href="https://leetcode.cn/problems/collect-coins-in-a-tree/">2603. 收集树中金币</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230818173630191.png" /></p>
<h3 id="方法一两次拓扑排序">方法一：两次拓扑排序</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">collectTheCoins</span><span class="hljs-params">(<span class="hljs-type">int</span>[] coins, <span class="hljs-type">int</span>[][] edges)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> edges.length + <span class="hljs-number">1</span>;<br>        List&lt;Integer&gt;[] g = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[n];<br>        Arrays.setAll(g, e -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        <span class="hljs-type">int</span>[] degree = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] edge : edges) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">from</span> <span class="hljs-operator">=</span> edge[<span class="hljs-number">0</span>], to = edge[<span class="hljs-number">1</span>];<br>            g[from].add(to);<br>            g[to].add(from);<br>            ++degree[from];<br>            ++degree[to];<br>        &#125;<br>        Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            <span class="hljs-keyword">if</span> (degree[i] == <span class="hljs-number">1</span> &amp;&amp; coins[i] == <span class="hljs-number">0</span>)<br>                queue.offer(i);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> next : g[node])<br>                <span class="hljs-keyword">if</span> (--degree[next] == <span class="hljs-number">1</span> &amp;&amp; coins[next] == <span class="hljs-number">0</span>)<br>                    queue.offer(next);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            <span class="hljs-keyword">if</span> (degree[i] == <span class="hljs-number">1</span> &amp;&amp; coins[i] == <span class="hljs-number">1</span>)<br>                queue.offer(i);<br>        <span class="hljs-type">int</span>[] times = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> size= queue.size();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> next : g[node]) &#123;<br>                    <span class="hljs-keyword">if</span> (--degree[next] == <span class="hljs-number">1</span>) &#123;<br>                        queue.offer(next);<br>                        times[next] = t;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            ++t;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] edge : edges)<br>            <span class="hljs-keyword">if</span> (times[edge[<span class="hljs-number">0</span>]] &gt;= <span class="hljs-number">2</span> &amp;&amp; times[edge[<span class="hljs-number">1</span>]] &gt;= <span class="hljs-number">2</span>)<br>                res += <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Contest</category>
        <category>LCP</category>
      </categories>
      <tags>
        <tag>力扣杯</tag>
      </tags>
  </entry>
  <entry>
    <title>lcp339</title>
    <url>/2023/08/16/lcp339/</url>
    <content><![CDATA[<h2 id="最长平衡子字符串">最长平衡子字符串</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230816091347753.png" /></p>
<h3 id="方法二一次遍历">方法二：一次遍历</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findTheLongestBalancedSubstring</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length(), pre = <span class="hljs-number">0</span>, cur = <span class="hljs-number">0</span>, res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            ++cur;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-keyword">if</span> (i == n - <span class="hljs-number">1</span> || s.charAt(i + <span class="hljs-number">1</span>) != ch) &#123; <span class="hljs-comment">// 分界点</span><br>                <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;1&#x27;</span>)<br>                    res = Math.max(res, Math.min(pre, cur) * <span class="hljs-number">2</span>);<br>                pre = cur;<br>                cur = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法一模拟">方法一：模拟</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findTheLongestBalancedSubstring</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">if</span> (s.equals(<span class="hljs-string">&quot;&quot;</span>))<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, n = s.length();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cnt0</span> <span class="hljs-operator">=</span>  <span class="hljs-number">0</span>, cnt1 = <span class="hljs-number">0</span>;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;2&#x27;</span>; <span class="hljs-comment">// pre =</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; n; ++j) &#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> s.charAt(j);<br>                <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (pre == <span class="hljs-string">&#x27;1&#x27;</span>)<br>                        <span class="hljs-keyword">break</span>;<br>                    ++cnt0;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// ch == &#x27;1&#x27;</span><br>                    <span class="hljs-keyword">if</span> (pre == <span class="hljs-string">&#x27;0&#x27;</span> || pre == <span class="hljs-string">&#x27;1&#x27;</span> )<br>                        ++cnt1;<br>                    <span class="hljs-keyword">if</span> (cnt1 == cnt0) &#123;<br>                        res = Math.max(res, cnt0 + cnt1);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>                pre = ch;<br><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="转换二维数组">转换二维数组</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230816093506317.png" /></p>
<h3 id="方法一哈希数组">方法一：哈希数组</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">findMatrix</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span>[] cnt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">201</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : nums) &#123;<br>            cnt[x]++;<br>            max = Math.max(max, cnt[x]);<br>        &#125;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; max; ++k) &#123;<br>            List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; cnt.length; ++i) &#123;<br>                <span class="hljs-keyword">if</span> (cnt[i] &gt; <span class="hljs-number">0</span>) &#123;<br>                    --cnt[i];<br>                    list.add(i);<br>                &#125;<br>            &#125;<br>            res.add(list);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="老鼠和奶酪">老鼠和奶酪</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230816094246695.png" /></p>
<h3 id="方法一贪心-排序">方法一：贪心 + 排序</h3>
<p><a href="https://leetcode.cn/problems/mice-and-cheese/solutions/2292688/lao-shu-he-nai-luo-by-leetcode-solution-6ia1/">贪心</a></p>
<p><span class="math inline">\(10^{10}\)</span>复杂度，dp会超时</p>
<p><strong>思路：</strong></p>
<ol type="1">
<li>如果老鼠1不吃奶酪，全部给老鼠2吃，那么分数为s = sum(reward2)。</li>
<li>如果老鼠1吃了第i颗奶酪，那么分数为s + reward1[i] - reward2[i]</li>
<li>求一个diff数组，并且排序，老鼠1吃diff[i]最大的k个奶酪</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">miceAndCheese</span><span class="hljs-params">(<span class="hljs-type">int</span>[] reward1, <span class="hljs-type">int</span>[] reward2, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, n = reward1.length;<br>        <span class="hljs-type">int</span>[] diff = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            sum += reward2[i];<br>            diff[i] = reward1[i] - reward2[i];<br>        &#125;<br>        Arrays.sort(diff);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= n - k; --i)<br>            sum += diff[i];<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="最少翻转操作数"><a href="https://leetcode.cn/problems/minimum-reverse-operations/">2612. 最少翻转操作数</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230816134058590.png" /></p>
<h3 id="方法一">方法一：</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Contest</category>
        <category>LCP</category>
      </categories>
      <tags>
        <tag>力扣杯</tag>
      </tags>
  </entry>
  <entry>
    <title>lcp340</title>
    <url>/2023/08/15/lcp340/</url>
    <content><![CDATA[<h2 id="对角线上的质数">对角线上的质数</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230815143809363.png" /></p>
<h3 id="方法一埃氏筛">方法一：埃氏筛</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span> * (<span class="hljs-type">int</span>) <span class="hljs-number">1e6</span> + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span>[] notPrime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n];<br>    <span class="hljs-keyword">static</span> &#123;<br>        notPrime[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        notPrime[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (!notPrime[i]) &#123;<br>                <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span>) i * i &lt; n) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i * i; j &lt; n; j+=i) &#123;<br>                        notPrime[j] = <span class="hljs-literal">true</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">diagonalPrime</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, m = nums.length, n = nums[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (!notPrime[nums[i][m - <span class="hljs-number">1</span> - i]])<br>                res = Math.max(res, nums[i][m - <span class="hljs-number">1</span> - i]);<br>            <span class="hljs-keyword">if</span> (!notPrime[nums[i][i]])<br>                res = Math.max(res, nums[i][i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="等值距离和">等值距离和</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230815150227713.png" /></p>
<h3 id="方法一相同元素分组考虑增量">方法一：相同元素分组+考虑增量</h3>
<p>如下图</p>
<p>左边距离增加了的个数，右边距离减少了的个数</p>
<p>long size = (j - 1) - (list.size() - 1 - j)= j * 2 - list.size();</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230815221918725.png" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span>[] distance(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">long</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n];<br>        Map&lt;Integer, List&lt;Integer&gt;&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> nums[i];<br>            <span class="hljs-keyword">if</span> (!map.containsKey(num))<br>                map.putIfAbsent(num, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>            map.get(num).add(i);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (List&lt;Integer&gt; list : map.values()) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : list) <br>                first += x - list.get(<span class="hljs-number">0</span>);<br>            <br>            res[list.get(<span class="hljs-number">0</span>)] = first;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; list.size(); ++j) &#123;<br>                <span class="hljs-type">long</span> <span class="hljs-variable">diff</span> <span class="hljs-operator">=</span> list.get(j) - list.get(j - <span class="hljs-number">1</span>);<br>                <span class="hljs-type">long</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> (<span class="hljs-type">long</span>) (j * <span class="hljs-number">2</span> - list.size());<br>                res[list.get(j)] = res[list.get(j - <span class="hljs-number">1</span>)] + diff * size;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="最小化数对的最大差值"><a href="https://leetcode.cn/problems/minimize-the-maximum-difference-of-pairs/">2616. 最小化数对的最大差值</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230816141607167.png" /></p>
<h3 id="方法一贪心-二分">方法一：贪心 + 二分</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimizeMax</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> p)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        Arrays.sort(nums);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = nums[n - <span class="hljs-number">1</span>] - nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (check(nums, mid, p))<br>                r = mid - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <br>                l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> l;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> limit, <span class="hljs-type">int</span> p)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">1</span>; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (Math.abs(nums[i] - nums[i + <span class="hljs-number">1</span>]) &lt;= limit) &#123;<br>                ++cnt;<br>                i++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt &gt;= p;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Contest</category>
        <category>LCP</category>
      </categories>
      <tags>
        <tag>力扣杯</tag>
      </tags>
  </entry>
  <entry>
    <title>Tree-DP</title>
    <url>/2023/08/14/tree-dp/</url>
    <content><![CDATA[<h2 id="打家劫舍-iii"><a href="https://leetcode.cn/problems/house-robber-iii/">337. 打家劫舍 III</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230814092511538.png" /></p>
<h3 id="方法一树形dp">方法一：树形DP</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-type">int</span>[] res = dfs(root);<br>        <span class="hljs-keyword">return</span> Math.max(res[<span class="hljs-number">0</span>], res[<span class="hljs-number">1</span>]);  <span class="hljs-comment">// 选或不选   </span><br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] dfs(TreeNode root) &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>        <span class="hljs-type">int</span>[] left = dfs(root.left);<br>        <span class="hljs-type">int</span>[] right = dfs(root.right);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rob</span> <span class="hljs-operator">=</span> root.val + left[<span class="hljs-number">1</span>] + right[<span class="hljs-number">1</span>]; <br>        <span class="hljs-type">int</span> <span class="hljs-variable">pass</span> <span class="hljs-operator">=</span> Math.max(left[<span class="hljs-number">0</span>], left[<span class="hljs-number">1</span>]) + Math.max(right[<span class="hljs-number">0</span>], right[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;rob, pass&#125;;   <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="最小化旅行的价格总和"><a href="https://leetcode.cn/problems/minimize-the-total-price-of-the-trips/">2646. 最小化旅行的价格总和</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230814100339968.png" /></p>
<h3 id="方法一树形dp-1">方法一：树形DP</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumTotalPrice</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] edges, <span class="hljs-type">int</span>[] price, <span class="hljs-type">int</span>[][] trips)</span> &#123;<br>        <span class="hljs-comment">// 建图</span><br>        <span class="hljs-built_in">this</span>.price = price;<br>        graph = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            graph[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] edge : edges) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">from</span> <span class="hljs-operator">=</span> edge[<span class="hljs-number">0</span>], to = edge[<span class="hljs-number">1</span>];<br>            graph[from].add(to);<br>            graph[to].add(from);<br>        &#125;<br>        count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-comment">// 获取每个节点经过的次数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] trip : trips)<br>            dfs(trip[<span class="hljs-number">0</span>], -<span class="hljs-number">1</span>, trip[<span class="hljs-number">1</span>]);<br>        <span class="hljs-comment">// 类似打家劫舍：打折或者不打折</span><br>        <span class="hljs-comment">// 随便选一个点作为根节点，所有情况都会考虑到</span><br>        <span class="hljs-type">int</span>[] res = dfs2(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> Math.min(res[<span class="hljs-number">0</span>], res[<span class="hljs-number">1</span>]);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] dfs2(<span class="hljs-type">int</span> cur, <span class="hljs-type">int</span> parent) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">notHalve</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, halve = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> next : graph[cur]) &#123;<br>            <span class="hljs-keyword">if</span> (next != parent) &#123;<br>                <span class="hljs-type">int</span>[] arr = dfs2(next, cur);<br>                <span class="hljs-type">int</span> <span class="hljs-variable">nh</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>], h = arr[<span class="hljs-number">1</span>];<br>                notHalve += Math.min(nh, h);<br>                halve += nh;<br>            &#125;<br>        &#125;<br>        notHalve += count[cur] * price[cur];<br>        halve += (count[cur] * price[cur]) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;notHalve, halve&#125;;<br>    &#125;<br><br>    <span class="hljs-type">int</span>[] count, price;<br>    List&lt;Integer&gt;[] graph;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> cur, <span class="hljs-type">int</span> parent, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-keyword">if</span> (cur == end) &#123;<br>            count[cur]++;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> next : graph[cur]) &#123;<br>            <span class="hljs-keyword">if</span> (next != parent &amp;&amp; dfs(next, cur, end)) &#123;<br>                count[cur]++;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="t-秒后青蛙的位置"><a href="https://leetcode.cn/problems/frog-position-after-t-seconds/">1377. T 秒后青蛙的位置</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230814111103435.png" /></p>
<h3 id="方法一树形dp-2">方法一：树形DP</h3>
<p><strong>思路：如果在给定步数t内找到target，则返回true，“归”的时候将概率prob / 当前节点的子树个数</strong></p>
<p><strong>特判根节点情况</strong></p>
<p>(leftStep &gt;= 0 &amp;&amp; graph[cur].size() &lt;= 1)表示走到根节点，但是步数没用完，可以原地起跳</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">frogPosition</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] edges, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span> &amp;&amp; target == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target == <span class="hljs-number">1</span> &amp;&amp; t &gt; <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0.0</span>;<br>        <span class="hljs-built_in">this</span>.n = n;<br>        <span class="hljs-built_in">this</span>.t = t;<br>        <span class="hljs-built_in">this</span>.target = target;<br>        graph = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[n + <span class="hljs-number">1</span>];<br>        Arrays.setAll(graph, o -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] edge : edges) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">from</span> <span class="hljs-operator">=</span> edge[<span class="hljs-number">0</span>], to = edge[<span class="hljs-number">1</span>];<br>            graph[from].add(to);<br>            graph[to].add(from);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!findPath(<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, t))<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> prob;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">findPath</span><span class="hljs-params">(<span class="hljs-type">int</span> cur, <span class="hljs-type">int</span> parent, <span class="hljs-type">int</span> leftStep)</span> &#123;<br>        <span class="hljs-comment">// (leftStep &gt;= 0 &amp;&amp; graph[cur].size() &lt;= 1)表示走到根节点，但是步数没用完，可以原地起跳</span><br>        <span class="hljs-keyword">if</span> (cur == target &amp;&amp; (leftStep == <span class="hljs-number">0</span> || (leftStep &gt;= <span class="hljs-number">0</span> &amp;&amp; graph[cur].size() &lt;= <span class="hljs-number">1</span>))) <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> next : graph[cur]) &#123;<br>            <span class="hljs-keyword">if</span> (next != parent &amp;&amp; findPath(next, cur, leftStep - <span class="hljs-number">1</span>)) &#123;<br>                <span class="hljs-keyword">if</span> (parent == -<span class="hljs-number">1</span>) <span class="hljs-comment">// root</span><br>                    prob /= graph[cur].size();<br>                <span class="hljs-keyword">else</span><br>                    prob /= (graph[cur].size() - <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    List&lt;Integer&gt;[] graph;<br>    <span class="hljs-type">int</span> n, t, target;<br>    <span class="hljs-type">double</span> <span class="hljs-variable">prob</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="树上最大得分和路径"><a href="https://leetcode.cn/problems/most-profitable-path-in-a-tree/">2467. 树上最大得分和路径</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230814113111223.png" /></p>
<h3 id="方法一树形dp-3">方法一：树形DP</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mostProfitablePath</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] edges, <span class="hljs-type">int</span> bob, <span class="hljs-type">int</span>[] amount)</span> &#123;<br>        n = edges.length + <span class="hljs-number">1</span>;<br>        graph = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[n];<br>        <span class="hljs-built_in">this</span>.amount = amount;<br>        Arrays.setAll(graph, o -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        time = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Arrays.fill(time, n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] edge : edges) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">from</span> <span class="hljs-operator">=</span> edge[<span class="hljs-number">0</span>], to = edge[<span class="hljs-number">1</span>];<br>            graph[from].add(to);<br>            graph[to].add(from);<br>        &#125;<br>        graph[<span class="hljs-number">0</span>].add(-<span class="hljs-number">1</span>);<br>        getDistFromRoot(bob, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        dfs(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> alice, <span class="hljs-type">int</span> parent, <span class="hljs-type">int</span> aliceTime, <span class="hljs-type">int</span> score)</span> &#123;<br>        <span class="hljs-keyword">if</span> (aliceTime == time[alice])<br>            score += amount[alice] / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (aliceTime &lt; time[alice])<br>            score += amount[alice];<br>        <span class="hljs-keyword">if</span> (graph[alice].size() == <span class="hljs-number">1</span>) &#123;<br>            res = Math.max(res, score);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> next : graph[alice])<br>            <span class="hljs-keyword">if</span> (next != parent)<br>                dfs(next, alice, aliceTime + <span class="hljs-number">1</span>, score);<br>    &#125;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">getDistFromRoot</span><span class="hljs-params">(<span class="hljs-type">int</span> cur, <span class="hljs-type">int</span> parent, <span class="hljs-type">int</span> t)</span> &#123;<br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-number">0</span>) &#123;<br>            time[cur] = t;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> next : graph[cur]) &#123;<br>            <span class="hljs-keyword">if</span> (next != parent &amp;&amp; getDistFromRoot(next, cur, t + <span class="hljs-number">1</span>)) &#123;<br>                time[cur] = t;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    &#125;<br><br>    List&lt;Integer&gt;[] graph;<br>    <span class="hljs-type">int</span>[] time;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">int</span>[] amount;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">_5</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">_5</span>().solve();<br>    &#125;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">int</span>[] v;<br>    List&lt;List&lt;Integer&gt;&gt; graph = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">solve</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        n = sc.nextInt();<br>        v = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            v[i] = sc.nextInt();<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= n; i++) graph.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;());<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; n  - <span class="hljs-number">1</span>; i ++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> sc.nextInt();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> sc.nextInt();<br>            graph.get(a).add(b);<br>            graph.get(b).add(a);<br>        &#125;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>][<span class="hljs-number">2</span>];<br>        dfs(<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>);<br>        System.out.println(Math.max(dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]));<br>    &#125;<br><br>    <span class="hljs-type">int</span>[][] dp; <span class="hljs-comment">//node 0不染色 1染色</span><br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> node, <span class="hljs-type">int</span> pre)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> next : graph.get(node)) &#123;<br>            <span class="hljs-keyword">if</span> (next != pre) &#123;<br>                dfs(next,node);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//不染色</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> next : graph.get(node)) &#123;<br>            <span class="hljs-keyword">if</span> (next != pre) &#123;<br>                dp[node][<span class="hljs-number">0</span>] += Math.max(dp[next][<span class="hljs-number">0</span>], dp[next][<span class="hljs-number">1</span>]) ;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> next : graph.get(node)) &#123;<br>            <span class="hljs-keyword">if</span> (next != pre) &#123;<br>                <span class="hljs-keyword">if</span> (isAns(v[next], v[node])) dp[node][<span class="hljs-number">1</span>] = Math.max(dp[node][<span class="hljs-number">0</span>] - Math.max(dp[next][<span class="hljs-number">0</span>], dp[next][<span class="hljs-number">1</span>])+<span class="hljs-number">2</span>+dp[next][<span class="hljs-number">0</span>], dp[node][<span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAns</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">if</span> (a &lt; <span class="hljs-number">0</span> || b &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a*b;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sq</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) Math.sqrt(c);<br>        <span class="hljs-keyword">return</span> sq*sq == c;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="二叉树中的最长交错路径"><a href="https://leetcode.cn/problems/longest-zigzag-path-in-a-binary-tree/">1372. 二叉树中的最长交错路径</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230905170621083.png" /></p>
<h3 id="方法一树形dp-4">方法一：树形DP</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    Map&lt;TreeNode, Integer&gt; f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(), g = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestZigZag</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        f.put(root, <span class="hljs-number">0</span>);<br>        g.put(root, <span class="hljs-number">0</span>);<br>        dfs(root, <span class="hljs-literal">null</span>);<br>        <span class="hljs-keyword">for</span> (TreeNode t : f.keySet())<br>            res = Math.max(res, Math.max(f.get(t), g.get(t)));<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, TreeNode pre)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (pre != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (root == pre.left) &#123;<br>                f.put(root, g.get(pre) + <span class="hljs-number">1</span>);<br>                g.put(root, <span class="hljs-number">0</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                f.put(root, <span class="hljs-number">0</span>);<br>                g.put(root, f.get(pre) + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        dfs(root.left, root);<br>        dfs(root.right, root);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二dfspost">方法二：DFS(post)</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestZigZag</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        dfs(root, <span class="hljs-literal">null</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, TreeNode pre)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> dfs(root.left, root);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> dfs(root.right, root);<br>        <span class="hljs-keyword">if</span> (pre != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (root == pre.left) &#123;<br>                res = Math.max(res, r + <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">return</span> r + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                res = Math.max(res, l + <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">return</span> l + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.max(l, r) + <span class="hljs-number">1</span>;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法三dfs">方法三：DFS</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestZigZag</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        dfs(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] dfs(TreeNode root) &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> dfs(root.left)[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> dfs(root.right)[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>;<br>        res = Math.max(res, Math.max(l, r));<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;l, r&#125;;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithms</category>
        <category>Dynamic Programming</category>
      </categories>
      <tags>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title>lcp358</title>
    <url>/2023/08/13/lcp358/</url>
    <content><![CDATA[<h2 id="第一题数组中的最大数对和">第一题数组中的最大数对和</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230813103044010.png" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; nums.length; ++j) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp1</span> <span class="hljs-operator">=</span> nums[i], temp2 = nums[j], maxDig1 = -<span class="hljs-number">1</span>, maxDig2 = -<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">while</span> (temp1 != <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> temp1 % <span class="hljs-number">10</span>;<br>                    temp1 /= <span class="hljs-number">10</span>;<br>                    <span class="hljs-keyword">if</span> (a &gt; maxDig1)<br>                        maxDig1 = a;<br>                &#125;<br>                <span class="hljs-keyword">while</span> (temp2 != <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> temp2 % <span class="hljs-number">10</span>;<br>                    temp2 /= <span class="hljs-number">10</span>;<br>                    <span class="hljs-keyword">if</span> (a &gt; maxDig2)<br>                        maxDig2 = a;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (maxDig1 == maxDig2 &amp;&amp; nums[i] + nums[j] &gt; max) &#123;<br>                    max = nums[i] + nums[j];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="第一题翻倍以链表形式表示的数字">第一题翻倍以链表形式表示的数字</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230813103917833.png" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">doubleIt</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> reverse(head), pre = <span class="hljs-literal">null</span>, tail = cur;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            cur.val = cur.val * <span class="hljs-number">2</span> + c;<br>            c = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (cur.val &gt;= <span class="hljs-number">10</span>) &#123;<br>                cur.val -= <span class="hljs-number">10</span>;<br>                c++;<br>            &#125;<br>            pre = cur;<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        cur = reverse(tail);<br>        <span class="hljs-keyword">if</span> (c &gt; <span class="hljs-number">0</span>) &#123;<br>            n = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">1</span>);<br>            n.next = head;<br>        &#125;<br>        <span class="hljs-keyword">return</span> c &gt; <span class="hljs-number">0</span> ? n : head;<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> ListNode <span class="hljs-title function_">reverse</span><span class="hljs-params">(ListNode cur)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>, pre = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            next = cur.next;<br>            cur.next = pre;<br>            pre = cur;<br>            cur = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="第一题限制条件下元素之间的最小绝对差">第一题限制条件下元素之间的最小绝对差</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230813110023185.png" /></p>
<h3 id="方法一双指针-treeset">方法一：双指针 + TreeSet</h3>
<p>指针i(左)初始化为0，指针r(右)初始化为x，遍历整个数组。 每轮开始，将nums[i]加入TreeSet中，在treeset查询是否存在小于等于nums[r]的最大值哥大于等于nums[r]的最小值，与全局遍历min进行比较。 由于右指针r指向的元素与TreeSet中的元素的间隔至少为x，满足题意</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minAbsoluteDifference</span><span class="hljs-params">(List&lt;Integer&gt; g, <span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-type">int</span>[] nums = g.stream().mapToInt(i-&gt;i).toArray();<br>        TreeSet&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length, min = Integer.MAX_VALUE;<br>        <span class="hljs-type">int</span>  <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> x;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            set.add(nums[i]);<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">lower</span> <span class="hljs-operator">=</span> set.floor(nums[r]), higher = set.ceiling(nums[r]);<br>            <span class="hljs-keyword">if</span> (lower != <span class="hljs-literal">null</span>) <br>                min = Math.min(min, Math.abs(lower - nums[r]));<br>            <span class="hljs-keyword">if</span> (higher != <span class="hljs-literal">null</span>)<br>                min = Math.min(min, Math.abs(higher - nums[r]));<br>            ++r;<br>            <span class="hljs-keyword">if</span> (r == n)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> min;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Contest</category>
        <category>LCP</category>
      </categories>
      <tags>
        <tag>力扣杯</tag>
      </tags>
  </entry>
  <entry>
    <title>lcp341</title>
    <url>/2023/08/12/lcp341/</url>
    <content><![CDATA[<h2 id="一最多的行">一最多的行</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230812192752419.png" /></p>
<h3 id="方法一模拟">方法一：模拟</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] rowAndMaximumOnes(<span class="hljs-type">int</span>[][] mat) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> mat.length, n = mat[<span class="hljs-number">0</span>].length, max = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (mat[i][j] == <span class="hljs-number">1</span>)<br>                    ++count;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (count &gt; max) &#123;<br>                res[<span class="hljs-number">0</span>] = i;<br>                res[<span class="hljs-number">1</span>] = count;<br>                max = count;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="找出可整除性得分最大的整数">找出可整除性得分最大的整数</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230812193113124.png" /></p>
<h3 id="方法一整除与被整除">方法一：整除与被整除？</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDivScore</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span>[] divisors)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, val = divisors[<span class="hljs-number">0</span>];<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; divisors.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (set.contains(divisors[i]))<br>                <span class="hljs-keyword">continue</span>;<br>            set.add(divisors[i]);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; nums.length; ++j) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> nums[j];<br>                <span class="hljs-keyword">if</span> (nums[j] % divisors[i] == <span class="hljs-number">0</span>)<br>                    ++count;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (count &gt; max || (count == max &amp;&amp; divisors[i] &lt; val)) &#123;<br>                max = count;<br>                val = divisors[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> val;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="构造有效字符串的最少插入数">构造有效字符串的最少插入数</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230812195410683.png" /></p>
<h3 id="方法一bullshit">方法一：bullshit</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">addMinimum</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-keyword">if</span> (word.equals(<span class="hljs-string">&quot;abc&quot;</span>))<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, n = word.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> word.charAt(i);<br>            <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;a&#x27;</span>) &#123;<br>                <span class="hljs-keyword">if</span> (i + <span class="hljs-number">2</span> &lt; n &amp;&amp; word.charAt(i + <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;b&#x27;</span> &amp;&amp; word.charAt(i + <span class="hljs-number">2</span>) == <span class="hljs-string">&#x27;c&#x27;</span>)<br>                    i = i + <span class="hljs-number">2</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i + <span class="hljs-number">2</span> &gt;= n) &#123;<br>                    <span class="hljs-keyword">if</span> (i == n - <span class="hljs-number">1</span>)<br>                        res += <span class="hljs-number">2</span>;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == n - <span class="hljs-number">2</span> &amp;&amp; word.charAt(i + <span class="hljs-number">1</span>) != <span class="hljs-string">&#x27;a&#x27;</span>) &#123;<br>                        res += <span class="hljs-number">1</span>;<br>                        i = n - <span class="hljs-number">1</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == n - <span class="hljs-number">2</span> &amp;&amp; word.charAt(i + <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;a&#x27;</span>)<br>                        res += <span class="hljs-number">2</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (word.charAt(i + <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;a&#x27;</span>) &#123;<br>                    res += <span class="hljs-number">2</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (word.charAt(i + <span class="hljs-number">1</span>) != <span class="hljs-string">&#x27;a&#x27;</span>) &#123;<br>                    res += <span class="hljs-number">1</span>;<br>                    i = i + <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (word.charAt(i + <span class="hljs-number">2</span>) != <span class="hljs-string">&#x27;c&#x27;</span>) &#123;<br>                    res += <span class="hljs-number">1</span>;<br>                    i += <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;b&#x27;</span>) &#123;<br>                <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt; n) &#123;<br>                    <span class="hljs-keyword">if</span> (word.charAt(i + <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;c&#x27;</span>) &#123;<br>                        res += <span class="hljs-number">1</span>;<br>                        ++i;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> &#123;<br>                        res += <span class="hljs-number">2</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == n - <span class="hljs-number">1</span>) &#123;<br>                    res += <span class="hljs-number">2</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span>  &#123; <span class="hljs-comment">// &#x27;c&#x27;</span><br>                res += <span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="最小化旅行的价格总和">最小化旅行的价格总和</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230812202807126.png" /></p>
]]></content>
      <categories>
        <category>Contest</category>
        <category>LCP</category>
      </categories>
      <tags>
        <tag>力扣杯</tag>
      </tags>
  </entry>
  <entry>
    <title>lcp342</title>
    <url>/2023/08/12/lcp342/</url>
    <content><![CDATA[<h2 id="计算列车到站时间">计算列车到站时间</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230812163041333.png" /></p>
<h3 id="方法一">方法一：</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findDelayedArrivalTime</span><span class="hljs-params">(<span class="hljs-type">int</span> arrivalTime, <span class="hljs-type">int</span> delayedTime)</span> &#123;<br>        <span class="hljs-keyword">return</span> (arrivalTime + delayedTime) % <span class="hljs-number">24</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="倍数求和">倍数求和</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230812163230300.png" /></p>
<h3 id="方法二数学">方法二：数学</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumOfMultiples</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-built_in">this</span>.n = n;<br>        <span class="hljs-keyword">return</span> s(<span class="hljs-number">3</span>) + s(<span class="hljs-number">5</span>) + s(<span class="hljs-number">7</span>) - s(<span class="hljs-number">15</span>) - s(<span class="hljs-number">21</span>) - s(<span class="hljs-number">35</span>) + s(<span class="hljs-number">105</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">s</span><span class="hljs-params">(<span class="hljs-type">int</span> m)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-number">1</span> + n / m) *  (n / m) / <span class="hljs-number">2</span> * m;<br>    &#125;<br>    <span class="hljs-type">int</span> n;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法一暴力">方法一：暴力</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumOfMultiples</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>; i &lt;= n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">3</span> == <span class="hljs-number">0</span> || i % <span class="hljs-number">5</span> == <span class="hljs-number">0</span> || i % <span class="hljs-number">7</span> == <span class="hljs-number">0</span>)<br>                res += i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="滑动子数组的美丽值">滑动子数组的美丽值</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230812164421174.png" /></p>
<h3 id="方法一双treemap">方法一：双TreeMap</h3>
<p><a href="https://leetcode.cn/problems/sliding-subarray-beauty/solutions/2242149/ping-heng-shu-wu-shi-zhi-yu-fan-wei-by-v-ch1y/">题解</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] getSubarrayBeauty(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> x) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n - k + <span class="hljs-number">1</span>];<br>        TreeMap&lt;Integer, Integer&gt; greater = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;(), smaller = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            smaller.put(nums[i], smaller.getOrDefault(nums[i], <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (i &gt;= x) &#123; <span class="hljs-comment">// smaller 弹出最大元素</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">curMax</span> <span class="hljs-operator">=</span> smaller.lastKey();<br>                greater.put(curMax, greater.getOrDefault(curMax, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span> (smaller.get(curMax) == <span class="hljs-number">1</span>)<br>                    smaller.remove(curMax);<br>                <span class="hljs-keyword">else</span><br>                    smaller.put(curMax, smaller.get(curMax) - <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (i &gt;= k) &#123; <span class="hljs-comment">// 移除nums[i-k]</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> nums[i - k];<br>                <span class="hljs-keyword">if</span> (greater.containsKey(target)) &#123;<br>                    <span class="hljs-keyword">if</span> (greater.get(target) == <span class="hljs-number">1</span>)<br>                        greater.remove(target);<br>                    <span class="hljs-keyword">else</span><br>                        greater.put(target, greater.get(target) - <span class="hljs-number">1</span>);<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (smaller.get(target) == <span class="hljs-number">1</span>)<br>                        smaller.remove(target);<br>                    <span class="hljs-keyword">else</span><br>                        smaller.put(target, smaller.get(target) - <span class="hljs-number">1</span>);<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> greater.firstKey();<br>                    smaller.put(temp, smaller.getOrDefault(temp, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>                    <span class="hljs-keyword">if</span> (greater.get(temp) == <span class="hljs-number">1</span>)<br>                        greater.remove(temp);<br>                    <span class="hljs-keyword">else</span><br>                        greater.put(temp, greater.get(temp) - <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (i &gt;= k - <span class="hljs-number">1</span>)<br>                res[i - k + <span class="hljs-number">1</span>] = Math.min(<span class="hljs-number">0</span>, smaller.lastKey());<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="使数组所有元素变成-1-的最少操作次数"><a href="https://leetcode.cn/problems/minimum-number-of-operations-to-make-all-array-elements-equal-to-1/">2654. 使数组所有元素变成 1 的最少操作次数</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230812191153349.png" /></p>
<h3 id="方法一-1">方法一：</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minOperations</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length, gcdAll = <span class="hljs-number">0</span>, count1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : nums) &#123;<br>            gcdAll = gcd(gcdAll, x);<br>            <span class="hljs-keyword">if</span> (x == <span class="hljs-number">1</span>)<br>                ++count1;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (gcdAll &gt; <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (count1 &gt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> n - count1;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">minSize</span> <span class="hljs-operator">=</span> n;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">g</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; n; ++j) &#123;<br>                g = gcd(g, nums[j]);<br>                <span class="hljs-keyword">if</span> (g == <span class="hljs-number">1</span>) &#123;<br>                    minSize = Math.min(minSize, j - i + <span class="hljs-number">1</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> minSize + n - <span class="hljs-number">2</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">while</span> (a != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> a;<br>            a = b % a;<br>            b = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Contest</category>
        <category>LCP</category>
      </categories>
      <tags>
        <tag>力扣杯</tag>
      </tags>
  </entry>
  <entry>
    <title>lcp357</title>
    <url>/2023/08/06/lcp357/</url>
    <content><![CDATA[<h2 id="故障键盘">故障键盘</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230806103021172.png" /></p>
<h3 id="方法二双端队列">方法二：双端队列</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">finalString</span><span class="hljs-params">(String s)</span> &#123;<br>        Deque&lt;Character&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">shouldReverse</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); ++i) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;i&#x27;</span>)<br>                shouldReverse = !shouldReverse;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (!shouldReverse) <br>                    queue.offerFirst(ch);<br>                <span class="hljs-keyword">else</span> <br>                    queue.offerLast(ch);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-keyword">if</span> (shouldReverse)<br>                sb.append(queue.pollFirst());<br>            <span class="hljs-keyword">else</span><br>                sb.append(queue.pollLast());<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法一暴力">方法一：暴力</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">finalString</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-keyword">if</span> (ch != <span class="hljs-string">&#x27;i&#x27;</span>) &#123;<br>                sb.append(ch);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                reverse(sb);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(StringBuilder sb)</span> &#123;<br>        sb.reverse();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="判断是否能拆分数组">判断是否能拆分数组</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230806103312610.png" /></p>
<h3 id="方法一记忆化搜索">方法一：记忆化搜索</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canSplitArray</span><span class="hljs-params">(List&lt;Integer&gt; nums, <span class="hljs-type">int</span> m)</span> &#123;<br>        <span class="hljs-built_in">this</span>.nums = nums;<br>        n = nums.size();<br>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-built_in">this</span>.m = m;<br>        preSum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            preSum[i + <span class="hljs-number">1</span>] = preSum[i] + nums.get(i);<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, n);<br>    &#125;<br><br>    <span class="hljs-comment">// [)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>        <span class="hljs-keyword">if</span> (r - l == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> l + <span class="hljs-string">&quot;#&quot;</span> + r;<br>        <span class="hljs-keyword">if</span> (map.containsKey(key))<br>            <span class="hljs-keyword">return</span> map.get(key);<br>        <span class="hljs-keyword">if</span> (preSum[r] - preSum[l] &lt; m) &#123;<br>            map.put(key, <span class="hljs-literal">false</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> l + <span class="hljs-number">1</span>; i &lt; r; ++i) &#123;<br>            res = dfs(l, i) &amp;&amp; dfs(i, r);<br>            <span class="hljs-keyword">if</span> (res) &#123;<br>                map.put(key, res);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        map.put(key, res);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    List&lt;Integer&gt; nums;<br>    <span class="hljs-type">int</span> m, n;<br>    Map&lt;String, Boolean&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-type">int</span>[] preSum;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二贪心">方法二：贪心</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canSplitArray</span><span class="hljs-params">(List&lt;Integer&gt; nums, <span class="hljs-type">int</span> m)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.size() - <span class="hljs-number">1</span>; ++i) <br>            <span class="hljs-keyword">if</span> (nums.get(i) + nums.get(i + <span class="hljs-number">1</span>) &gt;= m)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> nums.size() &lt;= <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="找出最安全路径"><a href="https://leetcode.cn/problems/find-the-safest-path-in-a-grid/">6951. 找出最安全路径</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230806175345482.png" /></p>
<h3 id="方法一多源bfs">方法一：多源BFS</h3>
<p>二分做右端点的初始</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = Math.min(dist[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], dist[n - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>]);<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximumSafenessFactor</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; g)</span> &#123;<br>        n = g.size();<br>        grid = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j)<br>                grid[i][j] = g.get(i).get(j);<br>        <span class="hljs-type">int</span>[][] dist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        Queue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dist)<br>            Arrays.fill(arr, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j)<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>) &#123;<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, j&#125;);<br>                    dist[i][j] = <span class="hljs-number">0</span>;<br>                &#125;<br><br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span>[] node = queue.poll();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> node[<span class="hljs-number">0</span>] + dir[<span class="hljs-number">0</span>], col = node[<span class="hljs-number">1</span>] + dir[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span> (isValid(row, col) &amp;&amp; dist[row][col] == -<span class="hljs-number">1</span>) &#123;<br>                    dist[row][col] = dist[node[<span class="hljs-number">0</span>]][node[<span class="hljs-number">1</span>]] + <span class="hljs-number">1</span>;<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;row, col&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = Math.min(dist[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], dist[n - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (check(mid, dist))<br>                l = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                r = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> r;<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span> limit, <span class="hljs-type">int</span>[][] dist)</span> &#123;<br>        Queue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">boolean</span>[][] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n][n];<br>        queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;);<br>        visited[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span>[] node = queue.poll();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> node[<span class="hljs-number">0</span>] + dir[<span class="hljs-number">0</span>], col = node[<span class="hljs-number">1</span>] + dir[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span> (isValid(row, col) &amp;&amp; !visited[row][col] &amp;&amp; dist[row][col] &gt;= limit) &#123;<br>                    visited[row][col] = <span class="hljs-literal">true</span>;<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;row, col&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> visited[n - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>    &#125;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; n &amp;&amp; j &lt; n;<br>    &#125;<br><br>    <span class="hljs-type">int</span>[][] grid, dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-type">int</span> n;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="在check中判断初始位置r-2-n---1-大一点也没关系">在check中判断初始位置，r = 2 * n - 1 (大一点也没关系)</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (dist[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] &lt; limit)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure>
<h4 id="代码">代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximumSafenessFactor</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; g)</span> &#123;<br>        n = g.size();<br>        grid = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j)<br>                grid[i][j] = g.get(i).get(j);<br><br>        <span class="hljs-type">int</span>[][] dist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        Queue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dist)<br>            Arrays.fill(arr, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j)<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>) &#123;<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, j&#125;);<br>                    dist[i][j] = <span class="hljs-number">0</span>;<br>                &#125;<br><br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span>[] node = queue.poll();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> node[<span class="hljs-number">0</span>] + dir[<span class="hljs-number">0</span>], col = node[<span class="hljs-number">1</span>] + dir[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span> (isValid(row, col) &amp;&amp; dist[row][col] == -<span class="hljs-number">1</span>) &#123;<br>                    dist[row][col] = dist[node[<span class="hljs-number">0</span>]][node[<span class="hljs-number">1</span>]] + <span class="hljs-number">1</span>;<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;row, col&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = <span class="hljs-number">2</span> * n;<br>        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (check(mid, dist))<br>                l = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                r = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> r;<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span> limit, <span class="hljs-type">int</span>[][] dist)</span> &#123;<br>        Queue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">boolean</span>[][] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n][n];<br>        <span class="hljs-keyword">if</span> (dist[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] &lt; limit)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;);<br>        visited[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span>[] node = queue.poll();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> node[<span class="hljs-number">0</span>] + dir[<span class="hljs-number">0</span>], col = node[<span class="hljs-number">1</span>] + dir[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span> (isValid(row, col) &amp;&amp; !visited[row][col] &amp;&amp; dist[row][col] &gt;= limit) &#123;<br>                    visited[row][col] = <span class="hljs-literal">true</span>;<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;row, col&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> visited[n - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>    &#125;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; n &amp;&amp; j &lt; n;<br>    &#125;<br><br>    <span class="hljs-type">int</span>[][] grid, dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-type">int</span> n;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="check使用dfs">check使用DFS</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximumSafenessFactor</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; g)</span> &#123;<br>        n = g.size();<br>        grid = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        dist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        Queue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                grid[i][j] = g.get(i).get(j);<br>                dist[i][j] = -<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>) &#123;<br>                    dist[i][j] = <span class="hljs-number">0</span>;<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, j&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// bfs</span><br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span>[] node = queue.poll();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> node[<span class="hljs-number">0</span>] + dir[<span class="hljs-number">0</span>], col = node[<span class="hljs-number">1</span>] + dir[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span> (isValid(row, col) &amp;&amp; dist[row][col] == -<span class="hljs-number">1</span>) &#123;<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;row, col&#125;);<br>                    dist[row][col] = dist[node[<span class="hljs-number">0</span>]][node[<span class="hljs-number">1</span>]] + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = (n - <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (check(mid))<br>                l = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                r = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span> minDist)</span> &#123;<br>        <span class="hljs-keyword">if</span> (dist[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] &lt; minDist)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">boolean</span>[][] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n][n];<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, minDist, visited);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> minDist, <span class="hljs-type">boolean</span>[][] visited)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i == n -<span class="hljs-number">1</span> &amp;&amp; j == n - <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        visited[i][j] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], col =  j + dir[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (isValid(row, col) &amp;&amp; !visited[row][col] &amp;&amp; dist[row][col] &gt;= minDist) &#123;<br>                <span class="hljs-keyword">if</span> (dfs(row, col, minDist, visited))<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &gt;=<span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; n &amp;&amp; j &lt; n;<br>    &#125;<br><br>    <span class="hljs-type">int</span>[][] grid, dist, dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-type">int</span> n;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二多源bfs-并查集">方法二：多源BFS + 并查集</h3>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230807195936407.png" /></p>
<p><strong>关于从dists.size() - 2开始枚举：最后一步是空集，所以最大的距离为 dists.size() - 2</strong></p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230807200100709.png" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximumSafenessFactor</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; g)</span> &#123;<br>        n = g.size();<br>        grid = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-type">int</span>[][] dist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dist)<br>            Arrays.fill(arr, -<span class="hljs-number">1</span>);<br>        List&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                grid[i][j] = g.get(i).get(j);<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>) &#123;<br>                    dist[i][j] = <span class="hljs-number">0</span>;<br>                    queue.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, j&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 多源BFS</span><br>        List&lt;List&lt;<span class="hljs-type">int</span>[]&gt;&gt; dists = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        dists.add(queue);<br>        List&lt;<span class="hljs-type">int</span>[]&gt; temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            temp = queue;<br>            queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] node : temp) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> node[<span class="hljs-number">0</span>] + dir[<span class="hljs-number">0</span>], col = node[<span class="hljs-number">1</span>] + dir[<span class="hljs-number">1</span>];<br>                    <span class="hljs-keyword">if</span> (isValid(row, col) &amp;&amp; dist[row][col] == -<span class="hljs-number">1</span>) &#123;  <span class="hljs-comment">// 没有被访问过</span><br>                        queue.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;row, col&#125;);<br>                        dist[row][col] = dists.size();<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 最后一步是空集，所以最大的距离为 dists.size() - 2</span><br>            dists.add(queue);<br>        &#125;<br>        <span class="hljs-comment">// 初始化并查集</span><br>        init(n * n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> dists.size() - <span class="hljs-number">2</span>; i &gt; <span class="hljs-number">0</span>; --i) &#123;<br>            List&lt;<span class="hljs-type">int</span>[]&gt; q = dists.get(i);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] node : q) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> node[<span class="hljs-number">0</span>] + dir[<span class="hljs-number">0</span>], col = node[<span class="hljs-number">1</span>] + dir[<span class="hljs-number">1</span>];<br>                    <span class="hljs-keyword">if</span> (isValid(row, col) &amp;&amp; dist[row][col] &gt;= i)<br>                        union(node[<span class="hljs-number">0</span>] * n + node[<span class="hljs-number">1</span>],row * n + col);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (findParent(<span class="hljs-number">0</span>) == findParent(n * n - <span class="hljs-number">1</span>))<br>                <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; n &amp;&amp; j &lt; n;<br>    &#125;<br><br>    <span class="hljs-type">int</span>[][] grid, dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-type">int</span> n;<br><br>    <span class="hljs-type">int</span>[] parent;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rootI</span> <span class="hljs-operator">=</span> findParent(i), rootJ = findParent(j);<br>        <span class="hljs-keyword">if</span> (rootI != rootJ) &#123;<br>            parent[rootI] = rootJ;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findParent</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i != parent[i])<br>            parent[i] = findParent(parent[i]);<br>        <span class="hljs-keyword">return</span> parent[i];<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        parent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            parent[i] = i;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="补充题-1631.-最小体力消耗路径">补充题 <a href="https://leetcode.cn/problems/path-with-minimum-effort/">1631. 最小体力消耗路径</a></h3>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230807221758342.png" /></p>
<h3 id="方法一多源bfs-二分">方法一：多源BFS + 二分</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumEffortPath</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] heights)</span> &#123;<br>        <span class="hljs-built_in">this</span>.heights = heights;<br>        m = heights.length;<br>        n = heights[<span class="hljs-number">0</span>].length;<br>        visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = (<span class="hljs-type">int</span>) <span class="hljs-number">1e6</span>;<br>        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (check(mid))<br>                r = mid - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> l;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span> limit)</span> &#123;<br>        visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n];<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, limit);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> limit)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i == m - <span class="hljs-number">1</span> &amp;&amp; j == n - <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        visited[i][j] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], col = j + dir[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (isValid(row, col) &amp;&amp; !visited[row][col] &amp;&amp; Math.abs(heights[i][j] - heights[row][col]) &lt;= limit)<br>                <span class="hljs-keyword">if</span> (dfs(row, col, limit))<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br><br>    <span class="hljs-type">int</span>[][] heights, dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-type">int</span> m, n;<br>    <span class="hljs-type">boolean</span>[][] visited;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &lt; n;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二并查集">方法二：并查集</h3>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230807223638902.png" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumEffortPath</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] heights)</span> &#123;<br>        <span class="hljs-built_in">this</span>.heights = heights;<br>        m = heights.length;<br>        n = heights[<span class="hljs-number">0</span>].length;<br>        visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n];<br>        List&lt;<span class="hljs-type">int</span>[]&gt; edges = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> i * n + j;<br>                <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>)<br>                    edges.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;id - n, id, Math.abs(heights[i][j] - heights[i - <span class="hljs-number">1</span>][j])&#125;);<br>                <span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">0</span>)<br>                    edges.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;id - <span class="hljs-number">1</span>, id, Math.abs(heights[i][j] - heights[i][j - <span class="hljs-number">1</span>])&#125;);<br>            &#125;<br>        &#125;<br>        Collections.sort(edges, (o1, o2) -&gt; o1[<span class="hljs-number">2</span>] - o2[<span class="hljs-number">2</span>]);<br>        <span class="hljs-comment">// 初始化并查集</span><br>        init(m * n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] edge : edges) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">from</span> <span class="hljs-operator">=</span> edge[<span class="hljs-number">0</span>], to = edge[<span class="hljs-number">1</span>], weight = edge[<span class="hljs-number">2</span>];<br>            union(from, to);<br>            <span class="hljs-keyword">if</span> (findParent(<span class="hljs-number">0</span>) == findParent(m * n - <span class="hljs-number">1</span>))<br>                <span class="hljs-keyword">return</span> weight;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span>[] parent;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rootI</span> <span class="hljs-operator">=</span> findParent(i), rootJ = findParent(j);<br>        <span class="hljs-keyword">if</span> (rootI != rootJ) &#123;<br>            parent[rootI] = rootJ;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findParent</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i != parent[i])<br>            parent[i] = findParent(parent[i]);<br>        <span class="hljs-keyword">return</span> parent[i];<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        parent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            parent[i] = i;<br>    &#125;<br><br><br><br>    <span class="hljs-type">int</span>[][] heights, dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-type">int</span> m, n;<br>    <span class="hljs-type">boolean</span>[][] visited;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &lt; n;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Contest</category>
        <category>LCP</category>
      </categories>
      <tags>
        <tag>力扣杯</tag>
      </tags>
  </entry>
  <entry>
    <title>lcpBi110</title>
    <url>/2023/08/05/lcpBi110/</url>
    <content><![CDATA[<h2 id="第一题取整购买后的账户余额">第一题取整购买后的账户余额</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230805223015154.png" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">accountBalanceAfterPurchase</span><span class="hljs-params">(<span class="hljs-type">int</span> purchaseAmount)</span> &#123;<br>        <span class="hljs-keyword">if</span> (purchaseAmount == <span class="hljs-number">100</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (purchaseAmount &lt; <span class="hljs-number">5</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;<br>        <span class="hljs-keyword">if</span> (purchaseAmount &lt; <span class="hljs-number">10</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">90</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">round</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, min = <span class="hljs-number">100</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>; i &lt;= <span class="hljs-number">100</span>; i += <span class="hljs-number">10</span>) &#123;<br>            <span class="hljs-keyword">if</span> (Math.abs(i - purchaseAmount) &lt;=  min) &#123;<br>                round = i;<br>                min = Math.abs(i - purchaseAmount);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">100</span> - round;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="第二题在链表中插入最大公约数">第二题在链表中插入最大公约数</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230805224003377.png" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">insertGreatestCommonDivisors</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (cur.next != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> cur.next;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> calc(cur.val, next.val);<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(val, next);<br>            cur.next = x;<br>            cur = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> Math.min(a, b);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= min; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (a % i == <span class="hljs-number">0</span> &amp;&amp; b % i == <span class="hljs-number">0</span>)<br>                res = i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="第三题使循环数组所有元素相等的最少秒数">第三题使循环数组所有元素相等的最少秒数</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230805224709443.png" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure>
<h2 id="第四题使数组和小于等于-x-的最少时间">第四题使数组和小于等于 x 的最少时间</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230805231038102.png" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure>
<figure>
<img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230806151531856.png" alt="image-20230806151531856" /><figcaption aria-hidden="true">image-20230806151531856</figcaption>
</figure>
]]></content>
      <categories>
        <category>Contest</category>
        <category>LCP</category>
      </categories>
      <tags>
        <tag>力扣杯</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode_hot100</title>
    <url>/2023/08/01/leetcode-hot100/</url>
    <content><![CDATA[<h2 id="两数之和"><a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230801105257951.png" /></p>
<h3 id="方法一hashmap">方法一：HashMap</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (map.containsKey(target - nums[i]))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;map.get(target - nums[i]), i&#125;;<br>            map.put(nums[i], i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="两数相加"><a href="https://leetcode.cn/problems/add-two-numbers/">2. 两数相加</a></h2>
<h3 id="方法一链表">方法一：链表</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">addTwoNumbers</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>), cur = dummy;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">carry</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-literal">null</span> || l2 != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> (l1 != <span class="hljs-literal">null</span> ? l1.val : <span class="hljs-number">0</span>) + (l2 != <span class="hljs-literal">null</span> ? l2.val : <span class="hljs-number">0</span>) + carry;<br>            carry = val &gt;= <span class="hljs-number">10</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>            cur.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(carry == <span class="hljs-number">0</span> ? val : val % <span class="hljs-number">10</span>);<br>            cur = cur.next;<br>            <span class="hljs-keyword">if</span> (l1 != <span class="hljs-literal">null</span>)<br>                l1 = l1.next;<br>            <span class="hljs-keyword">if</span> (l2 != <span class="hljs-literal">null</span>)<br>                l2 = l2.next;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (carry == <span class="hljs-number">1</span>)<br>            cur.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="无重复字符的最长子串"><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230801111037138.png" /></p>
<h3 id="方法一滑动窗口">方法一：滑动窗口</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, n = s.length();<br>        Map&lt;Character, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>; right &lt; n; ++right) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> s.charAt(right);<br>            <span class="hljs-keyword">while</span> (map.containsKey(ch)) &#123;<br>                left = Math.max(left, map.get(ch) + <span class="hljs-number">1</span>);<br>                map.remove(ch);<br>            &#125;<br>            map.put(ch, right);<br>            res = Math.max(res, right - left + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<div class="note note-danger">
            <h2 id="寻找两个正序数组的中位数"><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">4. 寻找两个正序数组的中位数</a></h2>
          </div>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230801142522081.png" /></p>
<h3 id="方法一划分区间">方法一：划分区间</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">findMedianSortedArrays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums1.length &gt; nums2.length)<br>            <span class="hljs-keyword">return</span> findMedianSortedArrays(nums2, nums1);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> nums1.length, n = nums2.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">median1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, median2 = <span class="hljs-number">0</span>; <span class="hljs-comment">// 如果有m + n是偶数，median2是第二个中位数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = m; <span class="hljs-comment">// i == m时，表示nums1全被划分为前一部分</span><br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-comment">// 前一部分包含 nums1[0 .. i-1] 和 nums2[0 .. j-1]</span><br>            <span class="hljs-comment">// 后一部分包含 nums1[i .. m-1] 和 nums2[j .. n-1]</span><br>            <span class="hljs-comment">// 当m + n是偶数，规定前一部分和后一部分的长度相同</span><br>            <span class="hljs-comment">// 当m + n是奇数，规定前一部分的长度 == 后一部分的长度 + 1</span><br>            <span class="hljs-comment">// j = (m + n + 1 ) / 2 - i 可以很好地满足，不管m+n是奇数还是偶数</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> (left + right) / <span class="hljs-number">2</span>, j = (m + n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> - i;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">nums_i</span> <span class="hljs-operator">=</span> i == m ? Integer.MAX_VALUE : nums1[i];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">nums_im1</span> <span class="hljs-operator">=</span> i == <span class="hljs-number">0</span> ? Integer.MIN_VALUE : nums1[i - <span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">nums_j</span> <span class="hljs-operator">=</span> j == n ? Integer.MAX_VALUE : nums2[j];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">nums_jm1</span> <span class="hljs-operator">=</span> j == <span class="hljs-number">0</span> ? Integer.MIN_VALUE : nums2[j - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (nums_im1 &lt;= nums_j) &#123;<br>                median1 = Math.max(nums_im1, nums_jm1);<br>                median2 = Math.min(nums_i, nums_j);<br>                left = i + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                right = i - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (m + n) % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? (median1 + median2) / <span class="hljs-number">2.0</span> : median1;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<div class="note note-danger">
            <h2 id="最长回文子串"><a href="https://leetcode.cn/problems/longest-palindromic-substring/">5. 最长回文子串</a></h2>
          </div>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230801152326814.png" /></p>
<h3 id="方法一dp">方法一：DP</h3>
<p><strong>注意遍历顺序</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length(), max = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] maxIndex = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch1</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; n; ++j) &#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">ch2</span> <span class="hljs-operator">=</span> s.charAt(j);<br>                <span class="hljs-keyword">if</span> (j - i + <span class="hljs-number">1</span> &lt;= <span class="hljs-number">2</span>)<br>                    dp[i][j] = ch1 == ch2 ? j - i + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">else</span><br>                    dp[i][j] = (ch1 == ch2 &amp;&amp; dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span>) ? <span class="hljs-number">2</span> + dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] : <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span> (dp[i][j] &gt; max) &#123;<br>                    max = dp[i][j];<br>                    maxIndex[<span class="hljs-number">0</span>] = i;<br>                    maxIndex[<span class="hljs-number">1</span>] = j;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.substring(maxIndex[<span class="hljs-number">0</span>], maxIndex[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<div class="note note-danger">
            <h2 id="正则表达式匹配"><a href="https://leetcode.cn/problems/regular-expression-matching/">10. 正则表达式匹配</a></h2>
          </div>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230803151243387.png" /></p>
<h3 id="方法一dp-1">方法一：DP</h3>
<p><a href="https://leetcode.cn/problems/regular-expression-matching/solutions/296114/shou-hui-tu-jie-wo-tai-nan-liao-by-hyj8/">题解</a></p>
<p><strong>初始化非常重要！！！！</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isMatch</span><span class="hljs-params">(String s, String p)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> s.length(), n = p.length();<br>        <span class="hljs-comment">// dp[i][j]:s[0:i]与p[0:j]是否匹配</span><br>        <span class="hljs-type">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 空串与空串匹配</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; ++j)<br>            <span class="hljs-keyword">if</span> (p.charAt(j - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;*&#x27;</span>)<br>                dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j - <span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (s.charAt(i - <span class="hljs-number">1</span>) == p.charAt(j - <span class="hljs-number">1</span>) || p.charAt(j - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;.&#x27;</span>)<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p.charAt(j - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (s.charAt(i - <span class="hljs-number">1</span>) == p.charAt(j - <span class="hljs-number">2</span>) || p.charAt(j - <span class="hljs-number">2</span>) == <span class="hljs-string">&#x27;.&#x27;</span>)<br>                        dp[i][j] = dp[i][j - <span class="hljs-number">2</span>] || dp[i - <span class="hljs-number">1</span>][j];<br>                    <span class="hljs-keyword">else</span> <br>                        dp[i][j] = dp[i][j - <span class="hljs-number">2</span>];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<div class="note note-danger">
            <h2 id="盛最多水的容器"><a href="https://leetcode.cn/problems/container-with-most-water/">11. 盛最多水的容器</a></h2>
          </div>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230803170353666.png" /></p>
<h3 id="方法一双指针贪心">方法一：双指针贪心</h3>
<p>移动短板，可以证明不会漏掉最大的结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> height.length, max = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> right - left;<br>            max = height[left] &lt; height[right] ? Math.max(max, length * height[left++]) : Math.max(max, length * height[right--]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二回溯超时">方法二：回溯(超时)</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>        n = height.length;<br>        <span class="hljs-built_in">this</span>.height = height;<br>        dfs(<span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-keyword">if</span> (left == right) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        res = Math.max(res, (right - left) * Math.min(height[right], height[left]));<br>        dfs(left + <span class="hljs-number">1</span>, right);<br>        dfs(left, right - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-type">int</span> n, res = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span>[] height;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<div class="note note-danger">
            <h2 id="三数之和"><a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a></h2><p><strong>二刷没做出来</strong></p>
          </div>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230803171841011.png" /></p>
<h3 id="方法一排序-双指针">方法一：排序 + 双指针</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">threeSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        Arrays.sort(nums);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">2</span>; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>])<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>, right = n - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>                <span class="hljs-keyword">if</span> (nums[i] + nums[left] + nums[right] == <span class="hljs-number">0</span>) &#123;<br>                    res.add(Arrays.asList(nums[i], nums[left], nums[right]));<br>                    <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left + <span class="hljs-number">1</span>] == nums[left])<br>                        ++left;<br>                    <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right - <span class="hljs-number">1</span>] == nums[right])<br>                        --right;<br>                    ++left;<br>                    --right;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] + nums[left] + nums[right] &lt; <span class="hljs-number">0</span>) <br>                    ++left;<br>                <span class="hljs-keyword">else</span> <br>                    --right;<br>            &#125; <br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="电话号码的字母组合"><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230803175703876.png" /></p>
<h3 id="方法一回溯">方法一：回溯</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">letterCombinations</span><span class="hljs-params">(String digits)</span> &#123;<br>        dfs(digits, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(String digits, <span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == digits.length()) &#123;<br>            <span class="hljs-keyword">if</span> (sb.length() &gt; <span class="hljs-number">0</span>)<br>                res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(sb));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">curDigit</span> <span class="hljs-operator">=</span> digits.charAt(index) - <span class="hljs-string">&#x27;0&#x27;</span>; <span class="hljs-comment">// 2</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">curStr</span> <span class="hljs-operator">=</span> map[curDigit];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; curStr.length(); ++i) &#123;<br>            sb.append(curStr.charAt(i));<br>            dfs(digits, index + <span class="hljs-number">1</span>);<br>            sb.deleteCharAt(sb.length() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    String[] map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;def&quot;</span>, <span class="hljs-string">&quot;ghi&quot;</span>, <span class="hljs-string">&quot;jkl&quot;</span>, <span class="hljs-string">&quot;mno&quot;</span>, <span class="hljs-string">&quot;pqrs&quot;</span>, <span class="hljs-string">&quot;tuv&quot;</span>, <span class="hljs-string">&quot;wxyz&quot;</span>&#125;;<br>    List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>&#125;   <br></code></pre></td></tr></table></figure>
<h2 id="删除链表的倒数第-n-个结点"><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230803181121272.png" /></p>
<h3 id="方法一模拟">方法一：模拟</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummyHead</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>, head), cur = head, pre = dummyHead;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            cur = cur.next;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            cur = cur.next;<br>            pre = pre.next;<br>        &#125;<br>        pre.next = pre.next.next;<br>        <span class="hljs-keyword">return</span> dummyHead.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="有效的括号"><a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230803181818901.png" /></p>
<h3 id="方法一栈-hashmap-模拟">方法一：栈 + HashMap 模拟</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String s)</span> &#123;<br>        Stack&lt;Character&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        Map&lt;Character, Character&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-string">&#x27;)&#x27;</span>, <span class="hljs-string">&#x27;(&#x27;</span>);<br>        map.put(<span class="hljs-string">&#x27;&#125;&#x27;</span>, <span class="hljs-string">&#x27;&#123;&#x27;</span>);<br>        map.put(<span class="hljs-string">&#x27;]&#x27;</span>, <span class="hljs-string">&#x27;[&#x27;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); ++i) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;(&#x27;</span> || ch == <span class="hljs-string">&#x27;[&#x27;</span> || ch == <span class="hljs-string">&#x27;&#123;&#x27;</span>)<br>                stack.push(ch);<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (stack.isEmpty())<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">if</span> (map.get(ch) != stack.pop())<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack.isEmpty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<div class="note note-success">
            <h2 id="合并两个有序链表"><a href="https://leetcode.cn/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></h2>
          </div>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230803195400672.png" /></p>
<h3 id="方法二递归">方法二：递归</h3>
<p><a href="https://leetcode.cn/problems/merge-two-sorted-lists/solutions/103891/yi-kan-jiu-hui-yi-xie-jiu-fei-xiang-jie-di-gui-by-/">题解</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode list1, ListNode list2)</span> &#123;<br>        <span class="hljs-keyword">if</span> (list1 == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> list2;<br>        <span class="hljs-keyword">if</span> (list2 == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> list1;<br>        <span class="hljs-keyword">if</span> (list1.val &lt; list2.val) &#123;<br>            list1.next = mergeTwoLists(list1.next, list2);<br>            <span class="hljs-keyword">return</span> list1;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            list2.next = mergeTwoLists(list1, list2.next);<br>            <span class="hljs-keyword">return</span> list2;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法三迭代">方法三：迭代</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>        <span class="hljs-keyword">if</span> (l1 == <span class="hljs-literal">null</span> || l2 == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> l1 == <span class="hljs-literal">null</span> ? l2 : l1;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummyHead</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(), cur = dummyHead;<br>        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-literal">null</span> &amp;&amp; l2 != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (l1.val &lt; l2.val) &#123;<br>                cur.next = l1;<br>                l1 = l1.next;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                cur.next = l2;<br>                l2 = l2.next;<br>            &#125;<br>            cur = cur.next;<br>        &#125;<br>        cur.next = l1 == <span class="hljs-literal">null</span> ? l2 : l1;<br>        <span class="hljs-keyword">return</span> dummyHead.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法一模拟-1">方法一：模拟</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode list1, ListNode list2)</span> &#123;<br>        <span class="hljs-keyword">if</span> (list1 == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> list2;<br>        <span class="hljs-keyword">if</span> (list2 == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> list1;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummyHead</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>), cur = dummyHead;<br>        <span class="hljs-keyword">while</span> (list1 != <span class="hljs-literal">null</span> &amp;&amp; list2 != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (list1.val &lt; list2.val) &#123;<br>                cur.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(list1.val);<br>                list1 = list1.next;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                cur.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(list2.val);<br>                list2 = list2.next;<br>            &#125;<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (list1 == <span class="hljs-literal">null</span>)<br>            cur.next = list2;<br>        <span class="hljs-keyword">if</span> (list2 == <span class="hljs-literal">null</span>)<br>            cur.next = list1;<br>        <span class="hljs-keyword">return</span> dummyHead.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="括号生成"><a href="https://leetcode.cn/problems/generate-parentheses/">22. 括号生成</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230803214345972.png" /></p>
<h3 id="方法一回溯-1">方法一：回溯</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-built_in">this</span>.n = n;<br>        dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-keyword">if</span> (left + right == <span class="hljs-number">2</span> * n) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(sb));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (left &lt; n) &#123;<br>            sb.append(<span class="hljs-string">&#x27;(&#x27;</span>);<br>            dfs(left + <span class="hljs-number">1</span>, right);<br>            sb.deleteCharAt(sb.length() - <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (left &gt; right) &#123;<br>            sb.append(<span class="hljs-string">&#x27;)&#x27;</span>);<br>            dfs(left, right + <span class="hljs-number">1</span>);<br>            sb.deleteCharAt(sb.length() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    <span class="hljs-type">int</span> n;<br>&#125;<br></code></pre></td></tr></table></figure>
<div class="note note-warning">
            <h2 id="合并-k-个升序链表"><a href="https://leetcode.cn/problems/merge-k-sorted-lists/">23. 合并 K 个升序链表</a></h2>
          </div>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230803215828985.png" /></p>
<h3 id="方法一暴力">方法一：暴力</h3>
<ol type="1">
<li>把所有ListNode的值加入小根堆</li>
<li>不断弹出小根堆，并创建新节点</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> &#123;<br>        PriorityQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (ListNode node : lists) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> node;<br>            <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>                queue.add(cur.val);<br>                cur = cur.next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummyHead</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>), cur = dummyHead;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            cur.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(queue.poll());<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummyHead.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二迭代">方法二：迭代</h3>
<p><strong>注意：</strong>debug很久，类比一道题：给出一个链表的头节点head，初始cur指向head，然后遍历cur，让cur = cur.next，head的位置没有变</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">// minNode = minNode.next; 没有修改头节点的指针</span><br>lists[minIndex] = lists[minIndex].next; <span class="hljs-comment">// 添加这行代码以更新指针</span><br></code></pre></td></tr></table></figure>
<h4 id="代码">代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummyHead</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>), cur = dummyHead;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> lists.length;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">minIndex</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>, minVal = <span class="hljs-number">10001</span>;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">minNode</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>                <span class="hljs-keyword">if</span> (lists[i] == <span class="hljs-literal">null</span>)<br>                    <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span> (minVal &gt; lists[i].val) &#123;<br>                    minVal = lists[i].val;<br>                    minIndex = i;<br>                    minNode = lists[i];<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (minIndex == -<span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">break</span>;<br>            cur.next = minNode;<br>            cur = cur.next;<br>            <span class="hljs-comment">// minNode = minNode.next; 没有修改头节点的指针</span><br>            lists[minIndex] = lists[minIndex].next; <span class="hljs-comment">// 添加这行代码以更新指针</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> dummyHead.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法三小根堆优化方法二">方法三：小根堆优化方法二</h3>
<p>不能按照以下方式初始化queue的大小，会报错</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">PriorityQueue&lt;ListNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(k, (v1, v2) -&gt; v1.val - v2.val);<br></code></pre></td></tr></table></figure>
<h4 id="代码-1">代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummyHead</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>), cur = dummyHead;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> lists.length;<br>        PriorityQueue&lt;ListNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((v1, v2) -&gt; v1.val - v2.val);<br>        <span class="hljs-keyword">for</span> (ListNode x : lists)<br>            <span class="hljs-keyword">if</span> (x != <span class="hljs-literal">null</span>)<br>                queue.add(x);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">minNode</span> <span class="hljs-operator">=</span> queue.poll();<br>            cur.next = minNode;<br>            cur = cur.next;<br>            minNode = minNode.next;<br>            <span class="hljs-keyword">if</span> (minNode != <span class="hljs-literal">null</span>)<br>                queue.add(minNode);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummyHead.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法四分治">方法四：分治</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> &#123;<br>        <span class="hljs-keyword">return</span> merge(lists, <span class="hljs-number">0</span>, lists.length - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">merge</span><span class="hljs-params">(ListNode[] lists, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>        <span class="hljs-keyword">if</span> (l == r)<br>            <span class="hljs-keyword">return</span> lists[l];<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l &gt; r)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">l1</span> <span class="hljs-operator">=</span> merge(lists, l, mid);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">l2</span> <span class="hljs-operator">=</span> merge(lists, mid + <span class="hljs-number">1</span>, r);<br>        <span class="hljs-keyword">return</span> mergeTwoList(l1, l2);        <br>    &#125;<br><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoList</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>        <span class="hljs-keyword">if</span> (l1 == <span class="hljs-literal">null</span> || l2 == <span class="hljs-literal">null</span>) <br>            <span class="hljs-keyword">return</span> l1 == <span class="hljs-literal">null</span> ? l2 : l1;<br>        <span class="hljs-keyword">if</span> (l1.val &lt; l2.val) &#123;<br>            l1.next = mergeTwoList(l1.next, l2);<br>            <span class="hljs-keyword">return</span> l1;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            l2.next = mergeTwoList(l1, l2.next);<br>            <span class="hljs-keyword">return</span> l2;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="下一个排列"><a href="https://leetcode.cn/problems/next-permutation/">31. 下一个排列</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230805145346349.png" /></p>
<h3 id="方法一双指针模拟">方法一：双指针模拟</h3>
<p><a href="https://leetcode.cn/problems/next-permutation/solutions/80560/xia-yi-ge-pai-lie-suan-fa-xiang-jie-si-lu-tui-dao-/">题解</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">nextPermutation</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 1. 从后往前，找到第一个升序序列，nums[i] &lt; nums[j] (i &lt; j)</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length, i = n - <span class="hljs-number">2</span>, j = n - <span class="hljs-number">1</span>, k = n - <span class="hljs-number">1</span>; <br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[i] &gt;= nums[j]) &#123;<br>            --i;<br>            --j;<br>        &#125;<br>        <span class="hljs-comment">// 如果i == -1，则此时nums是最大的逆序对，跳转到第3步(全部翻转)</span><br>        <span class="hljs-comment">// 2.从后往前，找到第一个大于nums[i]的数nums[k]，并swap (nums[k]是最小的大于nums[i]的数)</span><br>        <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">while</span> (nums[k] &lt;= nums[i])<br>                --k;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[i];<br>            nums[i] = nums[k];<br>            nums[k] = temp;<br>        &#125;<br>        <span class="hljs-comment">// 3.将j到末尾的子数组翻转</span><br>        k = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (j &lt; k) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[j];<br>            nums[j] = nums[k];<br>            nums[k] = temp;<br>            ++j;<br>            --k;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<div class="note note-success">
            <h2 id="最长有效括号"><a href="https://leetcode.cn/problems/longest-valid-parentheses/">32. 最长有效括号</a></h2>
          </div>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230805152234759.png" /></p>
<h3 id="方法一dp-2">方法一：DP</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestValidParentheses</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length(), max = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// dp[i]: 以s.charAt(i)结尾的子串的最长有效括号长度</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-comment">// 1.找到第一个左括号，前面的右括号是无效的</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (start &lt; n) &#123;<br>            <span class="hljs-keyword">if</span> (s.charAt(start) == <span class="hljs-string">&#x27;(&#x27;</span>)<br>                <span class="hljs-keyword">break</span>;<br>            ++start;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start + <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> s.charAt(i - <span class="hljs-number">1</span>), ch = s.charAt(i);<br>            <span class="hljs-comment">// 2.只考虑右括号</span><br>            <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>                <span class="hljs-comment">// 如果前一个括号是左括号，那么以ch结尾的子串至少长为2，如果前面也有有小括号，把长度累加</span><br>                <span class="hljs-keyword">if</span> (pre == <span class="hljs-string">&#x27;(&#x27;</span>)<br>                    dp[i] = <span class="hljs-number">2</span> + (i - <span class="hljs-number">2</span> &gt; start ? dp[i - <span class="hljs-number">2</span>] : <span class="hljs-number">0</span>);<br>                <span class="hljs-comment">// 前一个括号是右括号</span><br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 3.考虑 &quot;((()))&quot;</span><br>                    <span class="hljs-comment">// 如果前一个右括号形成了有效括号，并且这个有效括号的前一个字符是&#x27;(&#x27;，那么以ch结尾的子串至少</span><br>                    <span class="hljs-comment">// 长为2 + dp[i - 1]</span><br>                    <span class="hljs-comment">//4.考虑 &quot;()(())&quot;，计算出&quot;(())&quot;后，再往前面找一位，如果有有效括号，继续累加</span><br>                    <span class="hljs-comment">//  在3.的基础上，在</span><br>                    <span class="hljs-keyword">if</span> (dp[i - <span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span> &amp;&amp; i - dp[i - <span class="hljs-number">1</span>] &gt; start &amp;&amp; s.charAt(i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                        dp[i] = <span class="hljs-number">2</span> + dp[i - <span class="hljs-number">1</span>] + (i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">2</span> &gt; start ? dp[i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">2</span>] : <span class="hljs-number">0</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>            max = Math.max(max, dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Digit Dynamic Programming</title>
    <url>/2023/07/30/digit-dynamic-programming/</url>
    <content><![CDATA[<h1 id="数位-dp">数位 DP</h1>
<p><a href="https://www.bilibili.com/video/BV1do4y1K7Wq/?spm_id_from=333.999.0.0&amp;vd_source=d0a01265c4f3d5026b4e06c76cce4fe9">灵神视频</a></p>
<p>数位是指把一个数字按照个、十、百、千等等一位一位地拆开，关注它每一位上的数字。如果拆的是十进制数，那么每一位数字都是 0~9，其他进制可类比十进制。</p>
<p>数位 DP：用来解决一类特定问题，这种问题比较好辨认，一般具有这几个特征：</p>
<ol type="1">
<li>要求统计满足一定条件的数的数量（即，最终目的为计数）；</li>
<li>这些条件经过转化后可以使用「数位」的思想去理解和判断；</li>
<li>输入会提供一个数字区间（有时也只提供上界）来作为统计的限制；</li>
<li>上界很大（比如 <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="10^{18}" />），暴力枚举验证会超时。</li>
</ol>
<p>数位 DP 的基本原理：</p>
<p>考虑人类计数的方式，最朴素的计数就是从小到大开始依次加一。但我们发现对于位数比较多的数，这样的过程中有许多重复的部分。例如，从 7000 数到 7999、从 8000 数到 8999、和从 9000 数到 9999 的过程非常相似，它们都是后三位从 000 变到 999，不一样的地方只有千位这一位，所以我们可以把这些过程归并起来，将这些过程中产生的计数答案也都存在一个通用的数组里。此数组根据题目具体要求设置状态，用递推或 DP 的方式进行状态转移。</p>
<p>数位 DP 中通常会利用常规计数问题技巧，比如把一个区间内的答案拆成两部分相减（即 <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="{[l, r]} = {[0, r]}-_{[0, l - 1]}" />）</p>
<p>那么有了通用答案数组，接下来就是统计答案。统计答案可以选择记忆化搜索，也可以选择循环迭代递推。为了不重不漏地统计所有不超过上限的答案，要从高到低枚举每一位，再考虑每一位都可以填哪些数字，最后利用通用答案数组统计答案。</p>
<h2 id="统计整数数目"><a href="https://leetcode.cn/problems/count-of-integers/">2719. 统计整数数目</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230730230515525.png" /></p>
<h3 id="方法一数位dp">方法一：数位DP</h3>
<p><a href="https://leetcode.cn/problems/count-of-integers/solutions/2296043/shu-wei-dp-tong-yong-mo-ban-pythonjavacg-9tuc/">题解</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-type">int</span> min_sum, max_sum, n, MOD = (<span class="hljs-type">int</span>) (<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>);<br>    <span class="hljs-type">int</span>[][] dp;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">count</span><span class="hljs-params">(String num1, String num2, <span class="hljs-type">int</span> min_sum, <span class="hljs-type">int</span> max_sum)</span> &#123;<br>        <span class="hljs-built_in">this</span>.min_sum = min_sum;<br>        <span class="hljs-built_in">this</span>.max_sum = max_sum;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> count(num2) - count(num1) + MOD;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> count(num2);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; num1.length(); ++i)<br>            sum += num1.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (sum &gt;= min_sum &amp;&amp; sum &lt;= max_sum)<br>            ++res;<br>        <span class="hljs-keyword">return</span> res % MOD;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">count</span><span class="hljs-params">(String num)</span> &#123;<br>        n = num.length();<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][<span class="hljs-number">401</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dp)<br>            Arrays.fill(arr, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(num, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">true</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(String num, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> preSum, <span class="hljs-type">boolean</span> isLimit)</span> &#123;<br>        <span class="hljs-keyword">if</span> (preSum &gt; max_sum)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (index == num.length())<br>            <span class="hljs-keyword">return</span> preSum &gt;= min_sum ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (!isLimit &amp;&amp; dp[index][preSum] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[index][preSum];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">upperBound</span> <span class="hljs-operator">=</span> isLimit ? num.charAt(index) - <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">9</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= upperBound; ++i)<br>            res = (res + dfs(num, index + <span class="hljs-number">1</span>, preSum + i, isLimit &amp;&amp; i == upperBound)) % MOD;<br>        <span class="hljs-keyword">if</span> (!isLimit)<br>            dp[index][preSum] = res;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="统计特殊整数"><a href="https://leetcode.cn/problems/count-special-integers/">2376. 统计特殊整数</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230731192218490.png" /></p>
<h3 id="方法一数位dp-1">方法一：数位DP</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">int</span>[][] dp;<br>    String num;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countSpecialNumbers</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        num = String.valueOf(n);<br>        <span class="hljs-built_in">this</span>.n = num.length();<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-built_in">this</span>.n][<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">10</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dp)<br>            Arrays.fill(arr, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> mask, <span class="hljs-type">boolean</span> isLimit, <span class="hljs-type">boolean</span> isNum)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == n)<br>            <span class="hljs-keyword">return</span> isNum ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<span class="hljs-comment">// isNum 为 true 表示得到了一个合法数字</span><br>        <span class="hljs-keyword">if</span> (!isLimit &amp;&amp; isNum &amp;&amp; dp[index][mask] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[index][mask];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (!isNum) <span class="hljs-comment">// 可以跳过当前数位 (继续填0)</span><br>            res += dfs(index + <span class="hljs-number">1</span>, mask, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);<br>        <span class="hljs-comment">// 如果前面填的数字都和 n 的一样，那么这一位至多填数字 s[i]（否则就超过 n 啦）</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">upperBound</span> <span class="hljs-operator">=</span> isLimit ? num.charAt(index) - <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">9</span>; <br>        <span class="hljs-comment">// 如果isNum,是前导0，那么i从0开始；否则不是前导0，i从1开始</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> isNum ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>; i &lt;= upperBound; ++i)<br>            <span class="hljs-keyword">if</span> ((mask &gt;&gt; i &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) <span class="hljs-comment">// d 不在 mask 中</span><br>                res += dfs(index + <span class="hljs-number">1</span>, mask | <span class="hljs-number">1</span> &lt;&lt; i, isLimit &amp;&amp; i == upperBound, <span class="hljs-literal">true</span>);<br>        <span class="hljs-keyword">if</span> (!isLimit &amp;&amp; isNum)<br>            dp[index][mask] = res;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="数字-1-的个数"><a href="https://leetcode.cn/problems/number-of-digit-one/">233. 数字 1 的个数</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230731192735810.png" /></p>
<h3 id="方法一数位dp-2">方法一：数位DP</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">int</span>[][] dp;<br>    String num;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countDigitOne</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        num = String.valueOf(n);<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[num.length()][<span class="hljs-number">9</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dp)<br>            Arrays.fill(arr, -<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">this</span>.n = num.length();<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">true</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> count, <span class="hljs-type">boolean</span> isLimit)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == n)<br>            <span class="hljs-keyword">return</span> count;<br>        <span class="hljs-keyword">if</span> (!isLimit &amp;&amp; dp[index][count] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[index][count];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, cur = num.charAt(index) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">upperBound</span> <span class="hljs-operator">=</span> isLimit ? cur : <span class="hljs-number">9</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= upperBound; ++i)<br>            res += dfs(index + <span class="hljs-number">1</span>, count + (i == <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>), isLimit &amp;&amp; i == upperBound);<br>        <span class="hljs-keyword">if</span> (!isLimit)<br>            dp[index][count] = res;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="面试题-17.06.-2出现的次数"><a href="https://leetcode.cn/problems/number-of-2s-in-range-lcci/">面试题 17.06. 2出现的次数</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230731211730581.png" /></p>
<h3 id="方法一数位dp-3">方法一：数位DP</h3>
<p>把上一题的1改成2即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">int</span>[][] dp;<br>    String num;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numberOf2sInRange</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        num = String.valueOf(n);<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[num.length()][<span class="hljs-number">9</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dp)<br>            Arrays.fill(arr, -<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">this</span>.n = num.length();<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">true</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> count, <span class="hljs-type">boolean</span> isLimit)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == n)<br>            <span class="hljs-keyword">return</span> count;<br>        <span class="hljs-keyword">if</span> (!isLimit &amp;&amp; dp[index][count] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[index][count];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, cur = num.charAt(index) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">upperBound</span> <span class="hljs-operator">=</span> isLimit ? cur : <span class="hljs-number">9</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= upperBound; ++i)<br>            res += dfs(index + <span class="hljs-number">1</span>, count + (i == <span class="hljs-number">2</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>), isLimit &amp;&amp; i == upperBound);<br>        <span class="hljs-keyword">if</span> (!isLimit)<br>            dp[index][count] = res;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="至少有-1-位重复的数字"><a href="https://leetcode.cn/problems/numbers-with-repeated-digits/">1012. 至少有 1 位重复的数字</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230731211944295.png" /></p>
<h3 id="方法一数位dp-4">方法一：数位DP</h3>
<p>n - <a href="https://leetcode.cn/problems/count-of-integers/">2719. 统计整数数目</a>返回的结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numDupDigitsAtMostN</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">return</span> n - countSpecialNumbers(n);<br>    &#125;<br><br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">int</span>[][] dp;<br>    String num;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countSpecialNumbers</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        num = String.valueOf(n);<br>        <span class="hljs-built_in">this</span>.n = num.length();<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-built_in">this</span>.n][<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">10</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dp)<br>            Arrays.fill(arr, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> mask, <span class="hljs-type">boolean</span> isLimit, <span class="hljs-type">boolean</span> isNum)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == n)<br>            <span class="hljs-keyword">return</span> isNum ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<span class="hljs-comment">// isNum 为 true 表示得到了一个合法数字</span><br>        <span class="hljs-keyword">if</span> (!isLimit &amp;&amp; isNum &amp;&amp; dp[index][mask] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[index][mask];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (!isNum) <span class="hljs-comment">// 可以跳过当前数位 (继续填0)</span><br>            res += dfs(index + <span class="hljs-number">1</span>, mask, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);<br>        <span class="hljs-comment">// 如果前面填的数字都和 n 的一样，那么这一位至多填数字 s[i]（否则就超过 n 啦）</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">upperBound</span> <span class="hljs-operator">=</span> isLimit ? num.charAt(index) - <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">9</span>; <br>        <span class="hljs-comment">// 如果isNum,是前导0，那么i从0开始；否则不是前导0，i从1开始</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> isNum ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>; i &lt;= upperBound; ++i)<br>            <span class="hljs-keyword">if</span> ((mask &gt;&gt; i &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) <span class="hljs-comment">// d 不在 mask 中</span><br>                res += dfs(index + <span class="hljs-number">1</span>, mask | <span class="hljs-number">1</span> &lt;&lt; i, isLimit &amp;&amp; i == upperBound, <span class="hljs-literal">true</span>);<br>        <span class="hljs-keyword">if</span> (!isLimit &amp;&amp; isNum)<br>            dp[index][mask] = res;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="不含连续1的非负整数"><a href="https://leetcode.cn/problems/non-negative-integers-without-consecutive-ones/">600. 不含连续1的非负整数</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230731221451488.png" /></p>
<h3 id="方法一数位dp-5">方法一：数位DP</h3>
<p><strong>注意：res += dfs(index + 1, i, isLimit &amp;&amp; i == upperBound);不要把i写成cur！！！</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> length;<br>    <span class="hljs-type">int</span>[][] dp;<br>    String num;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findIntegers</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        num = Integer.toBinaryString(n);<br>        length = num.length();<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[length][<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dp)<br>            Arrays.fill(arr, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">true</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> pre, <span class="hljs-type">boolean</span> isLimit)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == length)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (!isLimit &amp;&amp; dp[index][pre] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[index][pre];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, cur = num.charAt(index) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">upperBound</span> <span class="hljs-operator">=</span> isLimit ? cur : <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= upperBound; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (pre == <span class="hljs-number">1</span> &amp;&amp; i == <span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            res += dfs(index + <span class="hljs-number">1</span>, i, isLimit &amp;&amp; i == upperBound);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!isLimit)<br>            dp[index][pre] = res;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="最大为-n-的数字组合"><a href="https://leetcode.cn/problems/numbers-at-most-n-given-digit-set/">902. 最大为 N 的数字组合</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230731222144469.png" /></p>
<h3 id="方法一数位dp-6">方法一：数位DP</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    String[] digits;<br>    <span class="hljs-type">int</span> length, n;<br>    String num;<br>    <span class="hljs-type">int</span>[] dp;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">atMostNGivenDigitSet</span><span class="hljs-params">(String[] digits, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-built_in">this</span>.n = n;<br>        <span class="hljs-built_in">this</span>.digits = digits;<br>        num = String.valueOf(n);<br>        length = num.length();<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[length];<br>        Arrays.fill(dp, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>,  <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">boolean</span> isLimit, <span class="hljs-type">boolean</span> isNum)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == length)<br>            <span class="hljs-keyword">return</span> isNum ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (!isLimit &amp;&amp; isNum &amp;&amp; dp[index] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[index];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, cur = num.charAt(index) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (!isNum)<br>            res += dfs(index + <span class="hljs-number">1</span>,  <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);<br>        <span class="hljs-keyword">for</span> (String x : digits) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> Integer.parseInt(x);<br>            <span class="hljs-keyword">if</span> (isLimit &amp;&amp; val &gt; cur)<br>                <span class="hljs-keyword">break</span>;<br>            res += dfs(index + <span class="hljs-number">1</span>, isLimit &amp;&amp; val == cur, <span class="hljs-literal">true</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (!isLimit &amp;&amp; isNum)<br>            dp[index] = res;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="找到所有好字符串"><a href="https://leetcode.cn/problems/find-all-good-strings/">1397. 找到所有好字符串</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230731224835958.png" /></p>
]]></content>
      <categories>
        <category>Algorithms</category>
        <category>Dynamic Programming</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>lcp356</title>
    <url>/2023/07/30/lcp356/</url>
    <content><![CDATA[<h2 id="第一题-满足目标工作时长的员工数目">第一题 满足目标工作时长的员工数目</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230730103016385.png" /></p>
<h3 id="方法一模拟">方法一：模拟</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numberOfEmployeesWhoMetTarget</span><span class="hljs-params">(<span class="hljs-type">int</span>[] hours, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : hours)<br>            <span class="hljs-keyword">if</span> (x &gt;= target)<br>                ++res;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="第二题统计完全子数组的数目">第二题统计完全子数组的数目</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230730103159064.png" /></p>
<h3 id="方法一hashset">方法一：HashSet</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countCompleteSubarrays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : nums)<br>            set.add(x);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> set.size(), res = <span class="hljs-number">0</span>, n = nums.length;<br>        <span class="hljs-comment">// 以第i位结尾，有多少完全子数组，i &gt;= length</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> length - <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">Set</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &gt;= <span class="hljs-number">0</span>; --j) &#123;<br>                s.add(nums[j]);<br>                <span class="hljs-keyword">if</span> (s.size() == length) &#123;<br>                    ++res;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="第三题包含三个字符串的最短字符串">第三题包含三个字符串的最短字符串</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230730104230167.png" /></p>
<h3 id="方法一">方法一：</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure>
<h2 id="第四题">第四题</h2>
<h3 id="方法一-1">方法一：</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure>
<h2 id="统计整数数目"><a href="https://leetcode.cn/problems/count-of-integers/">2719. 统计整数数目</a></h2>
<h2 id="统计特殊整数"><a href="https://leetcode.cn/problems/count-special-integers/">2376. 统计特殊整数</a></h2>
]]></content>
      <categories>
        <category>Contest</category>
        <category>LCP</category>
      </categories>
      <tags>
        <tag>力扣杯</tag>
      </tags>
  </entry>
  <entry>
    <title>Binary Index Tree</title>
    <url>/2023/07/29/binary-index-tree/</url>
    <content><![CDATA[<ul>
<li><p>数组不变，区间查询：<strong>前缀和</strong>、树状数组、线段树；</p></li>
<li><p>数组单点修改，区间查询：<strong>树状数组</strong>、线段树；</p></li>
<li><p>数组区间修改，单点查询：<strong>差分</strong>、线段树；</p></li>
<li><p>数组区间修改，区间查询：<strong>线段树</strong>。</p>
<p><a href="https://leetcode.cn/problems/corporate-flight-bookings/solutions/968467/gong-shui-san-xie-yi-ti-shuang-jie-chai-fm1ef/">链接</a></p></li>
</ul>
<p><a href="https://zhuanlan.zhihu.com/p/93795692">优质博客</a></p>
<p><a href="https://leetcode.cn/problems/range-sum-query-mutable/solutions/632515/guan-yu-ge-lei-qu-jian-he-wen-ti-ru-he-x-41hv/">模板</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">	<span class="hljs-comment">// 上来先把三个方法写出来</span><br>&#123;<br>    <span class="hljs-type">int</span>[] tree;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-keyword">return</span> x &amp; -x;<br>    &#125;<br>    <span class="hljs-comment">// 查询前缀和的方法</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> x; i &gt; <span class="hljs-number">0</span>; i -= lowbit(i)) ans += tree[i];<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-comment">// 在树状数组 x 位置中增加值 u</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> u)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> x; i &lt;= n; i += lowbit(i)) tree[i] += u;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 初始化「树状数组」，要默认数组是从 1 开始</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) add(i + <span class="hljs-number">1</span>, nums[i]);<br>&#125;<br><br><span class="hljs-comment">// 使用「树状数组」：</span><br>&#123;   <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-comment">// 原有的值是 nums[i]，要使得修改为 val，需要增加 val - nums[i]</span><br>        add(i + <span class="hljs-number">1</span>, val - nums[i]); <br>        nums[i] = val;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> <span class="hljs-title function_">sumRange</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>        <span class="hljs-keyword">return</span> query(r + <span class="hljs-number">1</span>) - query(l);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="区域和检索---数组可修改"><a href="https://leetcode.cn/problems/range-sum-query-mutable/">307. 区域和检索 - 数组可修改</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230729224309067.png" /></p>
<h3 id="方法一树状数组">方法一：树状数组</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumArray</span> &#123;<br>    <br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">int</span>[] tree, nums;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-keyword">return</span> x &amp; -x;<br>    &#125;<br>    <span class="hljs-comment">// 查询前缀和的方法</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> x; i &gt; <span class="hljs-number">0</span>; i -= lowbit(i)) ans += tree[i];<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-comment">// 在树状数组 x 位置中增加值 u</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> u)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> x; i &lt;= n; i += lowbit(i)) tree[i] += u;<br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        tree = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i)<br>            add(i + <span class="hljs-number">1</span>, nums[i]);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NumArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-built_in">this</span>.nums = nums;<br>        n = nums.length;<br>        init(nums);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> val)</span> &#123;<br>        add(index + <span class="hljs-number">1</span>, val - nums[index]);<br>        nums[index] = val;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumRange</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-keyword">return</span> query(right + <span class="hljs-number">1</span>) - query(left);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your NumArray object will be instantiated and called as such:</span><br><span class="hljs-comment"> * NumArray obj = new NumArray(nums);</span><br><span class="hljs-comment"> * obj.update(index,val);</span><br><span class="hljs-comment"> * int param_2 = obj.sumRange(left,right);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithms</category>
        <category>Binary Index Tree</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>lcpBi103</title>
    <url>/2023/07/29/lcpBi103/</url>
    <content><![CDATA[<h2 id="k-个元素的最大和">K 个元素的最大和</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230729155128690.png" /></p>
<h3 id="方法二等差数列">方法二：等差数列</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximizeSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : nums)<br>            max = Math.max(max, x);<br>        <span class="hljs-comment">// max + (max + 1) + ... + (max + k - 1)</span><br>        <span class="hljs-keyword">return</span> (max * <span class="hljs-number">2</span> + k - <span class="hljs-number">1</span>) * k / <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O(n)\)</span></p>
<h3 id="方法一模拟">方法一：模拟</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximizeSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        Arrays.sort(nums);<br>        <span class="hljs-type">int</span>  <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length, res = <span class="hljs-number">0</span>, cur = nums[n - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>            res += cur;<br>            ++cur;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O(nlogn)\)</span></p>
<h2 id="找到两个数组的前缀公共数组">找到两个数组的前缀公共数组</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230729155549034.png" /></p>
<h3 id="方法二位运算">方法二：位运算</h3>
<p>左移的时候是1L!!!,1是整型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] findThePrefixCommonArray(<span class="hljs-type">int</span>[] A, <span class="hljs-type">int</span>[] B) &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> A.length;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            a |= <span class="hljs-number">1L</span> &lt;&lt; A[i];<br>            b |= <span class="hljs-number">1L</span> &lt;&lt; B[i];<br>            res[i] = Long.bitCount(a &amp; b);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法一hashmap">方法一：HashMap</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] findThePrefixCommonArray(<span class="hljs-type">int</span>[] A, <span class="hljs-type">int</span>[] B) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> A.length;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Map&lt;Integer, Integer&gt; map1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(), map2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (A[i] == B[i]) &#123;<br>                <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>)<br>                    res[i] = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    res[i] = res[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (map2.containsKey(A[i])) &#123;<br>                    ++temp;<br>                    map2.remove(A[i]);<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                    map1.put(A[i], i);<br>                <span class="hljs-keyword">if</span> (map1.containsKey(B[i])) &#123;<br>                    ++temp;<br>                    map1.remove(B[i]);<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                    map2.put(B[i], i);<br>                <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>)<br>                    res[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    res[i] = res[i - <span class="hljs-number">1</span>] + temp;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="网格图中鱼的最大数目">网格图中鱼的最大数目</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230729161352272.png" /></p>
<h3 id="方法一dfs">方法一：DFS</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMaxFish</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-built_in">this</span>.grid = grid;<br>        m = grid.length;<br>        n = grid[<span class="hljs-number">0</span>].length;<br>        visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] &gt; <span class="hljs-number">0</span>) &#123;<br>                    res = Math.max(res, dfs(i, j));<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        visited[i][j] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> grid[i][j];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], col = j + dir[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (isValid(row, col) &amp;&amp; grid[row][col] &gt; <span class="hljs-number">0</span> &amp;&amp; !visited[row][col]) &#123;<br>                count += dfs(row, col);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br><br>    <span class="hljs-type">int</span> m, n, res = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span>[][] grid, dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-type">boolean</span>[][] visited;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &lt; n;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二并查集">方法二：并查集</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMaxFish</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-built_in">this</span>.grid = grid;<br>        m = grid.length;<br>        n = grid[<span class="hljs-number">0</span>].length;<br>        init(m * n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] &gt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> i * n + j;<br>                    fish[index] = grid[i][j];<br>                    <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; grid[i - <span class="hljs-number">1</span>][j] &gt; <span class="hljs-number">0</span>) &#123;<br>                        union(index, index - n);<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; grid[i][j - <span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span>) &#123;<br>                        union(index, index - <span class="hljs-number">1</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : fish)<br>            res = Math.max(res, x);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><br>    <span class="hljs-type">int</span> m, n, res = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span>[][] grid;<br>    <span class="hljs-type">int</span>[] parent, fish;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rootI</span> <span class="hljs-operator">=</span> findParent(i), rootJ = findParent(j);<br>        <span class="hljs-keyword">if</span> (rootI != rootJ) &#123;<br>            parent[rootJ] = rootI;<br>            fish[rootI] += fish[rootJ];<br>            fish[rootJ] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findParent</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i != parent[i])<br>            parent[i] = findParent(parent[i]);<br>        <span class="hljs-keyword">return</span> parent[i];<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        parent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            parent[i] = i;<br>        fish = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<figure>
<img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230729200112196.png" alt="image-20230729200112196" /><figcaption aria-hidden="true">image-20230729200112196</figcaption>
</figure>
]]></content>
      <categories>
        <category>Contest</category>
        <category>LCP</category>
      </categories>
      <tags>
        <tag>力扣杯</tag>
      </tags>
  </entry>
  <entry>
    <title>lcpBi102</title>
    <url>/2023/07/27/lcpBi102/</url>
    <content><![CDATA[<h2 id="查询网格图中每一列的宽度">查询网格图中每一列的宽度</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230727151315457.png" /></p>
<h3 id="方法一模拟">方法一：模拟</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs java\">class Solution &#123;<br>    public int[] findColumnWidth(int[][] grid) &#123;<br>        int m = grid.length, n = grid[0].length;<br>        int[] res = new int[n];<br>        for (int j = 0; j &lt; n; ++j) &#123;<br>            int max = 0;<br>            for (int i = 0; i &lt; m; ++i) &#123;<br>                int num = grid[i][j], count = num &gt; 0 ? 0 : 1;<br>                while (num != 0) &#123;<br>                    num /= 10;<br>                    ++count;<br>                &#125;<br>                max = Math.max(max, count);<br>                res[j] = max;<br>            &#125;<br>        &#125;<br>        return res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="一个数组所有前缀的分数">一个数组所有前缀的分数</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230727152114298.png" /></p>
<h3 id="方法一前缀和">方法一：前缀和</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span>[] findPrefixScore(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">long</span>[] conver = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n], res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n];<br>        <span class="hljs-type">long</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            max = Math.max(max, nums[i]);<br>            conver[i] = nums[i] + max;<br>            res[i] = (i &gt; <span class="hljs-number">0</span> ? res[i - <span class="hljs-number">1</span>] : <span class="hljs-number">0</span>)+ conver[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="二叉树的堂兄弟节点-ii">二叉树的堂兄弟节点 II</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230727153118667.png" /></p>
<h3 id="方法一">方法一：</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">replaceValueInTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        Map&lt;Integer, <span class="hljs-type">int</span>[]&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Map&lt;Integer, Integer&gt; sum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        root.val = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (root.left != <span class="hljs-literal">null</span>) &#123;<br>            root.left.val = <span class="hljs-number">0</span>;<br>            queue.offer(root.left);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root.right != <span class="hljs-literal">null</span>) &#123;<br>            root.right.val = <span class="hljs-number">0</span>;<br>            queue.offer(root.right);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">level</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">levelSum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>                levelSum += node.val;<br>                <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>)<br>                    queue.offer(node.left);<br>                <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>)<br>                    queue.offer(node.right);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (level &gt;= <span class="hljs-number">2</span>)<br>                sum.put(level, levelSum);<br>            ++level;<br>        &#125;<br>        level = <span class="hljs-number">0</span>;<br>        queue.offer(root);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">levelSum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (level &gt;= <span class="hljs-number">1</span>) <br>                levelSum = sum.getOrDefault(level + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">curSum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>                <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) &#123;<br>                    curSum += node.left.val;<br>                    queue.offer(node.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) &#123;<br>                    curSum += node.right.val;<br>                    queue.offer(node.right);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) &#123;<br>                    node.left.val = levelSum - curSum;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) &#123;<br>                    node.right.val = levelSum - curSum;<br>                &#125;<br>            &#125;<br>            <br>            ++level;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="设计可以求最短路径的图类">设计可以求最短路径的图类</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230727155135580.png" /></p>
<h3 id="方法一dijkstra">方法一：dijkstra</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">     <span class="hljs-keyword">class</span> <span class="hljs-title class_">Graph</span> &#123;<br><br>        <span class="hljs-type">int</span> n;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">inf</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span>[][] graph;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Graph</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] edges)</span> &#123;<br>            <span class="hljs-built_in">this</span>.n = n;<br>            graph = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : graph)<br>                Arrays.fill(arr, inf);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] edge : edges) &#123;<br>                graph[edge[<span class="hljs-number">0</span>]][edge[<span class="hljs-number">1</span>]] = edge[<span class="hljs-number">2</span>];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addEdge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] edge)</span> &#123;<br>            graph[edge[<span class="hljs-number">0</span>]][edge[<span class="hljs-number">1</span>]] = edge[<span class="hljs-number">2</span>];<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">shortestPath</span><span class="hljs-params">(<span class="hljs-type">int</span> from, <span class="hljs-type">int</span> to)</span> &#123;<br>            <span class="hljs-type">int</span>[] dist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>            Arrays.fill(dist, inf);<br>            <span class="hljs-type">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n];<br>            dist[from] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">minIndex</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>, minDist = inf;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                    <span class="hljs-keyword">if</span> (!visited[j] &amp;&amp; dist[j] &lt; minDist) &#123;<br>                        minDist = dist[j];<br>                        minIndex = j;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (minIndex == to)<br>                    <span class="hljs-keyword">return</span> minDist;<br>                <span class="hljs-keyword">if</span> (minIndex == -<span class="hljs-number">1</span>) <span class="hljs-comment">// not connected</span><br>                    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>                visited[minIndex] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                    <span class="hljs-keyword">if</span> (!visited[j] &amp;&amp; dist[j] &gt; minDist + graph[minIndex][j])<br>                        dist[j] = minDist + graph[minIndex][j];<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your Graph object will be instantiated and called as such:</span><br><span class="hljs-comment"> * Graph obj = new Graph(n, edges);</span><br><span class="hljs-comment"> * obj.addEdge(edge);</span><br><span class="hljs-comment"> * int param_2 = obj.shortestPath(node1,node2);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>
<h3 id="方法二floyd">方法二：floyd</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">     <span class="hljs-keyword">class</span> <span class="hljs-title class_">Graph</span> &#123;<br><br>        <span class="hljs-type">int</span> n;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">inf</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE &gt;&gt; <span class="hljs-number">2</span>; <span class="hljs-comment">// 只右移一位会溢出</span><br>        <span class="hljs-type">int</span>[][] dp;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Graph</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] edges)</span> &#123;<br>            <span class="hljs-built_in">this</span>.n = n;<br>            dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dp)<br>                Arrays.fill(arr, inf);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>                dp[i][i] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 为了增加边时更新</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] edge : edges) <br>                dp[edge[<span class="hljs-number">0</span>]][edge[<span class="hljs-number">1</span>]] = edge[<span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; n; ++k)<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j)<br>                        dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k][j]);<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addEdge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] edge)</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> edge[<span class="hljs-number">0</span>], y = edge[<span class="hljs-number">1</span>], w = edge[<span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">if</span> (w &gt;= dp[x][y]) <span class="hljs-comment">// 如果权重比原来的还大，不更新(bu&#x27;neng&#x27;sheng)</span><br>                <span class="hljs-keyword">return</span>;<br>            dp[x][y] = w;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j)<br>                    dp[i][j] = Math.min(dp[i][j], dp[i][x] + dp[x][y] + dp[y][j]);<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">shortestPath</span><span class="hljs-params">(<span class="hljs-type">int</span> from, <span class="hljs-type">int</span> to)</span> &#123;<br>            <span class="hljs-keyword">return</span> dp[from][to] &lt; inf ? dp[from][to] : -<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your Graph object will be instantiated and called as such:</span><br><span class="hljs-comment"> * Graph obj = new Graph(n, edges);</span><br><span class="hljs-comment"> * obj.addEdge(edge);</span><br><span class="hljs-comment"> * int param_2 = obj.shortestPath(node1,node2);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Contest</category>
        <category>LCP</category>
      </categories>
      <tags>
        <tag>力扣杯</tag>
      </tags>
  </entry>
  <entry>
    <title>lcp343</title>
    <url>/2023/07/26/lcp343/</url>
    <content><![CDATA[<h2 id="保龄球游戏的获胜者">保龄球游戏的获胜者</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230726144455782.png" /></p>
<h3 id="方法一模拟">方法一：模拟</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">isWinner</span><span class="hljs-params">(<span class="hljs-type">int</span>[] player1, <span class="hljs-type">int</span>[] player2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, sum2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">flag1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, flag2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; player1.length; ++i) &#123;<br>            sum1 += player1[i] + (flag1-- &gt; <span class="hljs-number">0</span> ? player1[i] : <span class="hljs-number">0</span>);<br>            sum2 += player2[i] + (flag2-- &gt; <span class="hljs-number">0</span> ? player2[i] : <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">if</span> (player1[i] == <span class="hljs-number">10</span>)<br>                flag1 = <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (player2[i] == <span class="hljs-number">10</span>)<br>                flag2 = <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (sum1 == sum2)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> sum1 &gt; sum2 ? <span class="hljs-number">1</span> : <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="找出叠涂元素">找出叠涂元素</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230726145525278.png" /></p>
<h3 id="方法一hashmap">方法一：HashMap</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">firstCompleteIndex</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span>[][] mat)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> mat.length, n = mat[<span class="hljs-number">0</span>].length;<br>        Map&lt;Integer, <span class="hljs-type">int</span>[]&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j)<br>                map.put(mat[i][j], <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, j&#125;);<br>        <span class="hljs-type">int</span>[] countR = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m], countC = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Arrays.fill(countR, n);<br>        Arrays.fill(countC, m);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m * n; ++i) &#123;<br>            <span class="hljs-type">int</span>[] rc = map.get(arr[i]);<br>            <span class="hljs-keyword">if</span> (--countR[rc[<span class="hljs-number">0</span>]] == <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> i;<br>            <span class="hljs-keyword">if</span> (--countC[rc[<span class="hljs-number">1</span>]] == <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> m * n - <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="前往目标的最小代价"><a href="https://leetcode.cn/problems/minimum-cost-of-a-path-with-special-roads/">2662. 前往目标的最小代价</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230727092559531.png" /></p>
<h3 id="方法一dijkstra">方法一：dijkstra</h3>
<h4 id="debug两小时的原因">Debug两小时的原因</h4>
<ol type="1">
<li><p>int vx = (int) minIndex &gt;&gt; 32应该加括号int vx = (int) (minIndex &gt;&gt; 32)，前者先把minIndex转成int，再右移</p></li>
<li><p>map里的节点不一定是specialRoads.length + 2个，可能有重复节点，所以要while(true)</p></li>
<li><p>初始化时，如果specialRoads有到达起点的点，那么所有点的距离都是max，所以dist.put(startLong, 0);要在此之后</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; specialRoads.length; ++i)<br>    dist.put((<span class="hljs-type">long</span>) specialRoads[i][<span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-number">32</span> | specialRoads[i][<span class="hljs-number">3</span>], Integer.MAX_VALUE);<br>dist.put(startLong, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure></li>
</ol>
<h4 id="代码">代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumCost</span><span class="hljs-params">(<span class="hljs-type">int</span>[] start, <span class="hljs-type">int</span>[] target, <span class="hljs-type">int</span>[][] specialRoads)</span> &#123;<br>        <span class="hljs-keyword">return</span> dijkstra(start, target, specialRoads);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span>[] start, <span class="hljs-type">int</span>[] target, <span class="hljs-type">int</span>[][] specialRoads)</span> &#123;<br>        Map&lt;Long, Integer&gt; dist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-comment">// key: 64位，前32位表示横坐标，后32位表示纵坐标;</span><br>        <span class="hljs-comment">// val: 距离targetLong的最短距离</span><br>        <span class="hljs-comment">// 大小为2 + specialRoads.length，顶点为：起点，target，specialRoads的所有终点</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">targetLong</span> <span class="hljs-operator">=</span> (<span class="hljs-type">long</span>) target[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-number">32</span> | target[<span class="hljs-number">1</span>], startLong = (<span class="hljs-type">long</span>) start[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-number">32</span> | start[<span class="hljs-number">1</span>];<br>        dist.put(targetLong, Integer.MAX_VALUE);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; specialRoads.length; ++i)<br>            dist.put((<span class="hljs-type">long</span>) specialRoads[i][<span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-number">32</span> | specialRoads[i][<span class="hljs-number">3</span>], Integer.MAX_VALUE);<br>        dist.put(startLong, <span class="hljs-number">0</span>);<br>        Set&lt;Long&gt; visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">minDist</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">minIndex</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (Long key : dist.keySet()) &#123;<br>                <span class="hljs-keyword">if</span> (!visited.contains(key) &amp;&amp; dist.get(key) &lt; minDist) &#123;<br>                    minDist = dist.get(key);<br>                    minIndex = key;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (minIndex == targetLong)<br>                <span class="hljs-keyword">return</span> minDist;<br>            visited.add(minIndex);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">vx</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (minIndex &gt;&gt; <span class="hljs-number">32</span>), vy = (<span class="hljs-type">int</span>) minIndex &amp; Integer.MAX_VALUE;<br>            <span class="hljs-comment">// 更新终点的最短距离</span><br>            dist.merge(targetLong, minDist + Math.abs(target[<span class="hljs-number">0</span>] - vx) + Math.abs(target[<span class="hljs-number">1</span>] - vy), Math::min);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] sr : specialRoads) &#123;<br>                <span class="hljs-type">long</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> (<span class="hljs-type">long</span>) sr[<span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-number">32</span> | sr[<span class="hljs-number">3</span>];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">manhattanDist</span> <span class="hljs-operator">=</span> minDist + Math.min(Math.abs(vx - sr[<span class="hljs-number">0</span>]) + Math.abs(vy - sr[<span class="hljs-number">1</span>]) + sr[<span class="hljs-number">4</span>], Math.abs(vx - sr[<span class="hljs-number">2</span>]) + Math.abs(vy - sr[<span class="hljs-number">3</span>]));<br>                <span class="hljs-keyword">if</span> (manhattanDist &lt; dist.get(node))<br>                    dist.put(node, manhattanDist);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="字典序最小的美丽字符串">字典序最小的美丽字符串</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230726152055785.png" /></p>
<h3 id="方法一贪心">方法一：贪心</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">smallestBeautifulString</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">char</span>[] chars = s.toCharArray();<br>        k =  (<span class="hljs-type">char</span>) (<span class="hljs-string">&#x27;a&#x27;</span> + k);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length(), i = n - <span class="hljs-number">1</span>;<br>        ++chars[i];<br>        <span class="hljs-keyword">while</span> (i &lt; n) &#123;<br>            <span class="hljs-keyword">if</span> (chars[i] == k) &#123;<br>                <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>                <span class="hljs-comment">// 进位</span><br>                chars[i] = <span class="hljs-string">&#x27;a&#x27;</span>;<br>                ++chars[--i];<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((i &gt; <span class="hljs-number">0</span> &amp;&amp; chars[i] == chars[i - <span class="hljs-number">1</span>]) || (i &gt; <span class="hljs-number">1</span> &amp;&amp; chars[i] == chars[i - <span class="hljs-number">2</span>])) <br>                ++chars[i];<br>            <span class="hljs-keyword">else</span> <br>                ++i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(chars);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Contest</category>
        <category>LCP</category>
      </categories>
      <tags>
        <tag>力扣杯</tag>
      </tags>
  </entry>
  <entry>
    <title>What is Memorization Search</title>
    <url>/2023/07/25/what-is-memorization-search/</url>
    <content><![CDATA[<h1 id="记忆化搜索一个模板秒杀6道股票题">记忆化搜索一个模板秒杀6道股票题</h1>
<h2 id="买卖股票的最佳时机买入卖出一支股票"><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a>：买入卖出一支股票</h2>
<p>首先可以从最暴力的方法出发，再加上缓存就是记忆化搜索啦</p>
<h3 id="方法一回溯">方法一：回溯</h3>
<ol type="1">
<li>从第0天开始到第n-1天，枚举<strong>买入</strong>或者<strong>不买入</strong>两种操作，记录能获得的最大值。</li>
<li>定义了三种状态state
<ol type="1">
<li>state == 0，初始状态，没有买入卖出股票
<ul>
<li>当前可以不买入股票，此时能获得的价值为：dfs(index + 1, state)</li>
<li>或者买入股票，此时能获得的价值为：dfs(index + 1, state + 1) - prices[index]</li>
</ul></li>
<li>state == 1，已经买入了一支股票
<ul>
<li>当前可以不卖出股票，此时能获得的价值为：dfs(index + 1, state)</li>
<li>或者卖出股票，此时能获得的价值为：dfs(index + 1, state + 1) + prices[index]</li>
</ul></li>
<li>state == 2，已经买入卖出一支股票，操作结束</li>
</ol></li>
<li>在state == 0 和 state == 1的时候返回最大的价值</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-built_in">this</span>.prices = prices;<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-type">int</span>[] prices;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> state)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == prices.length || state == <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (state == <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">// 不操作 买入</span><br>            <span class="hljs-keyword">return</span> Math.max(dfs(index + <span class="hljs-number">1</span>, state), dfs(index + <span class="hljs-number">1</span>, state + <span class="hljs-number">1</span>) - prices[index]);<br>        <span class="hljs-comment">// 不操作 卖出</span><br>        <span class="hljs-keyword">return</span> Math.max(dfs(index + <span class="hljs-number">1</span>, state), dfs(index + <span class="hljs-number">1</span>, state + <span class="hljs-number">1</span>) + prices[index]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二记忆化搜索">方法二：记忆化搜索</h3>
<ol type="1">
<li><p>定义dp数组，用于遍历过每种状态能获得的值，dp = new int[2][prices.length];</p></li>
<li><p>在return前，把当前的值记录在dp数组中</p>
<ul>
<li>return dp[state][index] = Math.max(dfs(index + 1, state), dfs(index + 1, state + 1) - prices[index]);</li>
<li>return dp[state][index] = Math.max(dfs(index + 1, state), dfs(index + 1, state + 1) + prices[index]);</li>
</ul></li>
<li><p>很多子问题可能会被多次调用，导致重复计算，这会极大地增加算法的时间复杂度。记忆化数组的作用就是将已经计算过的子问题的结果保存起来，下次遇到相同的子问题时，直接从记忆数组中取得结果，避免重复计算。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (dp[state][index] != -<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> dp[state][index];<br></code></pre></td></tr></table></figure></li>
<li><p>base case：index超过了数组长度或者卖出了股票</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (index == prices.length || state == <span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure>
<h4 id="代码">代码</h4></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-built_in">this</span>.prices = prices;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>][prices.length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dp)<br>            Arrays.fill(arr, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-type">int</span>[] prices;<br>    <span class="hljs-type">int</span>[][] dp;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> state)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == prices.length || state == <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (dp[state][index] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[state][index];<br>        <span class="hljs-keyword">if</span> (state == <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">// 不操作 买入</span><br>            <span class="hljs-keyword">return</span> dp[state][index] = Math.max(dfs(index + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>), dfs(index + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>) - prices[index]);<br>        <span class="hljs-comment">// 不操作 卖出</span><br>        <span class="hljs-keyword">return</span> dp[state][index] = Math.max(dfs(index + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>), dfs(index + <span class="hljs-number">1</span>, <span class="hljs-number">2</span>) + prices[index]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>接下来使用记忆化搜索解决其他5道股票问题</p>
<h2 id="买卖股票的最佳时机-ii可以买卖任意支股票"><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a>：可以买卖任意支股票</h2>
<p>有两处代码需要修改</p>
<ol type="1">
<li><p>买入一只股票后，可以不操作，或者卖出，由于可以买卖任意支股票，选择卖出股票后，状态回到0</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">return</span> dp[state][index] = Math.max(dfs(index + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>), dfs(index + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>) + prices[index]);<br></code></pre></td></tr></table></figure></li>
<li><p>base case：删除state == 2，这段条件，因为现在可以买卖任意支股票</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (index == prices.length)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure></li>
</ol>
<h4 id="代码-1">代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-built_in">this</span>.prices = prices;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>][prices.length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dp)<br>            Arrays.fill(arr, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-type">int</span>[] prices;<br>    <span class="hljs-type">int</span>[][] dp;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> state)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == prices.length)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (dp[state][index] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[state][index];<br>        <span class="hljs-keyword">if</span> (state == <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">// 不操作 买入</span><br>            <span class="hljs-keyword">return</span> dp[state][index] = Math.max(dfs(index + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>), dfs(index + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>) - prices[index]);<br>        <span class="hljs-comment">// 不操作 卖出</span><br>        <span class="hljs-keyword">return</span> dp[state][index] = Math.max(dfs(index + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>), dfs(index + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>) + prices[index]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="买卖股票的最佳时机-iii最多买卖两支股票"><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">123. 买卖股票的最佳时机 III</a>：最多买卖两支股票</h2>
<p>多定义两种state即可 ，state为偶数的时候可以选择不操作或者不买入，state为奇数的时候可以选择不操作或不卖出</p>
<h4 id="代码-2">代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-built_in">this</span>.prices = prices;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">4</span>][prices.length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dp)<br>            Arrays.fill(arr, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-type">int</span>[] prices;<br>    <span class="hljs-type">int</span>[][] dp;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> state)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == prices.length || state == <span class="hljs-number">4</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (dp[state][index] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[state][index];<br>        <span class="hljs-keyword">if</span> (state == <span class="hljs-number">0</span> || state == <span class="hljs-number">2</span>)<br>            <span class="hljs-comment">// 不操作 买入</span><br>            <span class="hljs-keyword">return</span> dp[state][index] = Math.max(dfs(index + <span class="hljs-number">1</span>, state), dfs(index + <span class="hljs-number">1</span>, state + <span class="hljs-number">1</span>) - prices[index]);<br>        <span class="hljs-comment">// 不操作 卖出</span><br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> dp[state][index] = Math.max(dfs(index + <span class="hljs-number">1</span>, state), dfs(index + <span class="hljs-number">1</span>, state + <span class="hljs-number">1</span>) + prices[index]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="买卖股票的最佳时机-iv最多买卖k支股票"><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">188. 买卖股票的最佳时机 IV</a>：最多买卖k支股票</h2>
<p>和<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">123. 买卖股票的最佳时机 III</a>：最多买卖两支股票类似，买卖一支股票我们需要开2个dp数组，买卖两支股票我们需要开4个dp数组，买卖k支股票需要开2*k个dp数组</p>
<h4 id="代码-3">代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-built_in">this</span>.prices = prices;<br>        <span class="hljs-built_in">this</span>.k = k;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span> * k][prices.length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dp)<br>            Arrays.fill(arr, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-type">int</span>[] prices;<br>    <span class="hljs-type">int</span>[][] dp;<br>    <span class="hljs-type">int</span> k;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> state)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == prices.length || state == <span class="hljs-number">2</span> * k)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (dp[state][index] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[state][index];<br>        <span class="hljs-keyword">if</span> (state % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">// 不操作 买入</span><br>            <span class="hljs-keyword">return</span> dp[state][index] = Math.max(dfs(index + <span class="hljs-number">1</span>, state), dfs(index + <span class="hljs-number">1</span>, state + <span class="hljs-number">1</span>) - prices[index]);<br>        <span class="hljs-comment">// 不操作 卖出</span><br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> dp[state][index] = Math.max(dfs(index + <span class="hljs-number">1</span>, state), dfs(index + <span class="hljs-number">1</span>, state + <span class="hljs-number">1</span>) + prices[index]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="买卖股票的最佳时机含手续费"><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714. 买卖股票的最佳时机含手续费</a></h2>
<p>与<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a>：可以买卖任意支股票类似，在卖出的时候多 <strong>- fee</strong>就ok</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">return</span> dp[state][index] = Math.max(dfs(index + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>), dfs(index + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>) + prices[index] - fee);<br></code></pre></td></tr></table></figure>
<h4 id="代码-4">代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices, <span class="hljs-type">int</span> fee)</span> &#123;<br>        <span class="hljs-built_in">this</span>.prices = prices;<br>        <span class="hljs-built_in">this</span>.fee = fee;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>][prices.length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dp)<br>            Arrays.fill(arr, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-type">int</span>[] prices;<br>    <span class="hljs-type">int</span>[][] dp;<br>    <span class="hljs-type">int</span> fee;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> state)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == prices.length)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (dp[state][index] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[state][index];<br>        <span class="hljs-keyword">if</span> (state == <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">// 不操作 买入</span><br>            <span class="hljs-keyword">return</span> dp[state][index] = Math.max(dfs(index + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>), dfs(index + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>) - prices[index]);<br>        <span class="hljs-comment">// 不操作 卖出</span><br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> dp[state][index] = Math.max(dfs(index + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>), dfs(index + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>) + prices[index] - fee);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="最佳买卖股票时机含冷冻期"><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309. 最佳买卖股票时机含冷冻期</a></h2>
<p>与<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a>：可以买卖任意支股票类似，在卖出的时候往后走两天即可dfs(index + 2, 0)，同时base case小修</p>
<ol type="1">
<li><p>base case</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (index &gt;= prices.length)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure></li>
<li><p>state == 1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">return</span> dp[state][index] = Math.max(dfs(index + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>), dfs(index + <span class="hljs-number">2</span>, <span class="hljs-number">0</span>) + prices[index]);<br></code></pre></td></tr></table></figure></li>
</ol>
<h4 id="代码-5">代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-built_in">this</span>.prices = prices;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>][prices.length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dp)<br>            Arrays.fill(arr, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-type">int</span>[] prices;<br>    <span class="hljs-type">int</span>[][] dp;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> state)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &gt;= prices.length)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (dp[state][index] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[state][index];<br>        <span class="hljs-keyword">if</span> (state == <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">// 不操作 买入</span><br>            <span class="hljs-keyword">return</span> dp[state][index] = Math.max(dfs(index + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>), dfs(index + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>) - prices[index]);<br>        <span class="hljs-comment">// 不操作 卖出</span><br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> dp[state][index] = Math.max(dfs(index + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>), dfs(index + <span class="hljs-number">2</span>, <span class="hljs-number">0</span>) + prices[index]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="最后">最后</h2>
<p><strong>打个比方</strong></p>
<ol type="1">
<li><strong>dp(手动挡)：需要初始化，考虑遍历顺序</strong></li>
<li><strong>记忆化搜索(自动挡)：不需要初始化，考虑遍历顺序</strong></li>
</ol>
<p>记忆化搜索和动态规划都是解决问题的常用方法，它们各自有一些优点和缺点。</p>
<p>记忆化搜索的优点：</p>
<p>减少重复计算：记忆化搜索通过缓存已经计算过的结果，避免了重复计算，提高了算法的效率。 简单易实现：相对于动态规划，记忆化搜索的实现通常更加简单直观，只需要在递归的基础上加上缓存即可。 记忆化搜索的缺点：</p>
<p>可能会占用较大的内存：记忆化搜索需要缓存所有的中间结果，如果问题规模较大，可能会占用较多的内存空间。 递归调用可能导致栈溢出：对于问题规模较大的情况，递归调用深度可能较深，可能导致栈溢出。 动态规划的优点：</p>
<p>自底向上的思路：动态规划通常采用自底向上的计算方式，从小规模问题开始逐步推导得到最终结果，确保所有子问题的解都被计算到。 适用于一些具有最优子结构的问题：动态规划适用于具有最优子结构的问题，即整个问题的最优解可以由子问题的最优解推导得到。 动态规划的缺点：</p>
<p>实现较为复杂：相对于记忆化搜索，动态规划的实现通常较为复杂，需要设计合适的状态转移方程和数组结构。 可能会占用较大的内存：类似于记忆化搜索，动态规划也需要维护一个数组来保存中间结果，可能会占用较多的内存空间。 综上所述，记忆化搜索适用于递归问题，能够减少重复计算，但可能会占用较大内存和导致栈溢出。动态规划适用于具有最优子结构的问题，通过自底向上的方式计算，但实现较为复杂且可能会占用较多内存。在实际应用中，根据问题的性质和规模选择合适的方法来解决问题。</p>
]]></content>
      <categories>
        <category>Algorithms</category>
        <category>.*</category>
        <category>Memorization Search</category>
      </categories>
      <tags>
        <tag>记忆化搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>lcp355</title>
    <url>/2023/07/24/lcp355/</url>
    <content><![CDATA[<h2 id="按分隔符拆分字符串">按分隔符拆分字符串</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230724091610104.png" /></p>
<h3 id="方法一模拟">方法一：模拟</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">splitWordsBySeparator</span><span class="hljs-params">(List&lt;String&gt; words, <span class="hljs-type">char</span> separator)</span> &#123;<br>        List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (String word : words) &#123;<br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">add</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; word.length(); ++i) &#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> word.charAt(i);<br>                <span class="hljs-keyword">if</span> (ch == separator) &#123;<br>                    <span class="hljs-keyword">if</span> (sb.length() &gt; <span class="hljs-number">0</span>) &#123;<br>                        res.add(sb.toString());<br>                        sb.setLength(<span class="hljs-number">0</span>);<br>                    &#125;<br>                    add = !add;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch != <span class="hljs-string">&#x27; &#x27;</span>)<br>                    sb.append(ch);<br>                <span class="hljs-keyword">if</span> (i == word.length() - <span class="hljs-number">1</span> &amp;&amp; sb.length() &gt; <span class="hljs-number">0</span>)<br>                    res.add(sb.toString());<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="合并后数组中的最大元素">合并后数组中的最大元素</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230724093841583.png" /></p>
<h3 id="方法一贪心">方法一：贪心</h3>
<p>不要直接用数组元素累加，会超出整型范围</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">maxArrayValue</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, pre = nums[n - <span class="hljs-number">1</span>];<br>        max = Math.max(max, nums[n - <span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">1</span>; --i) &#123;<br>            <span class="hljs-keyword">if</span> (pre &gt;= nums[i - <span class="hljs-number">1</span>]) &#123;<br>                pre += nums[i - <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                pre = nums[i - <span class="hljs-number">1</span>];<br>            &#125;<br>            max = Math.max(max, pre);<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="长度递增组的最大数目">长度递增组的最大数目</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230724100023723.png" /></p>
<h3 id="方法一排序-二分">方法一：排序 + 二分</h3>
<p><a href="https://leetcode.cn/problems/maximum-number-of-groups-with-increasing-length/solutions/2355580/pai-xu-er-fen-tu-jie-ban-by-yzq-a-smlx/">思路</a></p>
<p><strong>贫富差距，富人压榨穷人，穷人不能向富人索取</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxIncreasingGroups</span><span class="hljs-params">(List&lt;Integer&gt; usageLimits)</span> &#123;<br>        Collections.sort(usageLimits, Collections.reverseOrder());<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> usageLimits.size(), left = <span class="hljs-number">0</span>, right = n;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> mid= (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (check(mid, usageLimits))<br>                left = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> right;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span> mid, List&lt;Integer&gt; usageLimits)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">gap</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : usageLimits) &#123;<br>            gap = Math.min(<span class="hljs-number">0</span>, gap + x - mid);<br>            <span class="hljs-keyword">if</span> (mid &gt; <span class="hljs-number">0</span>)<br>                --mid;<br>        &#125;<br>        <span class="hljs-keyword">return</span> gap &gt;= <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="树中可以形成回文的路径数"><a href="https://leetcode.cn/problems/count-paths-that-can-form-a-palindrome-in-a-tree/">6942. 树中可以形成回文的路径数</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230724120404844.png" /></p>
<h3 id="方法一异或">方法一：异或</h3>
<p><a href="https://www.bilibili.com/video/BV1n8411m7Fs/?spm_id_from=333.999.0.0&amp;vd_source=d0a01265c4f3d5026b4e06c76cce4fe9">视频讲解</a></p>
<ol type="1">
<li>可以排列的回文串等价于<strong>至多一个字母出现奇数次，其余字母出现偶数次</strong></li>
<li><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230724152548335.png" /></li>
<li><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230724152607566.png" /></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">countPalindromePaths</span><span class="hljs-params">(List&lt;Integer&gt; parent, String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> parent.size();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            graph.put(i, <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; parent.size(); ++i)<br>            graph.get(parent.get(i)).put(i, <span class="hljs-number">1</span> &lt;&lt; (s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span> ));<br>        dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> node, <span class="hljs-type">int</span> xorVal)</span> &#123;<br>        res += xorCount.getOrDefault(xorVal, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; ++i)<br>            res += xorCount.getOrDefault(xorVal ^ (<span class="hljs-number">1</span> &lt;&lt; i), <span class="hljs-number">0</span>);<br>        xorCount.put(xorVal, xorCount.getOrDefault(xorVal, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        Map&lt;Integer, Integer&gt; nexts = graph.get(node);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> next : nexts.keySet())<br>            dfs(next, xorVal ^ graph.get(node).get(next));<br>    &#125;<br><br>    <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 第二个map key: 下标, val: 字符 - &#x27;a&#x27;</span><br>    Map&lt;Integer, Map&lt;Integer, Integer&gt;&gt; graph = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-comment">// key: xor的值，val: xor的值出现的次数</span><br>    Map&lt;Integer, Integer&gt; xorCount = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>&#125;<br><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Contest</category>
        <category>LCP</category>
      </categories>
      <tags>
        <tag>力扣杯</tag>
      </tags>
  </entry>
  <entry>
    <title>lcpBi109</title>
    <url>/2023/07/22/lcpBi109/</url>
    <content><![CDATA[<h2 id="第一题检查数组是否是好的">第一题检查数组是否是好的</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230722223026814.png" /></p>
<h3 id="方法一">方法一：</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isGood</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">if</span> (nums[<span class="hljs-number">0</span>] == <span class="hljs-number">1</span> &amp;&amp; nums[<span class="hljs-number">1</span>] == <span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">201</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            count[nums[i]]++;<br>            max = Math.max(max, nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (n &lt; max + <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">//        if (nums[max - 2] != nums[max - 1])</span><br><span class="hljs-comment">//            return false;</span><br>        <span class="hljs-keyword">if</span> (count[max] != <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (i == n || i == n - <span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">if</span> (count[i] != <span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="第二题将字符串中的元音字母排序">第二题将字符串中的元音字母排序</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230722224732816.png" /></p>
<h3 id="方法一-1">方法一：</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">sortVowels</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(s);<br>        List&lt;Integer&gt; emptyIndex = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">128</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;a&#x27;</span> || ch == <span class="hljs-string">&#x27;A&#x27;</span> || ch == <span class="hljs-string">&#x27;e&#x27;</span> || ch == <span class="hljs-string">&#x27;E&#x27;</span> || ch == <span class="hljs-string">&#x27;i&#x27;</span> || ch == <span class="hljs-string">&#x27;I&#x27;</span> || ch == <span class="hljs-string">&#x27;o&#x27;</span> || ch == <span class="hljs-string">&#x27;O&#x27;</span> || ch == <span class="hljs-string">&#x27;u&#x27;</span> || ch == <span class="hljs-string">&#x27;U&#x27;</span>) &#123;<br>                emptyIndex.add(i);<br>                ++count[ch];<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span>[] temp = emptyIndex.stream().mapToInt(i-&gt;i).toArray();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; temp.length; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> temp[i];<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27; &#x27;</span>;<br>            <span class="hljs-keyword">if</span> (count[<span class="hljs-string">&#x27;A&#x27;</span>] &gt; <span class="hljs-number">0</span>) &#123;<br>                --count[<span class="hljs-string">&#x27;A&#x27;</span>];<br>                sb.setCharAt(index, <span class="hljs-string">&#x27;A&#x27;</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count[<span class="hljs-string">&#x27;E&#x27;</span>] &gt; <span class="hljs-number">0</span>) &#123;<br>                sb.setCharAt(index, <span class="hljs-string">&#x27;E&#x27;</span>);<br>                --count[<span class="hljs-string">&#x27;E&#x27;</span>];<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count[<span class="hljs-string">&#x27;I&#x27;</span>] &gt; <span class="hljs-number">0</span>) &#123;<br>                sb.setCharAt(index, <span class="hljs-string">&#x27;I&#x27;</span>);<br>                --count[<span class="hljs-string">&#x27;I&#x27;</span>];<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count[<span class="hljs-string">&#x27;O&#x27;</span>] &gt; <span class="hljs-number">0</span>) &#123;<br>                sb.setCharAt(index, <span class="hljs-string">&#x27;O&#x27;</span>);<br>                --count[<span class="hljs-string">&#x27;O&#x27;</span>];<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count[<span class="hljs-string">&#x27;U&#x27;</span>] &gt; <span class="hljs-number">0</span>) &#123;<br>                sb.setCharAt(index, <span class="hljs-string">&#x27;U&#x27;</span>);<br>                --count[<span class="hljs-string">&#x27;U&#x27;</span>];<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count[<span class="hljs-string">&#x27;a&#x27;</span>] &gt; <span class="hljs-number">0</span>) &#123;<br>                sb.setCharAt(index, <span class="hljs-string">&#x27;a&#x27;</span>);<br>                --count[<span class="hljs-string">&#x27;a&#x27;</span>];<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count[<span class="hljs-string">&#x27;e&#x27;</span>] &gt; <span class="hljs-number">0</span>) &#123;<br>                sb.setCharAt(index, <span class="hljs-string">&#x27;e&#x27;</span>);<br>                --count[<span class="hljs-string">&#x27;e&#x27;</span>];<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count[<span class="hljs-string">&#x27;i&#x27;</span>] &gt; <span class="hljs-number">0</span>) &#123;<br>                sb.setCharAt(index, <span class="hljs-string">&#x27;i&#x27;</span>);<br>                --count[<span class="hljs-string">&#x27;i&#x27;</span>];<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count[<span class="hljs-string">&#x27;o&#x27;</span>] &gt; <span class="hljs-number">0</span>) &#123;<br>                sb.setCharAt(index, <span class="hljs-string">&#x27;o&#x27;</span>);<br>                --count[<span class="hljs-string">&#x27;o&#x27;</span>];<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count[<span class="hljs-string">&#x27;u&#x27;</span>] &gt; <span class="hljs-number">0</span>) &#123;<br>                sb.setCharAt(index, <span class="hljs-string">&#x27;u&#x27;</span>);<br>                --count[<span class="hljs-string">&#x27;u&#x27;</span>];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="第三题访问数组中的位置使分数最大">第三题访问数组中的位置使分数最大</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230722231808063.png" /></p>
<h3 id="方法一记忆化搜索">方法一：记忆化搜索</h3>
<p><strong>选或不选</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">maxScore</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-built_in">this</span>.nums = nums;<br>        <span class="hljs-built_in">this</span>.x = x;<br>        n = nums.length;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n][<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span>[] arr : dp)<br>            Arrays.fill(arr, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">1</span>, nums[<span class="hljs-number">0</span>] % <span class="hljs-number">2</span>) + nums[<span class="hljs-number">0</span>];<br>    &#125;<br><br>    <span class="hljs-type">long</span>[][] dp;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == n)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (dp[index][k] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[index][k];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> nums[index], v = num % <span class="hljs-number">2</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">pass</span> <span class="hljs-operator">=</span> dfs(index + <span class="hljs-number">1</span>, k);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">choose</span> <span class="hljs-operator">=</span> dfs(index + <span class="hljs-number">1</span>, v) + num - (k != v ? x : <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> dp[index][k] = Math.max(pass, choose);<br>    &#125;<br><br>    <span class="hljs-type">int</span>[] nums;<br>    <span class="hljs-type">int</span> x, n;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="第四题">第四题</h2>
<h2 id="将一个数字表示成幂的和的方案数"><a href="https://leetcode.cn/problems/ways-to-express-an-integer-as-sum-of-powers/">2787. 将一个数字表示成幂的和的方案数</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230915105617743.png" /></p>
<h3 id="方法一01背包">方法一：01背包</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numberOfWays</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br>        <span class="hljs-comment">// 01背包， 从1^x, 2^x,...,n^x里选物品，恰好能装满容量为n的背包的方案数</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 没有物品，恰好装满容量为0的背包的方案数：1,什么都不装</span><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) Math.pow(i, x);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= n; ++j) &#123;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>                <span class="hljs-keyword">if</span> (j &gt;= s)<br>                    dp[i][j] = (dp[i][j] +  dp[i - <span class="hljs-number">1</span>][j - s]) % mod;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二滚动数组">方法二：滚动数组</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numberOfWays</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br>        <span class="hljs-comment">// 01背包， 从1^x, 2^x,...,n^x里选物品，恰好能装满容量为n的背包的方案数</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 没有物品，恰好装满容量为0的背包的方案数：1,什么都不装</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) Math.pow(i, x);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> n; j &gt;= s; --j) &#123;<br>                dp[j] = (dp[j] +  dp[j - s]) % mod;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法三静态处理">方法三：静态处理</h3>
<p>所有x,n在static语句块中处理好</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[][] dp;<br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">300</span>, x = <span class="hljs-number">5</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br>        <span class="hljs-comment">// 01背包， 从1^x, 2^x,...,n^x里选物品，恰好能装满容量为n的背包的方案数</span><br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[x][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 没有物品，恰好装满容量为0的背包的方案数：1,什么都不装</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; x; ++i)<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; k &lt;= x; ++k) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) Math.pow(i, k);<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> n; j &gt;= s; --j) &#123;<br>                    dp[k - <span class="hljs-number">1</span>][j] = (dp[k - <span class="hljs-number">1</span>][j] +  dp[k - <span class="hljs-number">1</span>][j - s]) % mod;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numberOfWays</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-keyword">return</span> dp[x - <span class="hljs-number">1</span>][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Contest</category>
        <category>LCP</category>
      </categories>
      <tags>
        <tag>力扣杯</tag>
      </tags>
  </entry>
  <entry>
    <title>lcp344</title>
    <url>/2023/07/20/lcp344/</url>
    <content><![CDATA[<h2 id="找出不同元素数目差数组">找出不同元素数目差数组</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230720091338780.png" /></p>
<h3 id="方法一模拟">方法一：模拟</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] distinctDifferenceArray(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            Set&lt;Integer&gt; preSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(), postSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &gt;= <span class="hljs-number">0</span>; --j)<br>                preSet.add(nums[j]);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; n; ++j)<br>                    postSet.add(nums[j]);<br>            res[i] = preSet.size() - postSet.size();<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="频率跟踪器">频率跟踪器</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230720092248857.png" /></p>
<h2 id="方法一hashmap">方法一：HashMap</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FrequencyTracker</span> &#123;<br><br>    <span class="hljs-type">int</span>[] nums;<br>    Map&lt;Integer, Set&lt;Integer&gt;&gt; map;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">FrequencyTracker</span><span class="hljs-params">()</span> &#123;<br>        nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">100001</span>];<br>        map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span> &#123;<br>        ++nums[number];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">freq</span> <span class="hljs-operator">=</span> nums[number];<br>        <span class="hljs-keyword">if</span> (!map.containsKey(freq))<br>            map.put(freq, <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;());<br>        map.get(freq).add(number);<br>        <span class="hljs-keyword">if</span> (map.containsKey(freq - <span class="hljs-number">1</span>))<br>            map.get(freq - <span class="hljs-number">1</span>).remove(number);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteOne</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">freq</span> <span class="hljs-operator">=</span> nums[number];<br>        <span class="hljs-keyword">if</span> (nums[number] == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">else</span> &#123;<br>            --nums[number];<br>            map.get(freq).remove(number);<br>            <span class="hljs-keyword">if</span> (!map.containsKey(freq - <span class="hljs-number">1</span>))<br>                map.put(freq - <span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;());<br>            map.get(freq - <span class="hljs-number">1</span>).add(number);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasFrequency</span><span class="hljs-params">(<span class="hljs-type">int</span> frequency)</span> &#123;<br>        <span class="hljs-keyword">if</span> (map.containsKey(frequency) &amp;&amp; map.get(frequency).size() &gt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your FrequencyTracker object will be instantiated and called as such:</span><br><span class="hljs-comment"> * FrequencyTracker obj = new FrequencyTracker();</span><br><span class="hljs-comment"> * obj.add(number);</span><br><span class="hljs-comment"> * obj.deleteOne(number);</span><br><span class="hljs-comment"> * boolean param_3 = obj.hasFrequency(frequency);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>
<h3 id="方法二前后缀分解">方法二：前后缀分解</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] distinctDifferenceArray(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n],  suffix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            set.add(nums[i]);<br>            suffix[i] = set.size();<br>        &#125;<br>        set.clear();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            set.add(nums[i]);<br>            res[i] = set.size() - suffix[i + <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="有相同颜色的相邻元素数目">有相同颜色的相邻元素数目</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230720095250594.png" /></p>
<h3 id="方法一模拟-1">方法一：模拟</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] colorTheArray(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] queries) &#123;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[queries.length], nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, idx = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] query : queries) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> query[<span class="hljs-number">0</span>], color = query[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (nums[index] &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (index &gt; <span class="hljs-number">0</span> &amp;&amp; nums[index] == nums[index - <span class="hljs-number">1</span>])<br>                    --count;<br>                <span class="hljs-keyword">if</span> (index &lt; n &amp;&amp; nums[index] == nums[index + <span class="hljs-number">1</span>])<br>                    --count;<br>            &#125;<br>            nums[index] = color;<br>            <span class="hljs-keyword">if</span> (index &gt; <span class="hljs-number">0</span> &amp;&amp; nums[index] == nums[index - <span class="hljs-number">1</span>])<br>                ++count;<br>            <span class="hljs-keyword">if</span> (index &lt; n &amp;&amp; nums[index] == nums[index + <span class="hljs-number">1</span>])<br>                ++count;<br>            res[idx++] = count;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="使二叉树所有路径值相等的最小代价">使二叉树所有路径值相等的最小代价</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230720095745361.png" /></p>
<h3 id="方法一树上贪心">方法一：树上贪心</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minIncrements</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[] cost)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n / <span class="hljs-number">2</span>; i &gt; <span class="hljs-number">0</span>; --i) &#123;<br>            res += Math.abs(cost[<span class="hljs-number">2</span> * i - <span class="hljs-number">1</span>] - cost[<span class="hljs-number">2</span> * i]);<br>            cost[i - <span class="hljs-number">1</span>] += Math.max(cost[<span class="hljs-number">2</span> * i - <span class="hljs-number">1</span>], cost[<span class="hljs-number">2</span> * i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Contest</category>
        <category>LCP</category>
      </categories>
      <tags>
        <tag>力扣杯</tag>
      </tags>
  </entry>
  <entry>
    <title>lcpBi104</title>
    <url>/2023/07/19/lcpBi104/</url>
    <content><![CDATA[<h2 id="老人的数目">老人的数目</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230719091904094.png" /></p>
<h3 id="方法一模拟">方法一：模拟</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countSeniors</span><span class="hljs-params">(String[] details)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (String detail : details) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> Integer.parseInt(detail.substring(<span class="hljs-number">11</span>, <span class="hljs-number">13</span>));<br>            <span class="hljs-keyword">if</span> (age &gt; <span class="hljs-number">60</span>)<br>                ++res;<br>        &#125;<br>        <span class="hljs-keyword">return</span>  res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="矩阵中的和">矩阵中的和</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230719092213311.png" /></p>
<h3 id="方法一错">方法一：错</h3>
<p>TreeSet中不能存放重复的元素，使用大根堆！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">matrixSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> nums.length, n = <span class="hljs-number">0</span>;<br>    TreeSet&lt;Integer&gt;[] treeSets = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>[m];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>        treeSets[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; nums[i].length; ++j) &#123;<br>            n = Math.max(n, nums[i].length);<br>            treeSets[i].add(nums[i][j]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (!treeSets[i].isEmpty()) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> treeSets[i].last();<br>                treeSets[i].remove(cur);<br>                max = Math.max(max, cur);<br>            &#125;<br>        &#125;<br>        res += max;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二排序">方法二：排序</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">matrixSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] nums)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] row : nums)<br>            Arrays.sort(row);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; nums[<span class="hljs-number">0</span>].length; ++j) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i) &#123;<br>                <span class="hljs-keyword">if</span> (nums[i][j] &gt; max)<br>                    max = nums[i][j];<br>            &#125;<br>            res += max;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法三大根堆">方法三：大根堆</h3>
<p>用的小根堆，和大根堆一样，先把每行最小的弹出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">matrixSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> nums.length, n = nums[<span class="hljs-number">0</span>].length;<br>        PriorityQueue&lt;Integer&gt;[] queues = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>[m];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            queues[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; nums[i].length; ++j) &#123;<br>                queues[i].add(nums[i][j]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>                max = Math.max(max, queues[i].poll());<br>            &#125;<br>            res += max;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="最大或值">最大或值</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230719100055088.png" /></p>
<h3 id="方法一前后缀-记忆化搜索">方法一：前后缀+ 记忆化搜索</h3>
<p><strong>一定要用数组！不要用哈希表</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">maximumOr</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-built_in">this</span>.nums = nums;<br>        n = nums.length;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n + <span class="hljs-number">1</span>][<span class="hljs-number">16</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span>[] arr : dp)<br>            Arrays.fill(arr, -<span class="hljs-number">1</span>);<br>        preOr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>            preOr[i] = nums[i - <span class="hljs-number">1</span>] | preOr[i - <span class="hljs-number">1</span>];<br>        postOr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i)<br>            postOr[i] = nums[i] | postOr[i + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, k);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-keyword">if</span> (dp[index][k] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[index][k];<br>        <span class="hljs-keyword">if</span> (index == n) <span class="hljs-comment">// 走到这说明k的次数没用完</span><br>            <span class="hljs-keyword">return</span> preOr[n];<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">temp1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, temp2;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : change.keySet()) &#123;<br>                temp2 = preOr[i] | preOr[pre + <span class="hljs-number">1</span>];<br>                temp2 = temp2 | ((<span class="hljs-type">long</span>) nums[i] &lt;&lt; change.get(i));<br>                temp1 |= temp2;<br>                pre = i;<br>            &#125;<br>            temp2 = postOr[pre + <span class="hljs-number">1</span>];<br>            temp1 |= temp2;<br>            <span class="hljs-keyword">return</span> temp1;<br>        &#125;<br>        <span class="hljs-type">long</span> res, changeNext = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">pass</span> <span class="hljs-operator">=</span> dfs(index + <span class="hljs-number">1</span>, k);<br>        <span class="hljs-keyword">if</span> (k &gt; <span class="hljs-number">0</span>) &#123;<br>            change.put(index, change.getOrDefault(index, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            changeNext = dfs(index, k - <span class="hljs-number">1</span>);<br>            change.put(index, change.get(index) - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (change.get(index) == <span class="hljs-number">0</span>)<br>                change.remove(index);<br>        &#125;<br>        res = Math.max(pass, changeNext);<br>        <span class="hljs-keyword">return</span> dp[index][k] = res;<br>    &#125;<br><br>    <span class="hljs-type">int</span>[] nums;<br>    <span class="hljs-type">long</span>[] preOr, postOr;<br>    <span class="hljs-type">int</span> n;<br>    TreeMap&lt;Integer, Integer&gt; change = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;();<br>    <span class="hljs-type">long</span>[][] dp;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h3 id="方法二贪心">方法二：贪心</h3>
<p>把「乘 2」分配给多个数，不如只分配给一个数，这样更有可能得到更大的答案。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">maximumOr</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br><br>        <span class="hljs-type">var</span> <span class="hljs-variable">suf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--)<br><br>            suf[i] = suf[i + <span class="hljs-number">1</span>] | nums[i];<br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, pre = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br><br>            ans = Math.max(ans, pre | ((<span class="hljs-type">long</span>) nums[i] &lt;&lt; k) | suf[i + <span class="hljs-number">1</span>]);<br><br>            pre |= nums[i];<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="英雄的力量">英雄的力量</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230719141303380.png" /></p>
<h3 id="方法一贡献法">方法一：贡献法</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumOfPower</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Arrays.sort(nums);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>, res = <span class="hljs-number">0</span>, s = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> x : nums) &#123;<br>            res = (res + x * x % MOD * (x + s)) % MOD;<br>            s = (s * <span class="hljs-number">2</span> + x) % MOD;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Contest</category>
        <category>LCP</category>
      </categories>
      <tags>
        <tag>力扣杯</tag>
      </tags>
  </entry>
  <entry>
    <title>lcp345</title>
    <url>/2023/07/17/lcp345/</url>
    <content><![CDATA[<h2 id="找出转圈游戏输家">找出转圈游戏输家</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230717091824799.png" /></p>
<h3 id="模拟">模拟</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] circularGameLosers(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) &#123;<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, multiple = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">if</span> (set.contains(index))<br>                <span class="hljs-keyword">break</span>;<br>            set.add(index);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> index + multiple * k;<br>            <span class="hljs-keyword">if</span> (temp % n == <span class="hljs-number">0</span>)<br>                index = n;<br>            <span class="hljs-keyword">else</span><br>                index = temp % n;<br>            multiple++;<br>        &#125;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (set.contains(i))<br>                <span class="hljs-keyword">continue</span>;<br>            res.add(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res.stream().mapToInt(i-&gt;i).toArray();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二下标从0开始">方法二：下标从0开始</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] circularGameLosers(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) &#123;<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, multiple = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">if</span> (set.contains(index))<br>                <span class="hljs-keyword">break</span>;<br>            set.add(index);<br>            index = (index + multiple * k) % n;<br>            multiple++;<br>        &#125;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (set.contains(i))<br>                <span class="hljs-keyword">continue</span>;<br>            res.add(i + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res.stream().mapToInt(i-&gt;i).toArray();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="相邻值的按位异或">相邻值的按位异或</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230717093329148.png" /></p>
<h3 id="方法一回溯-枚举">方法一：回溯 (枚举)</h3>
<p>枚举ori[0]为0和1，只要有一个能构造成derived数组则为true</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">doesValidArrayExist</span><span class="hljs-params">(<span class="hljs-type">int</span>[] derived)</span> &#123;<br>        <span class="hljs-built_in">this</span>.derived = derived;<br>        n = derived.length;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> derived[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>;<br>        original = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>) || dfs(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == n - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span> (derived[index] == <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> original[<span class="hljs-number">0</span>] == x;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> original[<span class="hljs-number">0</span>] != x;<br>        &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> index + <span class="hljs-string">&quot;#&quot;</span> + x;<br>        original[index] = x;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (derived[index] == <span class="hljs-number">0</span>)<br>            next = x == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-comment">// derived[index] == 1</span><br>            next = x == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (dfs(index + <span class="hljs-number">1</span>, next))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span>[] derived, original;<br>    <span class="hljs-type">int</span> n;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="矩阵中移动的最大次数">矩阵中移动的最大次数</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230717100454402.png" /></p>
<h3 id="方法一记忆化搜索">方法一：记忆化搜索</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxMoves</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        m = grid.length;<br>        n = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-built_in">this</span>.grid = grid;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dp)<br>            Arrays.fill(arr, -<span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; m; ++j) &#123;<br>            res = Math.max(res, dfs(j, <span class="hljs-number">0</span>));<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">if</span> (dp[i][j] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[i][j];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">step</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], col = j + dir[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (isValid(row, col) &amp;&amp; grid[row][col] &gt; grid[i][j]) &#123;<br>                step = dfs(row, col) + <span class="hljs-number">1</span>;<br>            &#125;<br>            res = Math.max(res, step);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[i][j] = res;<br>    &#125;<br><br>    <span class="hljs-type">int</span> m, n;<br>    <span class="hljs-type">int</span>[][] dp, grid, dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;&#125;;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &lt; n;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="加上base-case">加上base case</h4>
<p>可以在j = n - 1时直接return</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (j == n - <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure>
<h4 id="代码">代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxMoves</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        m = grid.length;<br>        n = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-built_in">this</span>.grid = grid;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dp)<br>            Arrays.fill(arr, -<span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; m; ++j) &#123;<br>            res = Math.max(res, dfs(j, <span class="hljs-number">0</span>));<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">if</span> (j == n - <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (dp[i][j] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[i][j];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">step</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], col = j + dir[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (isValid(row, col) &amp;&amp; grid[row][col] &gt; grid[i][j]) &#123;<br>                step = dfs(row, col) + <span class="hljs-number">1</span>;<br>            &#125;<br>            res = Math.max(res, step);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[i][j] = res;<br>    &#125;<br><br>    <span class="hljs-type">int</span> m, n;<br>    <span class="hljs-type">int</span>[][] dp, grid, dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;&#125;;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &lt; n;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="简化去掉step">简化(去掉step)</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxMoves</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        m = grid.length;<br>        n = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-built_in">this</span>.grid = grid;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dp)<br>            Arrays.fill(arr, -<span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; m; ++j) &#123;<br>            res = Math.max(res, dfs(j, <span class="hljs-number">0</span>));<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">if</span> (j == n - <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (dp[i][j] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[i][j];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], col = j + dir[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (isValid(row, col) &amp;&amp; grid[row][col] &gt; grid[i][j]) <br>                res = Math.max(res, dfs(row, col) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[i][j] = res;<br>    &#125;<br><br>    <span class="hljs-type">int</span> m, n;<br>    <span class="hljs-type">int</span>[][] dp, grid, dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;&#125;;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &lt; n;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="时间复杂度omn">时间复杂度：<span class="math inline">\(O(mn)\)</span></h4>
<h3 id="方法二dp">方法二：DP</h3>
<h3 id="记忆化搜索自动挡转dp手动挡需要考虑">记忆化搜索(自动挡)转DP(手动挡)需要考虑</h3>
<ol type="1">
<li>初始化</li>
<li>遍历顺序</li>
</ol>
<p>步骤</p>
<ol type="1">
<li><p>记忆化搜索转DP，有几个状态(i,j)就有几个for循环</p></li>
<li><p>状态转移方程直接搬过来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (isValid(row, col) &amp;&amp; grid[row][col] &gt; grid[i][j]) <br>    res = Math.max(res, dfs(row, col) + <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure></li>
<li><p>遍历顺序</p>
<p>如下图，遍历顺序是从上到下，从右到左</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230717121909709.png" /></p></li>
<li><p><strong>最后的答案是在第一列里找最大值！不要用一个变量在所有列里找最大值</strong></p></li>
</ol>
<h4 id="代码-1">代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxMoves</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        m = grid.length;<br>        n = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-built_in">this</span>.grid = grid;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">2</span>; j &gt;= <span class="hljs-number">0</span>; --j) <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) <br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], col = j + dir[<span class="hljs-number">1</span>];<br>                    <span class="hljs-keyword">if</span> (isValid(row, col) &amp;&amp; grid[i][j] &lt; grid[row][col]) <br>                        dp[i][j] = Math.max(dp[i][j], dp[row][col] + <span class="hljs-number">1</span>);<br>                &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i)<br>            res = Math.max(res, dp[i][<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><br>    <span class="hljs-type">int</span> m, n;<br>    <span class="hljs-type">int</span>[][] dp, grid, dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;&#125;;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &lt; n;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法三bfs">方法三：BFS</h3>
<p>?why 双队列会超时</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxMoves</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        m = grid.length;<br>        n = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-built_in">this</span>.grid = grid;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Queue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">boolean</span>[][] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i)<br>            queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, <span class="hljs-number">0</span>&#125;);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span>[] arr = queue.poll();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>], col = arr[<span class="hljs-number">1</span>];<br>            res = Math.max(res, col);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">nextRow</span> <span class="hljs-operator">=</span> row + dir[<span class="hljs-number">0</span>], nextCol = col + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (isValid(nextRow, nextCol) &amp;&amp; !visited[nextRow][nextCol] &amp;&amp; grid[nextRow][nextCol] &gt; grid[row][col]) &#123;<br>                    <span class="hljs-keyword">if</span> (nextCol == n - <span class="hljs-number">1</span>)<br>                        <span class="hljs-keyword">return</span> n - <span class="hljs-number">1</span>;<br>                    visited[nextRow][nextCol] = <span class="hljs-literal">true</span>;<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;nextRow, nextCol&#125;);<br>                &#125;<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><br>    <span class="hljs-type">int</span> m, n;<br>    <span class="hljs-type">int</span>[][] grid, dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;&#125;;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &lt; n;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="统计完全连通分量的数量">统计完全连通分量的数量</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230717100534328.png" /></p>
<h3 id="方法一并查集">方法一：并查集</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countCompleteComponents</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] edges)</span> &#123;<br>        <span class="hljs-comment">// 并查集确定连通分量</span><br>        <span class="hljs-comment">// 遍历每个连通分量，如果每个节点的入度 == 连通分量节点数 - 1，则是完全连通(或者只有一个顶点)</span><br>        init(n);<br><br>        <span class="hljs-type">int</span>[] inDegrees = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br><span class="hljs-comment">//        Set&lt;Integer&gt; visited = new HashSet&lt;&gt;(); // 如果某个节点没有与其他节点有边，算一个完全连通分量</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] edge : edges) &#123;<br><span class="hljs-comment">//            visited.add(edge[0]);</span><br><span class="hljs-comment">//            visited.add(edge[1]);</span><br>            ++inDegrees[edge[<span class="hljs-number">0</span>]];<br>            ++inDegrees[edge[<span class="hljs-number">1</span>]];<br>            union(edge[<span class="hljs-number">0</span>], edge[<span class="hljs-number">1</span>]);<br>        &#125;<br><span class="hljs-comment">//        int notVisitedNum = n - visited.size(), res = 0;</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Map&lt;Integer, List&gt; graph = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            graph.putIfAbsent(findParent(i), <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>());<br>            graph.get(findParent(i)).add(i);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, List&gt; entry : graph.entrySet()) &#123;<br>            List&lt;Integer&gt; nodes = entry.getValue();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> nodes.size();<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> node : nodes) &#123;<br>                <span class="hljs-keyword">if</span> (inDegrees[node] != size - <span class="hljs-number">1</span>) &#123;<br>                    flag = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (flag)<br>                ++res;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-type">int</span>[] parent;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rootI</span> <span class="hljs-operator">=</span> findParent(i), rootJ = findParent(j);<br>        <span class="hljs-keyword">if</span> (rootI != rootJ) &#123;<br>            parent[rootI] = rootJ;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findParent</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i != parent[i])<br>            parent[i] = findParent(parent[i]);<br>        <span class="hljs-keyword">return</span> parent[i];<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        parent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            parent[i] = i;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="记忆化搜索的缺点">记忆化搜索的缺点</h2>
<p>值域大的时候，不能使用记忆化搜索，占用太多内存空间</p>
<p>比如不能解决https://leetcode.cn/problems/maximum-subarray/description/</p>
]]></content>
      <categories>
        <category>Contest</category>
        <category>LCP</category>
      </categories>
      <tags>
        <tag>力扣杯</tag>
      </tags>
  </entry>
  <entry>
    <title>lcp354</title>
    <url>/2023/07/16/lcp354/</url>
    <content><![CDATA[<h2 id="第一题-特殊元素平方和">第一题 特殊元素平方和</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230716103044467.png" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumOfSquares</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length, res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (n % (i + <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>)<br>                res += (nums[i] * nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="第二题-数组的最大美丽值">第二题 数组的最大美丽值</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230716103408304.png" /></p>
<h3 id="方法一二分查找">方法一：二分查找</h3>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230716190210639.png" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximumBeauty</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Arrays.sort(nums);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i) &#123;<br>            <span class="hljs-comment">// 求小于nums[i] + 2k的最大值</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> bisearch(nums, nums[i] + <span class="hljs-number">2</span> * k);<br>            res = Math.max(res, j - i + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">bisearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &lt;= num)<br>                left = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <br>                right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> right;<br>    &#125; <br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="滑动窗口">滑动窗口</h3>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230716192346279.png" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximumBeauty</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Arrays.sort(nums);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>; right &lt; nums.length; ++right) &#123;<br>            <span class="hljs-keyword">if</span> (nums[right] - nums[left] &gt; <span class="hljs-number">2</span> * k) <br>                left += <span class="hljs-number">1</span>;<br>            res = Math.max(res, right - left + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="差分">差分</h3>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230716194348073.png" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximumBeauty</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span>[] diff = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">100003</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : nums) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> Math.max(<span class="hljs-number">0</span>, x - k);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> Math.min(<span class="hljs-number">100001</span>, x + k);<br>            ++diff[left];<br>            --diff[right + <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; diff.length; ++i) &#123;<br>            diff[i] += diff[i - <span class="hljs-number">1</span>];<br>            res = Math.max(res, diff[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="第三题">第三题</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230716115924889.png" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumIndex</span><span class="hljs-params">(List&lt;Integer&gt; nums)</span> &#123;<br>        n = nums.size();<br>        <span class="hljs-built_in">this</span>.nums = nums.stream().mapToInt(i-&gt;i).toArray();<br>        Map&lt;Integer, Integer&gt; count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        TreeMap&lt;Integer, Integer&gt; treeMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            count.put(<span class="hljs-built_in">this</span>.nums[i], count.getOrDefault(<span class="hljs-built_in">this</span>.nums[i], <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            treeMap.put(count.get(<span class="hljs-built_in">this</span>.nums[i]), <span class="hljs-built_in">this</span>.nums[i]);<br>        &#125;<br>        primary = treeMap.lastEntry().getValue();<br>        <span class="hljs-type">int</span>[] cnt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        cnt[<span class="hljs-number">0</span>] = <span class="hljs-built_in">this</span>.nums[<span class="hljs-number">0</span>] == primary ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            cnt[i] = cnt[i - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.nums[i] == primary)<br>                cnt[i]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (cnt[i] * <span class="hljs-number">2</span> &gt; i + <span class="hljs-number">1</span> &amp;&amp; (cnt[n - <span class="hljs-number">1</span>] - cnt[i]) * <span class="hljs-number">2</span> &gt; n - i - <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br><br><br><br>    <span class="hljs-type">int</span> n, MAX = Integer.MAX_VALUE, primary;<br>    <span class="hljs-type">int</span>[] nums;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="第四题">第四题</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230716161423910.png" /></p>
<h3 id="双指针">双指针</h3>
<p>固定右端点，从右往左判断是否含有禁止的字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestValidSubstring</span><span class="hljs-params">(String word, List&lt;String&gt; forbidden)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, n = word.length();<br>        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(forbidden);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,right = <span class="hljs-number">0</span>; right &lt; n; ++right) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> right; i &gt;= left &amp;&amp; i &gt; right - <span class="hljs-number">10</span>; --i) &#123;<br>                <span class="hljs-keyword">if</span> (set.contains(word.substring(i, right + <span class="hljs-number">1</span>))) &#123;<br>                    left = i + <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            res = Math.max(res, right - left + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="section"></h2>
]]></content>
      <categories>
        <category>Contest</category>
        <category>LCP</category>
      </categories>
      <tags>
        <tag>力扣杯</tag>
      </tags>
  </entry>
  <entry>
    <title>lcp347</title>
    <url>/2023/07/13/lcp347/</url>
    <content><![CDATA[<h2 id="移除字符串中的尾随零">移除字符串中的尾随零</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230713105250605.png" /></p>
<h3 id="方法一模拟">方法一：模拟</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">removeTrailingZeros</span><span class="hljs-params">(String num)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>, n = num.length();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-keyword">if</span> (num.charAt(i) == <span class="hljs-string">&#x27;0&#x27;</span>)<br>                index = i;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> index == -<span class="hljs-number">1</span> ? num : num.substring(<span class="hljs-number">0</span>, index);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="对角线上不同值的数量差">对角线上不同值的数量差</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230713105832511.png" /></p>
<h3 id="方法一">方法一：</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">```<br><br>## 使所有字符相等的最小成本<br><br>![ ](https:<span class="hljs-comment">//leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230713110131294.png) </span><br><br>### 方法一：<br><br>```java<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">minimumCost</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-comment">// left[0][j]: 将前j个字符往左边翻转，全部翻转成0需要的次数</span><br>        <span class="hljs-comment">// left[1][j]: 将前j个字符往左边翻转，全部翻转成1需要的次数</span><br>        <span class="hljs-comment">// right[0][j]：将前j个字符往后翻转，全部反转成0需要的次数</span><br>        <span class="hljs-comment">// right[1][j]：将前j个字符往后翻转，全部反转成1需要的次数</span><br>        <span class="hljs-type">long</span>[][] left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[<span class="hljs-number">2</span>][n], right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[<span class="hljs-number">2</span>][n];<br>        <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> s.charAt(<span class="hljs-number">0</span>);<br>        left[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = ch == <span class="hljs-string">&#x27;0&#x27;</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;<br>        left[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = ch == <span class="hljs-string">&#x27;0&#x27;</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-keyword">if</span> (num == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>                left[<span class="hljs-number">0</span>][i] = left[<span class="hljs-number">0</span>][i - <span class="hljs-number">1</span>]; <span class="hljs-comment">// yes</span><br>                left[<span class="hljs-number">1</span>][i] = i + <span class="hljs-number">1</span> + left[<span class="hljs-number">0</span>][i - <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// num == 1</span><br>                left[<span class="hljs-number">0</span>][i] = i + <span class="hljs-number">1</span> + left[<span class="hljs-number">1</span>][i - <span class="hljs-number">1</span>]; <span class="hljs-comment">// ??</span><br>                left[<span class="hljs-number">1</span>][i] = left[<span class="hljs-number">1</span>][i - <span class="hljs-number">1</span>]; <span class="hljs-comment">// yes</span><br>            &#125;<br>        &#125;<br>        ch = s.charAt(n - <span class="hljs-number">1</span>);<br>        right[<span class="hljs-number">0</span>][n - <span class="hljs-number">1</span>] = ch == <span class="hljs-string">&#x27;0&#x27;</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;<br>        right[<span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>] = ch == <span class="hljs-string">&#x27;0&#x27;</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-keyword">if</span> (num == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>                right[<span class="hljs-number">0</span>][i] = right[<span class="hljs-number">0</span>][i + <span class="hljs-number">1</span>]; <span class="hljs-comment">// yes</span><br>                right[<span class="hljs-number">1</span>][i] = n - i + right[<span class="hljs-number">0</span>][i + <span class="hljs-number">1</span>] ;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// num == 1</span><br>                right[<span class="hljs-number">0</span>][i] = n - i + right[<span class="hljs-number">1</span>][i + <span class="hljs-number">1</span>] ;<br>                right[<span class="hljs-number">1</span>][i] = right[<span class="hljs-number">1</span>][i + <span class="hljs-number">1</span>]; <span class="hljs-comment">// yes</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Math.min(left[<span class="hljs-number">0</span>][n - <span class="hljs-number">1</span>], left[<span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>]);<br>        res = Math.min(res, Math.min(right[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], right[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++i) &#123;<br>            res = Math.min(res, left[<span class="hljs-number">0</span>][i] + right[<span class="hljs-number">0</span>][i + <span class="hljs-number">1</span>]);<br>            res = Math.min(res, left[<span class="hljs-number">1</span>][i] + right[<span class="hljs-number">1</span>][i + <span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Contest</category>
        <category>LCP</category>
      </categories>
      <tags>
        <tag>力扣杯</tag>
      </tags>
  </entry>
  <entry>
    <title>Segment Tree</title>
    <url>/2023/07/11/segment-tree/</url>
    <content><![CDATA[<h2 id="总结数组问题">总结数组问题</h2>
<ul>
<li><p>数组不变，区间查询：<strong>前缀和</strong>、树状数组、线段树；</p></li>
<li><p>数组单点修改，区间查询：<strong>树状数组</strong>、线段树；</p></li>
<li><p>数组区间修改，单点查询：<strong>差分</strong>、线段树；</p></li>
<li><p>数组区间修改，区间查询：<strong>线段树</strong>。</p>
<p>https://leetcode.cn/problems/my-calendar-i/solutions/1646079/by-lfool-xvpv/</p></li>
</ul>
<h2 id="以组为单位订音乐会的门票"><a href="https://leetcode.cn/problems/booking-concert-tickets-in-groups/">2286. 以组为单位订音乐会的门票</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230713104418591.png" /></p>
]]></content>
      <categories>
        <category>Algorithms</category>
        <category>Segment Tree</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>Prefix Sum</title>
    <url>/2023/07/10/prefix-sum/</url>
    <content><![CDATA[<h2 id="总结数组问题">总结数组问题</h2>
<ul>
<li><p>数组不变，区间查询：<strong>前缀和</strong>、树状数组、线段树；</p></li>
<li><p>数组单点修改，区间查询：<strong>树状数组</strong>、线段树；</p></li>
<li><p>数组区间修改，单点查询：<strong>差分</strong>、线段树；</p></li>
<li><p>数组区间修改，区间查询：<strong>线段树</strong>。</p>
<p><a href="https://leetcode.cn/problems/corporate-flight-bookings/solutions/968467/gong-shui-san-xie-yi-ti-shuang-jie-chai-fm1ef/">链接</a></p></li>
</ul>
<h1 id="差分数组">差分数组</h1>
<h2 id="航班预订统计"><a href="https://leetcode.cn/problems/corporate-flight-bookings/">1109. 航班预订统计</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230710121647717.png" /></p>
<h3 id="方法一差分数组">方法一：差分数组</h3>
<p>航班编号从1开始，初始化diff数组大小为n + 1，diff[0]没有意义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] corpFlightBookings(<span class="hljs-type">int</span>[][] bookings, <span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n], diff = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] booking : bookings) &#123;<br>            diff[booking[<span class="hljs-number">0</span>]] += booking[<span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">if</span> (booking[<span class="hljs-number">1</span>] != n)<br>                diff[booking[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>] -= booking[<span class="hljs-number">2</span>];<br>        &#125;<br>        res[<span class="hljs-number">0</span>] = diff[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; ++i) <br>            res[i] = diff[i + <span class="hljs-number">1</span>] + res[i - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="拼车"><a href="https://leetcode.cn/problems/car-pooling/">1094. 拼车</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230710131010303.png" /></p>
<h3 id="方法一差分数组-1">方法一：差分数组</h3>
<p>上车位置加，下车位置减</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">diff[trip[<span class="hljs-number">1</span>]] += trip[<span class="hljs-number">0</span>];<br>diff[trip[<span class="hljs-number">2</span>]] -= trip[<span class="hljs-number">0</span>];<br></code></pre></td></tr></table></figure>
<p>是<strong>diff[trip[2]] -= trip[0]</strong>; 而不是diff[trip[2] + 1] -= trip[0];</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">carPooling</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] trips, <span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-type">int</span>[] diff = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">1002</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] trip : trips) &#123;<br>            diff[trip[<span class="hljs-number">1</span>]] += trip[<span class="hljs-number">0</span>];<br>            diff[trip[<span class="hljs-number">2</span>]] -= trip[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : diff) &#123;<br>            sum += x;<br>            <span class="hljs-keyword">if</span> (sum &gt; capacity)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<div class="note note-danger">
            <h2 id="k-连续位的最小翻转次数"><a href="https://leetcode.cn/problems/minimum-number-of-k-consecutive-bit-flips/">995. K 连续位的最小翻转次数</a></h2>
          </div>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230710141435996.png" /></p>
<h3 id="方法一差分数组-2">方法一：差分数组</h3>
<p><a href="https://leetcode.cn/problems/minimum-number-of-k-consecutive-bit-flips/solutions/607416/k-lian-xu-wei-de-zui-xiao-fan-zhuan-ci-s-bikk/">题解</a></p>
<p>遍历到nums[i]时，如果nums[i] + count是偶数，则当前元素(可能被翻转过)实际值是0，需要翻转区间[i, i + k - 1]，</p>
<p>将diff[i + k]减一。遍历到i + k的时候，之前在i时的翻转不再生效，--count(--翻转次数)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minKBitFlips</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] diff = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>]; <span class="hljs-comment">// 减少一步越界处理</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 当前被翻转次数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (diff[i] == -<span class="hljs-number">1</span>)<br>                --count;<br>            <span class="hljs-keyword">if</span> ((nums[i] + count) % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (i + k &gt; n)<br>                    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>                ++res;<br>                ++count;<br>                --diff[i + k];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="使数组中的所有元素都等于零"><a href="https://leetcode.cn/problems/apply-operations-to-make-all-array-elements-equal-to-zero/">6919. 使数组中的所有元素都等于零</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230710155500866.png" /></p>
<h3 id="方法一差分数组-3">方法一：差分数组</h3>
<p>与<a href="https://leetcode.cn/problems/minimum-number-of-k-consecutive-bit-flips/">995. K 连续位的最小翻转次数</a>相似，草稿纸上模拟，多Debug</p>
<p>注意diff[i + k - 1] += nums[i] + curDiff; 复原的位置是i + k - 1</p>
<p><strong>举例</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,2,3,1,1,0]</span>, k = 3<br>输出：true<br>解释：可以执行下述操作：<br>- 选出子数组 <span class="hljs-comment">[2,2,3]</span> ，执行操作后，数组变为 nums = <span class="hljs-comment">[1,1,2,1,1,0]</span> 。<br>- 选出子数组 <span class="hljs-comment">[2,1,1]</span> ，执行操作后，数组变为 nums = <span class="hljs-comment">[1,1,1,0,0,0]</span> 。<br>- 选出子数组 <span class="hljs-comment">[1,1,1]</span> ，执行操作后，数组变为 nums = <span class="hljs-comment">[0,0,0,0,0,0]</span> 。<br></code></pre></td></tr></table></figure>
<table>
<thead>
<tr class="header">
<th>nums</th>
<th>2</th>
<th>2</th>
<th>3</th>
<th>1</th>
<th>1</th>
<th>0</th>
<th>curDiff</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>diff i = 0</td>
<td>-2</td>
<td>0</td>
<td>2</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>-2</td>
</tr>
<tr class="even">
<td>diff i = 1</td>
<td>-2</td>
<td>0</td>
<td>2</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>-2</td>
</tr>
<tr class="odd">
<td>diff i = 2</td>
<td>-2</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>-1</td>
</tr>
<tr class="even">
<td>diff i = 3</td>
<td>-2</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>-1</td>
</tr>
<tr class="odd">
<td>diff i = 4</td>
<td>-2</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>diff i = 5</td>
<td>-2</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] diff = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">curDiff</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] + curDiff &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (i + k &gt; n)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                diff[i] += -nums[i] - curDiff;<br>                diff[i + k - <span class="hljs-number">1</span>] += nums[i] + curDiff;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] + curDiff &lt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span> (diff[i] != <span class="hljs-number">0</span>)<br>                curDiff += diff[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="检查是否区域内所有整数都被覆盖"><a href="https://leetcode.cn/problems/check-if-all-the-integers-in-a-range-are-covered/">1893. 检查是否区域内所有整数都被覆盖</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230710163810686.png" /></p>
<h3 id="方法一差分数组-4">方法一：差分数组</h3>
<p><code>1 &lt;= ranges.length &lt;= 50</code>，所以diff大小为52，第0个位置不用，第51个位置用于防止越界</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCovered</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] ranges, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-type">int</span>[] diff = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">52</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, min = <span class="hljs-number">50</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] range : ranges) &#123;<br>            ++diff[range[<span class="hljs-number">0</span>]];<br>            --diff[range[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>];<br>            max = Math.max(max, range[<span class="hljs-number">1</span>]);<br>            min = Math.min(min, range[<span class="hljs-number">0</span>]);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> min; i &lt;= max; ++i) <br>            diff[i] = diff[i - <span class="hljs-number">1</span>] + diff[i];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> left; i &lt;= right; ++i)<br>            <span class="hljs-keyword">if</span> (diff[i] &lt;= <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二差分数组-前缀和">方法二：差分数组 + 前缀和</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCovered</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] ranges, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-type">int</span>[] diff = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">52</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] range : ranges) &#123;<br>            ++diff[range[<span class="hljs-number">0</span>]];<br>            --diff[range[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">preSum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">50</span>; ++i) &#123;<br>            preSum += diff[i];<br>            <span class="hljs-keyword">if</span> (i &gt;= left &amp;&amp; i &lt;= right &amp;&amp; preSum &lt;= <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<div class="note note-danger">
            <h2 id="花期内花的数目"><a href="https://leetcode.cn/problems/number-of-flowers-in-full-bloom/">2251. 花期内花的数目</a></h2>
          </div>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230928155315288.png" /></p>
<h3 id="方法一差分数组-treemap">方法一：差分数组 + TreeMap</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// O(n),差分数组</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] fullBloomFlowers(<span class="hljs-type">int</span>[][] flowers, <span class="hljs-type">int</span>[] people) &#123;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[people.length];<br>        TreeMap&lt;Integer, Integer&gt; differMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; flowers.length; i++) &#123;<br>            differMap.put(flowers[i][<span class="hljs-number">0</span>], differMap.getOrDefault(flowers[i][<span class="hljs-number">0</span>], <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            differMap.put(flowers[i][<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, differMap.getOrDefault(flowers[i][<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>) - <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-comment">//差分数组还原</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (Integer key : differMap.keySet()) &#123;<br>            pre = differMap.get(key) + pre;<br>            differMap.put(key, pre);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; people.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> people[i];<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> differMap.floorKey(x);<br>            <span class="hljs-keyword">if</span> (y != <span class="hljs-literal">null</span>) <br>                res[i] = differMap.get(y);<br>            <span class="hljs-comment">// res[i] = differMap.floorEntry(people[i]).getValue();</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二二分">方法二：二分</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] fullBloomFlowers(<span class="hljs-type">int</span>[][] flowers, <span class="hljs-type">int</span>[] people) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> flowers.length;<br>        <span class="hljs-type">int</span>[] start = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n], end = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            start[i] = flowers[i][<span class="hljs-number">0</span>];<br>            end[i] = flowers[i][<span class="hljs-number">1</span>];<br>        &#125;<br>        Arrays.sort(start);<br>        Arrays.sort(end);<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[people.length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; people.length; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> people[i];<br>            <span class="hljs-comment">// 时间time开了多少花，枯萎了多少花</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> bisearch(start, time), y = bisearch(end, time - <span class="hljs-number">1</span>); <span class="hljs-comment">// 花在end + 1时枯萎</span><br>            res[i] = x - y;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">// 找到小于等于t的最大数组下标</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">bisearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> t)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &gt; t)<br>                r = mid - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <br>                l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> l;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="前缀和">前缀和</h1>
<h2 id="区域和检索---数组不可变"><a href="https://leetcode.cn/problems/range-sum-query-immutable/">303. 区域和检索 - 数组不可变</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230717194525425.png" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumArray</span> &#123;<br><br>    <span class="hljs-type">int</span>[] preSum;<br>    <span class="hljs-type">int</span> n;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NumArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        n = nums.length;<br>        preSum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>            preSum[i] = preSum[i - <span class="hljs-number">1</span>] + nums[i - <span class="hljs-number">1</span>];<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumRange</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-keyword">return</span> preSum[right + <span class="hljs-number">1</span>] - preSum[left];<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your NumArray object will be instantiated and called as such:</span><br><span class="hljs-comment"> * NumArray obj = new NumArray(nums);</span><br><span class="hljs-comment"> * int param_1 = obj.sumRange(left,right);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>
<div class="note note-danger">
            <h2 id="二维区域和检索---矩阵不可变"><a href="https://leetcode.cn/problems/range-sum-query-2d-immutable/">304. 二维区域和检索 - 矩阵不可变</a></h2>
          </div>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230717195944472.png" /></p>
<p>看图</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230717205110275.png" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumMatrix</span> &#123;<br><br>    <span class="hljs-type">int</span>[][] preSum;<br>    <span class="hljs-type">int</span> m, n;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NumMatrix</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        m = matrix.length;<br>        n = matrix[<span class="hljs-number">0</span>].length;<br>        preSum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; ++i) <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; ++j) <br>                preSum[i][j] = matrix[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] - preSum[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + preSum[i][j - <span class="hljs-number">1</span>] + preSum[i - <span class="hljs-number">1</span>][j];<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumRegion</span><span class="hljs-params">(<span class="hljs-type">int</span> row1, <span class="hljs-type">int</span> col1, <span class="hljs-type">int</span> row2, <span class="hljs-type">int</span> col2)</span> &#123;<br>        <span class="hljs-keyword">return</span> preSum[row2 + <span class="hljs-number">1</span>][col2 + <span class="hljs-number">1</span>] + preSum[row1][col1] - preSum[row1][col2 + <span class="hljs-number">1</span>] - preSum[row2 + <span class="hljs-number">1</span>][col1];<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your NumMatrix object will be instantiated and called as such:</span><br><span class="hljs-comment"> * NumMatrix obj = new NumMatrix(matrix);</span><br><span class="hljs-comment"> * int param_1 = obj.sumRegion(row1,col1,row2,col2);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>
<div class="note note-danger">
            <h2 id="矩形区域不超过-k-的最大数值和"><a href="https://leetcode.cn/problems/max-sum-of-rectangle-no-larger-than-k/">363. 矩形区域不超过 K 的最大数值和</a></h2>
          </div>
<p><a href="https://leetcode.cn/problems/max-sum-of-rectangle-no-larger-than-k/solutions/734547/gong-shui-san-xie-you-hua-mei-ju-de-ji-b-dh8s/">题解</a></p>
<h3 id="方法一朴素前缀和">方法一：朴素前缀和</h3>
<p><strong><code>1 &lt;= m, n &lt;= 100</code>,时间复杂度<span class="math inline">\(O(m^2n^2)\)</span>,最坏情况<span class="math inline">\(10^8\)</span>刚刚好</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSumSubmatrix</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix.length, n = matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[][] preSum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; ++i) <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; ++j) <br>                preSum[i][j] = matrix[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + preSum[i][j - <span class="hljs-number">1</span>] + preSum[i - <span class="hljs-number">1</span>][j] - preSum[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE / <span class="hljs-number">2</span>, sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">row1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; row1 &lt; m; ++row1) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">col1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; col1 &lt; n; ++col1) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">row2</span> <span class="hljs-operator">=</span> row1; row2 &lt; m; ++row2) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">col2</span> <span class="hljs-operator">=</span> col1; col2 &lt; n; ++col2) &#123;<br>                        sum = preSum[row2 + <span class="hljs-number">1</span>][col2 + <span class="hljs-number">1</span>] + preSum[row1][col1] - preSum[row1][col2 + <span class="hljs-number">1</span>] - preSum[row2 + <span class="hljs-number">1</span>][col1];<br>                        <span class="hljs-keyword">if</span> (sum &lt;= k)<br>                            max = Math.max(max, sum);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二前缀和-二分查找">方法二：前缀和 + 二分查找</h3>
<p><a href="https://leetcode.cn/problems/max-sum-of-rectangle-no-larger-than-k/solutions/736564/ju-xing-qu-yu-bu-chao-guo-k-de-zui-da-sh-70q2/">题解</a></p>
<div class="note note-danger">
            <h2 id="连续的子数组和"><a href="https://leetcode.cn/problems/continuous-subarray-sum/">523. 连续的子数组和</a></h2>
          </div>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230717214639318.png" /></p>
<h3 id="方法一前缀和">方法一：前缀和</h3>
<p><a href="https://leetcode.cn/problems/continuous-subarray-sum/solutions/808246/gong-shui-san-xie-tuo-zhan-wei-qiu-fang-1juse/">题解</a> <a href="https://leetcode.cn/problems/continuous-subarray-sum/solutions/808031/zheng-ming-dong-tu-bang-ni-chi-tou-ben-t-nldg/">结论证明</a></p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230717221344067.png" /></p>
<p>preSum[i]:数组nums从下标0~i-1的和</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkSubarraySum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] preSum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>            preSum[i] = preSum[i - <span class="hljs-number">1</span>] + nums[i - <span class="hljs-number">1</span>];<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;<br>            set.add(preSum[i - <span class="hljs-number">2</span>] % k);<br>            <span class="hljs-keyword">if</span> (set.contains(preSum[i] % k))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="统计趣味子数组的数目"><a href="https://leetcode.cn/problems/count-of-interesting-subarrays/">6952. 统计趣味子数组的数目</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230903145357072.png" /></p>
<h3 id="方法一前缀和-hashmap-公式转换">方法一：前缀和 + HashMap + 公式转换</h3>
<p>类似两数之和</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">countInterestingSubarrays</span><span class="hljs-params">(List&lt;Integer&gt; nums, <span class="hljs-type">int</span> modulo, <span class="hljs-type">int</span> k)</span> &#123;<br>    Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    map.put(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>    <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : nums) &#123;<br>        <span class="hljs-keyword">if</span> (x % modulo == k)<br>            s = (s + <span class="hljs-number">1</span>) % modulo;<br>        res += map.getOrDefault((s - k + modulo) % modulo, <span class="hljs-number">0</span>);<br>        map.put(s, map.getOrDefault(s, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="和为-k-的子数组"><a href="https://leetcode.cn/problems/subarray-sum-equals-k/">560. 和为 K 的子数组</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230905141343016.png" /></p>
<h3 id="方法一前缀和-hashmap">方法一：前缀和 + HashMap</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">subarraySum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length, res = <span class="hljs-number">0</span>;<br>        Map&lt;Integer, Integer&gt; cnt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        cnt.put(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : nums) &#123;<br>            s += x;<br>            res += cnt.getOrDefault(s - k, <span class="hljs-number">0</span>);<br>            cnt.put(s, cnt.getOrDefault(s, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="和可被-k-整除的子数组"><a href="https://leetcode.cn/problems/subarray-sums-divisible-by-k/">974. 和可被 K 整除的子数组</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230905143311959.png" /></p>
<h3 id="方法一前缀和-hashmap-1">方法一：前缀和 + HashMap</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">subarraysDivByK</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, s = <span class="hljs-number">0</span>;<br>        Map&lt;Integer, Integer&gt; cnt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        cnt.put(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : nums) &#123;<br>            s += x;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> (s % k + k) % k;<br>            res += cnt.getOrDefault(mod, <span class="hljs-number">0</span>);<br>            cnt.put(mod , cnt.getOrDefault(mod, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="连续的子数组和"><a href="https://leetcode.cn/problems/continuous-subarray-sum/">523. 连续的子数组和</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230905150512840.png" /></p>
<h3 id="方法一前缀和-hashset">方法一：前缀和 + HashSet</h3>
<p>s[r + 1] - s[l] = mk =&gt; s[l] % k = s[r + 1] % k</p>
<p><strong>子数组长度至少为2，那么就从2开始遍历</strong></p>
<p><a href="https://leetcode.cn/problems/continuous-subarray-sum/solutions/808246/gong-shui-san-xie-tuo-zhan-wei-qiu-fang-1juse/">题解</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkSubarraySum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] sum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            sum[i + <span class="hljs-number">1</span>] = sum[i] + nums[i];<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;<br>            set.add(sum[i - <span class="hljs-number">2</span>] % k);<br>            <span class="hljs-keyword">if</span> (set.contains(sum[i] % k))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="连续数组"><a href="https://leetcode.cn/problems/contiguous-array/">525. 连续数组</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230905160242658.png" /></p>
<h3 id="方法一前缀和-hashmap-2">方法一：前缀和 + HashMap</h3>
<p><a href="https://leetcode.cn/problems/contiguous-array/solutions/809920/gong-shui-san-xie-qian-zhui-he-ha-xi-bia-q400/">题解</a></p>
<p>map.put(0, -1);哨兵，比如可以处理：nums = [0, 1]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMaxLength</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length, res = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            s += (nums[i] == <span class="hljs-number">0</span> ? -<span class="hljs-number">1</span> : <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (map.containsKey(s))<br>                res = Math.max(res, i - map.get(s));<br>            <span class="hljs-keyword">else</span><br>                map.put(s, i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithms</category>
        <category>Prefix Sum</category>
      </categories>
      <tags>
        <tag>前缀和，差分数组</tag>
      </tags>
  </entry>
  <entry>
    <title>others</title>
    <url>/2023/07/09/%E5%85%B6%E4%BB%96/</url>
    <content><![CDATA[<p>小红定义一个字符串是“好串”，<strong>当且仅当该字符串的长度不小于2</strong>，<strong>且首尾相同</strong>。例如"arcaea"是好串。 小红拿到了一个字符串(该字符串不一定是好串)，她准备把这个字符串切割成若干个好串，你可以帮小红求出好串的最多数量吗?</p>
<p>输入描述：一个仅包含小写字母的字符串，长度不超过200000。</p>
<p>输出描述：如果无法切割且该字符串本身不是好串，请输出-1。否则输出最终的好串数量。</p>
<p>示例： 输入： arcaea 输出： 1</p>
<p>输入： abcb 输出： -1</p>
<p>输入： aababaa 输出： 3</p>
<h3 id="方法一记忆化搜索">方法一：记忆化搜索</h3>
<p>先固定分割左边的子串，枚举右边分割的所有情况，取最大值</p>
<p>左子串第一个字符和右子串最后一个字符相等，被分割后产生的新str的首尾字符相同</p>
<ol type="1">
<li><p>如果i == j - 1,即新str只剩下一个字符了，那么str.charAt(i + 1) == str.charAt(j - 1)比较的是同一个字符</p>
<p>比如str = a b a b a,</p>
<pre><code class="hljs">                     i       (i + 1) == j - 1            j</code></pre></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">splitL.charAt(<span class="hljs-number">0</span>) == splitR.charAt(splitR.length() - <span class="hljs-number">1</span>) &amp;&amp; str.charAt(i + <span class="hljs-number">1</span>) == str.charAt(j - <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure>
<h4 id="代码">代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> 背包;<br><br><br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">goodString</span><span class="hljs-params">(String str)</span> &#123;<br>        n = str.length();<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dp)<br>            Arrays.fill(arr, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> dfs(str, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> res &lt; <span class="hljs-number">0</span> ? -<span class="hljs-number">1</span> : res;<br>    &#125;<br><br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">int</span>[][] dp;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(String str, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-keyword">if</span> (left &gt;= right)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (dp[left][right] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[left][right];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> -Integer.MAX_VALUE / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> left; i &lt; right; ++i) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">splitL</span> <span class="hljs-operator">=</span> str.substring(left, i + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> right; j &gt; i; --j) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">splitR</span> <span class="hljs-operator">=</span> str.substring(j, right + <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span> (splitL.charAt(<span class="hljs-number">0</span>) == splitR.charAt(splitR.length() - <span class="hljs-number">1</span>) &amp;&amp; str.charAt(i + <span class="hljs-number">1</span>) == str.charAt(j - <span class="hljs-number">1</span>)) &#123;<br>                    res = Math.max(res, dfs(str, i + <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[left][right] = res;<br>    &#125;<br><br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Solution</span> <span class="hljs-variable">solution</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Solution</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> solution.goodString(<span class="hljs-string">&quot;aababaa&quot;</span>);<br><span class="hljs-comment">//        int res = solution.goodString(&quot;abcb&quot;);</span><br><span class="hljs-comment">//        int res = solution.goodString(&quot;arcaea&quot;);</span><br><br><br>        System.out.println(res);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>lcp353</title>
    <url>/2023/07/09/lcp353/</url>
    <content><![CDATA[<h2 id="找出最大的可达成数字">找出最大的可达成数字</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230709103020706.png" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">theMaximumAchievableX</span><span class="hljs-params">(<span class="hljs-type">int</span> num, <span class="hljs-type">int</span> t)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; t; ++i) &#123;<br>            num += <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> num;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="达到末尾下标所需的最大跳跃次数">达到末尾下标所需的最大跳跃次数</h2>
<p><img src="C:\Users\ning\AppData\Roaming\Typora\typora-user-images\image-20230709103546652.png" /></p>
<h3 id="方法一记忆化搜索-flags存储可达路径">方法一：记忆化搜索 flags存储可达路径</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximumJumps</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-built_in">this</span>.nums = nums;<br>        <span class="hljs-built_in">this</span>.target = target;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        Arrays.fill(dp, -<span class="hljs-number">1</span>);<br>        flags = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[nums.length];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> flags[<span class="hljs-number">0</span>] ? res : -<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">boolean</span>[] flags;<br>    <span class="hljs-type">int</span>[] nums, dp;<br>    <span class="hljs-type">int</span> target;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> from)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == nums.length - <span class="hljs-number">1</span>) &#123;<br>            flags[from] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (dp[index] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[index];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> index + <span class="hljs-number">1</span>; i &lt; nums.length; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (Math.abs(nums[i] - nums[index]) &lt;= target) &#123;<br>                max += dfs(i,i) + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (flags[i])<br>                    flags[index] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">if</span> (flags[i]) &#123;<br>                    res = Math.max(res, max);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[index] = res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二">方法二：</h3>
<p><strong>题目中有：全部不满足情况下返回-1时，要重视dfs里res的初始化， -inf, inf等，根据具体要求具体分析</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximumJumps</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-built_in">this</span>.nums = nums;<br>        <span class="hljs-built_in">this</span>.target = target;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        Arrays.fill(dp, -<span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> dfs(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res &lt; <span class="hljs-number">0</span> ? -<span class="hljs-number">1</span> : res;<br>    &#125;<br><br>    <span class="hljs-type">int</span>[] nums;<br>    <span class="hljs-type">int</span> target;<br>    <span class="hljs-type">int</span>[] dp;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == nums.length - <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (dp[index] != -<span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">return</span> dp[index];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> -Integer.MAX_VALUE / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> index + <span class="hljs-number">1</span>; i &lt; nums.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (Math.abs(nums[i] - nums[index]) &lt;= target)<br>                res = Math.max(res, dfs(i) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[index] = res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="构造最长非递减子数组">构造最长非递减子数组</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230710095149722.png" /></p>
<h3 id="方法一记忆化搜索">方法一：记忆化搜索</h3>
<p>要遍历完从0到n-1开始的下标，因为最长不一定从下标0开始，比如nums1 = [8,7,4] nums2 = [13,4,4]，最大长度从下标1开始 [4,4]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxNonDecreasingLength</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2)</span> &#123;<br>        <span class="hljs-built_in">this</span>.nums1 = nums1;<br>        <span class="hljs-built_in">this</span>.nums2 = nums2;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums1.length; ++i)<br>            res = Math.max(res, dfs(i, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">return</span> res;       <br>    &#125;<br><br>    <span class="hljs-type">int</span>[] nums1, nums2;<br>    Map&lt;String, Integer&gt; dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> pre)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == nums1.length)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> index + <span class="hljs-string">&quot;-&quot;</span> + pre;<br>        <span class="hljs-keyword">if</span> (dp.containsKey(key))<br>            <span class="hljs-keyword">return</span> dp.get(key);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// res最小也是1，1个数的长度为1</span><br>        <span class="hljs-keyword">if</span> (pre &lt;= nums1[index])<br>            res = Math.max(res, dfs(index + <span class="hljs-number">1</span>, nums1[index]) + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (pre &lt;= nums2[index])<br>            res = Math.max(res, dfs(index + <span class="hljs-number">1</span>, nums2[index]) + <span class="hljs-number">1</span>);<br>        dp.put(key, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125; <br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="使数组中的所有元素都等于零">使数组中的所有元素都等于零</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230710103945841.png" /></p>
<h3 id="方法一差分数组">方法一：差分数组</h3>
<p>与<a href="https://leetcode.cn/problems/minimum-number-of-k-consecutive-bit-flips/">995. K 连续位的最小翻转次数</a>相似，草稿纸上模拟，多Debug</p>
<p>注意diff[i + k - 1] += nums[i] + curDiff; 复原的位置是i + k - 1</p>
<p><strong>举例</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,2,3,1,1,0]</span>, k = 3<br>输出：true<br>解释：可以执行下述操作：<br>- 选出子数组 <span class="hljs-comment">[2,2,3]</span> ，执行操作后，数组变为 nums = <span class="hljs-comment">[1,1,2,1,1,0]</span> 。<br>- 选出子数组 <span class="hljs-comment">[2,1,1]</span> ，执行操作后，数组变为 nums = <span class="hljs-comment">[1,1,1,0,0,0]</span> 。<br>- 选出子数组 <span class="hljs-comment">[1,1,1]</span> ，执行操作后，数组变为 nums = <span class="hljs-comment">[0,0,0,0,0,0]</span> 。<br></code></pre></td></tr></table></figure>
<table>
<thead>
<tr class="header">
<th>nums</th>
<th>2</th>
<th>2</th>
<th>3</th>
<th>1</th>
<th>1</th>
<th>0</th>
<th>curDiff</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>diff i = 0</td>
<td>-2</td>
<td>0</td>
<td>2</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>-2</td>
</tr>
<tr class="even">
<td>diff i = 1</td>
<td>-2</td>
<td>0</td>
<td>2</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>-2</td>
</tr>
<tr class="odd">
<td>diff i = 2</td>
<td>-2</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>-1</td>
</tr>
<tr class="even">
<td>diff i = 3</td>
<td>-2</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>-1</td>
</tr>
<tr class="odd">
<td>diff i = 4</td>
<td>-2</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>diff i = 5</td>
<td>-2</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] diff = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">curDiff</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] + curDiff &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (i + k &gt; n)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                diff[i] += -nums[i] - curDiff;<br>                diff[i + k - <span class="hljs-number">1</span>] += nums[i] + curDiff;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] + curDiff &lt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span> (diff[i] != <span class="hljs-number">0</span>)<br>                curDiff += diff[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure>
<img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230709144240215.png" alt="image-20230709144240215" /><figcaption aria-hidden="true">image-20230709144240215</figcaption>
</figure>
]]></content>
      <categories>
        <category>Contest</category>
        <category>LCP</category>
      </categories>
      <tags>
        <tag>力扣杯</tag>
      </tags>
  </entry>
  <entry>
    <title>lcpBi108</title>
    <url>/2023/07/08/lcpBi108/</url>
    <content><![CDATA[<h2 id="最长交替子序列">最长交替子序列</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230708223030144.png" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">alternatingSubarray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">1</span>; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; nums.length; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (pre == -<span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (nums[j] - nums[j - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span>) &#123;<br>                        res = Math.max(res, j - i + <span class="hljs-number">1</span>);<br>                        pre = <span class="hljs-number">1</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span><br>                        <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pre == <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (nums[j] - nums[j - <span class="hljs-number">1</span>] == -<span class="hljs-number">1</span>) &#123;<br>                        res = Math.max(res, j - i + <span class="hljs-number">1</span>);<br>                        pre = -<span class="hljs-number">1</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span><br>                        <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>分组循环</strong></p>
<h2 id="重新放置石块">重新放置石块</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230708224327867.png" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">relocateMarbles</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span>[] moveFrom, <span class="hljs-type">int</span>[] moveTo)</span> &#123;<br>        TreeMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : nums)<br>            map.put(x, map.getOrDefault(x, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; moveFrom.length; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">from</span> <span class="hljs-operator">=</span> moveFrom[i], to = moveTo[i];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">fromNum</span> <span class="hljs-operator">=</span> map.get(from);<br>            map.remove(from);<br>            map.put(to, map.getOrDefault(to, <span class="hljs-number">0</span>) + fromNum);<br>        &#125;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> key : map.keySet())<br>            res.add(key);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="将字符串分割为最少的美丽子字符串">将字符串分割为最少的美丽子字符串</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230708225452993.png" /></p>
<h3 id="方法一记忆化搜索">方法一：记忆化搜索</h3>
<p><strong>题目中有：全部不满足情况下返回-1时，要重视dfs里res的初始化， -inf, inf等，根据具体要求具体分析</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>     <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumBeautifulSubstrings</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) Math.pow(<span class="hljs-number">2</span>, <span class="hljs-number">15</span>);<br>        set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= a; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) Math.pow(<span class="hljs-number">5</span>, i);<br>            <span class="hljs-keyword">if</span> (num &gt; a)<br>                <span class="hljs-keyword">break</span>;<br>            set.add(Integer.toBinaryString(num));<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> dfs(s, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res == Integer.MAX_VALUE / <span class="hljs-number">2</span> ? -<span class="hljs-number">1</span> : res;<br>    &#125;<br><br>     Set&lt;String&gt; set;<br>     Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">private</span>  <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == s.length()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (map.containsKey(index))<br>            <span class="hljs-keyword">return</span> map.get(index);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> index; i &lt; s.length(); ++i) &#123;<br>            <span class="hljs-keyword">if</span> (s.charAt(index) == <span class="hljs-string">&#x27;0&#x27;</span>)<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">sub</span> <span class="hljs-operator">=</span> s.substring(index, i + <span class="hljs-number">1</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">splitNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (set.contains(sub)) &#123;<br>                splitNum += dfs(s, i + <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>                res = Math.min(res, splitNum);<br>            &#125;<br>        &#125;<br>        map.put(index, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二记忆化搜索-预处理">方法二：记忆化搜索 预处理</h3>
<p>预处理部分放在静态块里，只会执行一次</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-keyword">static</span> Set&lt;String&gt; set;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) Math.pow(<span class="hljs-number">2</span>, <span class="hljs-number">15</span>);<br>        set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= a; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) Math.pow(<span class="hljs-number">5</span>, i);<br>            <span class="hljs-keyword">if</span> (num &gt; a)<br>                <span class="hljs-keyword">break</span>;<br>            set.add(Integer.toBinaryString(num));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumBeautifulSubstrings</span><span class="hljs-params">(String s)</span> &#123;<br>        <br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>
<h2 id="黑格子的数目">黑格子的数目</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230709083617670.png" /></p>
<h3 id="方法一map">方法一：Map</h3>
<p><a href="https://leetcode.cn/circle/discuss/BO1c8V/view/bCGFbA/">题解</a></p>
<p>​ res[0] = (m - 1L) * (n - 1) - sum; 1L转成long避免m，n太大</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span>[] countBlackBlocks(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] coordinates) &#123;<br>        Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : coordinates) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>] + dir[<span class="hljs-number">0</span>], col = arr[<span class="hljs-number">1</span>] + dir[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span> (row &gt;= <span class="hljs-number">0</span> &amp;&amp; col &gt;= <span class="hljs-number">0</span> &amp;&amp; row &lt; m - <span class="hljs-number">1</span> &amp;&amp; col &lt; n - <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-type">String</span> <span class="hljs-variable">rc</span> <span class="hljs-operator">=</span> row + <span class="hljs-string">&quot;-&quot;</span> + col;<br>                    map.put(rc, map.getOrDefault(rc, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">long</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[<span class="hljs-number">5</span>];<br>        <span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> val : map.values()) &#123;<br>            ++res[val];<br>            ++sum;<br>        &#125;<br>        res[<span class="hljs-number">0</span>] = (m - <span class="hljs-number">1L</span>) * (n - <span class="hljs-number">1</span>) - sum;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Contest</category>
        <category>LCP</category>
      </categories>
      <tags>
        <tag>力扣杯</tag>
      </tags>
  </entry>
  <entry>
    <title>lcp349</title>
    <url>/2023/07/06/lcp349/</url>
    <content><![CDATA[<h2 id="既不是最小值也不是最大值">既不是最小值也不是最大值</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230706141211391.png" /></p>
<h3 id="方法一">方法一：</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findNonMinOrMax</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums.length &lt;= <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        Arrays.sort(nums);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>], max = nums[nums.length - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length - <span class="hljs-number">1</span>; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] != min &amp;&amp; nums[i] != max)<br>                <span class="hljs-keyword">return</span> nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="执行子串操作后的字典序最小字符串">执行子串操作后的字典序最小字符串</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230706141749526.png" /></p>
<h3 id="方法一-1">方法一：</h3>
<p>至少要操作一次</p>
<p>也就是说如果s = “aaaa”，操作一次后是“aaaz”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">smallestString</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">edit</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, n = s.length();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;a&#x27;</span>) &#123;<br>                <span class="hljs-keyword">if</span> (edit == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (i == n - <span class="hljs-number">1</span>)<br>                        sb.append(<span class="hljs-string">&#x27;z&#x27;</span>);<br>                    <span class="hljs-keyword">else</span><br>                        sb.append(<span class="hljs-string">&#x27;a&#x27;</span>);<br>                &#125;<br>                <span class="hljs-keyword">else</span>  &#123; <span class="hljs-comment">// edit &gt; 0</span><br>                    sb.append(s.substring(i));<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                sb.append((<span class="hljs-type">char</span>) (ch - <span class="hljs-number">1</span>));<br>                ++edit;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="收集巧克力">收集巧克力</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230706143235411.png" /></p>
<h2 id="最大和查询">最大和查询</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230706151543109.png" /></p>
]]></content>
      <categories>
        <category>Contest</category>
        <category>LCP</category>
      </categories>
      <tags>
        <tag>力扣杯</tag>
      </tags>
  </entry>
  <entry>
    <title>lcp350</title>
    <url>/2023/07/05/lcp350/</url>
    <content><![CDATA[<h2 id="总行驶距离">总行驶距离</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230705091551188.png" /></p>
<h3 id="二刷模拟">二刷：模拟</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">distanceTraveled</span><span class="hljs-params">(<span class="hljs-type">int</span> mainTank, <span class="hljs-type">int</span> additionalTank)</span> &#123;<br>        <span class="hljs-keyword">if</span> (mainTank &lt; <span class="hljs-number">5</span>)<br>            <span class="hljs-keyword">return</span> mainTank * <span class="hljs-number">10</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> mainTank, res = (mainTank - mainTank % <span class="hljs-number">5</span>) * <span class="hljs-number">10</span>, s = mainTank % <span class="hljs-number">5</span>;<br>        <span class="hljs-keyword">while</span> (x &gt;= <span class="hljs-number">5</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> x / <span class="hljs-number">5</span>;<br>            x = x % <span class="hljs-number">5</span>;<br>            y = Math.min(y, additionalTank);<br>            additionalTank -= y;<br>            x += y;<br>            s += y;<br>        &#125;<br>        res += s * <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O(1)\)</span></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">distanceTraveled</span><span class="hljs-params">(<span class="hljs-type">int</span> mainTank, <span class="hljs-type">int</span> additionalTank)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, ori = mainTank;<br>        <span class="hljs-keyword">while</span> (mainTank &gt; <span class="hljs-number">0</span>) &#123;<br>            --mainTank;<br>            res += <span class="hljs-number">10</span>;<br>            <span class="hljs-keyword">if</span> (ori == mainTank + <span class="hljs-number">5</span>) &#123;<br>                <span class="hljs-keyword">if</span> (additionalTank &gt; <span class="hljs-number">0</span>) &#123;<br>                    --additionalTank;<br>                    ++mainTank;<br>                    ori = mainTank;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="找出分区值">找出分区值</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230705092331024.png" /></p>
<h3 id="二刷排序">二刷：排序</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findValueOfPartition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Arrays.sort(nums);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">1</span>; ++i) <br>            min = Math.min(min,nums[i + <span class="hljs-number">1</span>] - nums[i]);<br>        <span class="hljs-keyword">return</span> min;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findValueOfPartition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Arrays.sort(nums);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++i)<br>            arr[i] = nums[i + <span class="hljs-number">1</span>] - nums[i];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : arr) &#123;<br>            min = Math.min(min, x);<br>        &#125;<br>        <span class="hljs-keyword">return</span> min;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<div class="note note-danger">
            <h2 id="特别的排列">特别的排列</h2>
          </div>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230705093756591.png" /></p>
<h3 id="方法一三种回溯超时">方法一：三种回溯(超时)</h3>
<h4 id="回溯一">回溯一</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">specialPerm</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[nums.length];<br>        Arrays.sort(nums);<br>        dfs(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, MOD = (<span class="hljs-type">int</span>) (<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>);<br>    Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-type">boolean</span>[] visited;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (path.size() == nums.length) &#123;<br>            res = (res + <span class="hljs-number">1</span>) % MOD;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (visited[i])<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span> &amp;&amp; nums[i - <span class="hljs-number">1</span>]  == nums[i] &amp;&amp; !visited[i - <span class="hljs-number">1</span>])<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (path.isEmpty() || check(nums[i], path.peekLast())) &#123;<br>                visited[i] = <span class="hljs-literal">true</span>;<br>                path.offerLast(nums[i]);<br>                dfs(nums, i + <span class="hljs-number">1</span>);<br>                path.pollLast();<br>                visited[i] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">return</span> (a % b == <span class="hljs-number">0</span>) || (b % a == <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="回溯二">回溯二</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">specialPerm</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[nums.length];<br>    dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    Arrays.sort(nums);<br>    <span class="hljs-keyword">return</span> dfs(nums);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>);<br>Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><span class="hljs-type">boolean</span>[] visited;<br>Map&lt;String, Integer&gt; dp;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-keyword">if</span> (path.size() == nums.length)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (visited[i])<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span> &amp;&amp; nums[i - <span class="hljs-number">1</span>]  == nums[i] &amp;&amp; !visited[i - <span class="hljs-number">1</span>])<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (path.isEmpty() || check(nums[i], path.peekLast())) &#123;<br>            visited[i] = <span class="hljs-literal">true</span>;<br>            path.offerLast(nums[i]);<br>            res = (res + dfs(nums)) % MOD;<br>            path.pollLast();<br>            visited[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>    <span class="hljs-keyword">return</span> (a % b == <span class="hljs-number">0</span>) || (b % a == <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="回溯三">回溯三</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">specialPerm</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-built_in">this</span>.nums = nums;<br>    visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[nums.length];<br>    dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    Arrays.sort(nums);<br>    <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> lastChoosed)</span> &#123;<br>    <span class="hljs-keyword">if</span> (index == nums.length)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (visited[i])<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (lastChoosed != -<span class="hljs-number">1</span> &amp;&amp; nums[lastChoosed] == nums[i] &amp;&amp; !visited[i])<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (lastChoosed == -<span class="hljs-number">1</span> || check(nums[lastChoosed], nums[i])) &#123;<br>            visited[i] = <span class="hljs-literal">true</span>;<br>            res = (res + dfs(index + <span class="hljs-number">1</span>, i)) % MOD;<br>            visited[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>);<br><span class="hljs-type">boolean</span>[] visited;<br><span class="hljs-type">int</span>[] nums;<br>Map&lt;String, Integer&gt; dp;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>    <span class="hljs-keyword">return</span> (a % b == <span class="hljs-number">0</span>) || (b % a == <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二记忆化搜索-状态压缩">方法二：记忆化搜索 + 状态压缩</h3>
<h4 id="先看题解">先看<a href="https://leetcode.cn/problems/special-permutations/solutions/2313085/bao-li-hui-su-si-lu-ji-yi-hua-sou-suo-er-o03i/">题解</a></h4>
<h4 id="举例-nums-2-3-6-6"><strong>举例 nums = [2, 3, 6, 6]</strong></h4>
<ul>
<li>2，6，3，6</li>
<li>3，6，2，6</li>
<li>6，2，6，3</li>
<li>6，3，6，2</li>
<li>2，6，6，3</li>
<li>3，6，6，2</li>
</ul>
<p>其中2，6，6，3与6，2，6，3可以使用记忆化搜索</p>
<p>[2，6]，<strong>6</strong>，3与[6，2]，<strong>6</strong>，3, 下标为2<strong>的6</strong>前[2, 6]与[6,2]是同一个<strong>组合(不考虑顺序)</strong></p>
<p>只要下标为i(2)是相同的数(6)，并且前i个数是同一个组合，那么在i之后是重复计算</p>
<p>计算过[2，6]，<strong>6</strong>后，再遇到[6，2]，<strong>6</strong>，只要返回map里的值就行</p>
<h4 id="状态压缩">状态压缩</h4>
<p>u | (1 &lt;&lt; i)存储的是数组下标，初始u = 0。 <code>|</code> 是或运算, <code>1 &lt;&lt; i</code> 将1左移i位</p>
<ul>
<li><p>例如，将2(下标0)存入u中，</p>
<p>初始u = 0000,</p>
<p>0000 | (1 &lt;&lt; 0) = 0001</p></li>
<li><p>将6(下标1)存入u中</p>
<p>u = 0001</p>
<p>0001 | (1 &lt;&lt; 1) = 0011</p></li>
</ul>
<p><strong>将[2, 6]存入u中 u = 0011</strong> == <strong>将[6, 2]存入u中u = 0011</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">specialPerm</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-built_in">this</span>.nums = nums;<br>        visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[nums.length];<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Arrays.sort(nums);<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> lastChoosed, <span class="hljs-type">int</span> u)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == nums.length)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> lastChoosed + <span class="hljs-string">&quot;#&quot;</span> + u;<br>        <span class="hljs-keyword">if</span> (dp.containsKey(key))<br>            <span class="hljs-keyword">return</span> dp.get(key);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (visited[i])<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">// 去重，这道题可以不要这段if</span><br>            <span class="hljs-keyword">if</span> (lastChoosed != -<span class="hljs-number">1</span> &amp;&amp; nums[lastChoosed] == nums[i] &amp;&amp; !visited[i])<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (lastChoosed == -<span class="hljs-number">1</span> || check(nums[lastChoosed], nums[i])) &#123;<br>                visited[i] = <span class="hljs-literal">true</span>;<br>                res = (res + dfs(index + <span class="hljs-number">1</span>, i, (u | (<span class="hljs-number">1</span> &lt;&lt; i)))) % MOD;<br>                visited[i] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        dp.put(key, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>);<br>    <span class="hljs-type">boolean</span>[] visited;<br>    <span class="hljs-type">int</span>[] nums;<br>    Map&lt;String, Integer&gt; dp;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">return</span> (a % b == <span class="hljs-number">0</span>) || (b % a == <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="给墙壁刷油漆">给墙壁刷油漆</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230705153825310.png" /></p>
<h3 id="方法一记忆化搜索">方法一：记忆化搜索</h3>
<p>dfs(int index, int leftTime) index是遍历到的cost的下标，leftTime是可以白嫖的次数(1单位时间白嫖1次)</p>
<p><strong>付费</strong>：dfs(index + 1, leftTime + time[index]) + cost[index];</p>
<p><strong>白嫖</strong>：dfs(index + 1, leftTime - 1);</p>
<p><strong>初始化</strong>：dp = new int[n][2 * n]; leftTime可能是负数而且最小-n</p>
<p><strong>剪枝</strong>：如果白嫖次数大于等于剩余需要刷漆的次数，那么全部白嫖的花费最小</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (leftTime &gt;= n - index)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure>
<h4 id="代码">代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">paintWalls</span><span class="hljs-params">(<span class="hljs-type">int</span>[] cost, <span class="hljs-type">int</span>[] time)</span> &#123;<br>        n = cost.length;<br>        <span class="hljs-built_in">this</span>.cost = cost;<br>        <span class="hljs-built_in">this</span>.time = time;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][<span class="hljs-number">2</span> * n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dp)<br>            Arrays.fill(arr, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> leftTime)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == n)<br>            <span class="hljs-keyword">return</span> leftTime &gt;= <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : Integer.MAX_VALUE / <span class="hljs-number">2</span>; <br>        <span class="hljs-keyword">if</span> (leftTime &gt;= n - index)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (dp[index][leftTime + n] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[index][leftTime + n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pay</span> <span class="hljs-operator">=</span> dfs(index + <span class="hljs-number">1</span>, leftTime + time[index]) + cost[index];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">free</span> <span class="hljs-operator">=</span> dfs(index + <span class="hljs-number">1</span>, leftTime - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dp[index][leftTime + n] = Math.min(pay, free);<br>    &#125;<br><br>    <span class="hljs-type">int</span>[] cost, time;<br>    <span class="hljs-type">int</span>[][] dp;<br>    <span class="hljs-type">int</span> n;<br>&#125;   <br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Contest</category>
        <category>LCP</category>
      </categories>
      <tags>
        <tag>力扣杯</tag>
      </tags>
  </entry>
  <entry>
    <title>lcpBi107</title>
    <url>/2023/07/04/lcpBi107/</url>
    <content><![CDATA[<h2 id="最大字符串配对数目">最大字符串配对数目</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230704092951773.png" /></p>
<h3 id="方法一记忆化搜索">方法一：记忆化搜索</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestString</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> z)</span> &#123;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">return</span> dfs(x, y, z, <span class="hljs-string">&#x27; &#x27;</span>); <span class="hljs-comment">// AA BB AB</span><br>    &#125;<br><br>    Map&lt;String, Integer&gt; dp;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> z, <span class="hljs-type">char</span> lastChar)</span> &#123;<br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span> &amp;&amp; y == <span class="hljs-number">0</span> &amp;&amp; z == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> x + <span class="hljs-string">&quot;,&quot;</span> + y + <span class="hljs-string">&quot;,&quot;</span> + z + <span class="hljs-string">&quot;,&quot;</span> + lastChar;<br>        <span class="hljs-keyword">if</span> (dp.containsKey(key))<br>            <span class="hljs-keyword">return</span> dp.get(key);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">0</span> &amp;&amp; lastChar != <span class="hljs-string">&#x27;A&#x27;</span>)<br>            max = Math.max(max, dfs(x - <span class="hljs-number">1</span>, y, z, <span class="hljs-string">&#x27;A&#x27;</span>) + <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">if</span> (y &gt; <span class="hljs-number">0</span> &amp;&amp; lastChar != <span class="hljs-string">&#x27;B&#x27;</span>)<br>            max = Math.max(max, dfs(x, y - <span class="hljs-number">1</span>, z, <span class="hljs-string">&#x27;B&#x27;</span>) + <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">if</span> (z &gt; <span class="hljs-number">0</span> &amp;&amp; lastChar != <span class="hljs-string">&#x27;A&#x27;</span>)<br>            max = Math.max(max, dfs(x, y, z - <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;B&#x27;</span>) + <span class="hljs-number">2</span>);<br>        dp.put(key, max);<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二记忆化搜索">方法二：记忆化搜索</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">```<br><br><br><br>## 字符串连接删减字母<br><br>![ ](https:<span class="hljs-comment">//leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230704113929490.png)</span><br><br>### 方法一：记忆化搜索<br><br>[题解](https:<span class="hljs-comment">//leetcode.cn/problems/decremental-string-concatenation/solutions/1/hui-su-ji-yi-hua-sou-suo-java-by-tailtal-dmix/)</span><br><br><span class="hljs-number">1.</span> 如果当前要合并的单词为words[index]，并且已合并单词str的首尾字符分别为first，last，记words[index]的首尾字符分别为first2, last2。<br><span class="hljs-number">2.</span> 现在有两种拼接方式：<br>   <span class="hljs-number">1.</span> str + words[index] ：<br>      - 如果last == first2，那么**拼接成新字符串长度的增量**为len1 = words[index].length() - <span class="hljs-number">1</span><br>      - 否则，**拼接成新字符串长度的增量**为len1 = words[index].length()<br>   <span class="hljs-number">2.</span> words[index] + str<br>      - 如果last2 == first，那么**拼接成新字符串长度的增量**为len2 = words[index].length() - <span class="hljs-number">1</span><br>      - 否则，**拼接成新字符串长度的增量**为len2 = words[index].length()<br>   <span class="hljs-number">3.</span> 取min(len1, len2)，存入map中，key为index + <span class="hljs-string">&quot;,&quot;</span>  + first + <span class="hljs-string">&quot;,&quot;</span> + last<br>   <span class="hljs-number">4.</span> 在下次遍历到相同index，first，last的时候，**虽然已合并单词str的长度可能不同，但是字符串长度增量是相同的！**<br><br>```java<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimizeConcatenatedLength</span><span class="hljs-params">(String[] words)</span> &#123;<br>        <span class="hljs-built_in">this</span>.words = words;<br>        n = words.length;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> dfs(<span class="hljs-number">1</span>, words[<span class="hljs-number">0</span>].charAt(<span class="hljs-number">0</span>), words[<span class="hljs-number">0</span>].charAt(words[<span class="hljs-number">0</span>].length() - <span class="hljs-number">1</span>)) + words[<span class="hljs-number">0</span>].length();<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    String[] words;<br>    <span class="hljs-type">int</span> n;<br>    Map&lt;String, Integer&gt; dp;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">char</span> first, <span class="hljs-type">char</span> last)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == n)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> index + <span class="hljs-string">&quot;,&quot;</span>  + first + <span class="hljs-string">&quot;,&quot;</span> + last;<br>        <span class="hljs-keyword">if</span> (dp.containsKey(key))<br>            <span class="hljs-keyword">return</span> dp.get(key);<br>        <span class="hljs-type">char</span> <span class="hljs-variable">first2</span> <span class="hljs-operator">=</span> words[index].charAt(<span class="hljs-number">0</span>), last2 = words[index].charAt(words[index].length() - <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-comment">// first插入到words[index]后面</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res1</span> <span class="hljs-operator">=</span> dfs(index + <span class="hljs-number">1</span>, first2, last);<br>        min = Math.min(min, res1 + words[index].length() - (first == last2 ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>));<br>        <span class="hljs-comment">// last插入到words[index]前面</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res2</span> <span class="hljs-operator">=</span> dfs(index + <span class="hljs-number">1</span>, first, last2);<br>        min = Math.min(min, res2 + words[index].length() - (last == first2 ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>));<br>        dp.put(key, min);<br>        <span class="hljs-keyword">return</span> min;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="统计没有收到请求的服务器数目">统计没有收到请求的服务器数目</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230704145002023.png" /></p>
<h3 id="方法一模拟超时">方法一：模拟(超时)</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] countServers(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] logs, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span>[] queries) &#123;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[queries.length];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxTime</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> q : queries)<br>            maxTime = Math.max(maxTime, q);<br>        <span class="hljs-type">int</span>[][] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][(<span class="hljs-type">int</span>) <span class="hljs-number">1e6</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] log : logs) &#123;<br>            arr[log[<span class="hljs-number">0</span>]][log[<span class="hljs-number">1</span>]] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; queries.length; ++k) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> queries[k], left = right - x;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>                <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> left; j &lt;= right; ++j) &#123;<br>                    <span class="hljs-keyword">if</span> (arr[i][j] == <span class="hljs-number">1</span>) &#123;<br>                        flag = <span class="hljs-literal">true</span>;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (!flag)<br>                    ++res[k];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Contest</category>
        <category>LCP</category>
      </categories>
      <tags>
        <tag>力扣杯</tag>
      </tags>
  </entry>
  <entry>
    <title>lcp351</title>
    <url>/2023/07/03/lcp351/</url>
    <content><![CDATA[<h2 id="美丽下标对的数目">美丽下标对的数目</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230703140509859.png" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countBeautifulPairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; nums.length; ++j)<br>                <span class="hljs-keyword">if</span> (check(i, j, nums))<br>                    ++res;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num1</span> <span class="hljs-operator">=</span> nums[i], num2 = nums[j];<br>        <span class="hljs-type">char</span> <span class="hljs-variable">ch1</span> <span class="hljs-operator">=</span> String.valueOf(num1).charAt(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> String.valueOf(num2);<br>        <span class="hljs-type">char</span> <span class="hljs-variable">ch2</span> <span class="hljs-operator">=</span> str.charAt(str.length() - <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> Integer.parseInt(String.valueOf(ch1)), r = Integer.parseInt(String.valueOf(ch2));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">small</span> <span class="hljs-operator">=</span> l &lt; r ? l : r;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">great</span> <span class="hljs-operator">=</span> l &gt; r ? l : r;<br>        <span class="hljs-keyword">if</span> (small == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; k &lt;= small; ++k) &#123;<br>            <span class="hljs-keyword">if</span> (small % k == <span class="hljs-number">0</span> &amp;&amp; great % k == <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="得到整数零需要执行的最少操作数">得到整数零需要执行的最少操作数</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230703143005624.png" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">makeTheIntegerZero</span><span class="hljs-params">(<span class="hljs-type">int</span> num1, <span class="hljs-type">int</span> num2)</span> &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 1. 从小到大枚举答案</span><br><span class="hljs-comment">         * 2. 假设操作次数为 k</span><br><span class="hljs-comment">         * 则问题变为：x = num1 - k * num2 能不能是k个2^i之和</span><br><span class="hljs-comment">         * 能的话就立即返回结果</span><br><span class="hljs-comment">         * 3. 如果x.bitCount &lt;= k，那么一定可以是k个2^i之和</span><br><span class="hljs-comment">         * 对于循环退出条件，那么如果num2 &lt; 0, 那么当 x &lt; k，再增大k只会让x越来越小，此时肯定要结束循环</span><br><span class="hljs-comment">         * 若num2 &lt; 0，因为num2只能是-1 -2 -3...这样，也就是说若k + 1，则x 会增加 -num2，也就是说至少也会+1</span><br><span class="hljs-comment">         * 则k永远无法追上x，此时也要结束循环</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; k &lt;= num1 - k * num2; k++) &#123;<br>            <span class="hljs-keyword">if</span> (k &gt;= Long.bitCount(num1 - k * num2)) <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)k;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="将数组划分成若干好子数组的方式">将数组划分成若干好子数组的方式</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230703144201785.png" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numberOfGoodSubarraySplits</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// &#123;0,1,|0,0,1|,0,0,1,0&#125;</span><br>        <span class="hljs-comment">// &#123;0,1,|0,0,1,0|,0,1,0&#125;</span><br>        <span class="hljs-comment">// &#123;0,1,|0,0,1,0,0|,1,0&#125;</span><br><br>        <span class="hljs-comment">// &#123;0,1,0,|0,1|,0,0,1,0&#125;</span><br>        <span class="hljs-comment">// &#123;0,1,0,|0,1,0|,0,1,0&#125;</span><br>        <span class="hljs-comment">// &#123;0,1,0,|0,1,0,0|,1,0&#125;</span><br><br>        <span class="hljs-comment">// &#123;0,1,0,0,|1,|0,0,1,0&#125;</span><br>        <span class="hljs-comment">// &#123;0,1,0,0,|1,0,|0,1,0&#125;</span><br>        <span class="hljs-comment">// &#123;0,1,0,0,|1,0,0,|1,0&#125;</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">long</span>) <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i)<br>            <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">1</span>)<br>                list.add(i);<br>        <span class="hljs-type">int</span>[] interval = list.stream().mapToInt(i -&gt; i).toArray();<br>        <span class="hljs-keyword">if</span> (interval.length == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; interval.length; ++i)<br>            res = (res * (interval[i] - interval[i - <span class="hljs-number">1</span>])) % MOD;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="机器人碰撞">机器人碰撞</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230703211455225.png" /></p>
<h3 id="方法一栈模拟">方法一：栈模拟</h3>
<h4 id="类似于735.-行星碰撞">类似于<a href="https://leetcode.cn/problems/asteroid-collision/">735. 行星碰撞</a></h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">survivedRobotsHealths</span><span class="hljs-params">(<span class="hljs-type">int</span>[] positions, <span class="hljs-type">int</span>[] healths, String directions)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> positions.length;<br>        Map&lt;Integer, Integer&gt; posToIdx = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(), posToHealth = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Map&lt;Integer, Character&gt; posToDir = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            posToIdx.put(positions[i], i);<br>            posToHealth.put(positions[i], healths[i]);<br>            posToDir.put(positions[i], directions.charAt(i));<br>        &#125;<br>        Arrays.sort(positions);<br>        Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">alive</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">dir</span> <span class="hljs-operator">=</span> posToDir.get(positions[i]);<br>            <span class="hljs-keyword">while</span> (alive &amp;&amp; !stack.isEmpty() &amp;&amp; dir == <span class="hljs-string">&#x27;L&#x27;</span> &amp;&amp; posToDir.get(stack.peek()) == <span class="hljs-string">&#x27;R&#x27;</span> ) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">topPos</span> <span class="hljs-operator">=</span> stack.peek();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">topHealth</span> <span class="hljs-operator">=</span> posToHealth.get(topPos);<br>                <span class="hljs-keyword">if</span> (posToHealth.get(positions[i]) &gt; topHealth) &#123;<br>                    stack.pop();<br>                    posToHealth.put(positions[i], posToHealth.get(positions[i]) - <span class="hljs-number">1</span>);<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (posToHealth.get(positions[i]) &lt; topHealth) &#123;<br>                    alive = <span class="hljs-literal">false</span>;<br>                    posToHealth.put(topPos, posToHealth.get(topPos) - <span class="hljs-number">1</span>);<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//==</span><br>                    alive = <span class="hljs-literal">false</span>;<br>                    stack.pop();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (alive)<br>                stack.push(positions[i]);<br>        &#125;<br>        <span class="hljs-type">int</span>[] newHealths = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">pos</span> <span class="hljs-operator">=</span> stack.pop();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> posToIdx.get(pos), health = posToHealth.get(pos);<br>            newHealths[index] = health;<br>        &#125;<br>        List&lt;Integer&gt; survivor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : newHealths)<br>            <span class="hljs-keyword">if</span> (x != <span class="hljs-number">0</span>)<br>                survivor.add(x);<br>        <span class="hljs-keyword">return</span> survivor;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>​</p>
]]></content>
      <categories>
        <category>Contest</category>
        <category>LCP</category>
      </categories>
      <tags>
        <tag>力扣杯</tag>
      </tags>
  </entry>
  <entry>
    <title>lcp352</title>
    <url>/2023/07/02/lcp352/</url>
    <content><![CDATA[<div class="note note-success">
            <h2 id="最长奇偶子数组"><a href="https://leetcode.cn/problems/longest-even-odd-subarray-with-threshold/">6909. 最长奇偶子数组</a></h2>
          </div>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230702175121393.png" /></p>
<h3 id="方法一暴力枚举">方法一：暴力枚举</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestAlternatingSubarray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> threshhold)</span> &#123;<br>        <span class="hljs-comment">// dp</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] % <span class="hljs-number">2</span> != <span class="hljs-number">0</span> || nums[i] &gt; threshhold)<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, pre = <span class="hljs-number">0</span>;<br>            res = Math.max(res, len);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (pre == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (nums[j] % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> &amp;&amp; nums[j] &lt;= threshhold) &#123;<br>                        ++len;<br>                        pre = <span class="hljs-number">1</span>;<br>                        res = Math.max(res, len);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// pre == 1</span><br>                    <span class="hljs-keyword">if</span> (nums[j] % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> &amp;&amp; nums[j] &lt;= threshhold) &#123;<br>                        ++len;<br>                        pre = <span class="hljs-number">0</span>;<br>                        res = Math.max(res, len);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二一轮遍历">方法二：一轮遍历</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestAlternatingSubarray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> threshold)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> &amp;&amp; nums[i] &lt;= threshold) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> nums[i] % <span class="hljs-number">2</span>, j = i + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">for</span> (; j &lt; nums.length; ++j) &#123;<br>                    <span class="hljs-keyword">if</span> (nums[j] % <span class="hljs-number">2</span> != pre &amp;&amp; nums[j] &lt;= threshold)<br>                        pre = nums[j] % <span class="hljs-number">2</span>;<br>                    <span class="hljs-keyword">else</span><br>                        <span class="hljs-keyword">break</span>;<br>                &#125;<br>                res = Math.max(res, j - i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="和等于目标值的质数对"><a href="https://leetcode.cn/problems/prime-pairs-with-target-sum/">6916. 和等于目标值的质数对</a></h2>
<p><img src="C:\Users\ning\AppData\Roaming\Typora\typora-user-images\image-20230702182034877.png" /></p>
<h3 id="方法一埃氏筛">方法一：埃氏筛</h3>
<p><strong>静态代码块:</strong> 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—&gt;非静态代码块—&gt;构造方法)。 该类不管创建多少对象，静态代码块只执行一次.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) <span class="hljs-number">1e6</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span>[] isPrime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[MAX + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] prime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[MAX];<br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= MAX; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (!isPrime[i]) &#123;<br>                prime[index++] = i;<br>                <span class="hljs-keyword">if</span> (i &lt; MAX / i)<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i * i; j &lt; MAX; j += i)<br>                        isPrime[j] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">findPrimePairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : prime) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> n - x;<br>            <span class="hljs-keyword">if</span> (y &lt; x)<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">if</span> (!isPrime[y])<br>                res.add(Arrays.asList(x, y));<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="计数质数"><a href="https://leetcode.cn/problems/count-primes/">204. 计数质数</a></h3>
<h4 id="埃氏筛">埃氏筛</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countPrimes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">boolean</span>[] isPrime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n];<br>        Arrays.fill(isPrime, <span class="hljs-literal">true</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (isPrime[i]) &#123;<br>                ++res;<br>                <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span>) i * i &lt; n)<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i * i; j &lt; n; j += i)<br>                        isPrime[j] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="不间断子数组"><a href="https://leetcode.cn/problems/continuous-subarrays/">6911. 不间断子数组</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230708211310939.png" /></p>
<h3 id="滑动窗口">滑动窗口</h3>
<p><strong>map.lastKey() - map.firstKey()得到最大值与最小值的差</strong></p>
<p><strong>res += (long) i - j + 1十分巧妙，举例nums=[5, 4, 2, 4]</strong></p>
<ol type="1">
<li>i = 0， [5]， res += 1 = 1</li>
<li>i = 1，[5, 4], [4], res +=2 = 3</li>
<li>i = 2, [4, 2], [2] ,res += 2 = 5</li>
<li>i = 3, [4,2, 4], [4], [2,4], res += 3 = 8</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">continuousSubarrays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        TreeMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            map.put(nums[i], map.getOrDefault(nums[i], <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">while</span> (j &lt;= i &amp;&amp; map.lastKey() - map.firstKey() &gt; <span class="hljs-number">2</span>) &#123;<br>                map.put(nums[j], map.getOrDefault(nums[j], <span class="hljs-number">0</span>) - <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span> (map.get(nums[j]) == <span class="hljs-number">0</span>)<br>                    map.remove(nums[j]);<br>                ++j;<br>            &#125;<br>            res += (<span class="hljs-type">long</span>) i - j + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="绝对差不超过限制的最长连续子数组"><a href="https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/">1438. 绝对差不超过限制的最长连续子数组</a></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestSubarray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> limit)</span> &#123;<br>        TreeMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length, res = <span class="hljs-number">0</span>;	<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            map.put(nums[i], map.getOrDefault(nums[i], <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">while</span> (j &lt;= i &amp;&amp; map.lastKey() - map.firstKey() &gt; limit) &#123;<br>                map.put(nums[j], map.get(nums[j]) - <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span> (map.get(nums[j]) == <span class="hljs-number">0</span>)<br>                    map.remove(nums[j]);<br>                ++j;<br>            &#125;<br>            res = Math.max(res, i - j + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="所有子数组中不平衡数字之和"><a href="https://leetcode.cn/problems/sum-of-imbalance-numbers-of-all-subarrays/">6894. 所有子数组中不平衡数字之和</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230703093306982.png" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumImbalanceNumbers</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, n = nums.length;<br>        <span class="hljs-type">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n + <span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            Arrays.fill(visited, <span class="hljs-literal">false</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            visited[nums[i]] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (!visited[nums[j]]) &#123;<br>                    ++count;<br>                    <span class="hljs-keyword">if</span> (visited[nums[j] - <span class="hljs-number">1</span>])<br>                        --count;<br>                    <span class="hljs-keyword">if</span> (visited[nums[j] + <span class="hljs-number">1</span>])<br>                        --count;<br>                    visited[nums[j]] = <span class="hljs-literal">true</span>;<br>                &#125;<br>                res += count;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Contest</category>
        <category>LCP</category>
      </categories>
      <tags>
        <tag>力扣杯</tag>
      </tags>
  </entry>
  <entry>
    <title>lcp346</title>
    <url>/2023/07/01/lcp346/</url>
    <content><![CDATA[<h2 id="删除子串后的字符串最小长度"><a href="https://leetcode.cn/problems/minimum-string-length-after-removing-substrings/">2696. 删除子串后的字符串最小长度</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230703093908389.png" /></p>
<h3 id="方法一暴力枚举">方法一：暴力枚举</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minLength</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span>[] last = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[s.length()];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">lastIndex</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; s.length(); ++i) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch1</span> <span class="hljs-operator">=</span> s.charAt(i - <span class="hljs-number">1</span>), ch2 = s.charAt(i);<br>            <span class="hljs-keyword">if</span> (ch1 == <span class="hljs-string">&#x27;A&#x27;</span> || ch1 == <span class="hljs-string">&#x27;C&#x27;</span>) &#123;<br>                <span class="hljs-keyword">if</span> (ch2 != <span class="hljs-string">&#x27;B&#x27;</span> &amp;&amp; ch2 != <span class="hljs-string">&#x27;D&#x27;</span>) &#123;<br>                    last[++lastIndex] = i - <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((ch1 == <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; ch2 == <span class="hljs-string">&#x27;B&#x27;</span>) || (ch1 == <span class="hljs-string">&#x27;C&#x27;</span> &amp;&amp; ch2 == <span class="hljs-string">&#x27;D&#x27;</span>)) &#123;<br>                    res -= <span class="hljs-number">2</span>;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">step</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; lastIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; r &lt; s.length(); ++r) &#123;<br>                        <span class="hljs-type">char</span> <span class="hljs-variable">ch3</span> <span class="hljs-operator">=</span> s.charAt(last[lastIndex]), ch4 = s.charAt(r);<br>                        <span class="hljs-keyword">if</span> ((ch3 == <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; ch4 == <span class="hljs-string">&#x27;B&#x27;</span>) || (ch3 == <span class="hljs-string">&#x27;C&#x27;</span> &amp;&amp; ch4 == <span class="hljs-string">&#x27;D&#x27;</span>)) &#123;<br>                            res -= <span class="hljs-number">2</span>;<br>                            ++step;<br>                            --lastIndex;<br>                        &#125;<br>                        <span class="hljs-keyword">else</span> &#123;<br>                            i += step;<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// ch1 != AC</span><br>                lastIndex = -<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二栈">方法二：栈</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minLength</span><span class="hljs-params">(String s)</span> &#123;<br>        Stack&lt;Character&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); ++i) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-keyword">if</span> (!stack.isEmpty() &amp;&amp; ((stack.peek() == <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; ch == <span class="hljs-string">&#x27;B&#x27;</span>) || (stack.peek() == <span class="hljs-string">&#x27;C&#x27;</span> &amp;&amp; ch == <span class="hljs-string">&#x27;D&#x27;</span>)))<br>                stack.pop();<br>            <span class="hljs-keyword">else</span><br>                stack.push(ch);<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack.size();<br>    &#125;<br>&#125;	<br></code></pre></td></tr></table></figure>
<h2 id="字典序最小回文串"><a href="https://leetcode.cn/problems/lexicographically-smallest-palindrome/">2697. 字典序最小回文串</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230703094758199.png" /></p>
<h3 id="方法一dp超时">方法一：DP(超时)</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">makeSmallestPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        String[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">chI</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= i; ++j) &#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">chJ</span> <span class="hljs-operator">=</span> s.charAt(j);<br>                <span class="hljs-type">char</span> <span class="hljs-variable">small</span> <span class="hljs-operator">=</span> chJ - chI &lt; <span class="hljs-number">0</span> ? chJ : chI;<br>                <span class="hljs-keyword">if</span> (i == j)<br>                    dp[j][i] = String.valueOf(chI);<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i - j == <span class="hljs-number">1</span>)<br>                    dp[j][i] = String.valueOf(small) + small;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i - j == <span class="hljs-number">2</span>)<br>                    dp[j][i] = String.valueOf(small) + s.charAt(j + <span class="hljs-number">1</span>) + small;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    dp[j][i] = String.valueOf(small) + dp[j + <span class="hljs-number">1</span>][i - <span class="hljs-number">1</span>] + small;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二贪心">方法二：贪心</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">makeSmallestPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">char</span>[] arr = s.toCharArray();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = s.length() - <span class="hljs-number">1</span>; i &lt; j; ++i, --j) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">small</span> <span class="hljs-operator">=</span> arr[i] &lt; arr[j] ? arr[i] : arr[j];<br>            arr[i] = small;<br>            arr[j] = small;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(arr);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="求一个整数的惩罚数">求一个整数的惩罚数</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230703101742163.png" /></p>
<h3 id="方法一回溯">方法一：回溯</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">punishmentNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (check(i))<br>                res += i * i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        path.clear();<br>        <span class="hljs-keyword">return</span> dfs(x, String.valueOf(x * x), <span class="hljs-number">0</span>);<br>    &#125;<br><br>    Deque&lt;String&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, String str, <span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == str.length()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (String s : path)<br>                sum += Integer.parseInt(s);<br>            <span class="hljs-keyword">return</span> sum == x;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> index; i &lt; str.length(); ++i) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">sub</span> <span class="hljs-operator">=</span> str.substring(index, i + <span class="hljs-number">1</span>);<br>            path.offerLast(sub);<br>            <span class="hljs-keyword">if</span> (dfs(x, str, i + <span class="hljs-number">1</span>))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            path.pollLast();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;	<br></code></pre></td></tr></table></figure>
<h2 id="修改图中的边权">修改图中的边权</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230703110231515.png" /></p>
<h3 id="方法一">方法一：</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Contest</category>
        <category>LCP</category>
      </categories>
      <tags>
        <tag>力扣杯</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2023/06/28/microsoft/</url>
    <content><![CDATA[<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230628153348108.png" /></p>
<div class="note note-danger">
            <h2 id="二叉树的最近公共祖先"><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h2><p>使用DFS解决</p>
          </div>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230628153518847.png" /></p>
<div class="note note-danger">
            <h2 id="二叉树中的最大路径和"><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></h2>
          </div>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230628161958142.png" /></p>
<div class="note note-danger">
            <h2 id="数组中的第k个最大元素"><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></h2>
          </div>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230628162929143.png" /></p>
<h2 id="二叉树的序列化与反序列化"><a href="https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/">297. 二叉树的序列化与反序列化</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230628171231282.png" /></p>
<h3 id="方法一dfs">方法一：DFS</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Codec</span> &#123;<br><br>    <span class="hljs-comment">// Encodes a tree to a single string.</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">serialize</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;#&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> serialize(root.left);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> serialize(root.right);<br>        <span class="hljs-keyword">return</span> root.val + <span class="hljs-string">&quot;,&quot;</span> + left + <span class="hljs-string">&quot;,&quot;</span> + right;<br>    &#125;<br><br>    <span class="hljs-comment">// Decodes your encoded data to tree.</span><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">deserialize</span><span class="hljs-params">(String data)</span> &#123;<br>        String[] nodes = data.split(<span class="hljs-string">&quot;,&quot;</span>);<br>        <span class="hljs-keyword">return</span> dfs(nodes);<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">dfs</span><span class="hljs-params">(String[] nodes)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> nodes[i++];<br>        <span class="hljs-keyword">if</span> (str.equals(<span class="hljs-string">&quot;#&quot;</span>))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(Integer.valueOf(str));<br>        root.left = dfs(nodes);<br>        root.right = dfs(nodes);<br>        <span class="hljs-keyword">return</span> root;       <br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Your Codec object will be instantiated and called as such:</span><br><span class="hljs-comment">// Codec ser = new Codec();</span><br><span class="hljs-comment">// Codec deser = new Codec();</span><br><span class="hljs-comment">// TreeNode ans = deser.deserialize(ser.serialize(root));</span><br></code></pre></td></tr></table></figure>
<p>为什么左边的代码不行，因为如何nodes[i]是节点，i没有自增！</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230628175204951.png" /></p>
<h2 id="反转链表"><a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230628175914833.png" /></p>
<h2 id="无重复字符的最长子串"><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230720140632582.png" /></p>
<h3 id="方法一滑动窗口-set">方法一：滑动窗口 set</h3>
<p>用HashSet判断重复，并将左区间滑动到没有重复元素为止</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Set&lt;Character&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, left = <span class="hljs-number">0</span>; i &lt; s.length(); ++i) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-keyword">if</span> (set.contains(ch)) &#123;<br>                <span class="hljs-keyword">while</span> (left &lt; i) &#123;<br>                    set.remove(s.charAt(left++));<br>                    <span class="hljs-keyword">if</span> (!set.contains(ch))<br>                        <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            set.add(ch);<br>            length = Math.max(length, i - left + <span class="hljs-number">1</span>);<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> length;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二滑动窗口-map">方法二：滑动窗口 map</h3>
<p>用HashMap存储遍历的字符以及其下标，当出现重复字符，将left赋值为<code>Math.max(left, map.get(ch) + 1)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, left = <span class="hljs-number">0</span>, n = s.length();<br>        Map&lt;Character, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-keyword">if</span> (map.containsKey(ch)) <br>                left = Math.max(left, map.get(ch) + <span class="hljs-number">1</span>);<br>            map.put(ch, i);<br>            max = Math.max(max, i - left + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="lru-缓存"><a href="https://leetcode.cn/problems/lru-cache/">146. LRU 缓存</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230720144841979.png" /></p>
<h3 id="方法一hashmap-listnode">方法一：HashMap + ListNode</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;<br>        <span class="hljs-type">int</span> key;<br>        <span class="hljs-type">int</span> val;<br>        ListNode next, pre;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">ListNode</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> val)</span> &#123;<br>            <span class="hljs-built_in">this</span>.key = key;<br>            <span class="hljs-built_in">this</span>.val = val;<br>        &#125;<br>    &#125;<br>    <br>    ListNode head, tail;<br>    Map&lt;Integer, ListNode&gt; map;<br>    <span class="hljs-type">int</span> capacity;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LRUCache</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>);<br>        tail = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>);<br>        head.next = tail;<br>        tail.pre = head;<br>        map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!map.containsKey(key))<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        moveToTail(key);<br>        <span class="hljs-keyword">return</span> map.get(key).val;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-keyword">if</span> (map.containsKey(key)) &#123;<br>            moveToTail(key);<br>            map.get(key).val = value;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (capacity == map.size())  <span class="hljs-comment">// delete last one</span><br>                delete(-<span class="hljs-number">1</span>, <span class="hljs-literal">true</span>);<br>            <span class="hljs-comment">// insert new node in the previous of tail</span><br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(key, value);<br>            map.put(key, node);<br>            insertIntail(key);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveToTail</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>        delete(key, <span class="hljs-literal">false</span>);<br>        insertIntail(key);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">boolean</span> isLast)</span> &#123;<br>        <span class="hljs-keyword">if</span> (isLast) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">toBeDelete</span> <span class="hljs-operator">=</span> head.next;<br>            map.remove(toBeDelete.key);<br>            head.next = toBeDelete.next;<br>            toBeDelete.next.pre = head;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">toBeDelete</span> <span class="hljs-operator">=</span> map.get(key);<br>            <span class="hljs-comment">// map.remove(toBeDelete.key);</span><br>            toBeDelete.pre.next = toBeDelete.next;<br>            toBeDelete.next.pre = toBeDelete.pre;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertIntail</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> map.get(key);<br>        node.next = tail;<br>        tail.pre.next = node;<br>        node.pre = tail.pre;<br>        tail.pre = node;<br>    &#125;<br>    <br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your LRUCache object will be instantiated and called as such:</span><br><span class="hljs-comment"> * LRUCache obj = new LRUCache(capacity);</span><br><span class="hljs-comment"> * int param_1 = obj.get(key);</span><br><span class="hljs-comment"> * obj.put(key,value);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>
<div class="note note-danger">
            <h2 id="删除二叉搜索树中的节点"><a href="https://leetcode.cn/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点</a></h2>
          </div>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230720155036346.png" /></p>
<h3 id="方法一dfs-1">方法一：DFS</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">deleteNode</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (root.val &gt; key)<br>            root.left = deleteNode(root.left, key);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.val &lt; key)<br>            root.right = deleteNode(root.right, key);<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">return</span> root.right;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.right == <span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">return</span> root.left;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root.right;<br>                <span class="hljs-keyword">while</span> (cur.left != <span class="hljs-literal">null</span>) <br>                    cur = cur.left;<br>                cur.left = root.left;<br>                <span class="hljs-keyword">return</span> root.right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<div class="note note-danger">
            <h2 id="最大子数组和"><a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></h2>
          </div>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230720195209645.png" /></p>
<h3 id="方法一dp">方法一：DP</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length, res = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            dp[i] = nums[i] + (dp[i - <span class="hljs-number">1</span>] &gt;= <span class="hljs-number">0</span> ? dp[i - <span class="hljs-number">1</span>] : <span class="hljs-number">0</span>);<br>            res = Math.max(res, dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="搜索旋转排序数组"><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230720210151576.png" /></p>
<h3 id="方法一二分查找">方法一：二分查找</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-comment">// 首先找到逆序的第一个数的下标x，x~n-1是较小的子数组</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length, targetIdx = -<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &lt;= nums[n - <span class="hljs-number">1</span>])<br>                right = mid - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <br>                left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// left &gt; right，此时找到了逆序的第一个数的下标left</span><br>        <span class="hljs-comment">// 接着根据target的值来二分，如果target &gt; nums[n - 1]，则在左边较大的子数组中二分查找，否在在右边较小的子数组中二分查找</span><br>        <span class="hljs-keyword">if</span> (target &gt; nums[n - <span class="hljs-number">1</span>])<br>            targetIdx = bisearch(nums, <span class="hljs-number">0</span>, left - <span class="hljs-number">1</span>, target);<br>        <span class="hljs-keyword">else</span> <br>            targetIdx = bisearch(nums, left, n - <span class="hljs-number">1</span>, target);<br>        <span class="hljs-keyword">return</span> targetIdx;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">bisearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &lt; target)<br>                left = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] == target)<br>                <span class="hljs-keyword">return</span> mid;<br>            <span class="hljs-keyword">else</span> <br>                right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230720213447271.png" /></p>
<div class="note note-danger">
            <h2 id="寻找两个正序数组的中位数"><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">4. 寻找两个正序数组的中位数</a></h2>
          </div>
<p><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/solutions/258842/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/">题解</a></p>
<h3 id="方法一划分数组">方法一：划分数组</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">findMedianSortedArrays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums1.length &gt; nums2.length)<br>            <span class="hljs-keyword">return</span> findMedianSortedArrays(nums2, nums1);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> nums1.length, n = nums2.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">median1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, median2 = <span class="hljs-number">0</span>; <span class="hljs-comment">// 如果有m + n是偶数，median2是第二个中位数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = m; <span class="hljs-comment">// i == m时，表示nums1全被划分为前一部分</span><br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-comment">// 前一部分包含 nums1[0 .. i-1] 和 nums2[0 .. j-1]</span><br>            <span class="hljs-comment">// 后一部分包含 nums1[i .. m-1] 和 nums2[j .. n-1]</span><br>            <span class="hljs-comment">// 当m + n是偶数，规定前一部分和后一部分的长度相同</span><br>            <span class="hljs-comment">// 当m + n是奇数，规定前一部分的长度 == 后一部分的长度 + 1</span><br>            <span class="hljs-comment">// j = (m + n + 1 ) / 2 - i 可以很好地满足，不管m+n是奇数还是偶数</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> (left + right) / <span class="hljs-number">2</span>, j = (m + n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> - i;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">nums_i</span> <span class="hljs-operator">=</span> i == m ? Integer.MAX_VALUE : nums1[i];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">nums_im1</span> <span class="hljs-operator">=</span> i == <span class="hljs-number">0</span> ? Integer.MIN_VALUE : nums1[i - <span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">nums_j</span> <span class="hljs-operator">=</span> j == n ? Integer.MAX_VALUE : nums2[j];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">nums_jm1</span> <span class="hljs-operator">=</span> j == <span class="hljs-number">0</span> ? Integer.MIN_VALUE : nums2[j - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (nums_im1 &lt;= nums_j) &#123;<br>                median1 = Math.max(nums_im1, nums_jm1);<br>                median2 = Math.min(nums_i, nums_j);<br>                left = i + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                right = i - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (m + n) % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? (median1 + median2) / <span class="hljs-number">2.0</span> : median1;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="括号生成"><a href="https://leetcode.cn/problems/generate-parentheses/">22. 括号生成</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230721151850064.png" /></p>
<h3 id="方法一回溯">方法一：回溯</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-built_in">this</span>.n = n;<br>        dfs(<span class="hljs-number">0</span>, n, n);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == <span class="hljs-number">2</span> * n) &#123;<br>            res.add(sb.toString());<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (left &gt; <span class="hljs-number">0</span>) &#123;<br>            sb.append(<span class="hljs-string">&#x27;(&#x27;</span>);<br>            dfs(index + <span class="hljs-number">1</span>, left - <span class="hljs-number">1</span>, right);<br>            sb.deleteCharAt(sb.length() - <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (right &gt; left) &#123;<br>            sb.append(<span class="hljs-string">&#x27;)&#x27;</span>);<br>            dfs(index + <span class="hljs-number">1</span>, left, right - <span class="hljs-number">1</span>);<br>            sb.deleteCharAt(sb.length() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    <span class="hljs-type">int</span> n;<br>&#125;<br></code></pre></td></tr></table></figure>
<div class="note note-danger">
            <h2 id="和为-k-的子数组"><a href="https://leetcode.cn/problems/subarray-sum-equals-k/">560. 和为 K 的子数组</a></h2>
          </div>
<h3 id="section"><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230721154645105.png" /></h3>
<h3 id="方法一前缀和-hashmap">方法一：前缀和 + HashMap</h3>
<p><a href="https://leetcode.cn/problems/subarray-sum-equals-k/solutions/238572/he-wei-kde-zi-shu-zu-by-leetcode-solution/">题解</a></p>
<p><a href="https://leetcode.cn/problems/subarray-sum-equals-k/solutions/562174/de-liao-yi-wen-jiang-qian-zhui-he-an-pai-yhyf/">可以用这种方法做链接中的题</a></p>
<p><strong>map.put(0, 1)是为了让第一组满足的子数组map.containsKey(pre - k) = 1</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">subarraySum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, count = <span class="hljs-number">0</span>;<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i) &#123;<br>            pre += nums[i];<br>            <span class="hljs-keyword">if</span> (map.containsKey(pre - k)) <br>                count += map.get(pre - k);<br>            map.put(pre, map.getOrDefault(pre, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="二叉树的锯齿形层序遍历"><a href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/">103. 二叉树的锯齿形层序遍历</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230721163840145.png" /></p>
<h3 id="方法一双队列">方法一：双队列</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">zigzagLevelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">nextRight</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        Deque&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(), temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.offer(root);<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>            List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>                <span class="hljs-keyword">if</span> (nextRight) &#123;<br>                    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> queue.pollFirst();<br>                    list.add(cur.val);<br>                    <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-literal">null</span>)<br>                        temp.offerLast(cur.left);<br>                    <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-literal">null</span>)<br>                        temp.offerLast(cur.right);<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> queue.pollLast();<br>                    list.add(cur.val);<br>                    <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-literal">null</span>)<br>                        temp.offerFirst(cur.right);<br>                    <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-literal">null</span>)<br>                        temp.offerFirst(cur.left);<br>                &#125;<br>            &#125;<br>            queue = temp;<br>            temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>            res.add(list);<br>            nextRight = !nextRight;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="反转字符串中的单词"><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">151. 反转字符串中的单词</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230721222458026.png" /></p>
<h3 id="方法一双端队列">方法一：双端队列</h3>
<p>用栈实现不是逆序的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseWords</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">// 去除首尾空格</span><br>        Deque&lt;String&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = s.length() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (s.charAt(left) == <span class="hljs-string">&#x27; &#x27;</span>)<br>            ++left;<br>        <span class="hljs-keyword">while</span> (s.charAt(right) == <span class="hljs-string">&#x27; &#x27;</span>)<br>            --right;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> s.charAt(left++);<br>            <span class="hljs-keyword">if</span> (ch != <span class="hljs-string">&#x27; &#x27;</span>)<br>                sb.append(ch);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27; &#x27;</span> &amp;&amp; sb.length() &gt; <span class="hljs-number">0</span>) &#123;<br>                queue.offerFirst(sb.toString());<br>                sb.setLength(<span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;<br>        queue.offerFirst(sb.toString());<br>        <span class="hljs-keyword">return</span> String.join(<span class="hljs-string">&quot; &quot;</span>, queue);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="k-个一组翻转链表"><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230722091839555.png" /></p>
<h3 id="方法一模拟">方法一：模拟</h3>
<p>多debug</p>
<p>使用outOfBound判断最后一部分节点的数量是否少于k，如果少于k就break</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseKGroup</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummyHead</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>, head);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> dummyHead, next = dummyHead, cur = head, start = dummyHead;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span> &amp;&amp; cur.next != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">outOfBound</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k - <span class="hljs-number">1</span>; ++i) &#123;<br>                <span class="hljs-keyword">if</span> (cur.next == <span class="hljs-literal">null</span>) &#123;<br>                    outOfBound = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                cur = cur.next;<br>                next = cur.next;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (outOfBound)<br>                <span class="hljs-keyword">break</span>;<br>            cur.next = <span class="hljs-literal">null</span>;<br>            start = pre.next;<br>            pre.next = reverse(start);<br>            start.next = next;<br>            pre = start;<br>            cur = pre.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummyHead.next;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> ListNode <span class="hljs-title function_">reverse</span><span class="hljs-params">(ListNode cur)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>, next;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            next = cur.next;<br>            cur.next = pre;;<br>            pre = cur;<br>            cur = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="字符串转换整数-atoi"><a href="https://leetcode.cn/problems/string-to-integer-atoi/">8. 字符串转换整数 (atoi)</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230722131846770.png" /></p>
<h3 id="方法一模拟-1">方法一：模拟</h3>
<p>判断是否溢出</p>
<p>其中Integer.MAX_VALUE / 10 == res &amp;&amp; val &gt; 7，如果是正数val &gt; 7溢出；如果是负数val &gt; 8才溢出，不过等于8时，结果恰好是Integer.MIN_VALUE</p>
<p>[-2147483648,2147483647]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (Integer.MAX_VALUE / <span class="hljs-number">10</span> &lt; res || (Integer.MAX_VALUE / <span class="hljs-number">10</span> == res &amp;&amp; val &gt; <span class="hljs-number">7</span>))<br>    <span class="hljs-keyword">return</span> positive ? Integer.MAX_VALUE : Integer.MIN_VALUE;<br></code></pre></td></tr></table></figure>
<h4 id="代码">代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">myAtoi</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, n = s.length();<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 丢弃前导空格</span><br>        <span class="hljs-keyword">while</span> (left &lt; n) &#123;<br>            <span class="hljs-keyword">if</span> (s.charAt(left) != <span class="hljs-string">&#x27; &#x27;</span>)<br>                <span class="hljs-keyword">break</span>;<br>            ++left;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (left == n)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 判断正负号</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">positive</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (!isDigital(s.charAt(left))) &#123;<br>            positive = s.charAt(left) == <span class="hljs-string">&#x27;-&#x27;</span> ? <span class="hljs-literal">false</span> : <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (s.charAt(left) == <span class="hljs-string">&#x27;-&#x27;</span>)<br>                positive = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.charAt(left) != <span class="hljs-string">&#x27;+&#x27;</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            ++left;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> left; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-keyword">if</span> (!isDigital(ch))<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> ch - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (Integer.MAX_VALUE / <span class="hljs-number">10</span> &lt; res || (Integer.MAX_VALUE / <span class="hljs-number">10</span> == res &amp;&amp; val &gt; <span class="hljs-number">7</span>))<br>                <span class="hljs-keyword">return</span> positive ? Integer.MAX_VALUE : Integer.MIN_VALUE;<br>            res = res * <span class="hljs-number">10</span> + val;<br>        &#125;<br>        <span class="hljs-keyword">return</span> positive ? res : -res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDigital</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span> &#123;<br>        <span class="hljs-keyword">return</span> ch == <span class="hljs-string">&#x27;0&#x27;</span> || ch == <span class="hljs-string">&#x27;1&#x27;</span> || ch == <span class="hljs-string">&#x27;2&#x27;</span> || ch == <span class="hljs-string">&#x27;3&#x27;</span> || ch == <span class="hljs-string">&#x27;4&#x27;</span> || ch == <span class="hljs-string">&#x27;5&#x27;</span> || ch == <span class="hljs-string">&#x27;6&#x27;</span>|| ch == <span class="hljs-string">&#x27;7&#x27;</span>|| ch == <span class="hljs-string">&#x27;8&#x27;</span>|| ch == <span class="hljs-string">&#x27;9&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="合并区间"><a href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230722153624555.png" /></p>
<h3 id="方法一射气球">方法一：射气球</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] merge(<span class="hljs-type">int</span>[][] intervals) &#123;<br>        Arrays.sort(intervals, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;<span class="hljs-type">int</span>[]&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">int</span>[] o1, <span class="hljs-type">int</span>[] o2)</span> &#123;<br>                <span class="hljs-keyword">return</span> Integer.compare(o1[<span class="hljs-number">0</span>], o2[<span class="hljs-number">0</span>]);<br>            &#125;<br>        &#125;);<br>        List&lt;<span class="hljs-type">int</span>[]&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; intervals.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (intervals[left][<span class="hljs-number">1</span>] &gt;= intervals[i][<span class="hljs-number">0</span>])<br>                intervals[left][<span class="hljs-number">1</span>] = Math.max(intervals[left][<span class="hljs-number">1</span>], intervals[i][<span class="hljs-number">1</span>]);<br>            <span class="hljs-keyword">else</span>  &#123;<br>                list.add(intervals[left]);<br>                left = i;<br>            &#125;<br>        &#125;<br>        intervals[left][<span class="hljs-number">1</span>] = Math.max(intervals[left][<span class="hljs-number">1</span>], intervals[intervals.length - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>        list.add(intervals[left]);<br>        <span class="hljs-keyword">return</span> list.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[list.size()][]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<div class="note note-danger">
            <h2 id="旋转图像"><a href="https://leetcode.cn/problems/rotate-image/">48. 旋转图像</a></h2>
          </div>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230722155259003.png" /></p>
<h3 id="方法一模拟-2">方法一：模拟</h3>
<p>别看题解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n &gt;&gt; <span class="hljs-number">1</span>; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> n - i * <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; len - <span class="hljs-number">1</span>; ++j) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> matrix[i][i + j];<br>                matrix[i][i + j] = matrix[n - i - j - <span class="hljs-number">1</span>][i];<br>                matrix[n - i - j - <span class="hljs-number">1</span>][i] = matrix[n - i - <span class="hljs-number">1</span>][n - i - j - <span class="hljs-number">1</span>];<br>                matrix[n - i - <span class="hljs-number">1</span>][n - i - j - <span class="hljs-number">1</span>] = matrix[i + j][n - i - <span class="hljs-number">1</span>];<br>                matrix[i + j][n - i - <span class="hljs-number">1</span>] = temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="三数之和"><a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230722171606041.png" /></p>
<h3 id="方法一排序-双指针">方法一：排序 + 双指针</h3>
<p><a href="https://leetcode.cn/problems/3sum/solutions/39722/pai-xu-shuang-zhi-zhen-zhu-xing-jie-shi-python3-by/">题解</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">threeSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        Arrays.sort(nums);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> res;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>])<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>, right = n - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>                <span class="hljs-keyword">if</span> (nums[i] + nums[left] + nums[right] == <span class="hljs-number">0</span>) &#123;<br>                    res.add(Arrays.asList(nums[i], nums[left], nums[right]));<br>                    <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>])<br>                        ++left;<br>                    <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>])<br>                        --right;<br>                    ++left;<br>                    --right;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] + nums[left] + nums[right] &lt; <span class="hljs-number">0</span>)<br>                    ++left;<br>                <span class="hljs-keyword">else</span> <br>                    --right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="两数之和"><a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230725093344209.png" /></p>
<h3 id="方法一hashmap">方法一：HashMap</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (map.containsKey(target - nums[i])) &#123;<br>                res[<span class="hljs-number">0</span>] = i;<br>                res[<span class="hljs-number">1</span>] = map.get(target - nums[i]);<br>            &#125;<br>            map.put(nums[i], i);<br>                <br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="最长回文子串"><a href="https://leetcode.cn/problems/longest-palindromic-substring/">5. 最长回文子串</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230725093915580.png" /></p>
<h3 id="方法一dp-1">方法一：DP</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length(), max = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] maxIndex = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &gt;= <span class="hljs-number">0</span>; --j) &#123;<br>                <span class="hljs-keyword">if</span> (i - j + <span class="hljs-number">1</span> == <span class="hljs-number">1</span>)<br>                    dp[i][j] = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i - j + <span class="hljs-number">1</span> == <span class="hljs-number">2</span>)<br>                    dp[i][j] = s.charAt(i) == s.charAt(j) ? <span class="hljs-number">2</span> : <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i - j + <span class="hljs-number">1</span> == <span class="hljs-number">3</span>)<br>                    dp[i][j] = s.charAt(i) == s.charAt(j) ? <span class="hljs-number">3</span> : <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (s.charAt(i) != s.charAt(j))<br>                        dp[i][j] = <span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">else</span><br>                        dp[i][j] = dp[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span> ? dp[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] + <span class="hljs-number">2</span> : <span class="hljs-number">0</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (dp[i][j] &gt; max) &#123;<br>                    max = dp[i][j];<br>                    maxIndex = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;j, i&#125;;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.substring(maxIndex[<span class="hljs-number">0</span>], maxIndex[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="买卖股票的最佳时机"><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230725101934740.png" /></p>
]]></content>
  </entry>
  <entry>
    <title>Package Problem</title>
    <url>/2023/06/26/package-problem/</url>
    <content><![CDATA[<div class="note note-success">
            <p>dp数组的初始化、状态转移方程、遍历顺序至关重要</p><p>其中的关键是<strong>状态转移方程</strong>，初始化以及遍历顺序都由状态转移方程确定</p>
          </div>
<h1 id="背包">01背包</h1>
<h2 id="背包-二维dp数组m行">01背包-二维dp数组(m行)</h2>
<h4 id="代码">代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> 背包;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">bag01_2d</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] weight = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>&#125;;<br>        <span class="hljs-type">int</span>[] value = &#123;<span class="hljs-number">30</span>, <span class="hljs-number">15</span>, <span class="hljs-number">20</span>&#125;;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">capacity</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> calcMaxValue(weight, value, capacity);<br>        System.out.println(<span class="hljs-string">&quot;res: &quot;</span> + res);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calcMaxValue</span><span class="hljs-params">(<span class="hljs-type">int</span>[] weight, <span class="hljs-type">int</span>[] value, <span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[weight.length][capacity + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * dp[i][j]:容量为j的背包，在物品0~i中任选，能获得的最大价值</span><br><span class="hljs-comment">         * 状态转移；if(j &gt;= weight[i]) dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]) 选物品i或不选物品i</span><br><span class="hljs-comment">         *         else dp[i][j] = dp[i - 1][j] 不选物品i</span><br><span class="hljs-comment">         * 初始化：由状态转移可以看出，dp[i][j]依赖于dp[i - 1][j]，所以需要初始化第0行</span><br><span class="hljs-comment">         *       第0行：选择物品0.如果j &gt; weight[0]，dp[0][j] = value[0]</span><br><span class="hljs-comment">         *       第0列：背包容量为0，什么都装不下，dp[i][0] = 0</span><br><span class="hljs-comment">         * */</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= capacity; ++j)<br>            dp[<span class="hljs-number">0</span>][j] = j &gt;= weight[<span class="hljs-number">0</span>] ? value[<span class="hljs-number">0</span>] : <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; weight.length; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= capacity; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (j &gt;= weight[i])<br>                    dp[i][j] = Math.max(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weight[i]] + value[i]);<br>                <span class="hljs-keyword">else</span><br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; weight.length; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= capacity; ++j)<br>                System.out.print(dp[i][j] + <span class="hljs-string">&quot;\t&quot;</span>);<br>            System.out.println();<br>        &#125;<br>        System.out.println();<br>        <span class="hljs-keyword">return</span> dp[weight.length - <span class="hljs-number">1</span>][capacity];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="输出">输出</h4>
<figure class="highlight txt"><table><tr><td class="code"><pre><code class="hljs txt">0	0	0	0	30	<br>0	15	15	15	30	<br>0	15	15	20	35	<br><br>res: 35<br></code></pre></td></tr></table></figure>
<h2 id="背包-二维dp数组两行">01背包-二维dp数组(两行)</h2>
<h4 id="状态转移">状态转移：</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(j &gt;= weight[i]) <br>    dp[i][j] = Math.max(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weight[i]] + value[i]) 选物品i或不选物品i<br><span class="hljs-keyword">else</span> <br>    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] 不选物品i<br></code></pre></td></tr></table></figure>
<p>可以看出dp[i][j]只可能被dp[i - 1][j]和dp[i - 1][j - weight[i]]推导出，也就是说第i行只与第i - 1行关联，那么dp数组只需要用两行</p>
<p>与使用m行的代码相比，只需要将dp数组更改为2行，dp[i]与dp[i - 1]改为dp[i % 2]与dp[(i - 1) % 2]</p>
<p>初始化后(遍历完第0个物品后)的dp数组为</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><code class="hljs txt">0	0	0	0	30	<br>0	0	0	0	0<br></code></pre></td></tr></table></figure>
<p>遍历完第1个物品后的dp数组为</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><code class="hljs txt">0	0	0	0	30	<br>0	15	15	15	30	<br></code></pre></td></tr></table></figure>
<p>遍历第2个物品时，只需要遍历第1个物品的dp数据，不需要遍历第0个物品的dp数据，所以把遍历第2个物品的dp数据覆盖在第0行</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><code class="hljs txt">0	0	0	20	35	<br>0	15	15	15	30	<br></code></pre></td></tr></table></figure>
<h4 id="代码-1">代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> 背包;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">bag01_2d</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] weight = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>&#125;;<br>        <span class="hljs-type">int</span>[] value = &#123;<span class="hljs-number">30</span>, <span class="hljs-number">15</span>, <span class="hljs-number">20</span>&#125;;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">capacity</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> calcMaxValue(weight, value, capacity);<br>        System.out.println(<span class="hljs-string">&quot;res: &quot;</span> + res);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calcMaxValue</span><span class="hljs-params">(<span class="hljs-type">int</span>[] weight, <span class="hljs-type">int</span>[] value, <span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>][capacity + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= capacity; ++j)<br>            dp[<span class="hljs-number">0</span>][j] = j &gt;= weight[<span class="hljs-number">0</span>] ? value[<span class="hljs-number">0</span>] : <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; weight.length; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> weight[i]; j &lt;= capacity; ++j) &#123;<br>                dp[i % <span class="hljs-number">2</span>][j] = Math.max(dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][j], dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][j - weight[i]] + value[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= capacity; ++j)<br>                System.out.print(dp[i][j] + <span class="hljs-string">&quot;\t&quot;</span>);<br>            System.out.println();<br>        &#125;<br>        System.out.println();<br>        <span class="hljs-keyword">return</span> dp[(weight.length - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][capacity];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="输出-1">输出</h4>
<figure class="highlight txt"><table><tr><td class="code"><pre><code class="hljs txt">0	0	0	20	35	<br>0	15	15	15	30	<br><br>res: 35<br></code></pre></td></tr></table></figure>
<h2 id="背包-滚动数组一维dp数组">01背包-滚动数组(一维dp数组)</h2>
<p>两行能搞定，一行也行！</p>
<p>现在使用一维dp数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[capacity + <span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure>
<p>回顾一下使用二维dp数组是如何填表的</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><code class="hljs txt">0	0	0	0	30	<br>0	15	15	15	30	<br>0	15	15	20	35	<br>// int[] weight = &#123;4, 1, 3&#125;;<br>// int[] value = &#123;30, 15, 20&#125;;<br>// int capacity = 4;<br></code></pre></td></tr></table></figure>
<p>直接看第二行最后一个元素35(此时i = 2, j = 4)，它是由dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);更新</p>
<p>dp[i - 1][j - weight[i]] = dp[1][1] = 15, value[i] = 20</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230626120303326.png" /></p>
<p>35是由左上方的15加上value[2]得到的</p>
<p>所以使用一维滚动数组，在更新dp[4]的时候(相对于两维数组是要更新dp[2][4])，</p>
<p>需要上一行的dp[1](相对于二维dp数组是dp[1][1])，</p>
<p><strong>那么j的遍历顺序一定要从后往前！否则(从前往后)，dp[1]是二维dp数组中dp[2][1]的数据</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> capacity; j &gt;= weight[i]; --j)<br></code></pre></td></tr></table></figure>
<h4 id="代码-2">代码</h4>
<p>初始化为0即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> 背包;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">bag01</span> &#123;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] weight = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>&#125;;<br>        <span class="hljs-type">int</span>[] value = &#123;<span class="hljs-number">30</span>, <span class="hljs-number">15</span>, <span class="hljs-number">20</span>&#125;;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">capacity</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> calcMaxValue(weight, value, capacity);<br>        System.out.println(res);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calcMaxValue</span><span class="hljs-params">(<span class="hljs-type">int</span>[] weight, <span class="hljs-type">int</span>[] value, <span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[capacity + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; weight.length; ++i) <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> capacity; j &gt;= weight[i]; --j)<br>                dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= capacity; j++)&#123;<br>            System.out.print(dp[j] + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[capacity];<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h3 id="输出-2">输出</h3>
<figure class="highlight txt"><table><tr><td class="code"><pre><code class="hljs txt">0 15 15 20 35 35<br></code></pre></td></tr></table></figure>
<h2 id="目标和"><a href="https://leetcode.cn/problems/target-sum/">494. 目标和</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230826100241376.png" /></p>
<h3 id="方法一记忆化搜索背包">方法一：记忆化搜索背包</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findTargetSumWays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-built_in">this</span>.nums = nums;<br>        n = nums.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : nums)<br>            target += x;<br>        <span class="hljs-keyword">if</span> (target % <span class="hljs-number">2</span> != <span class="hljs-number">0</span> || target &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        target /= <span class="hljs-number">2</span>;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][target + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dp)<br>            Arrays.fill(arr, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, target);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == n)<br>            <span class="hljs-keyword">return</span> target == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (dp[index][target] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[index][target];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">choose</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, pass = dfs(index + <span class="hljs-number">1</span>, target);<br>        <span class="hljs-keyword">if</span> (target &gt;= nums[index])<br>            choose = dfs(index + <span class="hljs-number">1</span>, target - nums[index]);<br>        <span class="hljs-keyword">return</span> dp[index][target] = pass + choose;<br>    &#125;<br><br>    <span class="hljs-type">int</span>[] nums;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">int</span>[][] dp;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二01背包">方法二：01背包</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findTargetSumWays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : nums)<br>            target += x;<br>        <span class="hljs-keyword">if</span> (target % <span class="hljs-number">2</span> != <span class="hljs-number">0</span> || target &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        target /= <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][target + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= target; ++j) &#123;<br>                dp[i + <span class="hljs-number">1</span>][j] = dp[i][j];<br>                <span class="hljs-keyword">if</span> (j &gt;= nums[i])<br>                    dp[i + <span class="hljs-number">1</span>][j] += dp[i][j - nums[i]];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][target];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法三滚动数组">方法三：滚动数组</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findTargetSumWays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : nums)<br>            target += x;<br>        <span class="hljs-keyword">if</span> (target % <span class="hljs-number">2</span> != <span class="hljs-number">0</span> || target &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        target /= <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[target + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> target; j &gt;= nums[i]; --j) <br>                dp[j] += dp[j - nums[i]];<br>        <span class="hljs-keyword">return</span> dp[target];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="零钱兑换"><a href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230826105715253.png" /></p>
<h3 id="方法一记忆化搜索">方法一：记忆化搜索</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">coinChange</span><span class="hljs-params">(<span class="hljs-type">int</span>[] coins, <span class="hljs-type">int</span> amount)</span> &#123;<br>        <span class="hljs-built_in">this</span>.coins = coins;<br>        n = coins.length;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][amount + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dp)<br>            Arrays.fill(arr, -<span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> dfs(<span class="hljs-number">0</span>, amount);<br>        <span class="hljs-keyword">return</span> res == Integer.MAX_VALUE / <span class="hljs-number">2</span> ? -<span class="hljs-number">1</span> : res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> amount)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == n)<br>            <span class="hljs-keyword">return</span> amount == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : Integer.MAX_VALUE / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (dp[index][amount] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[index][amount];<br>        <span class="hljs-keyword">if</span> (coins[index] &gt; amount)<br>            <span class="hljs-keyword">return</span> dfs(index + <span class="hljs-number">1</span>, amount);<br>        <span class="hljs-keyword">return</span> dp[index][amount] = Math.min(dfs(index + <span class="hljs-number">1</span>, amount), dfs(index, amount - coins[index]) + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-type">int</span>[] coins;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">int</span>[][] dp;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二完全背包">方法二：完全背包</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">coinChange</span><span class="hljs-params">(<span class="hljs-type">int</span>[] coins, <span class="hljs-type">int</span> amount)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> coins.length;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][amount + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dp)<br>            Arrays.fill(arr, Integer.MAX_VALUE &gt;&gt; <span class="hljs-number">1</span>);<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= amount; ++j) &#123;<br>                dp[i + <span class="hljs-number">1</span>][j] = dp[i][j];<br>                <span class="hljs-keyword">if</span> (coins[i] &lt;= j)<br>                    dp[i + <span class="hljs-number">1</span>][j] = Math.min(dp[i][j], dp[i + <span class="hljs-number">1</span>][j - coins[i]] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][amount] == Integer.MAX_VALUE &gt;&gt; <span class="hljs-number">1</span> ? -<span class="hljs-number">1</span> : dp[n][amount];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法三滚动数组-1">方法三：滚动数组</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">coinChange</span><span class="hljs-params">(<span class="hljs-type">int</span>[] coins, <span class="hljs-type">int</span> amount)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> coins.length;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[amount + <span class="hljs-number">1</span>];<br>        Arrays.fill(dp, Integer.MAX_VALUE &gt;&gt; <span class="hljs-number">1</span>);<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= amount; ++j) <br>                <span class="hljs-keyword">if</span> (j &gt;= coins[i])<br>                    dp[j] = Math.min(dp[j], dp[j - coins[i]] + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dp[amount] == Integer.MAX_VALUE &gt;&gt; <span class="hljs-number">1</span> ? -<span class="hljs-number">1</span> : dp[amount];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="将一个数字表示成幂的和的方案数"><a href="https://leetcode.cn/problems/ways-to-express-an-integer-as-sum-of-powers/">2787. 将一个数字表示成幂的和的方案数</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230915105617743.png" /></p>
<h3 id="方法一01背包">方法一：01背包</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numberOfWays</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br>        <span class="hljs-comment">// 01背包， 从1^x, 2^x,...,n^x里选物品，恰好能装满容量为n的背包的方案数</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 没有物品，恰好装满容量为0的背包的方案数：1,什么都不装</span><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) Math.pow(i, x);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= n; ++j) &#123;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>                <span class="hljs-keyword">if</span> (j &gt;= s)<br>                    dp[i][j] = (dp[i][j] +  dp[i - <span class="hljs-number">1</span>][j - s]) % mod;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二滚动数组">方法二：滚动数组</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numberOfWays</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br>        <span class="hljs-comment">// 01背包， 从1^x, 2^x,...,n^x里选物品，恰好能装满容量为n的背包的方案数</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 没有物品，恰好装满容量为0的背包的方案数：1,什么都不装</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) Math.pow(i, x);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> n; j &gt;= s; --j) &#123;<br>                dp[j] = (dp[j] +  dp[j - s]) % mod;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法三静态处理">方法三：静态处理</h3>
<p>所有x,n在static语句块中处理好</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[][] dp;<br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">300</span>, x = <span class="hljs-number">5</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br>        <span class="hljs-comment">// 01背包， 从1^x, 2^x,...,n^x里选物品，恰好能装满容量为n的背包的方案数</span><br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[x][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 没有物品，恰好装满容量为0的背包的方案数：1,什么都不装</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; x; ++i)<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; k &lt;= x; ++k) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) Math.pow(i, k);<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> n; j &gt;= s; --j) &#123;<br>                    dp[k - <span class="hljs-number">1</span>][j] = (dp[k - <span class="hljs-number">1</span>][j] +  dp[k - <span class="hljs-number">1</span>][j - s]) % mod;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numberOfWays</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-keyword">return</span> dp[x - <span class="hljs-number">1</span>][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="盈利计划"><a href="https://leetcode.cn/problems/profitable-schemes/">879. 盈利计划</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230915113103747.png" /></p>
<h3 id="方法一记忆化搜索爆内存">方法一：记忆化搜索(爆内存)</h3>
<p>方案数用 <strong>+</strong>！！！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">profitableSchemes</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> minProfit, <span class="hljs-type">int</span>[] group, <span class="hljs-type">int</span>[] profit)</span> &#123;<br>        <span class="hljs-built_in">this</span>.group = group;<br>        <span class="hljs-built_in">this</span>.profit = profit;<br>        <span class="hljs-built_in">this</span>.n = n;<br>        <span class="hljs-built_in">this</span>.minProfit = minProfit;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[group.length][n + <span class="hljs-number">1</span>][<span class="hljs-number">10000</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[][] a : dp)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] b : a)<br>                Arrays.fill(b, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, n, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> hc, <span class="hljs-type">int</span> p)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == group.length)<br>            <span class="hljs-keyword">return</span> p &gt;= minProfit ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (dp[index][hc][p] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[index][hc][p];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> group[index], y = profit[index];<br>        <span class="hljs-keyword">if</span> (hc &gt;= x)<br>            <span class="hljs-keyword">return</span> dp[index][hc][p] = (dfs(index + <span class="hljs-number">1</span>, hc, p) + dfs(index + <span class="hljs-number">1</span>, hc - x, p + y)) % mod;<br>        <span class="hljs-keyword">return</span> dp[index][hc][p] = dfs(index + <span class="hljs-number">1</span>, hc, p) % mod;<br>    &#125;<br><br>    <span class="hljs-type">int</span>[] group, profit;<br>    <span class="hljs-type">int</span> n, minProfit, mod = (<span class="hljs-type">int</span>) <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br>    <span class="hljs-type">int</span>[][][] dp;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二10000改成sum">方法二：10000改成sum</h3>
<p>勉勉强强过</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">profitableSchemes</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> minProfit, <span class="hljs-type">int</span>[] group, <span class="hljs-type">int</span>[] profit)</span> &#123;<br>        <span class="hljs-built_in">this</span>.group = group;<br>        <span class="hljs-built_in">this</span>.profit = profit;<br>        <span class="hljs-built_in">this</span>.n = n;<br>        <span class="hljs-built_in">this</span>.minProfit = minProfit;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : profit)<br>            sum += x;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[group.length][n + <span class="hljs-number">1</span>][sum + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[][] a : dp)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] b : a)<br>                Arrays.fill(b, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, n, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> hc, <span class="hljs-type">int</span> p)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == group.length)<br>            <span class="hljs-keyword">return</span> p &gt;= minProfit ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (dp[index][hc][p] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[index][hc][p];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> group[index], y = profit[index];<br>        <span class="hljs-keyword">if</span> (hc &gt;= x)<br>            <span class="hljs-keyword">return</span> dp[index][hc][p] = (dfs(index + <span class="hljs-number">1</span>, hc, p) + dfs(index + <span class="hljs-number">1</span>, hc - x, p + y)) % mod;<br>        <span class="hljs-keyword">return</span> dp[index][hc][p] = dfs(index + <span class="hljs-number">1</span>, hc, p) % mod;<br>    &#125;<br><br>    <span class="hljs-type">int</span>[] group, profit;<br>    <span class="hljs-type">int</span> n, minProfit, mod = (<span class="hljs-type">int</span>) <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br>    <span class="hljs-type">int</span>[][][] dp;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法三01背包">方法三：01背包</h3>
<p><a href="https://leetcode.cn/problems/profitable-schemes/solutions/820111/gong-shui-san-xie-te-shu-duo-wei-fei-yon-7su9/">题解</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">profitableSchemes</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> minProfit, <span class="hljs-type">int</span>[] group, <span class="hljs-type">int</span>[] profit)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, mod = (<span class="hljs-type">int</span>) <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : profit)<br>            sum += x;<br>        <span class="hljs-comment">// 从group下标0~i中选任务，当前的最大可用人数是j，获得的利润至少为k的方案数</span><br>        <span class="hljs-type">int</span>[][][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[group.length + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>][minProfit + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 没有任务，没有人，可获得的利润大于等于0的方案数是1：什么都不选</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= n; ++i)<br>            dp[<span class="hljs-number">0</span>][i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= group.length; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> group[i - <span class="hljs-number">1</span>], y = profit[i - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= n; ++j) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt;= minProfit; ++k) &#123;<br>                    dp[i][j][k] = dp[i - <span class="hljs-number">1</span>][j][k];<br>                    <span class="hljs-keyword">if</span> (j &gt;= x)<br>                        dp[i][j][k] = (dp[i][j][k] + dp[i - <span class="hljs-number">1</span>][j - x][Math.max(<span class="hljs-number">0</span>, k - y)]) % mod;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[group.length][n][minProfit];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="完全平方数"><a href="https://leetcode.cn/problems/perfect-squares/">279. 完全平方数</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230915144052949.png" /></p>
<h3 id="方法一记忆化搜索-1">方法一：记忆化搜索</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10000</span>];<br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; ++i)<br>            nums[i] = i * i;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numSquares</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-built_in">this</span>.n = n;<br>        m = (<span class="hljs-type">int</span>) Math.sqrt(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>            nums[i] = i * i;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dp)<br>            Arrays.fill(arr, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">1</span>, n);<br>    &#125;<br><br>    <span class="hljs-type">int</span> n, m, inf = Integer.MAX_VALUE / <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span>[][] dp;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> sum)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == m + <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> sum == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : inf;<br>        <span class="hljs-keyword">if</span> (dp[index][sum] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[index][sum];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> nums[index];<br>        <span class="hljs-keyword">if</span> (sum &gt;= x) <br>            <span class="hljs-keyword">return</span> dp[index][sum] = Math.min(dfs(index, sum - x) + <span class="hljs-number">1</span>, dfs(index + <span class="hljs-number">1</span>, sum));<br>        <span class="hljs-keyword">return</span> dp[index][sum] = dfs(index + <span class="hljs-number">1</span>, sum);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二完全背包-1">方法二：完全背包</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numSquares</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) Math.sqrt(n);<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// dp[0] = 0 没有物品，容量为0，需要0个数</span><br>        Arrays.fill(dp, <span class="hljs-number">100010</span>);<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> i * i;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> x; j &lt;= n; ++j) &#123;<br>                dp[j] = Math.min(dp[j], dp[j - x] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithms</category>
        <category>Dynamic Programming</category>
      </categories>
      <tags>
        <tag>动态规划,背包问题</tag>
      </tags>
  </entry>
  <entry>
    <title>Sort</title>
    <url>/2023/06/12/sort/</url>
    <content><![CDATA[<div class="note note-success">
            <p>贪心是一种思想，使用贪心思想解决的问题，如果能被总结成具体某一类问题，那么就有具体的名字，比如<code>单源最短路问题</code>，<code>最小生成树问题</code>，<code>拓扑排序问题</code>，如果不能被总结出来，那它就叫贪心问题哈哈。</p><p>贪心问题经常需要借助排序来实现。</p>
          </div>
<div class="note note-primary">
            <h2 id="快速排序">快速排序</h2>
          </div>
<ol type="1">
<li>取一个随机值作为下标，与最后一个位置交换</li>
<li><strong>small始终指向最后一个小于pivot的下标</strong>，初始为start - 1</li>
<li>从start开始遍历，不需要遍历最后一个数(特殊处理)</li>
<li>当nums[i] &lt; nums[end]，将small前移，并且交换i与small</li>
<li>退出循环后，将small前移，与最后一个位置的数(pivot)交换</li>
</ol>
<h4 id="代码">代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> sort;<br><br><span class="hljs-keyword">import</span> java.util.Random;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] sortArray(<span class="hljs-type">int</span>[] nums) &#123;<br>        quickSort(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-keyword">if</span> (start &lt; end) &#123; <span class="hljs-comment">// 递归到子数组只有一个数字为止</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">pivot</span> <span class="hljs-operator">=</span> partition(nums, start, end);<br>            quickSort(nums, start, pivot - <span class="hljs-number">1</span>);<br>            quickSort(nums, pivot + <span class="hljs-number">1</span>, end);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">partition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(end - start + <span class="hljs-number">1</span>) + start; <span class="hljs-comment">// nextInt左闭右开</span><br>        swap(nums, random, end);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">small</span> <span class="hljs-operator">=</span> start - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; end; ++i)  <span class="hljs-comment">// end存放的是pivot，退出循环特殊处理</span><br>            <span class="hljs-keyword">if</span> (nums[i] &lt; nums[end])<br>                swap(nums, ++small, i);<br>        swap(nums, end, ++small);<br>        <span class="hljs-keyword">return</span> small;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> index1, <span class="hljs-type">int</span> index2)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index1 == index2)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[index1];<br>        nums[index1] = nums[index2];<br>        nums[index2] = temp;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">test</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">test</span>();<br>        <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>,<span class="hljs-number">34</span>,<span class="hljs-number">1</span>,<span class="hljs-number">544</span>,-<span class="hljs-number">13</span>&#125;;<br>        t.sortArray(arr);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : arr)<br>            System.out.print(x + <span class="hljs-string">&quot; &quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<div class="note note-success">
            <h2 id="计数排序">计数排序</h2><p><strong>计数排序是一种线性时间的整数排序算法。如果数组的长度为<code>n</code>，整数范围(数组中最大整数与最小整数的差值)为<code>k</code>对于<code>k</code>远小于<code>n</code>的场景(如对某公司所有员工的年龄排序)，那么计数排序的时间复杂度优于其他基于比较的排序算法(如归并排序、快速排序)</strong>，</p>
          </div>
<p><strong>三次遍历！</strong></p>
<ol type="1">
<li>遍历原始数组<code>nums</code>，得出最大值<code>max</code>与最小值<code>min</code>，并创建大小为<code>max - min + 1</code>的<code>count</code>数组</li>
<li>遍历<code>nums</code>数组，把对应整数<code>num</code>出现的次数记录在<code>count</code>数组的<code>count[num - min]</code>中</li>
<li>令<code>num</code>从<code>min</code>遍历到<code>max</code>，将<code>num</code>顺序填入<code>nums</code>中(每个<code>num</code>有<code>count[num - min]</code>个)</li>
</ol>
<h4 id="代码-1">代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] sortArray(<span class="hljs-type">int</span>[] nums) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE, max = Integer.MIN_VALUE;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        min = Math.min(min, num);<br>        max = Math.max(max, num);<br>    &#125;<br>    <span class="hljs-type">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[max - min + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums)<br>        ++count[num - min];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> min; num &lt;= max; ++num)<br>        <span class="hljs-keyword">while</span> (count[num - min]-- &gt; <span class="hljs-number">0</span>)<br>            nums[i++] = num;<br>    <span class="hljs-keyword">return</span> nums;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="剑指-offer-ii-074.-合并区间"><a href="https://leetcode.cn/problems/SsGoHC/">剑指 Offer II 074. 合并区间</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230613093629951.png" /></p>
<h4 id="方法一射气球的思路">方法一：射气球的思路</h4>
<ol type="1">
<li><p>首先将数组按照左边界升序排序</p></li>
<li><p>当intervals[i][1] &gt;= intervals[j][0]，那么这两个元素一定是要合并的，因为是intervals数组是按照左边界升序排序的，那么合并区间[a, b]的a一定是intervals[i][0]，将intervals[i][1]赋值为intervals[i][1]与intervals[j][1]的最大值</p></li>
<li><p>当intervals[i][1] &lt; intervals[j][0]，那么这个两个区间是不重合的，先把上一个重合区间加入结果集，再把j赋值给i，进行下一轮循环</p></li>
<li><p>当j == intervals.length - 1时候，</p>
<ol type="1">
<li>如果intervals[i][1] &gt;= intervals[j][0]，那么会将intervals[i][1]取intervals[i][1]与intervals[j][1]的最大值</li>
<li>如果intervals[i][1] &lt; intervals[j][0]，那么会将之前的重合区间存入结果集，并将j赋值给i</li>
</ol>
<p>所以出循环，只需要把intervals[i]加入结果集就好！</p></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] merge(<span class="hljs-type">int</span>[][] intervals) &#123;<br>        Arrays.sort(intervals, (o1, o2) -&gt; Integer.compare(o1[<span class="hljs-number">0</span>], o2[<span class="hljs-number">0</span>]));<br>        List&lt;<span class="hljs-type">int</span>[]&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; intervals.length; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (intervals[i][<span class="hljs-number">1</span>] &gt;= intervals[j][<span class="hljs-number">0</span>])<br>                intervals[i][<span class="hljs-number">1</span>] = Math.max(intervals[i][<span class="hljs-number">1</span>], intervals[j][<span class="hljs-number">1</span>]);<br>            <span class="hljs-keyword">else</span> &#123;<br>                list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;intervals[i][<span class="hljs-number">0</span>], intervals[i][<span class="hljs-number">1</span>]&#125;);<br>                i = j;<br>            &#125;<br>        &#125;<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;intervals[i][<span class="hljs-number">0</span>], intervals[i][<span class="hljs-number">1</span>]&#125;);<br>        <span class="hljs-keyword">return</span> list.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[list.size()][]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230613093658576.png" style="zoom:50%;" /></p>
<h2 id="剑指-offer-ii-075.-数组相对排序"><a href="https://leetcode.cn/problems/0H97ZC/">剑指 Offer II 075. 数组相对排序</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230613100232591.png" /></p>
<ol type="1">
<li>数据范围是[0, 1000]，创建大小为1001的<code>count</code>数组</li>
<li>统计<code>arr1</code>中出现整数的个数</li>
<li>按照<code>arr2</code>整数出现的顺序填<code>arr1</code>数组</li>
<li>从0到1000(升序)，把剩下的数组填入<code>arr1</code>数组</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] relativeSortArray(<span class="hljs-type">int</span>[] arr1, <span class="hljs-type">int</span>[] arr2) &#123;<br>        <span class="hljs-type">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">1001</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : arr1)<br>            ++count[num];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : arr2) <br>            <span class="hljs-keyword">while</span> (count[num]-- &gt; <span class="hljs-number">0</span>)<br>                arr1[i++] = num;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; num &lt;= <span class="hljs-number">1000</span>; ++num) <br>            <span class="hljs-keyword">while</span> (count[num]-- &gt; <span class="hljs-number">0</span>)<br>                arr1[i++] = num;<br>        <span class="hljs-keyword">return</span> arr1;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230613102141241.png" style="zoom:50%;" /></p>
<h2 id="剑指-offer-ii-076.-数组中的第-k-大的数字"><a href="https://leetcode.cn/problems/xx4gT2/">剑指 Offer II 076. 数组中的第 k 大的数字</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230613103525009.png" /></p>
<p><strong>快排找到下标为n-k的数x，左边的数都小于x，右边的数都大于x</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findKthLargest</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length, target = n - k, start = <span class="hljs-number">0</span>, end = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pivot</span> <span class="hljs-operator">=</span> partition(nums, start, end);<br>        <span class="hljs-keyword">while</span> (pivot != target) &#123;<br>            <span class="hljs-keyword">if</span> (pivot &gt; target)<br>                end = pivot - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                start = pivot + <span class="hljs-number">1</span>;<br>            pivot = partition(nums, start, end);<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[pivot];<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">partition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(end - start + <span class="hljs-number">1</span>) + start;<br>        swap(nums, random, end);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">small</span> <span class="hljs-operator">=</span> start - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; end; ++i) <br>            <span class="hljs-keyword">if</span> (nums[i] &lt; nums[end])<br>                swap(nums, ++small, i);<br>        swap(nums, ++small, end);<br>        <span class="hljs-keyword">return</span> small;        <br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> index1, <span class="hljs-type">int</span> index2)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index1 == index2)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[index1];<br>        nums[index1] = nums[index2];<br>        nums[index2] = temp;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230613105515198.png" style="zoom:50%;" /></p>
]]></content>
      <categories>
        <category>Algorithms</category>
        <category>Sort</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>Sliding Window</title>
    <url>/2023/06/10/sliding-window/</url>
    <content><![CDATA[<div class="note note-success">
            <p>滑动窗口主要解决<code>满足某个条件的连续子串</code>问题，因为我们枚举 <strong>区间、子数组、子串</strong>问题的时候时间复杂度是<span class="math inline">\(O(n^2)\)</span>，使用滑窗可以将时间复杂度优化至<span class="math inline">\(O(n)\)</span>。</p><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/solution/hua-dong-chuang-kou-by-powcai/">优质题解</a></p>
          </div>
<h2 id="无重复字符的最长子串"><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230610121616161.png" /></p>
<ol type="1">
<li>left = Math.max(left , map.get(s.charAt(i))+1);十分tricky，举例 <code>abba</code></li>
<li>当遍历到第二个<code>a</code>的时候，此时的left指向第二个<code>b</code>，right指向第二个<code>a</code>，字符出现重复，所以要更新left，往map里一查，之前出现的<code>a</code>下标比left还小，说明当前记录的最长不重复子串就不包含第一个<code>a</code>，所以left不变</li>
<li>然后不管出没出现重复字符，都要执行 map.put(s.charAt(i) , i);如果字符串是<code>abbab</code>，当遍历到最后一个<code>b</code>的时候，left赋值为第二个<code>b</code> 的下标 + 1 的位置，也就是a下标的位置；如果出现重复字符就不执行map.put(s.charAt(i) , i)，那么此时b在map里记录的下标是第一个b的下标</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> &#123;<br>        HashMap&lt;Character, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//用于记录最大不重复子串的长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//滑动窗口左指针</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length() ; i++)<br>        &#123;<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">            1、首先，判断当前字符是否包含在map中，如果不包含，将该字符添加到map（字符，字符在数组下标）,</span><br><span class="hljs-comment">             此时没有出现重复的字符，左指针不需要变化。此时不重复子串的长度为：i-left+1，与原来的maxLen比较，取最大值；</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">            2、如果当前字符 ch 包含在 map中，此时有2类情况：</span><br><span class="hljs-comment">             1）当前字符包含在当前有效的子段中，如：abca，当我们遍历到第二个a，当前有效最长子段是 abc，我们又遍历到a，</span><br><span class="hljs-comment">             那么此时更新 left 为 map.get(a)+1=1，当前有效子段更新为 bca；</span><br><span class="hljs-comment">             2）当前字符不包含在当前最长有效子段中，如：abba，我们先添加a,b进map，此时left=0，我们再添加b，发现map中包含b，</span><br><span class="hljs-comment">             而且b包含在最长有效子段中，就是1）的情况，我们更新 left=map.get(b)+1=2，此时子段更新为 b，而且map中仍然包含a，map.get(a)=0；</span><br><span class="hljs-comment">             随后，我们遍历到a，发现a包含在map中，且map.get(a)=0，如果我们像1）一样处理，就会发现 left=map.get(a)+1=1，实际上，left此时</span><br><span class="hljs-comment">             应该不变，left始终为2，子段变成 ba才对。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">             为了处理以上2类情况，我们每次更新left，left=Math.max(left , map.get(ch)+1).</span><br><span class="hljs-comment">             另外，更新left后，不管原来的 s.charAt(i) 是否在最长子段中，我们都要将 s.charAt(i) 的位置更新为当前的i，</span><br><span class="hljs-comment">             因此此时新的 s.charAt(i) 已经进入到 当前最长的子段中！</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-keyword">if</span>(map.containsKey(s.charAt(i)))<br>            &#123;<br>                left = Math.max(left , map.get(s.charAt(i))+<span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-comment">//不管是否更新left，都要更新 s.charAt(i) 的位置！</span><br>            map.put(s.charAt(i) , i);<br>            maxLen = Math.max(maxLen , i-left+<span class="hljs-number">1</span>);<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> maxLen;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230610150102870.png" style="zoom:50%;" /></p>
<div class="note note-danger">
            <h2 id="串联所有单词的子串"><a href="https://leetcode.cn/problems/substring-with-concatenation-of-all-words/">30. 串联所有单词的子串</a></h2><p>"ling mind rabo o<code>foo owin gdin gbar rwin g</code> monkeypoundcake" ["fooo","barr","wing","ding","wing"]</p>
          </div>
<h2 id="重复的dna序列"><a href="https://leetcode.cn/problems/repeated-dna-sequences/">187. 重复的DNA序列</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230610182534009.png" /></p>
<h3 id="方法一暴搜说是滑动窗口也行吧">方法一：暴搜(说是滑动窗口也行吧)</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">findRepeatedDnaSequences</span><span class="hljs-params">(String s)</span> &#123;<br>        List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; l &lt;= s.length() - <span class="hljs-number">10</span>; ++l) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">subStr</span> <span class="hljs-operator">=</span> s.substring(l, l + <span class="hljs-number">10</span>);<br>            map.put(subStr, map.getOrDefault(subStr, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) <br>            <span class="hljs-keyword">if</span> (entry.getValue() &gt; <span class="hljs-number">1</span>)<br>                res.add(entry.getKey());<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>一次循环也可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">findRepeatedDnaSequences</span><span class="hljs-params">(String s)</span> &#123;<br>        List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; l &lt;= s.length() - <span class="hljs-number">10</span>; ++l) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">subStr</span> <span class="hljs-operator">=</span> s.substring(l, l + <span class="hljs-number">10</span>);<br>            map.put(subStr, map.getOrDefault(subStr, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (map.getOrDefault(subStr, <span class="hljs-number">0</span>) == <span class="hljs-number">2</span>)<br>                res.add(subStr);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="最小覆盖子串"><a href="https://leetcode.cn/problems/minimum-window-substring/">76. 最小覆盖子串</a></h2>
<p><img src="C:\Users\ning\AppData\Roaming\Typora\typora-user-images\image-20230610183126790.png" /></p>
<h3 id="方法一滑动窗口超时check部分">方法一：滑动窗口(超时check部分)</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">minWindow</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">if</span> (s.length() &lt; t.length())<br>            <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">minLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">100000</span>;<br>        <span class="hljs-type">int</span>[] map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">256</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : t.toCharArray())<br>            ++map[ch - <span class="hljs-string">&#x27;A&#x27;</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, i = <span class="hljs-number">0</span>; i &lt; s.length(); ++i) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            --map[ch - <span class="hljs-string">&#x27;A&#x27;</span>];<br>            <span class="hljs-keyword">while</span> (i - left + <span class="hljs-number">1</span> &gt;= t.length() &amp;&amp; check(map, t)) &#123;<br>                <span class="hljs-keyword">if</span> (i - left + <span class="hljs-number">1</span> &lt; minLen) &#123;<br>                    res = s.substring(left, i + <span class="hljs-number">1</span>);<br>                    minLen = i - left + <span class="hljs-number">1</span>;<br>                &#125;<br>                ++map[s.charAt(left) - <span class="hljs-string">&#x27;A&#x27;</span>];<br>                ++left;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span>[] map, String t)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : t.toCharArray())<br>            <span class="hljs-keyword">if</span> (map[ch - <span class="hljs-string">&#x27;A&#x27;</span>] &gt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="把t提前转换好勉强能过char-arr-t.tochararray">把t提前转换好勉强能过，char[] arr = t.toCharArray();</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">minWindow</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">if</span> (s.length() &lt; t.length())<br>            <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-type">char</span>[] arr = t.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">minLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">100000</span>;<br>        <span class="hljs-type">int</span>[] map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">128</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : arr)<br>            ++map[ch - <span class="hljs-string">&#x27;A&#x27;</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, i = <span class="hljs-number">0</span>; i &lt; s.length(); ++i) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            --map[ch - <span class="hljs-string">&#x27;A&#x27;</span>];<br>            <span class="hljs-keyword">while</span> (i - left + <span class="hljs-number">1</span> &gt;= t.length() &amp;&amp; check(map, arr)) &#123;<br>                <span class="hljs-keyword">if</span> (i - left + <span class="hljs-number">1</span> &lt; minLen) &#123;<br>                    res = s.substring(left, i + <span class="hljs-number">1</span>);<br>                    minLen = i - left + <span class="hljs-number">1</span>;<br>                &#125;<br>                ++map[s.charAt(left) - <span class="hljs-string">&#x27;A&#x27;</span>];<br>                ++left;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span>[] map, <span class="hljs-type">char</span>[] arr)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : arr)<br>            <span class="hljs-keyword">if</span> (map[ch - <span class="hljs-string">&#x27;A&#x27;</span>] &gt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230610215538026.png" style="zoom:50%;" /></p>
<h2 id="长度最小的子数组"><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230610222958552.png" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, minLen = <span class="hljs-number">100001</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>; right &lt; nums.length; ++right) &#123;<br>            sum += nums[right];<br>            <span class="hljs-keyword">while</span> (sum &gt;= target) &#123;<br>                minLen = Math.min(minLen, right - left + <span class="hljs-number">1</span>);<br>                sum -= nums[left++];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> minLen == <span class="hljs-number">100001</span> ? <span class="hljs-number">0</span> : minLen;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230610222934593.png" style="zoom:50%;" /></p>
<h2 id="字符串的排列"><a href="https://leetcode.cn/problems/permutation-in-string/">567. 字符串的排列</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230610224450779.png" /></p>
<h3 id="方法一滑动窗口">方法一：滑动窗口</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkInclusion</span><span class="hljs-params">(String s1, String s2)</span> &#123;<br>        <span class="hljs-type">int</span>[] map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : s1.toCharArray())<br>            ++map[ch - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>; right &lt; s2.length(); ++right) &#123;<br>            --map[s2.charAt(right) - <span class="hljs-string">&#x27;a&#x27;</span>];<br>            <span class="hljs-keyword">if</span> (right - left + <span class="hljs-number">1</span> &gt;= s1.length()) &#123;<br>                <span class="hljs-keyword">if</span> (check(map, s1))<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                ++map[s2.charAt(left++) - <span class="hljs-string">&#x27;a&#x27;</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span>[] map, String s)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : s.toCharArray()) <br>            <span class="hljs-keyword">if</span> (map[ch - <span class="hljs-string">&#x27;a&#x27;</span>] != <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230610224427389.png" style="zoom:50%;" /></p>
<h2 id="尽可能使字符串相等"><a href="https://leetcode.cn/problems/get-equal-substrings-within-budget/">1208. 尽可能使字符串相等</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230610224658689.png" /></p>
<h3 id="方法一滑动窗口-1">方法一：滑动窗口</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">equalSubstring</span><span class="hljs-params">(String s, String t, <span class="hljs-type">int</span> maxCost)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, cost = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, i = <span class="hljs-number">0</span>; i &lt; s.length() &amp;&amp; i &lt; t.length(); ++i) &#123;<br>            cost += Math.abs(s.charAt(i) - t.charAt(i));<br>            <span class="hljs-keyword">while</span> (left &lt;= i &amp;&amp; cost &gt; maxCost) <br>                cost -= Math.abs(Math.abs(s.charAt(left) - t.charAt(left++)));<br>            maxLen = Math.max(maxLen, i - left + <span class="hljs-number">1</span>);            <br>        &#125;<br>        <span class="hljs-keyword">return</span> maxLen;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="找出最长等值子数组"><a href="https://leetcode.cn/contest/weekly-contest-359/problems/find-the-longest-equal-subarray/">找出最长等值子数组</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230820111728081.png" /></p>
<h3 id="方法一滑动窗口-同向双指针">方法一：滑动窗口 同向双指针</h3>
<ol type="1">
<li><p>将每个值的下标存到List中，例如对于nums = [1,3,2,3,1,3], k = 3</p>
<p>list[1]: [0, 4]</p>
<p>list[2] : [4]</p>
<p>list[3]: [1, 3, 5]</p></li>
<li><p>枚举每个list，即把元素替换成1或2或3，例如枚举list[3]: [1, 3, 5]，l = 0, r = 1时，nums数组有list.get(r) - list.get(0) + 1 = 3 - 1 + 1 = 3个数：[3，2，3]，这个子数组中有r - l + 1 = 1 - 0 + 1 = 2个3，所以需要删除3 - 2 = 1个数</p></li>
<li><p>当需要删除的数大于k时，将左端点右移，直到满足需要删除的元素小于等于k</p></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestEqualSubarray</span><span class="hljs-params">(List&lt;Integer&gt; nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.size();<br>        List&lt;Integer&gt;[] pos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[n + <span class="hljs-number">1</span>];<br>        Arrays.setAll(pos, e -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            pos[nums.get(i)].add(i);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (List&lt;Integer&gt; list : pos) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; r &lt; list.size(); ++r) &#123;<br>                <span class="hljs-keyword">while</span> (list.get(r) - list.get(l) + <span class="hljs-number">1</span> - (r - l + <span class="hljs-number">1</span>) &gt; k)<br>                    ++l;<br>                res = Math.max(res, r - l + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="乘积小于-k-的子数组"><a href="https://leetcode.cn/problems/subarray-product-less-than-k/">713. 乘积小于 K 的子数组</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230822000207064.png" /></p>
<h3 id="方法一滑动窗口-相向双指针">方法一：滑动窗口 相向双指针</h3>
<p>res += i - l + 1;把当前[l,r]的子数组都涵括了</p>
<p>如果[l,r]满足条件，那么[l + 1, r], [l + 2, r], ... , [r, r]都满足，满足条件的个数为 r - l + 1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numSubarrayProductLessThanK</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length ,res = <span class="hljs-number">0</span>, l = <span class="hljs-number">0</span>, prod = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            prod *= nums[i];<br>            <span class="hljs-keyword">while</span> (l &lt;= i &amp;&amp; prod &gt;= k)<br>                prod /= nums[l++];<br>            res += i - l + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="最大连续1的个数-iii"><a href="https://leetcode.cn/problems/max-consecutive-ones-iii/">1004. 最大连续1的个数 III</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230822214630799.png" /></p>
<h3 id="方法一滑动窗口同向双指针">方法一：滑动窗口(同向双指针)</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestOnes</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length, left = <span class="hljs-number">0</span>, res = <span class="hljs-number">0</span>, cnt0 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            cnt0 += <span class="hljs-number">1</span> - nums[i];<br>            <span class="hljs-keyword">while</span> (cnt0 &gt; k) &#123;<br>              cnt0 -= (nums[left++] == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br>            &#125;<br>            res = Math.max(res, i - left + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure>
<div class="note note-danger">
            <h2 id="替换子串得到平衡字符串"><a href="https://leetcode.cn/problems/replace-the-substring-for-balanced-string/">1234. 替换子串得到平衡字符串</a></h2>
          </div>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230822214747634.png" /></p>
<h3 id="方法一滑动窗口同向双指针-1">方法一：滑动窗口(同向双指针)</h3>
<p>将[l,r]的字符数量减去，如果满足QWERd的数量都小于n / 4，那么子串长度为r - l + 1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">balancedString</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span>[] cnt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-string">&#x27;X&#x27;</span>]; <span class="hljs-comment">// &#x27;X&#x27; - &#x27;W&#x27; = 1</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length(), l = <span class="hljs-number">0</span>, res = Integer.MAX_VALUE, target = n / <span class="hljs-number">4</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            cnt[s.charAt(i)]++;<br>        <span class="hljs-keyword">if</span> (check(cnt, target))<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            --cnt[ch];<br>            <span class="hljs-keyword">while</span> (check(cnt, target)) &#123;<br>                ++cnt[s.charAt(l)];<br>                res = Math.min(res, i - l + <span class="hljs-number">1</span>);<br>                ++l;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span>[] cnt,  <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">return</span> cnt[<span class="hljs-string">&#x27;Q&#x27;</span>] &lt;= target &amp;&amp; cnt[<span class="hljs-string">&#x27;W&#x27;</span>] &lt;= target &amp;&amp; cnt[<span class="hljs-string">&#x27;E&#x27;</span>] &lt;= target &amp;&amp; cnt[<span class="hljs-string">&#x27;R&#x27;</span>] &lt;= target;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="将-x-减到-0-的最小操作数"><a href="https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/">1658. 将 x 减到 0 的最小操作数</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230822224933506.png" /></p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230822223646030.png" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minOperations</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span>  <span class="hljs-operator">=</span> nums.length, res = -<span class="hljs-number">1</span>, l = <span class="hljs-number">0</span>, sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a : nums)<br>            sum += a;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> sum - x, cur = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (target &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            cur += nums[i];<br>            <span class="hljs-keyword">while</span> (cur &gt; target)<br>                cur -= nums[l++];<br>            <span class="hljs-keyword">if</span> (cur == target)<br>                res = Math.max(res, i - l + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res &lt; <span class="hljs-number">0</span> ? -<span class="hljs-number">1</span> : n - res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="两个线段获得的最多奖品"><a href="https://leetcode.cn/problems/maximize-win-from-two-segments/">两个线段获得的最多奖品</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230830220237567.png" /></p>
<h3 id="方法一同向双指针">方法一：同向双指针</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximizeWin</span><span class="hljs-params">(<span class="hljs-type">int</span>[] pos, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> pos.length, res = <span class="hljs-number">0</span>, l = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] pre = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">while</span> (pos[i] - pos[l] &gt; k)<br>                ++l;<br>            res = Math.max(res, pre[l] + i - l + <span class="hljs-number">1</span>);<br>            pre[i + <span class="hljs-number">1</span>] = Math.max(pre[i], i - l + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="定长子串中元音的最大数目"><a href="https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/">1456. 定长子串中元音的最大数目</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20231006112323250.png" /></p>
<h3 id="方法一滑动窗口同向双指针-2">方法一：滑动窗口(同向双指针)</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxVowels</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> k)</span> &#123;<br>        Set&lt;Character&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        set.add(<span class="hljs-string">&#x27;a&#x27;</span>);<br>        set.add(<span class="hljs-string">&#x27;e&#x27;</span>);<br>        set.add(<span class="hljs-string">&#x27;i&#x27;</span>);<br>        set.add(<span class="hljs-string">&#x27;o&#x27;</span>);<br>        set.add(<span class="hljs-string">&#x27;u&#x27;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length(), l = <span class="hljs-number">0</span>, res = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-keyword">if</span> (set.contains(ch)) &#123;<br>                ++cnt;<br>                res = Math.max(res, cnt);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (i - l + <span class="hljs-number">1</span> == k) &#123;<br>                <span class="hljs-keyword">if</span> (set.contains(s.charAt(l)))<br>                    --cnt;<br>                ++l;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="找到一个数字的-k-美丽值"><a href="https://leetcode.cn/problems/find-the-k-beauty-of-a-number/">2269. 找到一个数字的 K 美丽值</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20231006114250606.png" /></p>
<h3 id="方法一滑动窗口同向双指针-3">方法一：滑动窗口(同向双指针)</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">divisorSubstrings</span><span class="hljs-params">(<span class="hljs-type">int</span> num, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> num + <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length(), cnt = <span class="hljs-number">0</span>, x = <span class="hljs-number">0</span>, mod = (<span class="hljs-type">int</span>) Math.pow(<span class="hljs-number">10</span>, k - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; ++i) <br>            x = x * <span class="hljs-number">10</span> + (s.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (x != <span class="hljs-number">0</span> &amp;&amp; num % x == <span class="hljs-number">0</span>) <br>                ++cnt;<br>            x %= mod;<br>            x = x * <span class="hljs-number">10</span> + (s.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (x != <span class="hljs-number">0</span> &amp;&amp; num % x == <span class="hljs-number">0</span>) <br>            ++cnt;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二子串处理">方法二：子串处理</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">divisorSubstrings</span><span class="hljs-params">(<span class="hljs-type">int</span> num, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> String.valueOf(num);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length(), cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i + k &lt;= n; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> Integer.parseInt(s.substring(i, i + k));<br>            <span class="hljs-keyword">if</span> (x != <span class="hljs-number">0</span> &amp;&amp; num % x == <span class="hljs-number">0</span>)<br>                ++cnt;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="学生分数的最小差值"><a href="https://leetcode.cn/problems/minimum-difference-between-highest-and-lowest-of-k-scores/">1984. 学生分数的最小差值</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20231006120017109.png" /></p>
<h3 id="方法一排序-滑动窗口">方法一：排序 + 滑动窗口</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumDifference</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">1</span> || k == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        Arrays.sort(nums);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000001</span>, n = nums.length, l = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (i - l + <span class="hljs-number">1</span> == k) &#123;<br>                res = Math.min(res, nums[i] - nums[l]);<br>                ++l;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="子数组最大平均数-i"><a href="https://leetcode.cn/problems/maximum-average-subarray-i/">643. 子数组最大平均数 I</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20231006122034070.png" /></p>
<h3 id="方法一滑动窗口-2">方法一：滑动窗口</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">findMaxAverage</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length, l = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE, sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            sum += nums[i];<br>            <span class="hljs-keyword">if</span> (i - l + <span class="hljs-number">1</span> == k) &#123;<br>                res = Math.max(res, sum / k);<br>                sum -= nums[l++];<br>            &#125;<br>        &#125;   <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="大小为-k-且平均值大于等于阈值的子数组数目"><a href="https://leetcode.cn/problems/number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold/">1343. 大小为 K 且平均值大于等于阈值的子数组数目</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20231006122336583.png" /></p>
<h3 id="方法一滑动窗口-3">方法一：滑动窗口</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numOfSubarrays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> threshold)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>, n = arr.length, sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            sum += arr[i];<br>            <span class="hljs-keyword">if</span> (i - l + <span class="hljs-number">1</span> == k) &#123;<br>                <span class="hljs-keyword">if</span> (sum / k &gt;= threshold)<br>                    ++cnt;<br>                sum -= arr[l++];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="半径为-k-的子数组平均值"><a href="https://leetcode.cn/problems/k-radius-subarray-averages/">2090. 半径为 k 的子数组平均值</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20231006134903997.png" /></p>
<h3 id="方法一滑动数组">方法一：滑动数组</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] getAverages(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length, l = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] avg = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Arrays.fill(avg, -<span class="hljs-number">1</span>);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            sum += nums[i];<br>            <span class="hljs-keyword">if</span> (i - l + <span class="hljs-number">1</span> == <span class="hljs-number">2</span> * k + <span class="hljs-number">1</span>) &#123;<br>                avg[i - k] = (<span class="hljs-type">int</span>) (sum / (<span class="hljs-number">2</span> * k + <span class="hljs-number">1</span>));<br>                sum -= nums[l++];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> avg;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="得到-k-个黑块的最少涂色次数"><a href="https://leetcode.cn/problems/minimum-recolors-to-get-k-consecutive-black-blocks/">2379. 得到 K 个黑块的最少涂色次数</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20231006143215983.png" /></p>
<h3 id="方法一滑动窗口-4">方法一：滑动窗口</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumRecolors</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, res = <span class="hljs-number">10000</span>, l = <span class="hljs-number">0</span>, n = s.length();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;W&#x27;</span>) <br>                ++cnt;<br>            <span class="hljs-keyword">if</span> (i - l + <span class="hljs-number">1</span> == k) &#123;<br>                res = Math.min(res, cnt);<br>                cnt -= (s.charAt(l++) == <span class="hljs-string">&#x27;W&#x27;</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="爱生气的书店老板"><a href="https://leetcode.cn/problems/grumpy-bookstore-owner/">1052. 爱生气的书店老板</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20231006145800806.png" /></p>
<h3 id="方法一滑动窗口-5">方法一：滑动窗口</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSatisfied</span><span class="hljs-params">(<span class="hljs-type">int</span>[] customers, <span class="hljs-type">int</span>[] grumpy, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> customers.length, l = <span class="hljs-number">0</span>, sum = <span class="hljs-number">0</span>, res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            sum += grumpy[i] == <span class="hljs-number">0</span> ? customers[i] : <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            sum += grumpy[i] == <span class="hljs-number">1</span> ? customers[i] : <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (i - l + <span class="hljs-number">1</span> == k) &#123;<br>                res = Math.max(res, sum);<br>                <span class="hljs-keyword">if</span> (grumpy[l] == <span class="hljs-number">1</span>)<br>                    sum -= customers[l];<br>                ++l;            <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="几乎唯一子数组的最大和"><a href="https://leetcode.cn/problems/maximum-sum-of-almost-unique-subarray/">2841. 几乎唯一子数组的最大和</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20231006145934859.png" /></p>
<h3 id="方法一滑动窗口-6">方法一：滑动窗口</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">maxSum</span><span class="hljs-params">(List&lt;Integer&gt; nums, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.size(), l = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, res = <span class="hljs-number">0</span>;<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> nums.get(i);<br>            sum += x;<br>            map.put(x, map.getOrDefault(x, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (i - l + <span class="hljs-number">1</span> == k) &#123;<br>                <span class="hljs-keyword">if</span> (map.size() &gt;= m)<br>                    res = Math.max(res, sum);<br>                <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> nums.get(l++);<br>                sum -= y;<br>                map.put(y, map.get(y) - <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span> (map.get(y) == <span class="hljs-number">0</span>) <br>                    map.remove(y);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="长度为-k-子数组中的最大和"><a href="https://leetcode.cn/problems/maximum-sum-of-distinct-subarrays-with-length-k/">2461. 长度为 K 子数组中的最大和</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20231006150947193.png" /></p>
<h3 id="方法一滑动窗口-7">方法一：滑动窗口</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">maximumSubarraySum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length, cnt = <span class="hljs-number">0</span>, l = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, s = <span class="hljs-number">0</span>;<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> nums[i];<br>            s += x;<br>            <span class="hljs-keyword">if</span> (!map.containsKey(x))<br>                ++cnt;<br>            map.put(x, map.getOrDefault(x, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (i - l + <span class="hljs-number">1</span> == k) &#123;<br>                <span class="hljs-keyword">if</span> (cnt == k)<br>                    res = Math.max(res, s);<br>                <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> nums[l++];<br>                s -= y;<br>                map.put(y, map.get(y) - <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span> (map.get(y) == <span class="hljs-number">0</span>) &#123;<br>                    map.remove(y);<br>                    --cnt;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="可获得的最大点数"><a href="https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/">1423. 可获得的最大点数</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20231006151614837.png" /></p>
<h3 id="方法一逆向思维-滑动窗口">方法一：逆向思维 + 滑动窗口</h3>
<p><strong>正难则反：</strong>从数组中长出长度为<code>n - k</code>，和最小的子数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxScore</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, s = <span class="hljs-number">0</span>, l = <span class="hljs-number">0</span>, n = nums.length, res = Integer.MAX_VALUE; <span class="hljs-comment">// n = 7 , k = 3 求长度位4的最小组数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            sum += nums[i];<br>            s += nums[i];<br>            <span class="hljs-keyword">if</span> (i - l + <span class="hljs-number">1</span> == n - k) &#123;<br>                res = Math.min(res, s);<br>                s -= nums[l++];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum - (n - k == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : res);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<div class="note note-danger">
            <h2 id="最少交换次数来组合所有的-1-ii"><a href="https://leetcode.cn/problems/minimum-swaps-to-group-all-1s-together-ii/">2134. 最少交换次数来组合所有的 1 II</a></h2>
          </div>
<p><img src="C:\Users\ning\AppData\Roaming\Typora\typora-user-images\image-20231006155825337.png" /></p>
<h3 id="方法一逆向思维">方法一：逆向思维</h3>
<p><strong>统计1的个数k，以k为窗口，计算窗口内0的数量</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSwaps</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, k = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>, n = nums.length, res = n;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : nums)<br>            k += x == <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; ++i) <br>            cnt += nums[i];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> k;<br>        <span class="hljs-keyword">while</span> (l &lt; n) &#123;<br>            res = Math.min(res, k - cnt);<br>            cnt -= nums[l++ % n];<br>            cnt += nums[r++ % n];   <br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;   <br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithms</category>
        <category>Sliding Window</category>
      </categories>
      <tags>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>Trie</title>
    <url>/2023/06/06/trie/</url>
    <content><![CDATA[<div class="note note-success">
            <p>前缀树主要用于解决与字符串查找相关d</p>
          </div>
<h2 id="剑指-offer-ii-062.-实现前缀树"><a href="https://leetcode.cn/problems/QC3q1f/">剑指 Offer II 062. 实现前缀树</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230606171854583.png" /></p>
<h3 id="方法一前缀树">方法一：前缀树</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TrieNode</span> &#123;<br>        <span class="hljs-keyword">private</span> TrieNode[] children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> isWord;<br>    &#125;<br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">TrieNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>();<br>    <br>    <span class="hljs-comment">/** Inserts a word into the trie. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">TrieNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : word.toCharArray()) &#123;<br>            <span class="hljs-keyword">if</span> (node.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">null</span>)<br>                node.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>();<br>            node = node.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        node.isWord = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Returns if the word is in the trie. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">search</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">TrieNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : word.toCharArray()) &#123;<br>            <span class="hljs-keyword">if</span> (node.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            node = node.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> node.isWord;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">startsWith</span><span class="hljs-params">(String prefix)</span> &#123;<br>        <span class="hljs-type">TrieNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : prefix.toCharArray()) &#123;<br>            <span class="hljs-keyword">if</span> (node.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            node = node.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your Trie object will be instantiated and called as such:</span><br><span class="hljs-comment"> * Trie obj = new Trie();</span><br><span class="hljs-comment"> * obj.insert(word);</span><br><span class="hljs-comment"> * boolean param_2 = obj.search(word);</span><br><span class="hljs-comment"> * boolean param_3 = obj.startsWith(prefix);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>
<h2 id="剑指-offer-ii-063.-替换单词"><a href="https://leetcode.cn/problems/UhWRSj/">剑指 Offer II 063. 替换单词</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230606172122863.png" /></p>
<h3 id="一刷">一刷：</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TrieNode</span> &#123;<br>        <span class="hljs-keyword">private</span> TrieNode[] children;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> isWord;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">TrieNode</span><span class="hljs-params">()</span> &#123;<br>            children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>[<span class="hljs-number">26</span>];<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">replaceWords</span><span class="hljs-params">(List&lt;String&gt; dictionary, String sentence)</span> &#123;<br>        <span class="hljs-type">TrieNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> buildTrie(dictionary);<br>        String[] words = sentence.split(<span class="hljs-string">&quot; &quot;</span>);<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; words.length; ++i) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">prefix</span> <span class="hljs-operator">=</span> findPrefix(root, words[i]);<br>            <span class="hljs-keyword">if</span> (!prefix.isEmpty()) &#123;<br>                words[i] = prefix;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> String.join(<span class="hljs-string">&quot; &quot;</span>, words);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">findPrefix</span><span class="hljs-params">(TrieNode root, String word)</span> &#123;<br>        <span class="hljs-type">TrieNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : word.toCharArray()) &#123;<br>            <span class="hljs-keyword">if</span> (cur.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">null</span> || cur.isWord)<br>                <span class="hljs-keyword">break</span>;<br>            sb.append(ch);<br>            cur = cur.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> cur.isWord == <span class="hljs-literal">true</span> ? sb.toString() : <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> TrieNode <span class="hljs-title function_">buildTrie</span><span class="hljs-params">(List&lt;String&gt; dictionary)</span> &#123;<br>        <span class="hljs-type">TrieNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>();<br>        <span class="hljs-keyword">for</span> (String str : dictionary) &#123;<br>            <span class="hljs-type">TrieNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : str.toCharArray()) &#123;<br>                <span class="hljs-keyword">if</span> (cur.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">null</span>)<br>                    cur.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>();<br>                cur = cur.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>];<br>            &#125;<br>            cur.isWord = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="二刷">二刷</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TrieNode</span> &#123;<br>        TrieNode[] children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-type">boolean</span> isWord;<br>    &#125;<br>    <span class="hljs-type">TrieNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildDict</span><span class="hljs-params">(List&lt;String&gt; dictionary)</span> &#123;<br>        <span class="hljs-keyword">for</span> (String word : dictionary) &#123;<br>            <span class="hljs-type">TrieNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> root;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : word.toCharArray()) &#123;<br>                <span class="hljs-keyword">if</span> (node.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">null</span>)<br>                    node.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>();<br>                node = node.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>];<br>            &#125;<br>            node.isWord = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">replaceWords</span><span class="hljs-params">(List&lt;String&gt; dictionary, String sentence)</span> &#123;<br>        buildDict(dictionary);<br>        String[] words = sentence.split(<span class="hljs-string">&quot; &quot;</span>);<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(), sb = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (String word : words) &#123;<br>            <span class="hljs-type">TrieNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> root;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : word.toCharArray()) &#123;<br>                <span class="hljs-keyword">if</span> (node.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">null</span>)<br>                    <span class="hljs-keyword">break</span>;<br>                sb.append(ch);<br>                node = node.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>];<br>                <span class="hljs-keyword">if</span> (node.isWord) &#123;<br>                    sb.append(<span class="hljs-string">&quot; &quot;</span>);<br>                    res.append(sb);<br>                    sb = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            sb = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>            <span class="hljs-keyword">if</span> (!node.isWord)<br>                res.append(word + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        res.deleteCharAt(res.length() - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> res.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="剑指-offer-ii-064.-神奇的字典"><a href="https://leetcode.cn/problems/US1pGT/">剑指 Offer II 064. 神奇的字典</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230607175607726.png" /></p>
<h3 id="方法一前缀树-1">方法一：前缀树</h3>
<p><strong>注意：一定要判断root.isWord，比如字典里有“hello”，search(“hhll”)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (root.isWord &amp;&amp; index == searchWord.length() &amp;&amp; diff == <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure>
<hr />
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MagicDictionary</span> &#123;<br>    <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TrieNode</span> &#123;<br>        TrieNode[] children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-type">boolean</span> isWord;<br>    &#125; <br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-type">TrieNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>();<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildDict</span><span class="hljs-params">(String[] dictionary)</span> &#123;<br>        <span class="hljs-keyword">for</span> (String word : dictionary) &#123;<br>            <span class="hljs-type">TrieNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> root;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : word.toCharArray()) &#123;<br>                <span class="hljs-keyword">if</span> (node.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">null</span>)<br>                    node.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>();<br>                node = node.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>];<br>            &#125;<br>            node.isWord = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">search</span><span class="hljs-params">(String searchWord)</span> &#123;<br>        <span class="hljs-keyword">return</span> dfs(root, searchWord, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TrieNode root, String searchWord, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> diff)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span> || diff &gt; <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (root.isWord &amp;&amp; index == searchWord.length() &amp;&amp; diff == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (index == searchWord.length())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">found</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (found)<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">nextDiff</span> <span class="hljs-operator">=</span> i == searchWord.charAt(index) - <span class="hljs-string">&#x27;a&#x27;</span> ? diff : diff + <span class="hljs-number">1</span>;<br>            found = dfs(root.children[i], searchWord, index + <span class="hljs-number">1</span>, nextDiff);<br>        &#125;<br>        <span class="hljs-keyword">return</span> found;<br>    &#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MagicDictionary object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MagicDictionary obj = new MagicDictionary();</span><br><span class="hljs-comment"> * obj.buildDict(dictionary);</span><br><span class="hljs-comment"> * boolean param_2 = obj.search(searchWord);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithms</category>
        <category>Trie</category>
      </categories>
      <tags>
        <tag>前缀树</tag>
      </tags>
  </entry>
  <entry>
    <title>Binary Search</title>
    <url>/2023/06/06/binary-search/</url>
    <content><![CDATA[<div class="note note-warning">
            <p>mid的计算方式</p><figure class="highlight excel"><table><tr><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">int</span> mid1 = <span class="hljs-built_in">right</span> - ((<span class="hljs-built_in">right</span> - <span class="hljs-built_in">left</span>) &gt;&gt; <span class="hljs-number">1</span>);<br><span class="hljs-built_in">int</span> mid2 = <span class="hljs-built_in">left</span> + (<span class="hljs-built_in">right</span> - <span class="hljs-built_in">left</span>) / <span class="hljs-number">2</span>;<br>当<span class="hljs-built_in">right</span> = <span class="hljs-number">5</span>， <span class="hljs-built_in">left</span> = <span class="hljs-number">4</span>时<br>mid1 = <span class="hljs-number">5</span>, mid2 = <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>
          </div>
<div class="note note-primary">
            <h2 id="总结经验">总结经验</h2><ol type="1"><li><p>求大于(等于)target的最小值返回left</p><p><strong>思路：尽量执行right = mid - 1，当最后一次满足check(mid) &lt;= target并向左滑动右区间，之后只会向右滑动左区间，最后left = right + 1退出while循环，left就是最小的最大值</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (check(mid) &lt;= target) <span class="hljs-comment">// mid大了</span><br>        right = mid - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <br>        left = mid + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> left;<br></code></pre></td></tr></table></figure><ol type="1"><li>while的执行条件为<strong>left &lt;= right</strong></li><li>if (check(mid) <strong>&lt;=</strong> m) // mid大了 right = mid - 1;</li><li>return <strong>left</strong>;</li></ol><p>只要nums[mid] &gt; target，令right = mid - 1，当遇到大于target的最小值时，也会让right = mid - 1，之后在while循环中都不满足nums[mid] &gt; target，只会执行left = mid + 1，直到left = right + 1退出while循环，此时的left便是大于target的最小值</p></li><li><p>求小于target的最大值返回right</p></li></ol>
          </div>
<h2 id="搜索插入位置"><a href="https://leetcode.cn/problems/search-insert-position/">35. 搜索插入位置</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230606090557047.png" /></p>
<ol type="1">
<li><strong>求大于等于target的最小值</strong></li>
<li><strong>如果target在数组中，则会在while循环内被return</strong></li>
<li><strong>如果target不在数组中，while会遍历到left&gt;right结束循环</strong>
<ol type="1">
<li><strong>在left&gt;right的上一步一定是left == right，此时nums[mid]&lt;target，由于右边界是right，可以确定target一定小于nums[right + 1] (或者nums[right]已经是右边界了)</strong></li>
<li><strong>所以while退出循环时，left指向的位置是大于target的，插入在这个位置就好</strong></li>
</ol></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">searchInsert</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] == target)<br>                <span class="hljs-keyword">return</span> mid;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target)<br>                right = mid - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <br>                left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230606091511618.png" style="zoom:50%;" /></p>
<h2 id="剑指-offer-ii-069.-山峰数组的顶部"><a href="https://leetcode.cn/problems/B1IidL/">剑指 Offer II 069. 山峰数组的顶部</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230606093747147.png" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">peakIndexInMountainArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, right = arr.length - <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (arr[mid] &gt; arr[mid - <span class="hljs-number">1</span>] &amp;&amp; arr[mid] &gt; arr[mid + <span class="hljs-number">1</span>])<br>                <span class="hljs-keyword">return</span> mid;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[mid] &gt; arr[mid - <span class="hljs-number">1</span>])<br>                left = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230606095336759.png" style="zoom:50%;" /></p>
<div class="note note-danger">
            <h2 id="剑指-offer-ii-070.-排序数组中只出现一次的数字"><a href="https://leetcode.cn/problems/skFtm2/">剑指 Offer II 070. 排序数组中只出现一次的数字</a></h2>
          </div>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230606095525023.png" /></p>
<p><a href="https://leetcode.cn/problems/single-element-in-a-sorted-array/solution/gong-shui-san-xie-er-duan-xing-fen-xi-yu-17nv/">优质题解</a>,这道题需要在纸上模拟</p>
<p><strong>在单一元素<code>x</code>之前,成对出现的第一个元素下标一定是偶数</strong></p>
<p><strong>在单一元素<code>x</code>之后,成对出现的第一个元素下标一定是奇数</strong></p>
<p>举例</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html">数组:1 1 2 2 3 4 4 5 5<br>下标:0 1 2 3 4 5 6 7 8<br></code></pre></td></tr></table></figure>
<p>单一元素<code>x</code>的值为3,下标为4</p>
<p>在x之前,成对出现的元素有1 1, 2 2,第一个1的下标为0,第一个2的下标为2,均为偶数</p>
<p>在x之后,成对出现的元素有4 4,5 5,第一个4的下标为5,第一个5的下标为7,均为奇数</p>
<p>因此可以根据mid下标的奇偶性来进行二分</p>
<ul>
<li><p>如果mid的下标是偶数</p>
<ul>
<li>如果mid + 1 &lt; n &amp;&amp; nums[mid] == nums[mid + 1],那么单一元素<code>x</code>一定在mid + 1后,令 left = mid + 2;</li>
<li>否则,当nums[mid] != nums[mid + 1]时,mid可能就是单一元素<code>x</code>,如果不是,那么<code>x</code>也肯定在mid前面,令right = mid</li>
</ul></li>
<li><p>如果mid的下标是奇数</p>
<ul>
<li><p>如果mid - 1 &gt;= 0 &amp;&amp; nums[mid] == nums[mid - 1],那么单一元素<code>x</code>一定在mid后面,令left = mid + 1</p></li>
<li><p>否则,当nums[mid] != nums[mid - 1]时,肯定是mid - 1或者mid - 1之前出现了<code>x</code>,令right = mid - 1</p>
<ul>
<li><p>举例</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html">数组:1 2 2 4 4 <br>下标:0 1 2 3 4 <br></code></pre></td></tr></table></figure></li>
</ul></li>
</ul></li>
<li><p>当left == right时,退出循环,此时left(right)下标对应的数就是<code>x</code></p></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">singleNonDuplicate</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (mid % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (mid + <span class="hljs-number">1</span> &lt; n &amp;&amp; nums[mid] == nums[mid + <span class="hljs-number">1</span>])<br>                    left = mid + <span class="hljs-number">2</span>;<br>                <span class="hljs-keyword">else</span> <br>                    right = mid;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (mid - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[mid] == nums[mid - <span class="hljs-number">1</span>])<br>                    left = mid + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span> <br>                    right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[right];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230606110947602.png" style="zoom:50%;" /></p>
<h3 id="如果nums时未排序的那么这就是另一类经典面试题">如果nums时未排序的，那么这就是另一类经典面试题</h3>
<p><strong>将数组中所有数字异或，最终的结果就是那个唯一只出现一次的数字</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">singleNonDuplicate</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i) <br>            res = res ^ nums[i];<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<div class="note note-warning">
            <h2 id="剑指-offer-ii-071.-按权重生成随机数"><a href="https://leetcode.cn/problems/cuyjEf/">剑指 Offer II 071. 按权重生成随机数</a></h2>
          </div>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230606142800739.png" /></p>
<h3 id="方法一-前缀和-二分查找">方法一: 前缀和 + 二分查找</h3>
<p><strong>剑指offer题解</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> total;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] preSum;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Solution</span><span class="hljs-params">(<span class="hljs-type">int</span>[] w)</span> &#123;<br>        n = w.length;<br>        preSum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            total += w[i];<br>            preSum[i] += total;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pickIndex</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>        <span class="hljs-comment">// 找到大于p的最小值的下标</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> random.nextInt(total);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (preSum[mid] == p)<br>                <span class="hljs-keyword">return</span> mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (preSum[mid] &gt; p)<br>                right = mid - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <br>                left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your Solution object will be instantiated and called as such:</span><br><span class="hljs-comment"> * Solution obj = new Solution(w);</span><br><span class="hljs-comment"> * int param_1 = obj.pickIndex();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230606144221598.png" style="zoom:50%;" /></p>
<h2 id="剑指-offer-ii-072.-求平方根"><a href="https://leetcode.cn/problems/jJ0w9p/">剑指 Offer II 072. 求平方根</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230606150707313.png" /></p>
<h3 id="方法一二分查找">方法一：二分查找</h3>
<p><strong>求平方小于等于x的最大值</strong></p>
<ol type="1">
<li><strong>如果<code>x</code>取根号为整数，会在while循环被返回</strong></li>
<li><strong>如果x取根号不为整数，while循环不会return，结束时right = left - 1，<span class="math inline">\(right^2 &lt; x\)</span>并且<span class="math inline">\(left^2 &gt; x\)</span>， right就是所求答案</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mySqrt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, right = x;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> right - (right - left &gt;&gt; <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (mid == x / mid)<br>                <span class="hljs-keyword">return</span> mid;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mid &lt; x / mid)<br>                left = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> right;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230606150639618.png" style="zoom:50%;" /></p>
<h3 id="方法二二分查找另一种写法">方法二：二分查找另一种写法</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mySqrt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, right = x;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> right - (right - left &gt;&gt; <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (mid &lt;= x / mid) &#123;<br>                <span class="hljs-keyword">if</span> ((mid + <span class="hljs-number">1</span>) &gt; x / (mid + <span class="hljs-number">1</span>))<br>                    <span class="hljs-keyword">return</span> mid;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<div class="note note-warning">
            <h2 id="剑指-offer-ii-073.-狒狒吃香蕉"><a href="https://leetcode.cn/problems/nZZqjQ/">剑指 Offer II 073. 狒狒吃香蕉</a></h2>
          </div>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230606151538441.png" /></p>
<h3 id="方法一二分查找-1">方法一：二分查找</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (hours &lt;= h) &#123; <span class="hljs-comment">// 吃香蕉速度太快了</span><br>    res = mid;<br>    right = mid - <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<ol type="1">
<li>只要hours &lt;= h，说明速度太快，降低速度，并且记录这次能满足hours = h的速度</li>
<li>之后总会进入else语句，最终left &gt; right退出循环</li>
<li>最后一次记录的res就是答案</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minEatingSpeed</span><span class="hljs-params">(<span class="hljs-type">int</span>[] piles, <span class="hljs-type">int</span> h)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> pile : piles)<br>            n = Math.max(n, pile);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, right = n,res = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">hours</span> <span class="hljs-operator">=</span> getHours(mid, piles);<br>            <span class="hljs-keyword">if</span> (hours &lt;= h) &#123; <span class="hljs-comment">// 吃香蕉速度太快了</span><br>                res = mid;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getHours</span><span class="hljs-params">(<span class="hljs-type">int</span> speed, <span class="hljs-type">int</span>[] piles)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">hours</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> pile : piles)<br>            hours += (pile + speed - <span class="hljs-number">1</span>) / speed;<br>        <span class="hljs-keyword">return</span> hours;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230606155522003.png" alt=" " style="zoom:50%;" /></p>
<h3 id="方法二二分查找另一种写法-1">方法二：二分查找另一种写法</h3>
<p>与方法一类似，不过不需要用一个变量记录答案</p>
<ol type="1">
<li>最后一次满足在h小时内吃完香蕉后，right = mid - 1,这个mid就是答案</li>
<li>之后一直循环else，最后left = right + 1退出循环，这个left就是最后一次满足在h小时内吃完香蕉的su'du</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minEatingSpeed</span><span class="hljs-params">(<span class="hljs-type">int</span>[] piles, <span class="hljs-type">int</span> h)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> pile : piles)<br>            n = Math.max(n, pile);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, right = n;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">hours</span> <span class="hljs-operator">=</span> getHours(mid, piles);<br>            <span class="hljs-keyword">if</span> (hours &lt;= h) &#123; <span class="hljs-comment">// 吃香蕉速度太快了</span><br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <br>                left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getHours</span><span class="hljs-params">(<span class="hljs-type">int</span> speed, <span class="hljs-type">int</span>[] piles)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">hours</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> pile : piles)<br>            hours += (pile + speed - <span class="hljs-number">1</span>) / speed;<br>        <span class="hljs-keyword">return</span> hours;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="第一个错误的版本"><a href="https://leetcode.cn/problems/first-bad-version/">278. 第一个错误的版本</a></h2>
<p>和排序数组中只出现一次的数字类似</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230607094659183.png" /></p>
<h3 id="方法一二分查找-2">方法一：二分查找</h3>
<p>如果isBadVersion(mid)为true，说明当前版本或者之前的版本出错，那么令right = mid - 1(即使是mid出错了)往前面搜。当遇到第一个出错的版本(我们不知道是不是第一个)，并且执行right = mid - 1，之后的while循环中只会执行else部分，</p>
<p>即left = mid + 1;最终left会等于right + 1并且退出while循环，这个left就是第一个出错的版本</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* The isBadVersion API is defined in the parent class VersionControl.</span><br><span class="hljs-comment">      boolean isBadVersion(int version); */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">VersionControl</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">firstBadVersion</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, right = n;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> right - ((right - left) &gt;&gt; <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (isBadVersion(mid)) <span class="hljs-comment">// 当前版本或者之前的版本出错</span><br>                right = mid - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230607095853388.png" style="zoom:50%;" /></p>
<div class="note note-warning">
            <h2 id="寻找峰值"><a href="https://leetcode.cn/problems/find-peak-element/">162. 寻找峰值</a></h2>
          </div>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230607101713127.png" /></p>
<h3 id="方法一两端添加负无穷">方法一：两端添加负无穷</h3>
<p>一定要return 0，解决只有一个数的用例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findPeakElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length, left = <span class="hljs-number">1</span>, right = n;<br>        <span class="hljs-type">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            nums[i + <span class="hljs-number">1</span>] = arr[i];<br>        nums[<span class="hljs-number">0</span>] = nums[n + <span class="hljs-number">1</span>] = Integer.MIN_VALUE;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> right - ((right - left) &gt;&gt; <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (nums[mid] &gt; nums[mid - <span class="hljs-number">1</span>] &amp;&amp; nums[mid] &gt; nums[mid + <span class="hljs-number">1</span>])<br>                <span class="hljs-keyword">return</span> mid - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &lt; nums[mid + <span class="hljs-number">1</span>])<br>                left = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <br>                right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230607105134318.png" style="zoom:50%;" /></p>
<h3 id="方法二">方法二：</h3>
<p>int mid = left + (right - left) / 2; // mid要选较小的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findPeakElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length, left = <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>; <span class="hljs-comment">// mid要选较小的</span><br>            <span class="hljs-keyword">if</span> (mid + <span class="hljs-number">1</span> &lt; n &amp;&amp; nums[mid] &gt; nums[mid + <span class="hljs-number">1</span>])<br>                right = mid;<br>            <span class="hljs-keyword">else</span><br>                left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="有效的完全平方数"><a href="https://leetcode.cn/problems/valid-perfect-square/">367. 有效的完全平方数</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230607112819820.png" /></p>
<h3 id="方法一二分查找-3">方法一：二分查找</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPerfectSquare</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, right = num;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> right - ((right - left) &gt;&gt; <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (mid == num / mid &amp;&amp; num % mid == <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (mid &gt; num / mid)<br>                right = mid - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;	<br></code></pre></td></tr></table></figure>
<h2 id="寻找比目标字母大的最小字母"><a href="https://leetcode.cn/problems/find-smallest-letter-greater-than-target/">744. 寻找比目标字母大的最小字母</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230607121228926.png" /></p>
<p><strong>求大于target的最小值</strong></p>
<ol type="1">
<li><strong>首先判断target是否大于letters中最后一个字符，如果大于，直接返回letters[0]</strong></li>
<li>进入while循环，如果letters[mid] - 'a' &lt;= target - 'a'，令left = mid + 1，<strong>最后一次执行这个else循环的letters[mid]就是答案</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">char</span> <span class="hljs-title function_">nextGreatestLetter</span><span class="hljs-params">(<span class="hljs-type">char</span>[] letters, <span class="hljs-type">char</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = letters.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (target - <span class="hljs-string">&#x27;a&#x27;</span> &gt;= letters[right] - <span class="hljs-string">&#x27;a&#x27;</span>)<br>            <span class="hljs-keyword">return</span> letters[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (letters[mid] - <span class="hljs-string">&#x27;a&#x27;</span> &gt; target - <span class="hljs-string">&#x27;a&#x27;</span>) <br>                right = mid - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> letters[left];<br>    &#125;   <br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230607141748244.png" style="zoom:50%;" /></p>
<div class="note note-danger">
            <h2 id="在排序数组中查找元素的第一个和最后一个位置"><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></h2>
          </div>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230607143248142.png" /></p>
<h3 id="方法一二分查找-4">方法一：二分查找</h3>
<p><strong>二分两次，第一次找大于等于target的最小值，第二次找小于等于target的最大值，从而找到target第一个以及最后一个位置</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] searchRange(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">resL</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>, resR = -<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &gt;= target)<br>                right = mid - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (left &gt;= <span class="hljs-number">0</span> &amp;&amp; left &lt; nums.length)<br>            resL = nums[left] == target ? left : -<span class="hljs-number">1</span>;<br>        left = <span class="hljs-number">0</span>;<br>        right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &gt; target)<br>                right = mid - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (right &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt; nums.length)<br>            resR = nums[right] == target ? right : -<span class="hljs-number">1</span>;<br>        res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;resL, resR&#125;;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230607153550678.png" style="zoom:50%;" /></p>
<div class="note note-danger">
            <h2 id="分割数组的最大值"><a href="https://leetcode.cn/problems/split-array-largest-sum/">410. 分割数组的最大值</a></h2>
          </div>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230607154014116.png" /></p>
<p><a href="https://leetcode.cn/problems/split-array-largest-sum/solution/er-fen-cha-zhao-by-liweiwei1419-4/">优质题解</a></p>
<h3 id="方法一二分查找-5">方法一：二分查找</h3>
<p>不能写成getSplitNum(nums, mid) &gt;= k，以下这个例子</p>
<p>输入：nums = [7,2,5,10,8], m = 2 输出：18 解释： 一共有四种方法将 nums 分割为 2 个子数组。 其中最好的方式是将其分为 [7,2,5] 和 [10,8] 。 因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。</p>
<p>如果写成getSplitNum(nums, mid) &gt;= k，当mid=21(答案是18),得到的getSplitNum(nums, mid) = 2 &gt;= k，会继续让mid往更大的方向搜</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (getSplitNum(nums, mid) &gt; k)<br>    left = mid + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span><br>    <span class="hljs-comment">// 分割的数量太少，mid选大了</span><br>    right = mid - <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">splitArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        1.如果把数组分割成n个子数组，那么n个子数组各自和的最大值为数组中的最大值</span><br><span class="hljs-comment">        2.如果把数组分割成1个子数组，那么这个子数组的最大值为数组的和</span><br><span class="hljs-comment">        把以上两种情况返回的最大值当作二分查找的左右边界</span><br><span class="hljs-comment">        每次选择一个中间值mid用于分割数组，被分割的数组和必须小于等于mid，返回分割的子数组个数splitNum</span><br><span class="hljs-comment">        目标是确定一个恰当的「子数组各自的和的最大值」，使得它对应的「子数组的分割数」恰好等于 m</span><br><span class="hljs-comment">        如果splitNum &gt; k，说明mid小了，选更大的值可以让</span><br><span class="hljs-comment">        * */</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num: nums) &#123;<br>            <span class="hljs-keyword">if</span> (left &lt; num)<br>                left = num;<br>            right += num;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 分割的数量太多，mid选小了</span><br>            <span class="hljs-keyword">if</span> (getSplitNum(nums, mid) &gt; k)<br>                left = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-comment">// 分割的数量太少，mid选大了</span><br>                right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSplitNum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> maxSum)</span> &#123;<br>        <span class="hljs-comment">// [至少是一个分割] [当前区间的和]</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">splitNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, curSum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-keyword">if</span> (curSum + num &gt; maxSum) &#123;<br>                ++splitNum;<br>                curSum = <span class="hljs-number">0</span>;<br>            &#125;<br>            curSum += num;<br>        &#125;<br>        <span class="hljs-keyword">return</span> splitNum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230607164413605.png" style="zoom:50%;" /></p>
<h3 id="二刷">二刷</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">splitArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : nums) &#123;<br>            r += x;<br>            l = Math.max(l, x);<br>        &#125;<br>        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// k个桶，容量上限为mid，是否能容纳所有数组元素</span><br>            <span class="hljs-keyword">if</span> (check(nums, k, mid)) <span class="hljs-comment">// 如果能容纳，mid上限选大了或者刚刚好</span><br>                r = mid - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> l;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> mid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">bucket</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : nums) &#123;<br>            <span class="hljs-keyword">if</span> (sum + x &gt; mid) &#123;<br>                ++bucket;<br>                sum = <span class="hljs-number">0</span>;<br>            &#125;<br>            sum += x;<br>        &#125;<br>        <span class="hljs-keyword">return</span> bucket &lt;= k;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230621102440093.png" /></p>
<div class="note note-primary">
            <h2 id="lcp-12.-小张刷题计划"><a href="https://leetcode.cn/problems/xiao-zhang-shua-ti-ji-hua/">LCP 12. 小张刷题计划</a></h2>
          </div>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230608093912477.png" /></p>
<p><strong>和分割数组的最大值相比，加了一个条件，每个分割后的数组减去其中的最大值</strong></p>
<p><strong>getSpendDay函数，在每一个新的一天第一次要刷的题先不加入totalTime，先记录maxTime，最后少计入时长的那道题就是需要花费时间最长的题</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minTime</span><span class="hljs-params">(<span class="hljs-type">int</span>[] time, <span class="hljs-type">int</span> m)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> t : time)<br>            right += t;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (getSpendDay(time, mid) &lt;= m) <span class="hljs-comment">// mid大了</span><br>                right = mid - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <br>                left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSpendDay</span><span class="hljs-params">(<span class="hljs-type">int</span>[] time, <span class="hljs-type">int</span> limit)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">totalTime</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, maxTime = <span class="hljs-number">0</span>, day = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> t : time) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">nextTime</span> <span class="hljs-operator">=</span> Math.min(maxTime, t);<br>            <span class="hljs-keyword">if</span> (totalTime + nextTime &lt;= limit) &#123;<br>                totalTime += nextTime;<br>                maxTime = Math.max(maxTime, t);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                ++day;<br>                totalTime = <span class="hljs-number">0</span>;<br>                maxTime = t;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> day;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230608103235418.png" style="zoom:50%;" /></p>
<h2 id="制作-m-束花所需的最少天数"><a href="https://leetcode.cn/problems/minimum-number-of-days-to-make-m-bouquets/">1482. 制作 m 束花所需的最少天数</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230608103709875.png" /></p>
<h3 id="方法一二分查找-6">方法一：二分查找</h3>
<ol type="1">
<li><p><strong>求能满足条件的最小值</strong></p></li>
<li><p>如果用以下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (check(bloomDay, k, mid) &lt;= m) <span class="hljs-comment">// 天数不够凑成m束花</span><br>    left = mid + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> <br>    right = mid - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> right;<br></code></pre></td></tr></table></figure>
<p>举例</p>
<p>输入：bloomDay = [1,10,3,10,2], m = 3, k = 1 输出：3 解释：让我们一起观察这三天的花开过程，x 表示花开，而 _ 表示花还未开。 现在需要制作 3 束花，每束只需要 1 朵。 1 天后：[x, <em>, </em>, <em>, </em>] // 只能制作 1 束花 2 天后：[x, <em>, </em>, _, x] // 只能制作 2 束花 3 天后：[x, <em>, x, </em>, x] // 可以制作 3 束花，答案为 3</p>
<p>mid == 5，check(bloomDay, k, mid) == 3(m)，此时还左区间还要向右边滑动当然错了</p></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minDays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] bloomDay, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">        摘m束花的最小等待天数:能满足条件的最小值</span><br><span class="hljs-comment">        等待bloomDay数组中的最大元素天能摘n束花</span><br><span class="hljs-comment">        等待bloomDay 0天摘0束花</span><br><span class="hljs-comment">        在这两者之间二分</span><br><span class="hljs-comment">        如果选取的天数能凑成小于m束花，则left = mid + 1</span><br><span class="hljs-comment">        如果选取的天数能凑成大于m束花，则right = mid - 1</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> bloomDay.length;<br>        <span class="hljs-keyword">if</span> (n / m &lt; k)<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> flower : bloomDay)<br>            right = Math.max(right, flower);<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (check(bloomDay, k, mid) &lt; m) <span class="hljs-comment">// 天数不够凑成m束花</span><br>                left = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <br>                right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span>[] bloomDay, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> days)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">bouquets</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, curFlower = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> flower : bloomDay) &#123;<br>            <span class="hljs-keyword">if</span> (flower &lt;= days) &#123;<br>                ++curFlower;<br>                <span class="hljs-keyword">if</span> (curFlower == k) &#123;<br>                    ++bouquets;<br>                    curFlower = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                curFlower = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> bouquets;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230608145008008.png" style="zoom:50%;" /></p>
<h2 id="在-d-天内送达包裹的能力"><a href="https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/">1011. 在 D 天内送达包裹的能力</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230608111745713.png" /></p>
<p><strong>和分割数组的最大值一样</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">shipWithinDays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] weights, <span class="hljs-type">int</span> days)</span> &#123;<br>        <span class="hljs-comment">// 把weights数组分割为days份，求最大的被分割子数组和的最小值</span><br>        <span class="hljs-comment">// 当运载能力为数组中最大的元素时，最多n天运输完所有货物</span><br>        <span class="hljs-comment">// 当运载能力为数组的和时，一天能运输完所有货物</span><br>        <span class="hljs-comment">// 在这两者之间进行二分</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> weights.length, left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> w : weights) &#123;<br>            left = Math.max(left, w);<br>            right += w;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (check(weights, mid) &lt;= days) <span class="hljs-comment">// 运载能力太强了</span><br>                right = mid - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <br>                left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span>[] weights, <span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, spendDay = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> w : weights) &#123;<br>            <span class="hljs-keyword">if</span> (total + w &lt;= capacity) <br>                total += w;<br>            <span class="hljs-keyword">else</span> &#123;<br>                ++spendDay;<br>                total = w;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> spendDay;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230608113138180.png" style="zoom:50%;" /></p>
<div class="note note-primary">
            <h2 id="两球之间的磁力"><a href="https://leetcode.cn/problems/magnetic-force-between-two-balls/">1552. 两球之间的磁力</a></h2>
          </div>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230608113242741.png" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDistance</span><span class="hljs-params">(<span class="hljs-type">int</span>[] position, <span class="hljs-type">int</span> m)</span> &#123;<br>        <span class="hljs-comment">/** 1.最小的最大值：尽量执行left = mid + 1,最后一次执行它后，之后都只会执行right = mid - 1</span><br><span class="hljs-comment">        最后right = left - 1退出循环，此时的right就是最小的最大值</span><br><span class="hljs-comment">        2.二分查找当前磁力(最小求间距)是否可以放得下m个球</span><br><span class="hljs-comment">        3.如果放得下m个球，增大球间距</span><br><span class="hljs-comment">        4.如果放不下m个球，减小球间距</span><br><span class="hljs-comment">        */</span><br>        Arrays.sort(position);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> position.length, left = <span class="hljs-number">1</span>, right = position[n - <span class="hljs-number">1</span>] - position[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (check(position, mid) &gt;= m)<br>                left = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> right;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span>[] position, <span class="hljs-type">int</span> limit)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> position[<span class="hljs-number">0</span>], count = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; position.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (position[i] - pre &gt;= limit) &#123;<br>                pre = position[i];<br>                ++count;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230608132847904.png" style="zoom:50%;" /></p>
]]></content>
      <categories>
        <category>Algorithms</category>
        <category>Binary Search</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>Maze Problem</title>
    <url>/2023/06/05/maze-problem/</url>
    <content><![CDATA[<h2 id="被围绕的区域"><a href="https://leetcode.cn/problems/surrounded-regions/">130. 被围绕的区域</a></h2>
<p>​ <img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230611150645399.png" /></p>
<h3 id="方法一dfs">方法一：DFS</h3>
<ol type="1">
<li><p>从边界出发，把边界以及与边界连通的O<code>标记为</code>B`</p></li>
<li><p>遍历整个board，把<code>B</code>还原为<code>O</code>，把<code>O</code>(此时的O是被X包围的)改变为<code>X</code></p></li>
<li><p>没有这句死循环，m == 1，( i += 0)</p>
<pre><code class="hljs">    if (m &lt;= 2 || n &lt;= 2)
        return;</code></pre></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">solve</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board)</span> &#123;<br>        m = board.length;<br>        n = board[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">if</span> (m &lt;= <span class="hljs-number">2</span> || n &lt;= <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i += m - <span class="hljs-number">1</span>) <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) <br>                <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;O&#x27;</span>)<br>                    dfs(i, j, board);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j += n - <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i)<br>                <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;O&#x27;</span>)<br>                    dfs(i, j, board);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;B&#x27;</span>)<br>                    board[i][j] = <span class="hljs-string">&#x27;O&#x27;</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;O&#x27;</span>)<br>                    board[i][j] = <span class="hljs-string">&#x27;X&#x27;</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-type">int</span> m, n;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">char</span>[][] board)</span> &#123;<br>        board[i][j] = <span class="hljs-string">&#x27;B&#x27;</span>; <span class="hljs-comment">// backtrack</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], col = j + dir[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (isValid(row, col) &amp;&amp; board[row][col] == <span class="hljs-string">&#x27;O&#x27;</span>)<br>                dfs(row, col, board);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &lt; n;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230611150714241.png" style="zoom:50%;" /></p>
<h3 id="方法二bfs">方法二：BFS</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">solve</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board)</span> &#123;<br>        <span class="hljs-built_in">this</span>.board = board;<br>        m = board.length;<br>        n = board[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">if</span> (m &lt;= <span class="hljs-number">2</span> || n &lt;= <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span>;<br>        Queue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i += m - <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j)<br>                <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;O&#x27;</span>)<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, j&#125;);<br>                    <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j += n - <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m - <span class="hljs-number">1</span>; ++i)<br>                 <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;O&#x27;</span>)<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, j&#125;);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span>[] node = queue.poll();<br>            board[node[<span class="hljs-number">0</span>]][node[<span class="hljs-number">1</span>]] = <span class="hljs-string">&#x27;#&#x27;</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> node[<span class="hljs-number">0</span>] + dir[<span class="hljs-number">0</span>], col = node[<span class="hljs-number">1</span>] + dir[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span> (isValid(row, col) &amp;&amp; board[row][col] == <span class="hljs-string">&#x27;O&#x27;</span>)<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;row, col&#125;);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;#&#x27;</span>)<br>                    board[i][j] = <span class="hljs-string">&#x27;O&#x27;</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;O&#x27;</span>)<br>                    board[i][j] = <span class="hljs-string">&#x27;X&#x27;</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        board[i][j] = <span class="hljs-string">&#x27;#&#x27;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], col = j + dir[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (isValid(row, col) &amp;&amp; board[row][col] == <span class="hljs-string">&#x27;O&#x27;</span>) &#123;<br>                dfs(row, col);<br>            &#125;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col)</span> &#123;<br>        <span class="hljs-keyword">return</span> row &lt; m &amp;&amp; row &gt;= <span class="hljs-number">0</span> &amp;&amp; col &lt; n &amp;&amp; col &gt;= <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-type">int</span> m, n;<br>    <span class="hljs-type">char</span>[][] board;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法三并查集">方法三：并查集</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> 背包;<br><br><br><span class="hljs-keyword">import</span> java.awt.image.VolatileImage;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">solve</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board)</span> &#123;<br>        <span class="hljs-built_in">this</span>.board = board;<br>        m = board.length;<br>        n = board[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">if</span> (m &lt;= <span class="hljs-number">2</span> || n &lt;= <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span>;<br>        init(m * n + <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> m * n;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;O&#x27;</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> || i == m - <span class="hljs-number">1</span> || j == <span class="hljs-number">0</span> || j == n - <span class="hljs-number">1</span>)<br>                        union(n * i + j, dummy);<br>                    <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>                            <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], col = j + dir[<span class="hljs-number">1</span>];<br>                            <span class="hljs-keyword">if</span> (isValid(row, col) &amp;&amp; board[row][col] == <span class="hljs-string">&#x27;O&#x27;</span>)<br>                                union(row * n + col, i * n + j);<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;O&#x27;</span> &amp;&amp; findParent(i * n + j) != dummy)<br>                    board[i][j] = <span class="hljs-string">&#x27;X&#x27;</span>;<br>            &#125;<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-type">int</span>[] parent;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rootI</span> <span class="hljs-operator">=</span> findParent(i), rootJ = findParent(j);<br>        <span class="hljs-keyword">if</span> (rootI != rootJ) &#123;<br>            parent[rootI] = rootJ;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findParent</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i != parent[i])<br>            parent[i] = findParent(parent[i]);<br>        <span class="hljs-keyword">return</span> parent[i];<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        parent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            parent[i] = i;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col)</span> &#123;<br>        <span class="hljs-keyword">return</span> row &lt; m &amp;&amp; row &gt;= <span class="hljs-number">0</span> &amp;&amp; col &lt; n &amp;&amp; col &gt;= <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-type">int</span> m, n;<br>    <span class="hljs-type">char</span>[][] board;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Solution</span> <span class="hljs-variable">solution</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Solution</span>();<br>        <span class="hljs-type">char</span>[][] board = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[][]&#123;&#123;<span class="hljs-string">&#x27;O&#x27;</span>,<span class="hljs-string">&#x27;O&#x27;</span>,<span class="hljs-string">&#x27;O&#x27;</span>&#125;, &#123;<span class="hljs-string">&#x27;O&#x27;</span>,<span class="hljs-string">&#x27;O&#x27;</span>,<span class="hljs-string">&#x27;O&#x27;</span>&#125;, &#123;<span class="hljs-string">&#x27;O&#x27;</span>,<span class="hljs-string">&#x27;O&#x27;</span>,<span class="hljs-string">&#x27;O&#x27;</span>&#125;&#125;;<br>        solution.solve(board);<br>        System.out.println(board);<br><br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="岛屿数量"><a href="https://leetcode.cn/problems/number-of-islands/">200. 岛屿数量</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230611151356910.png" /></p>
<h3 id="方法一dfs-1">方法一：DFS</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numIslands</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] grid)</span> &#123;<br>        m = grid.length;<br>        n = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                    dfs(i, j, grid);<br>                    ++res;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, m, n;<br>    <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">char</span>[][] grid)</span> &#123;<br>        grid[i][j] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], col = j + dir[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (isValid(row, col) &amp;&amp; grid[row][col] == <span class="hljs-string">&#x27;1&#x27;</span>)<br>                dfs(row, col, grid);<br>        &#125;<br><br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;=<span class="hljs-number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &lt; n;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230611152306889.png" style="zoom:50%;" /></p>
<h3 id="方法二bfs-1">方法二：BFS</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numIslands</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] grid)</span> &#123;<br>        m = grid.length;<br>        n = grid[<span class="hljs-number">0</span>].length;<br>        Queue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                    bfs(queue, i, j, grid);<br>                    ++res;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, m, n;<br>    <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bfs</span><span class="hljs-params">(Queue&lt;<span class="hljs-type">int</span>[]&gt; queue, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">char</span>[][] grid)</span> &#123;<br>        queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, j&#125;);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span>[] node = queue.poll();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> node[<span class="hljs-number">0</span>] + dir[<span class="hljs-number">0</span>], col = node[<span class="hljs-number">1</span>] + dir[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span> (isValid(row, col) &amp;&amp; grid[row][col] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                    grid[row][col] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;row, col&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br>       <br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;=<span class="hljs-number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &lt; n;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230611153421224.png" style="zoom:50%;" /></p>
<h2 id="矩阵中的最长递增路径"><a href="https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/">329. 矩阵中的最长递增路径</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230611153554985.png" /></p>
<h3 id="方法一dfs-记忆化搜索">方法一：DFS + 记忆化搜索</h3>
<ol type="1">
<li><p>如果之前计算过dp[i][j]，直接返回dp[i][j]</p></li>
<li><p>计算从matrix[i][j]为起点的最长路径，并用max记录最大值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (isValid(row, col) &amp;&amp; matrix[row][col] &gt; matrix[i][j]) &#123;<br>    max = Math.max(max, dfs(row, col, matrix));<br></code></pre></td></tr></table></figure></li>
<li><p>返回上一个节点的时候需要加上1，因为当前节点也需要加上，并用dp[i][j]记录</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">return</span> dp[i][j] = max + <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestIncreasingPath</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        m = matrix.length;<br>        n = matrix[<span class="hljs-number">0</span>].length;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) <br>                res = Math.max(res, dfs(i, j, matrix));<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, m, n;<br>    <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;, dp;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-keyword">if</span> (dp[i][j] != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> dp[i][j];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], col = j + dir[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (isValid(row, col) &amp;&amp; matrix[row][col] &gt; matrix[i][j]) &#123;<br>                max = Math.max(max, dfs(row, col, matrix));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[i][j] = max + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &lt; n;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230611155235937.png" style="zoom:50%;" /></p>
<h3 id="二刷">二刷</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestIncreasingPath</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        m = matrix.length;<br>        n = matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-built_in">this</span>.matrix = matrix;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) <br>                res = Math.max(res, dfs(i, j));<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-type">int</span>[][] matrix, dp, dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-type">int</span> m, n, res = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">if</span> (dp[i][j] != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> dp[i][j];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], col = j + dir[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (isValid(row, col) &amp;&amp; matrix[i][j] &lt; matrix[row][col])<br>                len = dfs(row, col) + <span class="hljs-number">1</span>;<br>            max = Math.max(len, max);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[i][j] = max;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; n;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="太平洋大西洋水流问题"><a href="https://leetcode.cn/problems/pacific-atlantic-water-flow/">417. 太平洋大西洋水流问题</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230611160147316.png" /></p>
<h3 id="三刷dfs">三刷DFS</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">pacificAtlantic</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] heights)</span> &#123;<br>        m = heights.length;<br>        n = heights[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-built_in">this</span>.heights = heights;<br>        <span class="hljs-type">boolean</span>[][] pacific = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n], atlantic = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>            dfs(<span class="hljs-number">0</span>, j, pacific);<br>            dfs(m - <span class="hljs-number">1</span>, j, atlantic);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            dfs(i, <span class="hljs-number">0</span>, pacific);<br>            dfs(i, n - <span class="hljs-number">1</span>, atlantic);<br>        &#125;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j)<br>                <span class="hljs-keyword">if</span> (pacific[i][j] &amp;&amp; atlantic[i][j])<br>                    res.add(Arrays.asList(i, j));<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-type">int</span>[][] heights, dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-type">int</span> m, n;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">boolean</span>[][] ocean)</span> &#123;<br>        ocean[i][j] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], col = j + dir[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (isValid(row, col) &amp;&amp; !ocean[row][col] &amp;&amp; heights[row][col] &gt;= heights[i][j]) <br>                dfs(row, col, ocean);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &gt;=<span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &lt; n;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="二刷dfs">二刷DFS</h3>
<p><strong>把四条边先标记好，然后dfs</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">pacificAtlantic</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] heights)</span> &#123;<br>        m = heights.length;<br>        n = heights[<span class="hljs-number">0</span>].length;<br>        pacific = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n];<br>        atlantic = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j)<br>            pacific[<span class="hljs-number">0</span>][j] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i)<br>            pacific[i][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j)<br>            atlantic[m - <span class="hljs-number">1</span>][j] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i)<br>            atlantic[i][n - <span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) <br>                <span class="hljs-keyword">if</span> (pacific[i][j] || atlantic[i][j]) <br>                    dfs(i, j, heights);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) <br>                <span class="hljs-keyword">if</span> (pacific[i][j] &amp;&amp; atlantic[i][j])<br>                    res.add(Arrays.asList(i, j));<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-type">boolean</span>[][] pacific, atlantic;<br>    <span class="hljs-type">int</span> m, n;<br>    <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>     <br>     <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span>[][]heights)</span> &#123;<br>         <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>             <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], col = j + dir[<span class="hljs-number">1</span>];<br>             <span class="hljs-keyword">if</span> (isValid(row, col) &amp;&amp; heights[row][col] &gt;= heights[i][j]) &#123;<br>                <span class="hljs-keyword">if</span> (pacific[i][j] &amp;&amp; !pacific[row][col]) &#123;<br>                    pacific[row][col] = <span class="hljs-literal">true</span>;<br>                    dfs(row, col, heights);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (atlantic[i][j] &amp;&amp; !atlantic[row][col]) &#123;<br>                    atlantic[row][col] = <span class="hljs-literal">true</span>;<br>                    dfs(row, col, heights);<br>                &#125;<br>             &#125;<br>         &#125;<br>     &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &lt; n;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230611181549966.png" style="zoom:50%;" /></p>
<h2 id="岛屿的周长"><a href="https://leetcode.cn/problems/island-perimeter/">463. 岛屿的周长</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230611193258993.png" /></p>
<h3 id="方法一dfs-2">方法一：DFS</h3>
<ol type="1">
<li><strong>初始每个陆地的边长都为4，如果周围有一个相连的陆地，那么周长-1，如上图grid[1][1]，上下左右都有陆地，所以它拥有的边长为4 - 4 = 0</strong></li>
<li><strong>只要陆地i, j的邻居row, col不是水域，那么先将周长减一</strong>
<ol type="1">
<li>如果grid[row][col] == 2，说明之前访问过，不需要继续dfs，但是需要讲周长减一</li>
<li>如果grid[row][col] == 1，周长需要减一并且需要dfs访问</li>
</ol></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (isValid(row, col) &amp;&amp; grid[row][col] != <span class="hljs-number">0</span>) &#123;<br>   --length;<br>   <span class="hljs-keyword">if</span> (grid[row][col] == <span class="hljs-number">1</span>)<br>       dfs(row, col, grid);<br></code></pre></td></tr></table></figure>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">islandPerimeter</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        m = grid.length;<br>        n = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) <br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>) <br>                    dfs(i, j, grid);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, m, n;<br>    <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        grid[i][j] = <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], col = j + dir[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (isValid(row, col) &amp;&amp; grid[row][col] != <span class="hljs-number">0</span>) &#123;<br>                --length;<br>                <span class="hljs-keyword">if</span> (grid[row][col] == <span class="hljs-number">1</span>)<br>                    dfs(row, col, grid);<br>            &#125;<br>        &#125;<br>        res += length; <br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &lt; n;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二bfs-2">方法二：BFS</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">islandPerimeter</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        m = grid.length;<br>        n = grid[<span class="hljs-number">0</span>].length;<br>        Queue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j)<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>) &#123;<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, j&#125;);<br>                    grid[i][j] = <span class="hljs-number">2</span>;<br>                    bfs(i, j, grid, queue);<br>                    <span class="hljs-keyword">return</span> res;<br>                &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, m, n;<br>    <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span>[][] grid, Queue&lt;<span class="hljs-type">int</span>[]&gt; queue)</span> &#123;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span>[] node = queue.poll();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> node[<span class="hljs-number">0</span>] + dir[<span class="hljs-number">0</span>], col = node[<span class="hljs-number">1</span>] + dir[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span> (isValid(row, col) &amp;&amp; grid[row][col] != <span class="hljs-number">0</span>) &#123;<br>                    --length;<br>                    <span class="hljs-keyword">if</span> (grid[row][col] == <span class="hljs-number">1</span>) &#123;<br>                        grid[row][col] = <span class="hljs-number">2</span>;<br>                        queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;row, col&#125;);<br>                    &#125;<br>                &#125;<br>            &#125;<br>            res += length;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &lt; n;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="岛屿的最大面积"><a href="https://leetcode.cn/problems/max-area-of-island/">695. 岛屿的最大面积</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230612094903323.png" /></p>
<h3 id="方法一dfs-3">方法一：DFS</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxAreaOfIsland</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        m = grid.length;<br>        n = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j)<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>)<br>                    res = Math.max(res, dfs(i, j, grid));<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> m, n, res = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;&#125;;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        grid[i][j] = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], col = j + dir[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (isValid(row, col) &amp;&amp; grid[row][col] == <span class="hljs-number">1</span>)<br>                length += dfs(row, col, grid);<br>        &#125;<br>        <span class="hljs-keyword">return</span> length;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &lt; n;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230612094842476.png" style="zoom:50%;" /></p>
<h3 id="方法二并查集">方法二：并查集</h3>
<p><strong>注意</strong></p>
<ol type="1">
<li><p>只有当grid[i][j] == 1时才判断</p>
<ol type="1">
<li><p>如果row,col不超过边界，且grid[row][col]是陆地(1或者2)，且没有被访问过(如果访问过，</p>
<p>那么grid[i][j]与grid[row][col]的parent一致)，则将grid[i][j]赋值2(1表示没有被访问的陆地，2表示被访问过的陆地)</p></li>
<li><p>如果row,col不超过边界，且grid[row][col]是陆地(1或者2)，但是被访问过(此时也会绑定grid[i][j]与grid[row][col]的parent)，不执行</p></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], col = j + dir[<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 1.不超过边界 2.是陆地 3.没有被访问过</span><br>        <span class="hljs-keyword">if</span> (isValid(row, col) &amp;&amp; grid[row][col] != <span class="hljs-number">0</span> &amp;&amp; union(i * n + j, row * n + col))<br>            grid[i][j] = <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>遍历所有陆地，将每块陆地的祖先存入map，值为子孙的数量，那么含有最大子孙的数量就是岛屿最大数量</p>
<p>map进行put操作时，key为<code>findParent(i * n + j)</code>，因为在之前进行<code>union</code>的过程(parent[parentOfI] = parentOfJ)，直接将i的祖先的祖先赋值为j的祖先，但是此时i的祖先还没有同步，所以这里是进行一个祖先同步的操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) <br>        <span class="hljs-keyword">if</span> (grid[i][j] != <span class="hljs-number">0</span>) &#123;<br>            map.put(findParent(i * n + j), map.getOrDefault(parent[i * n + j], <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            res = Math.max(res, map.get(parent[i * n + j]));<br>        &#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxAreaOfIsland</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        m = grid.length;<br>        n = grid[<span class="hljs-number">0</span>].length;<br>        init(m, n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j)<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], col = j + dir[<span class="hljs-number">1</span>];<br>                        <span class="hljs-comment">// 1.不超过边界 2.是陆地 3.没有被访问过</span><br>                        <span class="hljs-keyword">if</span> (isValid(row, col) &amp;&amp; grid[row][col] != <span class="hljs-number">0</span> &amp;&amp; union(i * n + j, row * n + col))<br>                            grid[i][j] = <span class="hljs-number">2</span>;<br>                    &#125;<br>                &#125;<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) <br>                <span class="hljs-keyword">if</span> (grid[i][j] != <span class="hljs-number">0</span>) &#123;<br>                    map.put(findParent(i * n + j), map.getOrDefault(parent[i * n + j], <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>                    res = Math.max(res, map.get(parent[i * n + j]));<br>                &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-type">int</span> m, n, res = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;&#125;;<br>    <span class="hljs-type">int</span>[] parent;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        parent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m * n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m * n; ++i)<br>            parent[i] = i;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findParent</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-keyword">return</span> i == parent[i] ? parent[i] : (parent[i] = findParent(parent[i]));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">parentOfI</span> <span class="hljs-operator">=</span> findParent(i), parentOfJ = findParent(j);<br>        <span class="hljs-keyword">if</span> (parentOfI != parentOfJ) &#123;<br>            parent[parentOfI] = parentOfJ;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &lt; n;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="二刷并查集">二刷并查集</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxAreaOfIsland</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-built_in">this</span>.grid = grid;<br>        m = grid.length;<br>        n = grid[<span class="hljs-number">0</span>].length;<br>        init(m * n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], col = j + dir[<span class="hljs-number">1</span>];<br>                        <span class="hljs-keyword">if</span> (isValid(row, col) &amp;&amp; grid[row][col] == <span class="hljs-number">1</span>)<br>                            union(i * n + j, row * n + col);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j)<br>                <span class="hljs-keyword">if</span> (grid[i][j] != <span class="hljs-number">0</span>) &#123;<br>                    map.put(findParent(i * n + j), map.getOrDefault(parent[i * n + j], <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>                    res = Math.max(res, map.get(parent[i * n + j]));<br>                &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &lt; n;<br>    &#125;<br><br>    <span class="hljs-type">int</span> m, n;<br>    <span class="hljs-type">int</span>[][] grid, dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-type">int</span>[] parent;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rootI</span> <span class="hljs-operator">=</span> findParent(i), rootJ = findParent(j);<br>        <span class="hljs-keyword">if</span> (rootI != rootJ) &#123;<br>            parent[rootI] = rootJ;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findParent</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i != parent[i])<br>            parent[i] = findParent(parent[i]);<br>        <span class="hljs-keyword">return</span> parent[i];<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        parent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            parent[i] = i;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="图像渲染"><a href="https://leetcode.cn/problems/flood-fill/">733. 图像渲染</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230612105745985.png" /></p>
<h3 id="方法一bfs">方法一：BFS</h3>
<h4 id="二刷-1">二刷</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] floodFill(<span class="hljs-type">int</span>[][] image, <span class="hljs-type">int</span> sr, <span class="hljs-type">int</span> sc, <span class="hljs-type">int</span> color) &#123;<br>        m = image.length;<br>        n = image[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">targetColor</span> <span class="hljs-operator">=</span> image[sr][sc];<br>        image[sr][sc] = color;<br>        Queue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;sr, sc&#125;);<br>        <span class="hljs-type">boolean</span>[][] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n];<br>        visited[sr][sc] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span>[] node = queue.poll();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> node[<span class="hljs-number">0</span>] + dir[<span class="hljs-number">0</span>], col = node[<span class="hljs-number">1</span>] + dir[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span> (isValid(row,col) &amp;&amp; !visited[row][col] &amp;&amp; image[row][col] == targetColor) &#123;<br>                    visited[row][col] = <span class="hljs-literal">true</span>;<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;row, col&#125;);<br>                    image[row][col] = color;<br>                &#125;<br>            &#125;<br>        &#125; <br>        <span class="hljs-keyword">return</span> image;<br>    &#125;<br><br>    <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-type">int</span> m, n;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &lt; n;    <br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="一刷">一刷</h4>
<p><strong>小心死循环，curColor很关键</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] floodFill(<span class="hljs-type">int</span>[][] image, <span class="hljs-type">int</span> sr, <span class="hljs-type">int</span> sc, <span class="hljs-type">int</span> color) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">curColor</span> <span class="hljs-operator">=</span> image[sr][sc];<br>        <span class="hljs-keyword">if</span> (color == curColor)<br>            <span class="hljs-keyword">return</span> image;<br>        m = image.length;<br>        n = image[<span class="hljs-number">0</span>].length;<br>        Queue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;sr, sc&#125;);<br>        image[sr][sc] = color;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span>[] node = queue.poll();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> node[<span class="hljs-number">0</span>] + dir[<span class="hljs-number">0</span>], col = node[<span class="hljs-number">1</span>] + dir[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span> (isValid(row, col) &amp;&amp; image[row][col] == curColor) &#123;<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;row, col&#125;);<br>                    image[row][col] = color;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> image;<br>    &#125;<br><br>    <span class="hljs-type">int</span> m, n;<br>    <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &gt;=<span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &lt; n;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二dfs">方法二：DFS</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] floodFill(<span class="hljs-type">int</span>[][] image, <span class="hljs-type">int</span> sr, <span class="hljs-type">int</span> sc, <span class="hljs-type">int</span> color) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">curColor</span> <span class="hljs-operator">=</span> image[sr][sc];<br>        <span class="hljs-keyword">if</span> (color == curColor)<br>            <span class="hljs-keyword">return</span> image;<br>        m = image.length;<br>        n = image[<span class="hljs-number">0</span>].length;<br>        image[sr][sc] = color;<br>        dfs(sr, sc, color, curColor, image);<br>        <span class="hljs-keyword">return</span> image;<br>    &#125;<br><br>    <span class="hljs-type">int</span> m, n;<br>    <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> color, <span class="hljs-type">int</span> curColor, <span class="hljs-type">int</span>[][] image)</span> &#123;<br>        image[i][j] = color;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], col = j + dir[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (isValid(row, col) &amp;&amp; image[row][col] == curColor)<br>                dfs(row, col, color, curColor, image);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &gt;=<span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &lt; n;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230612113029570.png" style="zoom:50%;" /></p>
<h2 id="飞地的数量"><a href="https://leetcode.cn/problems/number-of-enclaves/">1020. 飞地的数量</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230612113113173.png" /></p>
<h3 id="方法一dfs-4">方法一：DFS</h3>
<p><strong>同太平洋大西洋水流问题，从边缘进入dfs</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numEnclaves</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        m = grid.length;<br>        n = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">if</span> (m &lt;= <span class="hljs-number">2</span> || n &lt;= <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i += m - <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j)<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>)<br>                    dfs(i, j, grid);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j += n - <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m - <span class="hljs-number">1</span>; ++i)<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>)<br>                    dfs(i, j, grid);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; ++i)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; ++j)<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>)<br>                    ++res;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, m, n;<br>    <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        grid[i][j] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], col = j + dir[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (isValid(row, col) &amp;&amp; grid[row][col] == <span class="hljs-number">1</span>)<br>                dfs(row, col, grid);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &lt; n;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230612115006643.png" style="zoom:50%;" /></p>
<h3 id="方法二bfs-3">方法二：BFS</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numEnclaves</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        m = grid.length;<br>        n = grid[<span class="hljs-number">0</span>].length;<br>        Queue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j)<br>            <span class="hljs-keyword">if</span> (grid[<span class="hljs-number">0</span>][j] == <span class="hljs-number">1</span>) <br>                queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>, j&#125;);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; ++i)<br>            <span class="hljs-keyword">if</span> (grid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>)<br>                queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, <span class="hljs-number">0</span>&#125;);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; ++i)<br>            <span class="hljs-keyword">if</span> (grid[i][n - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span>)<br>                queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, n - <span class="hljs-number">1</span>&#125;);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n - <span class="hljs-number">1</span>; ++j)<br>            <span class="hljs-keyword">if</span> (grid[m - <span class="hljs-number">1</span>][j] == <span class="hljs-number">1</span>)<br>                queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;m - <span class="hljs-number">1</span>, j&#125;);<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span>[] node = queue.poll();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> node[<span class="hljs-number">0</span>] + dir[<span class="hljs-number">0</span>], col = node[<span class="hljs-number">1</span>] + dir[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span> (isValid(row, col) &amp;&amp; grid[row][col] == <span class="hljs-number">1</span>) &#123;<br>                    grid[row][col] = <span class="hljs-number">0</span>;<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;row, col&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m - <span class="hljs-number">1</span>; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n - <span class="hljs-number">1</span>; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>)<br>                    ++res;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-type">int</span> m, n;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &lt; n;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<div class="note note-warning">
            <h2 id="二维网格图中探测环"><a href="https://leetcode.cn/problems/detect-cycles-in-2d-grid/">1559. 二维网格图中探测环</a></h2>
          </div>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230612141612451.png" /></p>
<h3 id="方法三并查集-1">方法三：并查集</h3>
<p><a href="https://leetcode.cn/problems/detect-cycles-in-2d-grid/solutions/409096/er-wei-wang-ge-tu-zhong-tan-ce-huan-by-leetcode-so/">题解</a></p>
<p>遍历矩阵，只检查左边和上面，可以保证每一条边的两个节点只会被合并一次</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsCycle</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] grid)</span> &#123;<br>        m = grid.length;<br>        n = grid[<span class="hljs-number">0</span>].length;<br>        init(m * n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], col = j + dir[<span class="hljs-number">1</span>];<br>                    <span class="hljs-keyword">if</span> (isValid(row,col) &amp;&amp; grid[i][j] == grid[row][col]) &#123;<br>                        <span class="hljs-keyword">if</span> (!union(i * n + j, row * n + col))<br>                            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span>[] parent;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rootI</span> <span class="hljs-operator">=</span> findParent(i), rootJ = findParent(j);<br>        <span class="hljs-keyword">if</span> (rootI != rootJ) &#123;<br>            parent[rootI] = rootJ;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findParent</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i != parent[i])<br>            parent[i] = findParent(parent[i]);<br>        <span class="hljs-keyword">return</span> parent[i];<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        parent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            parent[i] = i;<br>    &#125;<br><br>    <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-type">int</span> m, n;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &lt; n;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法一bfs-1">方法一：BFS</h3>
<ol type="1">
<li><p>每次从队列中取出一个节点时，记录当前队列大小size，初始化neigbors = 0</p></li>
<li><p>在上下左右四个方向遍历，如果相邻节点没有越界且与当前字符相同，++neighbors，如果没访问过，加入队列，visited赋值true</p></li>
<li><p><strong>遍历完四个方向后，如果neigbors - 1== queue.size() - size，(-1是减去上一次访问过，并将当前节点入队的节点)，说明新入队的邻居之前都没有访问过 </strong></p></li>
<li><p><strong>如果neigbors - 1 &gt; queue.size() - size，说明遍历到了已经访问过的jie'dian，那么可以形成环</strong></p></li>
<li><p>举例</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230612142408397.png" /></p>
<p>从下标(0, 0)开始BFS遍历，有两条路径，一条向右出发(记为路径A)，一条向下出发(记为路径B)，这里默认先遍历右边再遍历下面</p>
<p>当遍历了5步后，如下图</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230612142605358.png" /></p>
<p>(路径A)此时下标为(2, 3)的节点往下遍历，将右下角编号为(3, 3)的节点赋值true，如下图</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230612142813003.png" /></p>
<p>(路径B)现在下标为(3, 2)的节点往右遍历，邻居neighbors = 2，但是queue.size() - size = 0(队列没有新入队节点)，说明路径A已经遍历过这个节点了 ，那么路径B可以按照路径A返回起点，所以可以形成环</p></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsCycle</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] grid)</span> &#123;<br>        m = grid.length;<br>        n = grid[<span class="hljs-number">0</span>].length;<br>        visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) <br>                <span class="hljs-keyword">if</span> (!visited[i][j] &amp;&amp; bfs(i, j, grid))<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">char</span>[][] grid)</span> &#123;<br>        queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, j&#125;);<br>        visited[i][j] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span>[] node = queue.poll();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">neibors</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, size = queue.size();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> node[<span class="hljs-number">0</span>] + dir[<span class="hljs-number">0</span>], col = node[<span class="hljs-number">1</span>] + dir[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span> (isValid(row, col) &amp;&amp; grid[row][col] == grid[node[<span class="hljs-number">0</span>]][node[<span class="hljs-number">1</span>]]) &#123;<br>                    ++neibors;<br>                    <span class="hljs-keyword">if</span> (!visited[row][col]) &#123;<br>                        queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;row, col&#125;);<br>                        visited[row][col] = <span class="hljs-literal">true</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (neibors - <span class="hljs-number">1</span> &gt; queue.size() - size)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> m, n;<br>    <span class="hljs-type">boolean</span>[][] visited;<br>    Queue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &gt;=<span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &lt; n;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230612141708868.png" style="zoom:50%;" /></p>
<h3 id="方法二dfs-1">方法二：DFS</h3>
<p><strong>通过<code>preI</code>,<code>preJ</code>记录上一个已访问节点</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsCycle</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] grid)</span> &#123;<br>        m = grid.length;<br>        n = grid[<span class="hljs-number">0</span>].length;<br>        visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j)<br>                <span class="hljs-keyword">if</span> (!visited[i][j] &amp;&amp; dfs(i, j, grid, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>))<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">char</span>[][] grid, <span class="hljs-type">int</span> preI, <span class="hljs-type">int</span> preJ)</span> &#123;<br>        <span class="hljs-keyword">if</span> (visited[i][j])<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        visited[i][j] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], col = j + dir[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (isValid(row, col) &amp;&amp; grid[row][col] == grid[i][j]) &#123;<br>                <span class="hljs-keyword">if</span> (row == preI &amp;&amp; col == preJ)<br>                    <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span> (dfs(row, col, grid, i, j))<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> m, n;<br>    <span class="hljs-type">boolean</span>[][] visited;<br>    Queue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &gt;=<span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &lt; n;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230612150527603.png" alt=" " style="zoom:50%;" /></p>
<div class="note note-danger">
            <h2 id="判断二分图"><a href="https://leetcode.cn/problems/is-graph-bipartite/">785. 判断二分图</a></h2>
          </div>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230714154958313.png" /></p>
<h3 id="方法一bfs-2">方法一：BFS</h3>
<p>colors[next] == 1 - color说明访问过，而且颜色与当前颜色不同，不用加入队列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBipartite</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] graph)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> graph.length;<br>        <span class="hljs-type">int</span>[] colors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Arrays.fill(colors, -<span class="hljs-number">1</span>);<br>        Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (colors[i] == -<span class="hljs-number">1</span>) &#123;<br>                colors[i] = <span class="hljs-number">0</span>;<br>                queue.offer(i);<br>                <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll(), color = colors[node];<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> next : graph[node]) &#123;<br>                        <span class="hljs-keyword">if</span> (colors[next] == -<span class="hljs-number">1</span>) &#123;<br>                            colors[next] = <span class="hljs-number">1</span> - color;<br>                            queue.offer(next);<br>                        &#125;<br>                       <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (colors[next] == color)<br>                            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二dfs-2">方法二：DFS</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBipartite</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] graph)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> graph.length;<br>        <span class="hljs-type">int</span>[] colors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Arrays.fill(colors, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (colors[i] == -<span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">if</span> (!dfs(graph, colors, i, <span class="hljs-number">0</span>))<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] graph, <span class="hljs-type">int</span>[] colors, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> color)</span> &#123;<br>        colors[i] = color;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> next : graph[i]) &#123;<br>            <span class="hljs-keyword">if</span> (colors[next] == -<span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">if</span> (!dfs(graph, colors, next, <span class="hljs-number">1</span> - color))<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (colors[next] == color)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法三并查集-2">方法三：并查集</h3>
<p>每个顶点i的邻居应该是在同一个集合里，如果i与邻居在一个集合，则不是二分图</p>
<p>遍历每一个顶点i，判断i与邻居是否在一个集合中，如果是则不是二分图返回false；如果顶点i不与邻居在同一个集合，那么将邻居合并到同一个集合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBipartite</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] graph)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> graph.length;<br>        init(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> next : graph[i]) &#123;<br>                <span class="hljs-keyword">if</span> (findParent(i) == findParent(next))<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                union(graph[i][<span class="hljs-number">0</span>], next);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span>[] parent;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rootI</span> <span class="hljs-operator">=</span> findParent(i), rootJ = findParent(j);<br>        <span class="hljs-keyword">if</span> (rootI != rootJ) &#123;<br>            parent[rootI] = rootJ;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findParent</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i != parent[i])<br>            parent[i] = findParent(parent[i]);<br>        <span class="hljs-keyword">return</span> parent[i];<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        parent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            parent[i] = i;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="剑指-offer-ii-110.-所有路径"><a href="https://leetcode.cn/problems/bP4bmD/">剑指 Offer II 110. 所有路径</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230714200743913.png" /></p>
<h3 id="方法一回溯">方法一：回溯</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">allPathsSourceTarget</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] graph)</span> &#123;<br>        n = graph.length;<br>        <span class="hljs-built_in">this</span>.graph = graph;<br>        path.offer(<span class="hljs-number">0</span>);<br>        dfs(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == n - <span class="hljs-number">1</span>) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> next : graph[index]) &#123;<br>            path.offerLast(next);<br>            dfs(next);<br>            path.pollLast();<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">int</span>[][] graph;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>&#125;<br></code></pre></td></tr></table></figure>
<div class="note note-danger">
            <h2 id="剑指-offer-ii-111.-计算除法"><a href="https://leetcode.cn/problems/vlzXQL/">剑指 Offer II 111. 计算除法</a></h2>
          </div>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230714223322583.png" /></p>
<h3 id="方法一dfs-5">方法一：DFS</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span>[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, <span class="hljs-type">double</span>[] values, List&lt;List&lt;String&gt;&gt; queries) &#123;<br>        Map&lt;String, Map&lt;String, Double&gt;&gt; graph = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; equations.size(); ++i) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">num1</span> <span class="hljs-operator">=</span> equations.get(i).get(<span class="hljs-number">0</span>), num2 = equations.get(i).get(<span class="hljs-number">1</span>);<br>            graph.putIfAbsent(num1, <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;());<br>            graph.putIfAbsent(num2, <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;());<br>            graph.get(num1).put(num2, values[i]);<br>            graph.get(num2).put(num1, <span class="hljs-number">1</span> / values[i]);<br>        &#125;<br>        <span class="hljs-type">double</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[queries.size()];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; queries.size(); ++i) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">num1</span> <span class="hljs-operator">=</span> queries.get(i).get(<span class="hljs-number">0</span>), num2 = queries.get(i).get(<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (!graph.containsKey(num1) || !graph.containsKey(num2))<br>                res[i] = -<span class="hljs-number">1.0</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num1.equals(num2)) <span class="hljs-comment">// 字符在图中且两个字符相等</span><br>                res[i] = <span class="hljs-number">1.0</span>; <br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (graph.get(num1).containsKey(num2))<br>                res[i] = graph.get(num1).get(num2);<br>            <span class="hljs-keyword">else</span> &#123;<br>                visited.clear();<br>                res[i] = dfs(num1, num2, graph);<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    Set&lt;String&gt; visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(String num1, String num2, Map&lt;String, Map&lt;String, Double&gt;&gt; graph)</span> &#123;<br>        <span class="hljs-keyword">if</span> (num1.equals(num2))<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span>;<br>        visited.add(num1);<br>        Map&lt;String, Double&gt; nexts = graph.get(num1);<br>        <span class="hljs-keyword">for</span> (String next : nexts.keySet()) &#123;<br>            <span class="hljs-keyword">if</span> (visited.contains(next))<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-type">double</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> dfs(next, num2, graph);<br>            <span class="hljs-keyword">if</span> (val &gt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> val * nexts.get(next);<br>        &#125;<br>        visited.remove(num1);<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1.0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="二进制矩阵中翻转最多一次使路径不连通"><a href="https://leetcode.cn/problems/disconnect-path-in-a-binary-matrix-by-at-most-one-flip/">二进制矩阵中翻转最多一次使路径不连通</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230831155400405.png" /></p>
<h3 id="方法一两次dfs">方法一：两次DFS</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPossibleToCutPath</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        m = grid.length;<br>        n = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-built_in">this</span>.grid = grid;<br>        <span class="hljs-keyword">return</span> !dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>) || !dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i == m - <span class="hljs-number">1</span> &amp;&amp; j == n - <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        grid[i][j] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], col = j + dir[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (isValid(row, col) &amp;&amp; grid[row][col] == <span class="hljs-number">1</span> &amp;&amp; dfs(row, col))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br><br>    <span class="hljs-type">int</span> m, n;<br>    <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;, grid;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &lt; m &amp;&amp; j &lt; n;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithms</category>
        <category>Graph</category>
      </categories>
      <tags>
        <tag>图</tag>
        <tag>迷宫问题</tag>
      </tags>
  </entry>
  <entry>
    <title>Monotonic Stack</title>
    <url>/2023/06/02/monotonic-stack/</url>
    <content><![CDATA[<div class="note note-success">
            <p>求某个区间的最大(小)值，可以使用单调队列</p><p>单调栈的作用：存放之前遍历过的元素i，当比nums[i]更大(小)的元素出现时，计算结果，并将i弹出</p>
          </div>
<h2 id="滑动窗口最大值"><a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230602104324124.png" /></p>
<ol type="1">
<li><p>维护一个单调递减的双端队列，队列大小为[0, k]，<strong>队列存储数组下标，从而更好判断滑动窗口区间</strong></p></li>
<li><p>存储答案的队列res大小为n - k + 1</p></li>
<li><p>遍历数组nums</p></li>
<li><p><strong>当队列不为空且当前元素大于队尾元素在nums中对应的值时，将队尾元素弹出，从而保持队列的单调递减性</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (!queue.isEmpty() &amp;&amp; nums[i] &gt; nums[queue.peekLast()])<br>    queue.pollLast();<br></code></pre></td></tr></table></figure></li>
<li><p>完成步骤4后，将当前元素<code>nums[i]</code>加入队列</p></li>
<li><p><strong>当队首元素等于i - k，说明已经遍历过k轮，滑动窗口的左边界已经超过队首元素了，弹出队首元素</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (queue.peekFirst() == i - k)<br>    queue.pollFirst();<br></code></pre></td></tr></table></figure></li>
<li><p><strong>只有当i &gt;= k - 1时，才记录结果res</strong></p></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] maxSlidingWindow(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n - k + <span class="hljs-number">1</span>];<br>        Deque&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">while</span> (!queue.isEmpty() &amp;&amp; nums[i] &gt; nums[queue.peekLast()])<br>                queue.pollLast();<br>            queue.offerLast(i);<br>            <span class="hljs-keyword">if</span> (queue.peekFirst() == i - k)<br>                queue.pollFirst();<br>            <span class="hljs-keyword">if</span> (i &gt;= k - <span class="hljs-number">1</span>)<br>                res[i - k + <span class="hljs-number">1</span>] = nums[queue.peekFirst()];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<div class="note note-success">
            <p>单调栈是一种基于栈的数据结构，所谓的单调就是满足单调递增（单调递减）的栈。主要用于解决 <strong>下一个更大的元素</strong>问题，也就是找到下一个更大的元素。</p><p>单调栈的意义：用 O(n) 复杂度的一重遍历找到每个元素前后最近的更小/大元素位置</p>
          </div>
<h2 id="每日温度"><a href="https://leetcode.cn/problems/daily-temperatures/">739. 每日温度</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230602104459823.png" /></p>
<h3 id="方法一单调栈">方法一：单调栈</h3>
<ol type="1">
<li>创建一个栈，存储元素下标</li>
<li>遍历数组元素</li>
<li>当栈不为空且数组元素值 &gt; 栈顶元素对应数组的值
<ol type="1">
<li>弹出栈顶元素并用变量i - topIndex;接收</li>
<li>topIndex的下一个更大值的距离为i - topIndex;</li>
</ol></li>
<li>将i压栈</li>
</ol>
<p>遍历完for循环，如果栈不为空，说明栈里的元素不存在比它更大的元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] dailyTemperatures(<span class="hljs-type">int</span>[] temperatures) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> temperatures.length;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; temperatures[i] &gt; temperatures[stack.peek()]) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">topIndex</span> <span class="hljs-operator">=</span> stack.pop();<br>                res[topIndex] = i - topIndex;<br>            &#125;<br>            stack.push(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="下一个更大元素-i"><a href="https://leetcode.cn/problems/next-greater-element-i/">496. 下一个更大元素 I</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230602111209413.png" /></p>
<h3 id="方法一单调栈-hashmap">方法一：单调栈 + HashMap</h3>
<p>res[i] = map.getOrDefault(nums1[i], -1);假设nums1[i]在nums2中的下标为j，如果map查不到nums1[i]，说明nums2[j]在j之后没有比nums2[j]更大的元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] nextGreaterElement(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2) &#123;<br>        Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums2.length; ++i) &#123;<br>            <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; nums2[i] &gt; nums2[stack.peek()]) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">topIndex</span> <span class="hljs-operator">=</span> stack.pop();<br>                map.put(nums2[topIndex], nums2[i]);<br>            &#125;<br>            stack.push(i);<br>        &#125;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums1.length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums1.length; ++i) &#123;<br>            res[i] = map.getOrDefault(nums1[i], -<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230602113744688.png" style="zoom:50%;" /></p>
<h2 id="下一个更大元素-ii"><a href="https://leetcode.cn/problems/next-greater-element-ii/">503. 下一个更大元素 II</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230602131521839.png" /></p>
<h3 id="方法一单调栈-1">方法一：单调栈</h3>
<ol type="1">
<li>初始res数组为-1很重要！默认所有元素都没有更大的下一个元素</li>
</ol>
<p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Arrays.fill(res, -<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure></p>
<ol start="2" type="1">
<li>循环数组遍历两次，即使第一轮遍历已经被赋值，第二轮也只会赋相同的值，不影响</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] nextGreaterElements(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Arrays.fill(res, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span> * n; ++i) &#123;<br>            <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; nums[i % n] &gt; nums[stack.peek()]) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">topIndex</span> <span class="hljs-operator">=</span> stack.pop();<br>                res[topIndex] = nums[i % n];<br>            &#125;<br>            stack.push(i % n);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230602131507655.png" style="zoom:50%;" /></p>
<div class="note note-danger">
            <h2 id="去除重复字母"><a href="https://leetcode.cn/problems/remove-duplicate-letters/">316. 去除重复字母</a></h2>
          </div>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230602131831847.png" /></p>
<h3 id="方法一单调栈-2">方法一：单调栈</h3>
<p><strong>遇到一个新字符 如果比栈顶小 并且在新字符后面还有和栈顶一样的 就把栈顶的字符抛弃了</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">removeDuplicateLetters</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); ++i)<br>            ++count[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        <span class="hljs-type">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">26</span>];<br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); ++i) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            --count[ch - <span class="hljs-string">&#x27;a&#x27;</span>];<br>            <span class="hljs-keyword">if</span> (visited[ch - <span class="hljs-string">&#x27;a&#x27;</span>])<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">while</span>(!stack.isEmpty() &amp;&amp; s.charAt(stack.peek()) &gt; ch &amp;&amp; count[s.charAt(stack.peek()) - <span class="hljs-string">&#x27;a&#x27;</span>] &gt; <span class="hljs-number">0</span>) &#123;<br>                visited[s.charAt(stack.peek()) - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-literal">false</span>;<br>                stack.pop();<br>            &#125;<br>            visited[ch - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-literal">true</span>;<br>            stack.push(i);<br>        &#125;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">while</span> (!stack.isEmpty())<br>            sb.append(s.charAt(stack.pollLast()));<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230602152901928.png" style="zoom:50%;" /></p>
<div class="note note-warning">
            <h2 id="柱状图中最大的矩形"><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">84. 柱状图中最大的矩形</a></h2>
          </div>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230602154000994.png" /></p>
<h3 id="方法一单调栈-3">方法一：单调栈</h3>
<h3 id="思路">思路</h3>
<ol type="1">
<li>对于一个高度，如果能得到向左和向右的边界</li>
<li>那么就能对每个高度求一次面积</li>
<li>遍历所有高度，即可得出最大面积</li>
<li>使用单调栈，在出栈操作时得到前后边界并计算面积</li>
</ol>
<p><strong>注意边界问题</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Arrays.fill(rights, n);<br>Arrays.fill(left, -<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[] heights)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> heights.length;<br>        <span class="hljs-type">int</span>[] rights = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Arrays.fill(rights, n);<br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; n ; i++)&#123;<br>            <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; heights[stack.getLast()] &gt; heights[i]) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">top</span> <span class="hljs-operator">=</span> stack.pollLast();<br>                rights[top] = i;<br>            &#125;<br>            stack.addLast(i);<br>        &#125;<br>        <span class="hljs-type">int</span>[] left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Arrays.fill(left, -<span class="hljs-number">1</span>);<br>        stack.clear();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span> ; i &gt;= <span class="hljs-number">0</span> ; i--) &#123;<br>            <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; heights[stack.getLast()] &gt; heights[i]) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">top</span> <span class="hljs-operator">=</span> stack.pollLast();<br>                left[top] = i;<br>            &#125;<br>            stack.addLast(i);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; n ; i++) &#123;<br>            res = Math.max(res,  (rights[i] - left[i] - <span class="hljs-number">1</span>) * heights[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230602163956020.png" style="zoom:50%;" /></p>
<div class="note note-danger">
            <h2 id="接雨水"><a href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水</a></h2>
          </div>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230602164417183.png" /></p>
<h3 id="方法一单调栈-4">方法一：单调栈</h3>
<p><a href="https://leetcode.cn/problems/trapping-rain-water/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-8/">优质题解</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">trap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> height.length, index = <span class="hljs-number">0</span>, res = <span class="hljs-number">0</span>;<br>        Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (index &lt; n) &#123;<br>            <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; height[index] &gt; height[stack.peek()]) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">topIndex</span> <span class="hljs-operator">=</span> stack.pop();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> height[topIndex];<br>                <span class="hljs-keyword">if</span> (stack.isEmpty())<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> Math.min(height[index], height[stack.peek()]);<br>                <span class="hljs-type">int</span> <span class="hljs-variable">width</span> <span class="hljs-operator">=</span> index - stack.peek() - <span class="hljs-number">1</span>;<br>                res += (min - h) * width;<br>            &#125;<br>            stack.push(index++);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="字符串解码-普通栈模拟"><a href="https://leetcode.cn/problems/decode-string/">394. 字符串解码</a> (普通栈模拟)</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20231007132009827.png" /></p>
<h3 id="方法一双栈模拟">方法一：双栈模拟</h3>
<p>创建两个栈：1.ns(num stack)存放数字，2.is(index stack)存放StringBuilder的下标，下面会详细解释两个栈的用法。</p>
<p>遍历字符串s的每个字符ch，有四种情况：</p>
<ol type="1">
<li><p>数字：压入数字栈ns中</p></li>
<li><p>字符：放入StringBuilder中</p></li>
<li><p>左括号<code>[</code>：将StringBuilder的长度压入下标栈is中</p></li>
<li><p>右括号<code>]</code>：将数字，也就是重复次数从数字栈ns中取出来，记作t。从下标栈is中取出要复制子串的初始位置index，</p>
<p>将子串sb.substring(index, sb.toString())复制t - 1次(stringbuilder中已经有一份数据了，所以是t-1)</p></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">decodeString</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        Stack&lt;Integer&gt; ns = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;(), is = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;(); <span class="hljs-comment">// numStack, indexStack</span><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">preIsNum</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-keyword">if</span> (ch - <span class="hljs-string">&#x27;0&#x27;</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; ch - <span class="hljs-string">&#x27;0&#x27;</span> &lt;= <span class="hljs-number">9</span>) &#123;<br>                <span class="hljs-keyword">if</span> (preIsNum) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> ns.pop();<br>                    ns.push(pre * <span class="hljs-number">10</span> + ch - <span class="hljs-string">&#x27;0&#x27;</span>);<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                    ns.push(ch - <span class="hljs-string">&#x27;0&#x27;</span>);<br>                preIsNum = <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                preIsNum = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;[&#x27;</span>) <br>                    is.add(sb.length());                    <br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;]&#x27;</span>) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> is.pop(), t = ns.pop();<br>                    <span class="hljs-type">String</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> sb.substring(index, sb.length());<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; t - <span class="hljs-number">1</span>; ++j) &#123;<br>                        sb.append(temp);<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <br>                    sb.append(ch);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="股票价格跨度"><a href="https://leetcode.cn/problems/online-stock-span/">901. 股票价格跨度</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20231007152230891.png" /></p>
<h3 id="方法一单调栈-5">方法一：单调栈</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StockSpanner</span> &#123;<br><br>    Stack&lt;Integer&gt; stack;<br>    List&lt;Integer&gt; nums, count;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">StockSpanner</span><span class="hljs-params">()</span> &#123;<br>        stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>();<br>        nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">next</span><span class="hljs-params">(<span class="hljs-type">int</span> price)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; price &gt;= nums.get(stack.peek())) <br>            cnt += count.get(stack.pop());<br>        nums.add(price);<br>        count.add(cnt);<br>        stack.push(nums.size() - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your StockSpanner object will be instantiated and called as such:</span><br><span class="hljs-comment"> * StockSpanner obj = new StockSpanner();</span><br><span class="hljs-comment"> * int param_1 = obj.next(price);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithms</category>
        <category>Queue &amp;&amp; Stack</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>Shortest Path Problem</title>
    <url>/2023/05/31/shortest-path-problem/</url>
    <content><![CDATA[<h2 id="迪杰斯特拉">迪杰斯特拉</h2>
<p><a href="https://leetcode.cn/problems/network-delay-time/solution/wang-luo-yan-chi-shi-jian-by-leetcode-so-6phc/">解析</a></p>
<ol type="1">
<li><strong>开一个dis数组，记录从给定点x到其他点的最短距离，初始化为max，；开一个visited数组，记录顶点是否被访问过</strong></li>
<li><strong>将x的dis初始为0</strong></li>
<li><strong>开始遍历，首先找到未被访问且距离x最短的顶点y，将y的visited赋值true</strong></li>
<li><strong>更新的dis中顶点z的距离：未被访问且 <code>z与x的距离</code>大于 <code>x到y + y到z的距离</code></strong></li>
</ol>
<h2 id="网络延迟时间"><a href="https://leetcode.cn/problems/network-delay-time/">743. 网络延迟时间</a></h2>
<h3 id="方法一迪杰斯特拉">方法一：迪杰斯特拉</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">inf</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">networkDelayTime</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] times, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span>[][] graph = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] g : graph)<br>            Arrays.fill(g, inf);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] time : times) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">from</span> <span class="hljs-operator">=</span> time[<span class="hljs-number">0</span>], to = time[<span class="hljs-number">1</span>], weight = time[<span class="hljs-number">2</span>];<br>            graph[from][to] = weight;<br>        &#125;<br>        <span class="hljs-type">int</span>[] dist = dijkstra(graph, n, k);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : dist) &#123;<br>            <span class="hljs-keyword">if</span> (x == inf)<br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            res = Math.max(res, x);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> d : dist)<br>            System.out.print(d + <span class="hljs-string">&quot;, &quot;</span>);<br>        System.out.println();<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] dijkstra(<span class="hljs-type">int</span>[][] graph, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> from) &#123;<br>        <span class="hljs-type">int</span>[] dist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>            <span class="hljs-keyword">if</span> (i != from)<br>                dist[i] = inf;<br>        <span class="hljs-comment">// 不要把visited[from]初始为true，dist[from] = 0，会在下面的for循环中被第一个选到</span><br>        <span class="hljs-type">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123; <span class="hljs-comment">// 每遍历一次将一个顶点visit赋值true，需要遍历n次</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">minIndex</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>, minDist = inf;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (!visited[j] &amp;&amp; dist[j] &lt; minDist) &#123;<br>                    minIndex = j;<br>                    minDist = dist[j];<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (minIndex == -<span class="hljs-number">1</span>) <span class="hljs-comment">// 如果有节点非连通，则返回</span><br>                <span class="hljs-keyword">return</span> dist;<br>            visited[minIndex] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; ++j)<br>                <span class="hljs-keyword">if</span> (!visited[j] &amp;&amp; dist[j] &gt; graph[minIndex][j] + minDist)<br>                    dist[j] = graph[minIndex][j] + minDist;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dist;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230531190152531.png" style="zoom:50%;" /></p>
<h3 id="方法二堆优化dijkstra">方法二：堆优化dijkstra</h3>
<p><strong>我们还可以使用一个小根堆来寻找「未确定节点」中与起点距离最近的点</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">inf</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">networkDelayTime</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] times, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span>[][] graph = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] g : graph)<br>            Arrays.fill(g, inf);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] time : times) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">from</span> <span class="hljs-operator">=</span> time[<span class="hljs-number">0</span>], to = time[<span class="hljs-number">1</span>], weight = time[<span class="hljs-number">2</span>];<br>            graph[from][to] = weight;<br>        &#125;<br>        <span class="hljs-type">int</span>[] dist = dijkstra(graph, n, k);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : dist) &#123;<br>            <span class="hljs-keyword">if</span> (x == inf)<br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            res = Math.max(res, x);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] dijkstra(<span class="hljs-type">int</span>[][] graph, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> from) &#123;<br>        <span class="hljs-type">int</span>[] dist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>            <span class="hljs-keyword">if</span> (i != from)<br>                dist[i] = inf;<br>        <span class="hljs-type">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n + <span class="hljs-number">1</span>];<br>        PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(((o1, o2) -&gt; o1[<span class="hljs-number">1</span>] - o2[<span class="hljs-number">1</span>]));<br>        queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;from, <span class="hljs-number">0</span>&#125;);<br>       <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>           <span class="hljs-type">int</span>[] arr = queue.poll();<br>           <span class="hljs-type">int</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>], disToFrom = arr[<span class="hljs-number">1</span>];<br>           <span class="hljs-keyword">if</span> (visited[node])<br>               <span class="hljs-keyword">continue</span>;<br>           visited[node] = <span class="hljs-literal">true</span>;<br>           <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>               <span class="hljs-comment">// graph[node][i] &lt; inf表示node与i有边</span><br>               <span class="hljs-keyword">if</span> (graph[node][i] &lt; inf &amp;&amp; dist[i] &gt; disToFrom + graph[node][i]) &#123;<br>                   dist[i] = disToFrom + graph[node][i];<br>                   queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, dist[i]&#125;);<br>               &#125;<br>           &#125;<br>       &#125;<br>        <span class="hljs-keyword">return</span> dist;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="零钱兑换"><a href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/883ca88a7339d6719406900b5e340b0.jpg" /></p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230605091913038.png" /></p>
<h3 id="方法一bfs">方法一：BFS</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">coinChange</span><span class="hljs-params">(<span class="hljs-type">int</span>[] coins, <span class="hljs-type">int</span> amount)</span> &#123;<br>        Queue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-comment">// 第一个元素表示已经凑成的钱(距离)，第二个元素表示使用的硬币数(步数)</span><br>        queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span> , <span class="hljs-number">0</span>&#125;);<br>        <span class="hljs-type">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[amount + <span class="hljs-number">1</span>];<br>        visited[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span>[] node = queue.poll();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> node[<span class="hljs-number">0</span>], num = node[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (sum == amount)<br>                <span class="hljs-keyword">return</span> num;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> coin : coins) &#123;<br>                <span class="hljs-keyword">if</span> (coin &gt; amount - sum || visited[sum + coin])<br>                    <span class="hljs-keyword">continue</span>;<br>                queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;sum + coin, num + <span class="hljs-number">1</span>&#125;);<br>                visited[sum + coin] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="跳跃游戏-ii"><a href="https://leetcode.cn/problems/jump-game-ii/">45. 跳跃游戏 II</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230605094700776.png" /></p>
<h3 id="方法一bfs-1">方法一：BFS</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">jump</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Queue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;);<br>        <span class="hljs-type">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[nums.length];<br>        visited[<span class="hljs-number">0</span>]= <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span>[] node = queue.poll();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">pos</span> <span class="hljs-operator">=</span> node[<span class="hljs-number">0</span>], step = node[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (pos == nums.length - <span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">return</span> step;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= nums[pos]; ++i)  &#123;<br>                <span class="hljs-keyword">if</span> (pos + i &gt;= nums.length || visited[pos + i])<br>                    <span class="hljs-keyword">continue</span>;<br>                queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;pos + i, step + <span class="hljs-number">1</span>&#125;);<br>                visited[pos + i] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<div class="note note-warning">
            <h2 id="矩阵"><a href="https://leetcode.cn/problems/01-matrix/">542. 01 矩阵</a></h2>
          </div>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230605100912339.png" /></p>
<h3 id="方法一bfs-2">方法一：BFS</h3>
<ol type="1">
<li><strong>queue三元组，分别为横坐标i，纵坐标j，mat[i][j]距离0的距离</strong></li>
<li><strong>将所有0加入队列，并标记visited</strong></li>
<li><strong>BFS搜索</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] updateMatrix(<span class="hljs-type">int</span>[][] mat) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> mat.length, n = mat[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[][] res =  <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        Queue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">boolean</span>[][] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (mat[i][j] == <span class="hljs-number">0</span>) &#123;<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, j, <span class="hljs-number">0</span>&#125;); <span class="hljs-comment">// x, y, distance</span><br>                    visited[i][j] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span>[] node = queue.poll();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> node[<span class="hljs-number">0</span>], j = node[<span class="hljs-number">1</span>], dist = node[<span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir :dirs) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], col = j + dir[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span> (isValid(row, col, m, n) &amp;&amp; !visited[row][col]) &#123;<br>                    res[row][col] = dist + <span class="hljs-number">1</span>;<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;row, col, dist + <span class="hljs-number">1</span>&#125;);<br>                    visited[row][col] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;=<span class="hljs-number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &lt; n;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230605104726735.png" style="zoom:50%;" /></p>
<div class="note note-danger">
            <h2 id="滑动谜题"><a href="https://leetcode.cn/problems/sliding-puzzle/">773. 滑动谜题</a></h2>
          </div>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230605105229101.png" /></p>
<h2 id="阈值距离内邻居最少的城市"><a href="https://leetcode.cn/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/">1334. 阈值距离内邻居最少的城市</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230605132508576.png" /></p>
<p><strong>不能用BFS做，这是求多源最短路径</strong></p>
<h3 id="方法一弗洛伊德">方法一：弗洛伊德</h3>
<ol type="1">
<li><strong>dp[i][j]表示i到j的最短距离</strong></li>
<li><strong>枚举所有中间节点k，如果i经过中间节点k再到达j比i直接到达j更短，那么将dp[i][j]赋值为dp[i][k] + dp[k][j]</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findTheCity</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] edges, <span class="hljs-type">int</span> distanceThreshold)</span> &#123;<br>        <span class="hljs-type">int</span>[][] dp = buildGraph(n, edges);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; n; ++k)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j)<br>                    dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k][j]);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">minNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">100000</span>, minIndex = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">neighborsNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j)<br>                <span class="hljs-keyword">if</span> (i!= j &amp;&amp; dp[i][j] &lt;= distanceThreshold)<br>                    ++neighborsNum;<br>            <span class="hljs-keyword">if</span> (neighborsNum &lt;= minNum) &#123;<br>                minNum = neighborsNum;<br>                minIndex = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> minIndex;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[][] buildGraph(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] edges) &#123;<br>        <span class="hljs-type">int</span>[][] graph = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] row : graph)<br>            Arrays.fill(row, <span class="hljs-number">100000</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] edge : edges) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">from</span> <span class="hljs-operator">=</span> edge[<span class="hljs-number">0</span>], to = edge[<span class="hljs-number">1</span>], weight = edge[<span class="hljs-number">2</span>];<br>            graph[from][to] = graph[to][from] = weight;<br>        &#125;<br>        <span class="hljs-keyword">return</span> graph;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230605153759886.png" style="zoom:50%;" /></p>
<h2 id="剑指-offer-ii-107.-矩阵中的距离"><a href="https://leetcode.cn/problems/2bCMpM/">剑指 Offer II 107. 矩阵中的距离</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230714165708758.png" /></p>
<h3 id="方法一bfs-3">方法一：BFS</h3>
<p>BFS可以确保从0到非0元素的最短路径</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] updateMatrix(<span class="hljs-type">int</span>[][] mat) &#123;<br>        m = mat.length;<br>        n = mat[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[][] dist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        Queue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j)<br>                <span class="hljs-keyword">if</span> (mat[i][j] == <span class="hljs-number">0</span>)<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, j&#125;);<br>        <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span>[] node = queue.poll();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> node[<span class="hljs-number">0</span>] + dir[<span class="hljs-number">0</span>], col = node[<span class="hljs-number">1</span>] + dir[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span> (isValid(row, col) &amp;&amp; mat[row][col] != <span class="hljs-number">0</span> &amp;&amp; dist[row][col] == <span class="hljs-number">0</span>) &#123;<br>                    dist[row][col] = dist[node[<span class="hljs-number">0</span>]][node[<span class="hljs-number">1</span>]] + <span class="hljs-number">1</span>;<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;row, col&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dist;<br>    &#125;<br><br>    <span class="hljs-type">int</span> m, n;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &lt; n;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="剑指-offer-ii-108.-单词演变"><a href="https://leetcode.cn/problems/om3reC/">剑指 Offer II 108. 单词演变</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230714170530095.png" /></p>
<h3 id="方法一单向bfs">方法一：单向BFS</h3>
<p>不能使用queue2.clear()，因为queue1是指向queue2内存空间的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">if</span> (queue1.isEmpty()) &#123;<br>    ++length;<br>    queue1 = queue2;<br>    queue2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="代码">代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ladderLength</span><span class="hljs-params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> &#123;<br>        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(wordList);<br>        Queue&lt;String&gt; queue1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(), queue2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue1.offer(beginWord);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (!queue1.isEmpty()) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue1.poll();<br>            <span class="hljs-keyword">if</span> (node.equals(endWord))<br>                <span class="hljs-keyword">return</span> length;<br>            List&lt;String&gt; neibors = getNeibors(node);<br>            <span class="hljs-keyword">for</span> (String next : neibors) &#123;<br>                <span class="hljs-keyword">if</span> (set.contains(next)) &#123;<br>                    queue2.offer(next);<br>                    <span class="hljs-comment">// 通过bfs最先遍历到的节点，距离初始节点的距离一定是最短的</span><br>                    set.remove(next);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (queue1.isEmpty()) &#123;<br>                ++length;<br>                queue1 = queue2;<br>                queue2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> List&lt;String&gt; <span class="hljs-title function_">getNeibors</span><span class="hljs-params">(String node)</span> &#123;<br>        List&lt;String&gt; neibors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">char</span>[] chs = node.toCharArray();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; chs.length; ++i) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> chs[i];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span>; j &lt;= <span class="hljs-string">&#x27;z&#x27;</span>; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (ch != j) &#123;<br>                    chs[i] = j;<br>                    neibors.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(chs));<br>                &#125;<br>            &#125;<br>            chs[i] = ch;<br>        &#125;<br>        <span class="hljs-keyword">return</span> neibors;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二双向bfs">方法二：双向BFS</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ladderLength</span><span class="hljs-params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> &#123;<br>        Set&lt;String&gt; notVisited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(wordList);<br>        <span class="hljs-keyword">if</span> (!notVisited.contains(endWord))<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        Set&lt;String&gt; set1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(), set2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        set1.add(beginWord);<br>        set2.add(endWord);<br>        notVisited.remove(endWord);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">while</span> (!set1.isEmpty() &amp;&amp; !set2.isEmpty()) &#123;<br>            <span class="hljs-keyword">if</span> (set1.size() &gt; set2.size())  &#123;<br>                Set&lt;String&gt; temp = set1;<br>                set1 = set2;<br>                set2 = temp;<br>            &#125;<br>            Set&lt;String&gt; set3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (String word : set1) &#123;<br>                List&lt;String&gt; neibors = getNeibors(word);<br>                <span class="hljs-keyword">for</span> (String next : neibors) &#123;<br>                    <span class="hljs-keyword">if</span> (set2.contains(next))<br>                        <span class="hljs-keyword">return</span> length;<br>                    <span class="hljs-keyword">if</span> (notVisited.contains(next)) &#123;<br>                        set3.add(next);<br>                        notVisited.remove(next);<br>                    &#125;<br>                &#125;<br>            &#125;<br>            ++length;<br>            set1 = set3;<br>            set3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> List&lt;String&gt; <span class="hljs-title function_">getNeibors</span><span class="hljs-params">(String node)</span> &#123;<br>        List&lt;String&gt; neibors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">char</span>[] chs = node.toCharArray();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; chs.length; ++i) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> chs[i];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span>; j &lt;= <span class="hljs-string">&#x27;z&#x27;</span>; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (ch != j) &#123;<br>                    chs[i] = j;<br>                    neibors.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(chs));<br>                &#125;<br>            &#125;<br>            chs[i] = ch;<br>        &#125;<br>        <span class="hljs-keyword">return</span> neibors;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="剑指-offer-ii-109.-开密码锁"><a href="https://leetcode.cn/problems/zlDJc7/">剑指 Offer II 109. 开密码锁</a></h2>
<h3 id="方法一单向bfs-1">方法一：单向BFS</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">openLock</span><span class="hljs-params">(String[] deadends, String target)</span> &#123;<br>        Set&lt;String&gt; notAchievable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(Arrays.asList(deadends));<br>        <span class="hljs-keyword">if</span> (notAchievable.contains(<span class="hljs-string">&quot;0000&quot;</span>))<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        Queue&lt;String&gt; queue1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(), queue2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue1.offer(<span class="hljs-string">&quot;0000&quot;</span>);<br>        Set&lt;String&gt; visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!queue1.isEmpty()) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue1.poll();<br>            <span class="hljs-keyword">if</span> (node.equals(target))<br>                <span class="hljs-keyword">return</span> length;<br>            List&lt;String&gt; neibors = getNeibors(node, notAchievable);<br>            <span class="hljs-keyword">for</span> (String next : neibors) &#123;<br>                <span class="hljs-keyword">if</span> (visited.contains(next))<br>                    <span class="hljs-keyword">continue</span>;<br>                visited.add(next);<br>                queue2.offer(next);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (queue1.isEmpty()) &#123;<br>                ++length;<br>                queue1 = queue2;<br>                queue2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> List&lt;String&gt; <span class="hljs-title function_">getNeibors</span><span class="hljs-params">(String node, Set&lt;String&gt; notAchievable)</span> &#123;<br>        List&lt;String&gt; neibors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">char</span>[] chs = node.toCharArray();<br>        String pre, next;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; ++i) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> chs[i];<br>            <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>                chs[i] = <span class="hljs-string">&#x27;1&#x27;</span>;<br>                next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(chs);<br>                <span class="hljs-keyword">if</span> (!notAchievable.contains(next))<br>                    neibors.add(next);<br>                chs[i] = <span class="hljs-string">&#x27;9&#x27;</span>;<br>                pre = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(chs);<br>                <span class="hljs-keyword">if</span> (!notAchievable.contains(pre))<br>                    neibors.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(chs));<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>                chs[i] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>                next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(chs);<br>                <span class="hljs-keyword">if</span> (!notAchievable.contains(next))<br>                    neibors.add(next);<br>                chs[i] = <span class="hljs-string">&#x27;8&#x27;</span>;<br>                pre = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(chs);<br>                <span class="hljs-keyword">if</span> (!notAchievable.contains(pre))<br>                    neibors.add(pre);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                chs[i] = (<span class="hljs-type">char</span>) (ch + <span class="hljs-number">1</span>);<br>                next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(chs);<br>                <span class="hljs-keyword">if</span> (!notAchievable.contains(next))<br>                    neibors.add(next);<br>                chs[i] = (<span class="hljs-type">char</span>) (ch - <span class="hljs-number">1</span>);<br>                pre = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(chs);<br>                <span class="hljs-keyword">if</span> (!notAchievable.contains(pre))<br>                    neibors.add(pre);<br>            &#125;<br>            chs[i] = ch;<br>        &#125;<br>        <span class="hljs-keyword">return</span> neibors;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="找出最安全路径"><a href="https://leetcode.cn/problems/find-the-safest-path-in-a-grid/">6951. 找出最安全路径</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230806175345482.png" /></p>
<h3 id="方法一多源bfs">方法一：多源BFS</h3>
<p>二分做右端点的初始</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = Math.min(dist[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], dist[n - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>]);<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximumSafenessFactor</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; g)</span> &#123;<br>        n = g.size();<br>        grid = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j)<br>                grid[i][j] = g.get(i).get(j);<br>        <span class="hljs-type">int</span>[][] dist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        Queue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dist)<br>            Arrays.fill(arr, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j)<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>) &#123;<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, j&#125;);<br>                    dist[i][j] = <span class="hljs-number">0</span>;<br>                &#125;<br><br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span>[] node = queue.poll();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> node[<span class="hljs-number">0</span>] + dir[<span class="hljs-number">0</span>], col = node[<span class="hljs-number">1</span>] + dir[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span> (isValid(row, col) &amp;&amp; dist[row][col] == -<span class="hljs-number">1</span>) &#123;<br>                    dist[row][col] = dist[node[<span class="hljs-number">0</span>]][node[<span class="hljs-number">1</span>]] + <span class="hljs-number">1</span>;<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;row, col&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = Math.min(dist[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], dist[n - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (check(mid, dist))<br>                l = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                r = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> r;<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span> limit, <span class="hljs-type">int</span>[][] dist)</span> &#123;<br>        Queue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">boolean</span>[][] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n][n];<br>        queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;);<br>        visited[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span>[] node = queue.poll();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> node[<span class="hljs-number">0</span>] + dir[<span class="hljs-number">0</span>], col = node[<span class="hljs-number">1</span>] + dir[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span> (isValid(row, col) &amp;&amp; !visited[row][col] &amp;&amp; dist[row][col] &gt;= limit) &#123;<br>                    visited[row][col] = <span class="hljs-literal">true</span>;<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;row, col&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> visited[n - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>    &#125;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; n &amp;&amp; j &lt; n;<br>    &#125;<br><br>    <span class="hljs-type">int</span>[][] grid, dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-type">int</span> n;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="在check中判断初始位置r-2-n---1-大一点也没关系">在check中判断初始位置，r = 2 * n - 1 (大一点也没关系)</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (dist[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] &lt; limit)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure>
<h4 id="代码-1">代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximumSafenessFactor</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; g)</span> &#123;<br>        n = g.size();<br>        grid = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j)<br>                grid[i][j] = g.get(i).get(j);<br><br>        <span class="hljs-type">int</span>[][] dist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        Queue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dist)<br>            Arrays.fill(arr, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j)<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>) &#123;<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, j&#125;);<br>                    dist[i][j] = <span class="hljs-number">0</span>;<br>                &#125;<br><br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span>[] node = queue.poll();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> node[<span class="hljs-number">0</span>] + dir[<span class="hljs-number">0</span>], col = node[<span class="hljs-number">1</span>] + dir[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span> (isValid(row, col) &amp;&amp; dist[row][col] == -<span class="hljs-number">1</span>) &#123;<br>                    dist[row][col] = dist[node[<span class="hljs-number">0</span>]][node[<span class="hljs-number">1</span>]] + <span class="hljs-number">1</span>;<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;row, col&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = <span class="hljs-number">2</span> * n;<br>        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (check(mid, dist))<br>                l = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                r = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> r;<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span> limit, <span class="hljs-type">int</span>[][] dist)</span> &#123;<br>        Queue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">boolean</span>[][] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n][n];<br>        <span class="hljs-keyword">if</span> (dist[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] &lt; limit)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;);<br>        visited[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span>[] node = queue.poll();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> node[<span class="hljs-number">0</span>] + dir[<span class="hljs-number">0</span>], col = node[<span class="hljs-number">1</span>] + dir[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span> (isValid(row, col) &amp;&amp; !visited[row][col] &amp;&amp; dist[row][col] &gt;= limit) &#123;<br>                    visited[row][col] = <span class="hljs-literal">true</span>;<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;row, col&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> visited[n - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>    &#125;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; n &amp;&amp; j &lt; n;<br>    &#125;<br><br>    <span class="hljs-type">int</span>[][] grid, dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-type">int</span> n;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="check使用dfs">check使用DFS</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximumSafenessFactor</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; g)</span> &#123;<br>        n = g.size();<br>        grid = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        dist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        Queue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                grid[i][j] = g.get(i).get(j);<br>                dist[i][j] = -<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>) &#123;<br>                    dist[i][j] = <span class="hljs-number">0</span>;<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, j&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// bfs</span><br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span>[] node = queue.poll();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> node[<span class="hljs-number">0</span>] + dir[<span class="hljs-number">0</span>], col = node[<span class="hljs-number">1</span>] + dir[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span> (isValid(row, col) &amp;&amp; dist[row][col] == -<span class="hljs-number">1</span>) &#123;<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;row, col&#125;);<br>                    dist[row][col] = dist[node[<span class="hljs-number">0</span>]][node[<span class="hljs-number">1</span>]] + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = (n - <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (check(mid))<br>                l = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                r = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span> minDist)</span> &#123;<br>        <span class="hljs-keyword">if</span> (dist[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] &lt; minDist)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">boolean</span>[][] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n][n];<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, minDist, visited);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> minDist, <span class="hljs-type">boolean</span>[][] visited)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i == n -<span class="hljs-number">1</span> &amp;&amp; j == n - <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        visited[i][j] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], col =  j + dir[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (isValid(row, col) &amp;&amp; !visited[row][col] &amp;&amp; dist[row][col] &gt;= minDist) &#123;<br>                <span class="hljs-keyword">if</span> (dfs(row, col, minDist, visited))<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &gt;=<span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; n &amp;&amp; j &lt; n;<br>    &#125;<br><br>    <span class="hljs-type">int</span>[][] grid, dist, dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-type">int</span> n;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="int-visited数组visited数组只需要创建一次">int[][] visited数组，visited数组只需要创建一次</h3>
<p>要初始化为-1，因为会考虑到limit == 0的情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximumSafenessFactor</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; g)</span> &#123;<br>        n = g.size();<br>        grid = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        dist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : visited)<br>            Arrays.fill(arr, -<span class="hljs-number">1</span>);<br>        Queue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                grid[i][j] = g.get(i).get(j);<br>                dist[i][j] = -<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>) &#123;<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, j&#125;);<br>                    dist[i][j] = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 多源BFS</span><br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span>[] node = queue.poll();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> node[<span class="hljs-number">0</span>], j = node[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], col = j + dir[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span> (isValid(row, col) &amp;&amp; dist[row][col] == -<span class="hljs-number">1</span>) &#123;<br>                    dist[row][col] = dist[i][j] + <span class="hljs-number">1</span>;<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;row, col&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = <span class="hljs-number">2</span> * (n - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (check(mid))<br>                l = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                r = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span> limit)</span> &#123;<br>        <span class="hljs-keyword">if</span> (dist[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] &lt; limit)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, limit);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> limit)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i == n - <span class="hljs-number">1</span> &amp;&amp; j == n - <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        visited[i][j] = limit;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], col = j + dir[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (isValid(row,col) &amp;&amp; visited[row][col] != limit &amp;&amp; dist[row][col] &gt;= limit &amp;&amp; dfs(row, col, limit)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span>[][] grid, dist, dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">int</span>[][] visited;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; n &amp;&amp; j &lt; n;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二多源bfs-并查集">方法二：多源BFS + 并查集</h3>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230807195936407.png" /></p>
<p><strong>关于从dists.size() - 2开始枚举：最后一步是空集，所以最大的距离为 dists.size() - 2</strong></p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230807200100709.png" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximumSafenessFactor</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; g)</span> &#123;<br>        n = g.size();<br>        grid = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-type">int</span>[][] dist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dist)<br>            Arrays.fill(arr, -<span class="hljs-number">1</span>);<br>        List&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                grid[i][j] = g.get(i).get(j);<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>) &#123;<br>                    dist[i][j] = <span class="hljs-number">0</span>;<br>                    queue.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, j&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 多源BFS</span><br>        List&lt;List&lt;<span class="hljs-type">int</span>[]&gt;&gt; dists = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        dists.add(queue);<br>        List&lt;<span class="hljs-type">int</span>[]&gt; temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            temp = queue;<br>            queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] node : temp) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> node[<span class="hljs-number">0</span>] + dir[<span class="hljs-number">0</span>], col = node[<span class="hljs-number">1</span>] + dir[<span class="hljs-number">1</span>];<br>                    <span class="hljs-keyword">if</span> (isValid(row, col) &amp;&amp; dist[row][col] == -<span class="hljs-number">1</span>) &#123;  <span class="hljs-comment">// 没有被访问过</span><br>                        queue.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;row, col&#125;);<br>                        dist[row][col] = dists.size();<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 最后一步是空集，所以最大的距离为 dists.size() - 2</span><br>            dists.add(queue);<br>        &#125;<br>        <span class="hljs-comment">// 初始化并查集</span><br>        init(n * n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> dists.size() - <span class="hljs-number">2</span>; i &gt; <span class="hljs-number">0</span>; --i) &#123;<br>            List&lt;<span class="hljs-type">int</span>[]&gt; q = dists.get(i);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] node : q) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> node[<span class="hljs-number">0</span>] + dir[<span class="hljs-number">0</span>], col = node[<span class="hljs-number">1</span>] + dir[<span class="hljs-number">1</span>];<br>                    <span class="hljs-keyword">if</span> (isValid(row, col) &amp;&amp; dist[row][col] &gt;= i)<br>                        union(node[<span class="hljs-number">0</span>] * n + node[<span class="hljs-number">1</span>],row * n + col);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (findParent(<span class="hljs-number">0</span>) == findParent(n * n - <span class="hljs-number">1</span>))<br>                <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; n &amp;&amp; j &lt; n;<br>    &#125;<br><br>    <span class="hljs-type">int</span>[][] grid, dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-type">int</span> n;<br><br>    <span class="hljs-type">int</span>[] parent;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rootI</span> <span class="hljs-operator">=</span> findParent(i), rootJ = findParent(j);<br>        <span class="hljs-keyword">if</span> (rootI != rootJ) &#123;<br>            parent[rootI] = rootJ;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findParent</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i != parent[i])<br>            parent[i] = findParent(parent[i]);<br>        <span class="hljs-keyword">return</span> parent[i];<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        parent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            parent[i] = i;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="补充题-1631.-最小体力消耗路径">补充题 <a href="https://leetcode.cn/problems/path-with-minimum-effort/">1631. 最小体力消耗路径</a></h3>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230807221758342.png" /></p>
<h3 id="方法一多源bfs-二分">方法一：多源BFS + 二分</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumEffortPath</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] heights)</span> &#123;<br>        <span class="hljs-built_in">this</span>.heights = heights;<br>        m = heights.length;<br>        n = heights[<span class="hljs-number">0</span>].length;<br>        visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = (<span class="hljs-type">int</span>) <span class="hljs-number">1e6</span>;<br>        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (check(mid))<br>                r = mid - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> l;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span> limit)</span> &#123;<br>        visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n];<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, limit);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> limit)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i == m - <span class="hljs-number">1</span> &amp;&amp; j == n - <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        visited[i][j] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], col = j + dir[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (isValid(row, col) &amp;&amp; !visited[row][col] &amp;&amp; Math.abs(heights[i][j] - heights[row][col]) &lt;= limit)<br>                <span class="hljs-keyword">if</span> (dfs(row, col, limit))<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br><br>    <span class="hljs-type">int</span>[][] heights, dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-type">int</span> m, n;<br>    <span class="hljs-type">boolean</span>[][] visited;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &lt; n;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二并查集">方法二：并查集</h3>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230807223638902.png" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumEffortPath</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] heights)</span> &#123;<br>        <span class="hljs-built_in">this</span>.heights = heights;<br>        m = heights.length;<br>        n = heights[<span class="hljs-number">0</span>].length;<br>        visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n];<br>        List&lt;<span class="hljs-type">int</span>[]&gt; edges = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> i * n + j;<br>                <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>)<br>                    edges.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;id - n, id, Math.abs(heights[i][j] - heights[i - <span class="hljs-number">1</span>][j])&#125;);<br>                <span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">0</span>)<br>                    edges.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;id - <span class="hljs-number">1</span>, id, Math.abs(heights[i][j] - heights[i][j - <span class="hljs-number">1</span>])&#125;);<br>            &#125;<br>        &#125;<br>        Collections.sort(edges, (o1, o2) -&gt; o1[<span class="hljs-number">2</span>] - o2[<span class="hljs-number">2</span>]);<br>        <span class="hljs-comment">// 初始化并查集</span><br>        init(m * n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] edge : edges) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">from</span> <span class="hljs-operator">=</span> edge[<span class="hljs-number">0</span>], to = edge[<span class="hljs-number">1</span>], weight = edge[<span class="hljs-number">2</span>];<br>            union(from, to);<br>            <span class="hljs-keyword">if</span> (findParent(<span class="hljs-number">0</span>) == findParent(m * n - <span class="hljs-number">1</span>))<br>                <span class="hljs-keyword">return</span> weight;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span>[] parent;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rootI</span> <span class="hljs-operator">=</span> findParent(i), rootJ = findParent(j);<br>        <span class="hljs-keyword">if</span> (rootI != rootJ) &#123;<br>            parent[rootI] = rootJ;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findParent</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i != parent[i])<br>            parent[i] = findParent(parent[i]);<br>        <span class="hljs-keyword">return</span> parent[i];<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        parent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            parent[i] = i;<br>    &#125;<br><br><br><br>    <span class="hljs-type">int</span>[][] heights, dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-type">int</span> m, n;<br>    <span class="hljs-type">boolean</span>[][] visited;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &lt; n;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="在网格图中访问一个格子的最少时间"><a href="https://leetcode.cn/problems/minimum-time-to-visit-a-cell-in-a-grid/">在网格图中访问一个格子的最少时间</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230817210925572.png" /></p>
<h3 id="二刷-dijkstra">二刷 dijkstra</h3>
<p>无需visited数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumTime</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length, n = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">if</span> (grid[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] &gt; <span class="hljs-number">1</span> &amp;&amp; grid[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] &gt; <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span>[][] dist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dist)<br>            Arrays.fill(arr, Integer.MAX_VALUE &gt;&gt; <span class="hljs-number">1</span>);<br>        dist[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">boolean</span>[][] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n];<br>        PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((o1, o2) -&gt; o1[<span class="hljs-number">2</span>] - o2[<span class="hljs-number">2</span>]);<br>        q.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">int</span>[] node = q.poll();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> node[<span class="hljs-number">0</span>], j = node[<span class="hljs-number">1</span>], d = node[<span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">if</span> (i == m - <span class="hljs-number">1</span> &amp;&amp; j == n - <span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">return</span> d;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], col = j + dir[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span> (isValid(row, col, m, n)) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">nd</span> <span class="hljs-operator">=</span> Math.max(d, grid[row][col]);<br>                    nd += (nd + row + col) % <span class="hljs-number">2</span>;<br>                    <span class="hljs-keyword">if</span> (nd &lt; dist[row][col]) &#123;<br>                        dist[row][col] = nd;<br>                        q.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;row, col, nd&#125;);<br>                    &#125;<br>                &#125;<br>            &#125; <br>        &#125;<br>    &#125;<br><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &lt; n;<br>    &#125;<br><br>    <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;, &#123;-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;&#125;;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法一堆优化的dijkstra">方法一：堆优化的dijkstra</h3>
<p><strong>dist[i][j]与 i + j 同奇偶</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumTime</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-built_in">this</span>.grid = grid;<br>        m = grid.length;<br>        n = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">if</span> (grid[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] &gt; <span class="hljs-number">1</span> &amp;&amp; grid[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] &gt; <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span>[][] dist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">inf</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dist)<br>            Arrays.fill(arr, inf);<br>        dist[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">boolean</span>[][] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n];<br>        PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(((o1, o2) -&gt; o1[<span class="hljs-number">0</span>] - o2[<span class="hljs-number">0</span>]));<br>        queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span>[] arr = queue.poll();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>], i = arr[<span class="hljs-number">1</span>], j = arr[<span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">if</span> (i == m - <span class="hljs-number">1</span> &amp;&amp; j == n - <span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">return</span> d;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], col = j + dir[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span> (isValid(row, col)) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">nd</span> <span class="hljs-operator">=</span> Math.max(d + <span class="hljs-number">1</span>, grid[row][col]);<br>                    nd += (nd - row - col) % <span class="hljs-number">2</span>;<br>                    <span class="hljs-keyword">if</span> (nd &lt; dist[row][col]) &#123;<br>                        dist[row][col] = nd;<br>                        queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;nd, row, col&#125;);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dist[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-type">int</span>[][] grid, dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-type">int</span> m, n;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &lt; n;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二二分-bfs">方法二：二分+ BFS</h3>
<h4 id="双数组">双数组</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumTime</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-built_in">this</span>.grid = grid;<br>        m = grid.length;<br>        n = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">if</span> (grid[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] &gt; <span class="hljs-number">1</span> &amp;&amp; grid[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] &gt; <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> Math.max(m + n - <span class="hljs-number">2</span>, grid[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>]), right = (<span class="hljs-type">int</span>) <span class="hljs-number">1e5</span> + m + n;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (check(mid))<br>                right = mid - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left + (left + m + n) % <span class="hljs-number">2</span>; <span class="hljs-comment">// 答案要与 m + n - 2同奇偶</span><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span> limit)</span> &#123;<br>        <span class="hljs-type">boolean</span>[][] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n];<br>        visited[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>        List&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> limit - <span class="hljs-number">1</span>;<br>        queue.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;m - <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>&#125;);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            List&lt;<span class="hljs-type">int</span>[]&gt; temp = queue;<br>            queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : temp) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>], j = arr[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], col = j + dir[<span class="hljs-number">1</span>];<br>                    <span class="hljs-keyword">if</span> (isValid(row, col) &amp;&amp; !visited[row][col] &amp;&amp; grid[row][col] &lt;= t) &#123;<br>                        <span class="hljs-keyword">if</span> (row == <span class="hljs-number">0</span> &amp;&amp; col == <span class="hljs-number">0</span>)<br>                            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                        visited[row][col] = <span class="hljs-literal">true</span>;<br>                        queue.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;row, col&#125;);<br>                    &#125;<br>                &#125;<br>            &#125;<br>            --t;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br><br><br>    <span class="hljs-type">int</span>[][] grid, dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-type">int</span> m, n;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &lt; n;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="queue">Queue</h4>
<p>q.offer(new int[]{m - 1, n - 1, limit - 1});表示终点在limit时访问过，邻居的grid值要小于limit - 1</p>
<p>从limit - 1开始</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumTime</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length, n = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">if</span> (grid[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] &gt; <span class="hljs-number">1</span> &amp;&amp; grid[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] &gt; <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> Math.max(m + n - <span class="hljs-number">2</span>, grid[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>]), r = (<span class="hljs-type">int</span>) <span class="hljs-number">1e5</span>;<br>        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (check(mid, grid, m, n))<br>                r = mid - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <br>                l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> l + (l + m + n - <span class="hljs-number">2</span>) % <span class="hljs-number">2</span>; <span class="hljs-comment">// 答案需要和重点坐标[m - 1, n - 1]之和同奇偶</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span> limit, <span class="hljs-type">int</span>[][] grid, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">boolean</span>[][] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n];<br>        Queue&lt;<span class="hljs-type">int</span>[]&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        q.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;m - <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>, limit - <span class="hljs-number">1</span>&#125;);<br>        visited[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">while</span> (!q.isEmpty()) &#123;<br>            <span class="hljs-type">int</span>[] node = q.poll();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> node[<span class="hljs-number">0</span>], j = node[<span class="hljs-number">1</span>], t = node[<span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> &amp;&amp; j == <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], col = j + dir[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span> (isValid(row, col, m, n) &amp;&amp; !visited[row][col] &amp;&amp; t &gt;= grid[row][col]) &#123;<br>                    q.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;row, col, t - <span class="hljs-number">1</span>&#125;);<br>                    visited[row][col] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &lt; n;<br>    &#125;<br><br>    <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;, &#123;-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;&#125;;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithms</category>
        <category>Graph</category>
      </categories>
      <tags>
        <tag>图</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>Minimum Spanning Tree</title>
    <url>/2023/05/30/minimum-spanning-tree/</url>
    <content><![CDATA[<h2 id="连接所有点的最小费用"><a href="https://leetcode.cn/problems/min-cost-to-connect-all-points/">1584. 连接所有点的最小费用</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230530154215879.png" /></p>
<h3 id="方法一kruskal算法">方法一：Kruskal算法</h3>
<ol type="1">
<li><strong>依次选择权值最小的边</strong></li>
<li><strong>如果要加入的边会使得图形成环，则跳过</strong></li>
<li><strong>使用并查集来判断是否会形成环</strong>
<ol type="1">
<li><strong>如果两个顶点不在同一个子图中，连接边不会形成环</strong></li>
<li><strong>如果两个顶点在同一个子图中，连接边会形成环</strong></li>
<li><strong>恰好可以用union解决</strong></li>
</ol></li>
</ol>
<p><strong>比如有三个顶点，1，2，3那么所有的边为(1,2),(1,3),(2,3)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[][] edges = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n * (n - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>][<span class="hljs-number">3</span>];<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCostConnectPoints</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] points)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> points.length;<br>        <span class="hljs-comment">// edge[0]:顶点1，edge[1]:顶点2，edge[2]:权值(举例)</span><br>        <span class="hljs-type">int</span>[][] edges = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n * (n - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>][<span class="hljs-number">3</span>];<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; n; ++j)<br>                edges[index++] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, j, Math.abs(points[i][<span class="hljs-number">0</span>] - points[j][<span class="hljs-number">0</span>]) + Math.abs(points[i][<span class="hljs-number">1</span>] - points[j][<span class="hljs-number">1</span>])&#125;;<br>        <span class="hljs-keyword">return</span> kruskal(edges, n);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">kruskal</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] edges, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        init(n);<br>        Arrays.sort(edges, (o1, o2) -&gt; Integer.compare(o1[<span class="hljs-number">2</span>], o2[<span class="hljs-number">2</span>]));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] edge : edges) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">node1</span> <span class="hljs-operator">=</span> edge[<span class="hljs-number">0</span>], node2 = edge[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (union(node1, node2)) &#123; <span class="hljs-comment">// node1与node2不在同一个子图中，加入这条边不会形成环</span><br>                res += edge[<span class="hljs-number">2</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-type">int</span>[] parent;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rootI</span> <span class="hljs-operator">=</span> findParent(i), rootJ = findParent(j);<br>        <span class="hljs-keyword">if</span> (rootI != rootJ) &#123;<br>            parent[rootI] = rootJ;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findParent</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i != parent[i])<br>            parent[i] = findParent(parent[i]);<br>        <span class="hljs-keyword">return</span> parent[i];<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        parent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            parent[i] = i;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<div class="note note-danger">
            <p>面试用：节点多，边少的时候用 <strong>稠密图</strong></p>
          </div>
<h3 id="方法二prim算法">方法二：Prim算法</h3>
<p><strong>误区：以下是prim，prim需要更新的是已选顶点集距离未选顶点的最短距离</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j)<br>    <span class="hljs-keyword">if</span> (!visited[j] &amp;&amp; dist[j] &gt; graph[minIndex][j])<br>        dist[j] = graph[minIndex][j];<br></code></pre></td></tr></table></figure>
<p><strong>以下是dijkstra</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; ++j)<br>    <span class="hljs-keyword">if</span> (!visited[j] &amp;&amp; dist[j] &gt; graph[minIndex][j] + minDist)<br>        dist[j] = graph[minIndex][j] + minDist;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCostConnectPoints</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] points)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> points.length, index = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[][] graph = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; n; ++j)<br>                graph[i][j] = graph[j][i] = getMDistance(points[i], points[j]);<br>        <span class="hljs-keyword">return</span> prim(graph, n);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">prim</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] graph, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, inf = Integer.MAX_VALUE &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 已选顶点集距离未选顶点的距离</span><br>        <span class="hljs-type">int</span>[] dist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; ++i)<br>            dist[i] = inf;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">minIndex</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>, minDist = inf;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (!visited[j] &amp;&amp; dist[j] &lt; minDist) &#123;<br>                    minDist = dist[j];<br>                    minIndex = j;<br>                &#125;<br>            &#125;<br>            visited[minIndex] = <span class="hljs-literal">true</span>;<br>            res += minDist;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j)<br>                <span class="hljs-keyword">if</span> (!visited[j] &amp;&amp; dist[j] &gt; graph[minIndex][j])<br>                    dist[j] = graph[minIndex][j];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMDistance</span><span class="hljs-params">(<span class="hljs-type">int</span>[] d1, <span class="hljs-type">int</span>[] d2)</span> &#123;<br>        <span class="hljs-keyword">return</span> Math.abs(d1[<span class="hljs-number">0</span>] - d2[<span class="hljs-number">0</span>]) + Math.abs(d1[<span class="hljs-number">1</span>] - d2[<span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230603155941399.png" style="zoom:50%;" /></p>
]]></content>
      <categories>
        <category>Algorithms</category>
        <category>Graph</category>
      </categories>
      <tags>
        <tag>图</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>Union Find</title>
    <url>/2023/05/29/union-find/</url>
    <content><![CDATA[<div class="note note-success">
            <h2 id="并查集是一种高效的数据结构用于解决-连通问题成环问题等">并查集是一种高效的数据结构，用于解决 <strong>连通问题、成环问题</strong>等。</h2>
          </div>
<div class="note note-primary">
            <h2 id="模板">模板</h2>
          </div>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] parent;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rootI</span> <span class="hljs-operator">=</span> findParent(i), rootJ = findParent(j);<br>        <span class="hljs-keyword">if</span> (rootI != rootJ) &#123;<br>            parent[rootI] = rootJ;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findParent</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i != parent[i])<br>            parent[i] = findParent(parent[i]);<br>        <span class="hljs-keyword">return</span> parent[i];<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        parent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            parent[i] = i;<br>    &#125;<br></code></pre></td></tr></table></figure>
<h2 id="省份数量"><a href="https://leetcode.cn/problems/number-of-provinces/">547. 省份数量</a></h2>
<h3 id="方法一bfs">方法一：BFS</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">boolean</span>[] visited;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findCircleNum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] isConnected)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> isConnected.length, res = <span class="hljs-number">0</span>;<br>        visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (!visited[i]) &#123;<br>                bfs(i, isConnected, n);<br>                ++res;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span>[][] isConnected, <span class="hljs-type">int</span> n)</span> &#123;<br>        Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.offer(i);<br>        visited[i] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (isConnected[node][j] == <span class="hljs-number">1</span> &amp;&amp; !visited[j]) &#123;<br>                    visited[j] = <span class="hljs-literal">true</span>;<br>                    queue.offer(j);<br>                &#125;<br>            &#125;<br>        &#125;<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二dfs">方法二：DFS</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">boolean</span>[] visited;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findCircleNum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] isConnected)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> isConnected.length, res = <span class="hljs-number">0</span>;<br>        visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (!visited[i]) &#123;<br>                dfs(i, isConnected, n);<br>                ++res;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span>[][] isConnected, <span class="hljs-type">int</span> n)</span> &#123;<br>        visited[index] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (isConnected[index][i] == <span class="hljs-number">1</span> &amp;&amp; !visited[i]) &#123;<br>                dfs(i, isConnected, n);<br>            &#125;<br>        &#125;<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法三并查集">方法三：并查集</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findCircleNum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] isConnected)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> isConnected.length, res = n;<br>    parent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>        parent[i] = i;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; n; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (isConnected[i][j] == <span class="hljs-number">1</span> &amp;&amp; union(i, j))<br>                --res;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-type">int</span>[] parent;<br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">rootI</span> <span class="hljs-operator">=</span> findParent(i), rootJ = findParent(j);<br>    <span class="hljs-keyword">if</span> (rootI != rootJ) &#123;<br>        parent[rootI] = rootJ;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findParent</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-keyword">if</span> (i != parent[i])<br>        parent[i] = findParent(parent[i]);<br>    <span class="hljs-keyword">return</span> parent[i];<br>&#125;	<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230530093742081.png" style="zoom:50%;" /></p>
<h2 id="冗余连接"><a href="https://leetcode.cn/problems/redundant-connection/">684. 冗余连接</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230530151558968.png" /></p>
<h3 id="方法一并查集">方法一：并查集</h3>
<ol type="1">
<li><strong>初始化为森林，依次连接节点之间的边</strong></li>
<li><strong>如果连接边之前，节点不在同一个子集，那么合并</strong></li>
<li><strong>如果连接边之前，节点已经在同一个子集了，那么一定会形成环，这条边就是最后的冗余连接</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] findRedundantConnection(<span class="hljs-type">int</span>[][] edges) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> edges.length;<br>        init(n + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] edge : edges) &#123;<br>            <span class="hljs-keyword">if</span> (!union(edge[<span class="hljs-number">0</span>], edge[<span class="hljs-number">1</span>])) &#123;<br>                <span class="hljs-keyword">return</span> edge;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-type">int</span>[] parent;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rootI</span> <span class="hljs-operator">=</span> findParent(i), rootJ = findParent(j);<br>        <span class="hljs-keyword">if</span> (rootI != rootJ) &#123;<br>            parent[rootI] = rootJ;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findParent</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i != parent[i])<br>            parent[i] = findParent(parent[i]);<br>        <span class="hljs-keyword">return</span> parent[i];<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        parent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            parent[i] = i;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="连通网络的操作次数"><a href="https://leetcode.cn/problems/number-of-operations-to-make-network-connected/">1319. 连通网络的操作次数</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230530151619040.png" /></p>
<h3 id="方法一并查集-1">方法一：并查集</h3>
<ol type="1">
<li><p>找到连通分量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; n ; i++)<br>    <span class="hljs-keyword">if</span> (parent[i] == i)<br>        require++;<br></code></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">makeConnected</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] connections)</span> &#123;<br>        init(n);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">redundancy</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] connection : connections) &#123;<br>            <span class="hljs-keyword">if</span> (!union(connection[<span class="hljs-number">0</span>], connection[<span class="hljs-number">1</span>])) &#123; <span class="hljs-comment">// 已连通</span><br>                ++redundancy;<br>            &#125;<br>         &#125;<br>        <span class="hljs-comment">// 找到连通分量数，n个连通分量需要用n-1条边连接</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">require</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; n ; i++)<br>            <span class="hljs-keyword">if</span> (parent[i] == i)<br>                require++;<br>        <span class="hljs-keyword">if</span> (require &lt;= redundancy)<br>            <span class="hljs-keyword">return</span> require;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-type">int</span>[] parent;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rootI</span> <span class="hljs-operator">=</span> findParent(i), rootJ = findParent(j);<br>        <span class="hljs-keyword">if</span> (rootI != rootJ) &#123;<br>            parent[rootI] = rootJ;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findParent</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i != parent[i])<br>            parent[i] = findParent(parent[i]);<br>        <span class="hljs-keyword">return</span> parent[i];<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        parent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            parent[i] = i;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="面试题-16.19.-水域大小"><a href="https://leetcode.cn/problems/pond-sizes-lcci/">面试题 16.19. 水域大小</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230530110808266.png" /></p>
<h3 id="方法一dfs">方法一：DFS</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-type">boolean</span>[][] visited;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] pondSizes(<span class="hljs-type">int</span>[][] land) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> land.length, n = land[<span class="hljs-number">0</span>].length;<br>        visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n];<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (!visited[i][j] &amp;&amp; land[i][j] == <span class="hljs-number">0</span>) <br>                    list.add(dfs(land, m, n, i, j));<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span>[] res = list.stream().mapToInt(i-&gt;i).toArray();<br>        Arrays.sort(res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] land, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        visited[i][j] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], col = j + dir[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (isValid(m, n, row, col) &amp;&amp; !visited[row][col] &amp;&amp; land[row][col] == <span class="hljs-number">0</span>) &#123;<br>                length += dfs(land, m, n, row, col);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> length;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &lt; n;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二并查集">方法二：并查集</h3>
<ol type="1">
<li><p><strong>使用哈希表count记录池塘的大小</strong></p></li>
<li><p><strong>初始化，额外将count赋值1</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    parent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        parent[i] = i;<br>        count.put(i, <span class="hljs-number">1</span>);<br>    &#125;<br></code></pre></td></tr></table></figure></li>
<li><p><strong>如果land[i][j] != 0，那么必然不会是池塘，将count值赋-1</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (land[i][j] != <span class="hljs-number">0</span>)<br>   count.put(i * n + j, -<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure></li>
<li><p><strong>遍历依次合并，合并时将新parent的count加上被合并的count，并将被合并的parent的count赋值-1(便于收集结果)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">rootI</span> <span class="hljs-operator">=</span> findParent(i), rootJ = findParent(j);<br>    <span class="hljs-keyword">if</span> (rootI != rootJ) &#123;<br>        parent[rootI] = rootJ;<br>        count.put(rootJ, count.get(rootI) + count.get(rootJ));<br>        count.put(rootI, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p><strong>收集结果</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> val : count.values())<br>    <span class="hljs-keyword">if</span> (val != -<span class="hljs-number">1</span>)<br>        list.add(val);<br></code></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    Map&lt;Integer, Integer&gt; count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] pondSizes(<span class="hljs-type">int</span>[][] land) &#123;<br>        <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> land.length, n = land[<span class="hljs-number">0</span>].length;<br>        init(m * n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (land[i][j] != <span class="hljs-number">0</span>)<br>                    count.put(i * n + j, -<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span> (land[i][j] == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], col = j + dir[<span class="hljs-number">1</span>];<br>                        <span class="hljs-keyword">if</span> (isValid(m, n, row, col) &amp;&amp; land[row][col] == <span class="hljs-number">0</span>) &#123;<br>                            union(i * n + j, row * n + col);<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><span class="hljs-comment">//        for (Map.Entry&lt;Integer, Integer&gt; entry : count.entrySet()) &#123;</span><br><span class="hljs-comment">//            System.out.println(&quot;key: &quot; + entry.getKey() + &quot;, value: &quot; + entry.getValue());</span><br><span class="hljs-comment">//        &#125;</span><br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> val : count.values())<br>            <span class="hljs-keyword">if</span> (val != -<span class="hljs-number">1</span>)<br>                list.add(val);<br>        <span class="hljs-type">int</span>[] res = list.stream().mapToInt(i-&gt;i).toArray();<br>        Arrays.sort(res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &lt; n;<br>    &#125;<br><br>    <span class="hljs-type">int</span>[] parent;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rootI</span> <span class="hljs-operator">=</span> findParent(i), rootJ = findParent(j);<br>        <span class="hljs-keyword">if</span> (rootI != rootJ) &#123;<br>            parent[rootI] = rootJ;<br>            count.put(rootJ, count.get(rootI) + count.get(rootJ));<br>            count.put(rootI, -<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findParent</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i != parent[i])<br>            parent[i] = findParent(parent[i]);<br>        <span class="hljs-keyword">return</span> parent[i];<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        parent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            parent[i] = i;<br>            count.put(i, <span class="hljs-number">1</span>);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<div class="note note-warning">
            <h2 id="账户合并"><a href="https://leetcode.cn/problems/accounts-merge/">721. 账户合并</a></h2>
          </div>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230530130742383.png" /></p>
<h3 id="方法一并查集-2">方法一：并查集</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    Map&lt;String, Integer&gt; emailToId = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    Map&lt;Integer, List&lt;String&gt;&gt; idToEmail = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">accountsMerge</span><span class="hljs-params">(List&lt;List&lt;String&gt;&gt; accounts)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> accounts.size();<br>        init(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> accounts.get(i).size();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; size; ++j) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">email</span> <span class="hljs-operator">=</span> accounts.get(i).get(j);<br>                <span class="hljs-keyword">if</span> (!emailToId.containsKey(email)) &#123;<br>                    emailToId.put(email, i);<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    union(i, emailToId.get(email));<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (String email : emailToId.keySet()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">rootId</span> <span class="hljs-operator">=</span> findParent(emailToId.get(email));<br>            List&lt;String&gt; emails = idToEmail.getOrDefault(rootId, <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;());<br>            emails.add(email);<br>            idToEmail.put(rootId, emails);<br>        &#125;<br>        <span class="hljs-comment">// 加入name</span><br>        List&lt;List&lt;String&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, List&lt;String&gt;&gt; entry : idToEmail.entrySet()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> entry.getKey();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> accounts.get(id).get(<span class="hljs-number">0</span>);<br>            List&lt;String&gt; row = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>            row.add(name);<br>            List&lt;String&gt; emails = entry.getValue();<br>            Collections.sort(emails);<br>            row.addAll(emails);<br>            res.add(row);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-type">int</span>[] parent;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rootI</span> <span class="hljs-operator">=</span> findParent(i), rootJ = findParent(j);<br>        <span class="hljs-keyword">if</span> (rootI != rootJ) &#123;<br>            parent[rootI] = rootJ;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findParent</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i != parent[i])<br>            parent[i] = findParent(parent[i]);<br>        <span class="hljs-keyword">return</span> parent[i];<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        parent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            parent[i] = i;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<div class="note note-danger">
            <h2 id="剑指-offer-ii-119.-最长连续序列"><a href="https://leetcode.cn/problems/WhsWhI/">剑指 Offer II 119. 最长连续序列</a></h2>
          </div>
<h3 id="方法一并查集-3">方法一：并查集</h3>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230717145053062.png" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestConsecutive</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        init(nums);<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : nums)<br>            set.add(x);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : nums) &#123;<br>            <span class="hljs-keyword">if</span> (set.contains(x - <span class="hljs-number">1</span>)) &#123;<br>                union(x, x - <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (set.contains(x + <span class="hljs-number">1</span>)) &#123;<br>                union(x, x + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> cnt : count.values())<br>            res = Math.max(res, cnt);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i) &#123;<br>            parent.put(nums[i], nums[i]);<br>            count.put(nums[i], <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findParent</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-keyword">if</span> (num != parent.get(num))<br>            parent.put(num, findParent(parent.get(num)));<br>        <span class="hljs-keyword">return</span> parent.get(num);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rootI</span> <span class="hljs-operator">=</span> findParent(i), rootJ = findParent(j);<br>        <span class="hljs-keyword">if</span> (rootI != rootJ) &#123;<br>            count.put(rootI, count.get(rootI) + count.get(rootJ));<br>            parent.put(rootJ, rootI);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    Map&lt;Integer, Integer&gt; parent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(), count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithms</category>
        <category>Graph</category>
      </categories>
      <tags>
        <tag>图</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>Topological Sort</title>
    <url>/2023/05/29/topological-sort/</url>
    <content><![CDATA[<div class="note note-success">
            <h2 id="模板">模板</h2>
          </div>
<ol type="1">
<li><p>首先通过Map创建图graph，graph的key是节点，graph的value是节点key后继的集合；一般如下定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Map&lt;Character, Set&lt;Character&gt;&gt; graph = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br></code></pre></td></tr></table></figure></li>
<li><p>创建一个节点映射其入度的Map；一般如下定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Map&lt;Character, Integer&gt; inDegrees = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br></code></pre></td></tr></table></figure></li>
<li><p>初始化graph的节点，把每个节点都加入图中；初始化inDegrees</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (String word : words) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : word.toCharArray()) &#123;<br>        graph.putIfAbsent(ch, <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;());<br>        inDegrees.putIfAbsent(ch, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>初始化graph的边，同时计算入度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; words.length; ++i) &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">word1</span> <span class="hljs-operator">=</span> words[i - <span class="hljs-number">1</span>], word2 = words[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; word1.length() &amp;&amp; j &lt; word2.length(); ++j) &#123;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">ch1</span> <span class="hljs-operator">=</span> word1.charAt(j), ch2 = word2.charAt(j);<br>        <span class="hljs-keyword">if</span> (ch1 != ch2) &#123;<br>            <span class="hljs-keyword">if</span> (!graph.get(ch1).contains(ch2)) &#123;<br>                graph.get(ch1).add(ch2);<br>                inDegrees.put(ch2, inDegrees.get(ch2) + <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>创建队列，并把入度为0的节点加入队列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Queue&lt;Character&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> key : inDegrees.keySet())<br>    <span class="hljs-keyword">if</span> (inDegrees.get(key) == <span class="hljs-number">0</span>)<br>        queue.offer(key);<br></code></pre></td></tr></table></figure></li>
<li><p>创建一个记录结果的容器，每次从queue中取出一个节点，把该节点加入结果集，并将该节点后继的入度减一，如果该节点后继的入度为0，则加入队列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>        sb.append(node);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> next : graph.get(node)) &#123;<br>            inDegrees.put(next, inDegrees.get(next) - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (inDegrees.get(next) == <span class="hljs-number">0</span>)<br>                queue.offer(next);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li>
<li><p>如果结果集包含所有节点，则是有向无环图</p></li>
</ol>
<h2 id="课程表"><a href="https://leetcode.cn/problems/course-schedule/">207. 课程表</a></h2>
<h3 id="方法一拓扑排序">方法一：拓扑排序</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canFinish</span><span class="hljs-params">(<span class="hljs-type">int</span> numCourses, <span class="hljs-type">int</span>[][] prerequisites)</span> &#123;<br>        <span class="hljs-comment">// key表示先修的课程，value表示list中的课程需要先修key</span><br>        Map&lt;Integer, List&lt;Integer&gt;&gt; graph = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numCourses; ++i)<br>            graph.put(i, <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;());<br>        <span class="hljs-type">int</span>[] inDegrees = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[numCourses];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : prerequisites) &#123;<br>            graph.get(arr[<span class="hljs-number">1</span>]).add(arr[<span class="hljs-number">0</span>]);<br>            ++inDegrees[arr[<span class="hljs-number">0</span>]];<br>        &#125;<br>        Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numCourses; ++i)<br>            <span class="hljs-keyword">if</span> (inDegrees[i] == <span class="hljs-number">0</span>)<br>                queue.offer(i);<br>        List&lt;Integer&gt; order = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>            order.add(node);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> next : graph.get(node)) &#123;<br>                <span class="hljs-keyword">if</span> (--inDegrees[next] == <span class="hljs-number">0</span>)<br>                    queue.offer(next);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> order.size() == numCourses ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="课程表-ii"><a href="https://leetcode.cn/problems/course-schedule-ii/">210. 课程表 II</a></h2>
<h3 id="方法一拓扑排序-1">方法一：拓扑排序</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] findOrder(<span class="hljs-type">int</span> numCourses, <span class="hljs-type">int</span>[][] prerequisites) &#123;<br>        Map&lt;Integer, List&lt;Integer&gt;&gt; graph = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numCourses; ++i)<br>            graph.put(i, <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;());<br>        <span class="hljs-type">int</span>[] inDegrees = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[numCourses];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : prerequisites) &#123;<br>            graph.get(arr[<span class="hljs-number">1</span>]).add(arr[<span class="hljs-number">0</span>]);<br>            ++inDegrees[arr[<span class="hljs-number">0</span>]];<br>        &#125;<br>        Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numCourses; ++i)<br>            <span class="hljs-keyword">if</span> (inDegrees[i] == <span class="hljs-number">0</span>)<br>                queue.offer(i);<br>        List&lt;Integer&gt; order = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>            order.add(node);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> next : graph.get(node)) &#123;<br>                <span class="hljs-keyword">if</span> (--inDegrees[next] == <span class="hljs-number">0</span>)<br>                    queue.offer(next);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> order.size() == numCourses ? order.stream().mapToInt(i-&gt;i).toArray() : <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="剑指-offer-ii-114.-外星文字典"><a href="https://leetcode.cn/problems/Jf1JuT/">剑指 Offer II 114. 外星文字典</a></h2>
<h3 id="方法一拓扑排序-2">方法一：拓扑排序</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">alienOrder</span><span class="hljs-params">(String[] words)</span> &#123;<br>        Map&lt;Character, Set&lt;Character&gt;&gt; graph = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Map&lt;Character, Integer&gt; inDegrees = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (String word : words) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : word.toCharArray()) &#123;<br>                graph.putIfAbsent(ch, <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;());<br>                inDegrees.putIfAbsent(ch, <span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; words.length; ++i) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">word1</span> <span class="hljs-operator">=</span> words[i - <span class="hljs-number">1</span>], word2 = words[i];<br>            <span class="hljs-keyword">if</span> (word1.startsWith(word2) &amp;&amp; !word1.equals(word2))<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; word1.length() &amp;&amp; j &lt; word2.length(); ++j) &#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">ch1</span> <span class="hljs-operator">=</span> word1.charAt(j), ch2 = word2.charAt(j);<br>                <span class="hljs-keyword">if</span> (ch1 != ch2) &#123;<br>                    <span class="hljs-keyword">if</span> (!graph.get(ch1).contains(ch2)) &#123;<br>                        graph.get(ch1).add(ch2);<br>                        inDegrees.put(ch2, inDegrees.get(ch2) + <span class="hljs-number">1</span>);<br>                    &#125;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        Queue&lt;Character&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> key : inDegrees.keySet())<br>            <span class="hljs-keyword">if</span> (inDegrees.get(key) == <span class="hljs-number">0</span>)<br>                queue.offer(key);<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>            sb.append(node);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> next : graph.get(node)) &#123;<br>                inDegrees.put(next, inDegrees.get(next) - <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span> (inDegrees.get(next) == <span class="hljs-number">0</span>)<br>                    queue.offer(next);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.length() == inDegrees.size() ? sb.toString() : <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="剑指-offer-ii-115.-重建序列"><a href="https://leetcode.cn/problems/ur2n8P/">剑指 Offer II 115. 重建序列</a></h2>
<h3 id="方法一拓扑排序-3">方法一：拓扑排序</h3>
<p><strong>判断有向图的拓扑排序序列是否唯一</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">sequenceReconstruction</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span>[][] sequences)</span> &#123;<br>        Map&lt;Integer, Set&lt;Integer&gt;&gt; graph = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Map&lt;Integer, Integer&gt; inDegrees = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] seq : sequences) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; seq.length; ++i) &#123;<br>                graph.putIfAbsent(seq[i], <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;());<br>                inDegrees.putIfAbsent(seq[i], <span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] seq : sequences) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; seq.length; ++i) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">num1</span> <span class="hljs-operator">=</span> seq[i - <span class="hljs-number">1</span>], num2 = seq[i];<br>                <span class="hljs-keyword">if</span> (!graph.get(num1).contains(num2)) &#123;<br>                    graph.get(num1).add(num2);<br>                    inDegrees.put(num2, inDegrees.get(num2) + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> node : inDegrees.keySet())<br>            <span class="hljs-keyword">if</span> (inDegrees.get(node) == <span class="hljs-number">0</span>)<br>                queue.offer(node);<br>        List&lt;Integer&gt; order = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (queue.size() == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>            order.add(node);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> next : graph.get(node)) &#123;<br>                inDegrees.put(next, inDegrees.get(next) - <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span> (inDegrees.get(next) == <span class="hljs-number">0</span>)<br>                    queue.offer(next);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span>[] res = order.stream().mapToInt(i-&gt;i).toArray();<br>        <span class="hljs-keyword">return</span> Arrays.equals(res, nums);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="二刷">二刷</h3>
<p>返回queue.isEmpty();就好，如下例，节点1和3的入度都为0，queue.size()为二，不进入while(queue.size() == 1)，此时queue中有1和3，不为空，所以返回false</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], sequences = <span class="hljs-string">[[1,2]]</span><br>输出：<span class="hljs-literal">false</span><br>解释：最短可能的超序列为 [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]。<br>序列 [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>] 是它的子序列：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]。<br>因为 nums 不是最短的超序列，所以返回<span class="hljs-literal">false</span>。<br></code></pre></td></tr></table></figure>
<h4 id="代码">代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">sequenceReconstruction</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span>[][] sequences)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        Map&lt;Integer, List&lt;Integer&gt;&gt; graph = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Map&lt;Integer, Integer&gt; inDegrees = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            graph.putIfAbsent(nums[i], <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;());<br>            inDegrees.putIfAbsent(nums[i], <span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] sequence : sequences) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; sequence.length; ++i) &#123;<br>                graph.get(sequence[i - <span class="hljs-number">1</span>]).add(sequence[i]);<br>                inDegrees.put(sequence[i], inDegrees.get(sequence[i]) + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> key : inDegrees.keySet())<br>            <span class="hljs-keyword">if</span> (inDegrees.get(key) == <span class="hljs-number">0</span>)<br>                queue.offer(key);<br>        <span class="hljs-keyword">while</span> (queue.size() == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> next : graph.get(node)) &#123;<br>                inDegrees.put(next, inDegrees.get(next) - <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span> (inDegrees.get(next) == <span class="hljs-number">0</span>)<br>                    queue.offer(next);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> queue.isEmpty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="三刷">三刷</h3>
<p>inDegrees换成数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">sequenceReconstruction</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span>[][] sequences)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        Map&lt;Integer, List&lt;Integer&gt;&gt; graph = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span>[] inDegrees = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) <br>            graph.putIfAbsent(nums[i], <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] sequence : sequences) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; sequence.length; ++i) &#123;<br>                graph.get(sequence[i - <span class="hljs-number">1</span>]).add(sequence[i]);<br>                ++inDegrees[sequence[i]];<br>            &#125;<br>        &#125;<br>        Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>            <span class="hljs-keyword">if</span> (inDegrees[i] == <span class="hljs-number">0</span>)<br>                queue.offer(i);<br>        <span class="hljs-keyword">while</span> (queue.size() == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> next : graph.get(node)) &#123;<br>                --inDegrees[next];<br>                <span class="hljs-keyword">if</span> (inDegrees[next] == <span class="hljs-number">0</span>)<br>                    queue.offer(next);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> queue.isEmpty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<div class="note note-danger">
            <h2 id="最小高度树"><a href="https://leetcode.cn/problems/minimum-height-trees/">310. 最小高度树</a></h2>
          </div>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230529133457364.png" /></p>
<h3 id="方法一拓扑排序-4">方法一：拓扑排序</h3>
<ol type="1">
<li><p>此题的思路是：找到所有边缘上的节点，然后一层一层删除，直到队列为空，那队列中最后的值就是答案了。比如样例1：边缘的节点为0，2，3，删除后就只剩下1了。不难发现，<strong>边缘的节点就是度数为1</strong>的节点。</p></li>
<li><p>定义graph时为空，需要初始化每一个List</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">List&lt;Integer&gt;[] graph = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[n];<br></code></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">findMinHeightTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] edges)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> Arrays.asList(<span class="hljs-number">0</span>);<br>        List&lt;Integer&gt;[] graph = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            graph[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span>[] degree = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] edge : edges) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">node1</span> <span class="hljs-operator">=</span> edge[<span class="hljs-number">0</span>], node2 = edge[<span class="hljs-number">1</span>];<br>            graph[node1].add(node2);<br>            graph[node2].add(node1);<br>            ++degree[node1];<br>            ++degree[node2];<br>        &#125;<br>        Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            <span class="hljs-keyword">if</span> (degree[i] == <span class="hljs-number">1</span>)<br>                queue.offer(i);<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>                res.add(node);<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> next : graph[node]) &#123;<br>                    <span class="hljs-keyword">if</span> (--degree[next] == <span class="hljs-number">1</span>)<br>                        queue.offer(next);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="二刷-1">二刷</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">findMinHeightTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] edges)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> Arrays.asList(<span class="hljs-number">0</span>);<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        Map&lt;Integer, List&lt;Integer&gt;&gt; graph = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span>[] degrees = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            graph.put(i, <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] edge : edges) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">from</span> <span class="hljs-operator">=</span> edge[<span class="hljs-number">0</span>], to = edge[<span class="hljs-number">1</span>];<br>            graph.get(from).add(to);<br>            graph.get(to).add(from);<br>            degrees[from]++;<br>            degrees[to]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)<br>            <span class="hljs-keyword">if</span> (degrees[i] == <span class="hljs-number">1</span>)<br>                queue.offer(i);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            res.clear();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>                res.add(node);<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> next : graph.get(node)) &#123;<br>                    <span class="hljs-keyword">if</span> (--degrees[next] == <span class="hljs-number">1</span>)<br>                        queue.offer(next);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="找到最终的安全状态"><a href="https://leetcode.cn/problems/find-eventual-safe-states/">802. 找到最终的安全状态</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230529150440616.png" /></p>
<h3 id="方法一拓扑排序-5">方法一：拓扑排序</h3>
<ol type="1">
<li><strong>找到所有不进入环的节点</strong></li>
<li>求反向图，拓扑排序</li>
<li>入度为0的节点符合要求</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">eventualSafeNodes</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] graph)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> graph.length;<br>        List&lt;Integer&gt;[] adj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[n];<br>        <span class="hljs-type">int</span>[] indegrees = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            adj[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; graph.length; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; graph[i].length; ++j) &#123;<br>                adj[graph[i][j]].add(i);<br>            &#125;<br>            indegrees[i] = graph[i].length;<br>        &#125;<br>        Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            <span class="hljs-keyword">if</span> (indegrees[i] == <span class="hljs-number">0</span>)<br>                queue.offer(i);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> next : adj[node])<br>                <span class="hljs-keyword">if</span> (--indegrees[next] == <span class="hljs-number">0</span>)<br>                    queue.offer(next);<br>        &#125;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            <span class="hljs-keyword">if</span> (indegrees[i] == <span class="hljs-number">0</span>)<br>                res.add(i);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="二刷-2">二刷</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">eventualSafeNodes</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] g)</span> &#123;<br>        Map&lt;Integer, List&lt;Integer&gt;&gt; graph = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> g.length;<br>        <span class="hljs-type">int</span>[] outDegrees = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            graph.put(i, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; g.length; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; g[i].length; ++j) &#123;<br>                graph.get(g[i][j]).add(i);<br>                outDegrees[i]++;<br>            &#125;<br>        &#125;<br>        Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            <span class="hljs-keyword">if</span> (outDegrees[i] == <span class="hljs-number">0</span>)<br>                queue.offer(i);<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> next : graph.get(node)) &#123;<br>                <span class="hljs-keyword">if</span> (--outDegrees[next] == <span class="hljs-number">0</span>)<br>                    queue.offer(next);<br>            &#125;<br>        &#125;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) <br>            <span class="hljs-keyword">if</span> (outDegrees[i] == <span class="hljs-number">0</span>)<br>                res.add(i);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="收集树中金币"><a href="https://leetcode.cn/problems/collect-coins-in-a-tree/">2603. 收集树中金币</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230818173630191.png" /></p>
<h3 id="方法一两次拓扑排序">方法一：两次拓扑排序</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">collectTheCoins</span><span class="hljs-params">(<span class="hljs-type">int</span>[] coins, <span class="hljs-type">int</span>[][] edges)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> edges.length + <span class="hljs-number">1</span>;<br>        List&lt;Integer&gt;[] g = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[n];<br>        Arrays.setAll(g, e -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        <span class="hljs-type">int</span>[] degree = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] edge : edges) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">from</span> <span class="hljs-operator">=</span> edge[<span class="hljs-number">0</span>], to = edge[<span class="hljs-number">1</span>];<br>            g[from].add(to);<br>            g[to].add(from);<br>            ++degree[from];<br>            ++degree[to];<br>        &#125;<br>        Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            <span class="hljs-keyword">if</span> (degree[i] == <span class="hljs-number">1</span> &amp;&amp; coins[i] == <span class="hljs-number">0</span>)<br>                queue.offer(i);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> next : g[node])<br>                <span class="hljs-keyword">if</span> (--degree[next] == <span class="hljs-number">1</span> &amp;&amp; coins[next] == <span class="hljs-number">0</span>)<br>                    queue.offer(next);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            <span class="hljs-keyword">if</span> (degree[i] == <span class="hljs-number">1</span> &amp;&amp; coins[i] == <span class="hljs-number">1</span>)<br>                queue.offer(i);<br>        <span class="hljs-type">int</span>[] times = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> size= queue.size();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> next : g[node]) &#123;<br>                    <span class="hljs-keyword">if</span> (--degree[next] == <span class="hljs-number">1</span>) &#123;<br>                        queue.offer(next);<br>                        times[next] = t;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            ++t;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] edge : edges)<br>            <span class="hljs-keyword">if</span> (times[edge[<span class="hljs-number">0</span>]] &gt;= <span class="hljs-number">2</span> &amp;&amp; times[edge[<span class="hljs-number">1</span>]] &gt;= <span class="hljs-number">2</span>)<br>                res += <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="有向图访问计数"><a href="https://leetcode.cn/problems/count-visited-nodes-in-a-directed-graph/">2876. 有向图访问计数</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20231003221818802.png" /></p>
<h3 id="方法一拓扑排序-反向图">方法一：拓扑排序 + 反向图</h3>
<p>注意<strong>内向基环图</strong>可以包含多个环！！！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] countVisitedNodes(List&lt;Integer&gt; g) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> g.size();<br>        <span class="hljs-type">int</span>[] degree = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        List&lt;Integer&gt;[] rg = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[n];<br>        Arrays.setAll(rg, e -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">from</span> <span class="hljs-operator">=</span> i, to = g.get(i);<br>            degree[to]++;<br>            rg[to].add(from);<br>        &#125;<br>        Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            <span class="hljs-keyword">if</span> (degree[i] == <span class="hljs-number">0</span>)<br>                queue.offer(i);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> g.get(node);<br>            <span class="hljs-keyword">if</span> (--degree[next] == <span class="hljs-number">0</span>)<br>                queue.offer(next);<br>        &#125;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (degree[i] &lt;= <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            List&lt;Integer&gt; ring = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                ring.add(j);<br>                degree[j] = -<span class="hljs-number">1</span>;<br>                j = g.get(j);<br>                <span class="hljs-keyword">if</span> (j == i)<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : ring)<br>                dfs(x, ring.size(), rg, res, degree);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> size, List&lt;Integer&gt;[] rg, <span class="hljs-type">int</span>[] res, <span class="hljs-type">int</span>[] degree)</span> &#123;<br>        res[x] = size;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> next : rg[x]) &#123;<br>            <span class="hljs-keyword">if</span> (degree[next] == <span class="hljs-number">0</span>)<br>                dfs(next, size + <span class="hljs-number">1</span>, rg, res, degree);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="图中的最长环"><a href="https://leetcode.cn/problems/longest-cycle-in-a-graph/">2360. 图中的最长环</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20231004154033434.png" /></p>
<h3 id="方法一拓扑排序-基环树">方法一：拓扑排序 + 基环树</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestCycle</span><span class="hljs-params">(<span class="hljs-type">int</span>[] g)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> g.length;<br>        Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span>[] degree = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)  &#123;<br>            <span class="hljs-keyword">if</span> (g[i] != -<span class="hljs-number">1</span>)<br>                degree[g[i]]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            <span class="hljs-keyword">if</span> (degree[i] == <span class="hljs-number">0</span>)<br>                queue.offer(i);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> g[node];<br>            <span class="hljs-keyword">if</span> (next == -<span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (--degree[next] == <span class="hljs-number">0</span>)<br>                queue.offer(next);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (degree[i]&lt;= <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            degree[i] = -<span class="hljs-number">1</span>;<br>            List&lt;Integer&gt; ring = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            ring.add(i);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> g[i];<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-keyword">if</span> (next == i)<br>                    <span class="hljs-keyword">break</span>;<br>                degree[next] = -<span class="hljs-number">1</span>;<br>                ring.add(next);<br>                next = g[next];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (ring.size() &gt; <span class="hljs-number">0</span>)<br>                res = Math.max(res, ring.size());<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithms</category>
        <category>Graph</category>
      </categories>
      <tags>
        <tag>图</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>Dynamic Programming</title>
    <url>/2023/05/27/dynamic-programming/</url>
    <content><![CDATA[<h1 id="自底向上的动态规划">自底向上的动态规划</h1>
<h2 id="斐波那契数"><a href="https://leetcode.cn/problems/fibonacci-number/">509. 斐波那契数</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230527230019853.png" /></p>
<h3 id="方法一暴搜">方法一：暴搜</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">return</span> dfs(n);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span> || index == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> index;<br>        <span class="hljs-keyword">return</span> dfs(index - <span class="hljs-number">1</span>) + dfs(index - <span class="hljs-number">2</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二记忆化搜索">方法二：记忆化搜索</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">return</span> dfs(n);<br>    &#125;<br><br>    <span class="hljs-type">int</span>[] dp;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span> || index == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> index;<br>        <span class="hljs-keyword">if</span> (dp[index] != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> dp[index];<br>        <span class="hljs-keyword">return</span> dp[index] = dfs(index - <span class="hljs-number">1</span>) + dfs(index - <span class="hljs-number">2</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230619142056564.png" style="zoom:50%;" /></p>
<h3 id="方法三dp">方法三：DP</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span> || n == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; ++i)<br>            dp[i] = dp[i - <span class="hljs-number">2</span>] + dp[i - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法四dp-滚动数组">方法四：DP + 滚动数组</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span> || n == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; ++i)<br>            dp[i % <span class="hljs-number">3</span>] = dp[(i - <span class="hljs-number">2</span>) % <span class="hljs-number">3</span>] + dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">3</span>];<br>        <span class="hljs-keyword">return</span> dp[n % <span class="hljs-number">3</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="打家劫舍"><a href="https://leetcode.cn/problems/house-robber/">198. 打家劫舍</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230527230002809.png" /></p>
<h3 id="方法一暴搜-1">方法一：暴搜</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">return</span> dfs(nums, nums.length - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span> || index &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> index == <span class="hljs-number">0</span> ? nums[<span class="hljs-number">0</span>] : <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> Math.max(dfs(nums, index - <span class="hljs-number">2</span>) + nums[index], dfs(nums, index - <span class="hljs-number">1</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二记忆化搜索-1">方法二：记忆化搜索</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[] dp;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        Arrays.fill(dp, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(nums, nums.length - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span> || index &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> index == <span class="hljs-number">0</span> ? nums[<span class="hljs-number">0</span>] : <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (dp[index] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[index];<br>        <span class="hljs-keyword">return</span> dp[index] = Math.max(dfs(nums, index - <span class="hljs-number">2</span>) + nums[index], dfs(nums, index - <span class="hljs-number">1</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法三dp-1">方法三：DP</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// dp[i]：经过第i个房间能获得的最大价值</span><br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> Math.max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">1</span>] = Math.max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; nums.length; ++i) &#123;<br>            dp[i] = Math.max(dp[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>] + nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[nums.length - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法四dp-滚动数组-1">方法四：DP + 滚动数组</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// dp[i]：经过第i个房间能获得的最大价值</span><br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> Math.max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">1</span>] = Math.max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; nums.length; ++i) &#123;<br>            dp[i % <span class="hljs-number">3</span>] = Math.max(dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">3</span>], dp[(i - <span class="hljs-number">2</span>) % <span class="hljs-number">3</span>] + nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[(nums.length - <span class="hljs-number">1</span>) % <span class="hljs-number">3</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="最小路径和"><a href="https://leetcode.cn/problems/minimum-path-sum/">64. 最小路径和</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230527225946109.png" /></p>
<h3 id="方法一回溯">方法一：回溯</h3>
<h4 id="回溯一">回溯一</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minPathSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        dfs(grid, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">8000000</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> sum)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i == grid.length || j == grid[<span class="hljs-number">0</span>].length)<br>            <span class="hljs-keyword">return</span>;<br>        sum += grid[i][j];<br>        <span class="hljs-keyword">if</span> (i == grid.length - <span class="hljs-number">1</span> &amp;&amp; j == grid[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>) &#123;<br>            res = Math.min(res, sum);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        dfs(grid, i + <span class="hljs-number">1</span>, j, sum);<br>        dfs(grid, i, j + <span class="hljs-number">1</span>, sum);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="回溯二">回溯二</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minPathSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        dfs(grid, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">8000000</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> sum)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i == grid.length || j == grid[<span class="hljs-number">0</span>].length)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        sum += grid[i][j];<br>        <span class="hljs-keyword">if</span> (i == grid.length - <span class="hljs-number">1</span> &amp;&amp; j == grid[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>) &#123;<br>            res = Math.min(res, sum);<br>            <span class="hljs-keyword">return</span> sum;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dfs(grid, i + <span class="hljs-number">1</span>, j, sum) + dfs(grid, i, j + <span class="hljs-number">1</span>, sum);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<div class="note note-danger">
            <h3 id="方法二记忆化搜索">方法二：记忆化搜索</h3>
          </div>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minPathSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[grid.length][grid[<span class="hljs-number">0</span>].length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dp)<br>            Arrays.fill(arr, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(grid, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-type">int</span>[][] dp;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i == grid.length || j == grid[<span class="hljs-number">0</span>].length)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">8000000</span>;<br>        <span class="hljs-keyword">if</span> (dp[i][j] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[i][j];<br>        <span class="hljs-keyword">if</span> (i == grid.length - <span class="hljs-number">1</span> &amp;&amp; j == grid[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> grid[i][j];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[i][j] = grid[i][j] + Math.min(dfs(grid, i + <span class="hljs-number">1</span>, j), dfs(grid, i, j + <span class="hljs-number">1</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法三dp-2">方法三：DP</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minPathSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-comment">// dp[i][j]:走到grid[i][j]的最小路径</span><br>        <span class="hljs-comment">// 状态转移：dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]</span><br>        <span class="hljs-comment">// 初始化：第0行和第0列</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[grid.length][grid[<span class="hljs-number">0</span>].length];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; grid.length; ++i)<br>            dp[i][<span class="hljs-number">0</span>] += dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + grid[i][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; grid[<span class="hljs-number">0</span>].length; ++j)<br>            dp[<span class="hljs-number">0</span>][j] += dp[<span class="hljs-number">0</span>][j - <span class="hljs-number">1</span>] + grid[<span class="hljs-number">0</span>][j];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; grid.length; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; grid[<span class="hljs-number">0</span>].length; ++j) &#123;<br>                dp[i][j] = Math.min(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]) + grid[i][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[grid.length - <span class="hljs-number">1</span>][grid[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="不同路径"><a href="https://leetcode.cn/problems/unique-paths/">62. 不同路径</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230527225907180.png" /></p>
<h3 id="方法一回溯-1">方法一：回溯</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">return</span> dfs(m, n, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i == m + <span class="hljs-number">1</span> || j == n + <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (i == m &amp;&amp; j == n)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> dfs(m, n, i + <span class="hljs-number">1</span>, j) + dfs(m, n, i, j + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二记忆化搜索-2">方法二：记忆化搜索</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">return</span> dfs(m, n, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-type">int</span>[][] dp;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i == m + <span class="hljs-number">1</span> || j == n + <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (i == m &amp;&amp; j == n)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (dp[i][j] != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> dp[i][j];<br>        <span class="hljs-keyword">return</span> dp[i][j] = dfs(m, n, i + <span class="hljs-number">1</span>, j) + dfs(m, n, i, j + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法三组合数学">方法三：组合数学</h3>
<p><code>res = res * i / j</code>不能写成<code>*=</code>，因为可能<code>i / j</code>不为整数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n, j = <span class="hljs-number">1</span>; j &lt; m; ++i, ++j)<br>            res = res * i / j;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法四dp">方法四：DP</h3>
<p>第0行第0列赋值1，反正后面都会被覆盖，干脆全赋值1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dp)<br>    Arrays.fill(arr, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (m == <span class="hljs-number">1</span> || n == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dp)<br>            Arrays.fill(arr, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; ++j) &#123;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法五dp-滚动数组两行">方法五：DP + 滚动数组(两行)</h3>
<p>边界都是1，所以可以滚动，不同路径那题不行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (m == <span class="hljs-number">1</span> || n == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dp)<br>            Arrays.fill(arr, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; ++j) &#123;<br>                dp[i % <span class="hljs-number">2</span>][j] = dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][j] + dp[i % <span class="hljs-number">2</span>][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[(m - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法五dp-滚动数组一行">方法五：DP + 滚动数组(一行)</h3>
<p>这里把数组全部初始化为1，是为了模拟第0行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (m == <span class="hljs-number">1</span> || n == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Arrays.fill(dp, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; ++j) &#123;<br>                dp[j] += + dp[j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="不同路径-ii"><a href="https://leetcode.cn/problems/unique-paths-ii/">63. 不同路径 II</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230527225930838.png" /></p>
<h3 id="方法一回溯-2">方法一：回溯</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePathsWithObstacles</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] obstacleGrid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> obstacleGrid.length, n = obstacleGrid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">return</span> dfs(obstacleGrid, m, n, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] obstacleGrid, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i == m || j == n || obstacleGrid[i][j] == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (i == m - <span class="hljs-number">1</span> &amp;&amp; j == n - <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> dfs(obstacleGrid, m, n, i + <span class="hljs-number">1</span>, j) + dfs(obstacleGrid, m, n, i, j + <span class="hljs-number">1</span>);            <br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h3 id="方法二记忆化搜索-3">方法二：记忆化搜索</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePathsWithObstacles</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] obstacleGrid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> obstacleGrid.length, n = obstacleGrid[<span class="hljs-number">0</span>].length;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dp)<br>            Arrays.fill(arr, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(obstacleGrid, m, n, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-type">int</span>[][] dp;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] obstacleGrid, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i == m || j == n || obstacleGrid[i][j] == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (i == m - <span class="hljs-number">1</span> &amp;&amp; j == n - <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (dp[i][j] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[i][j];<br>        <span class="hljs-keyword">return</span> dp[i][j] = dfs(obstacleGrid, m, n, i + <span class="hljs-number">1</span>, j) + dfs(obstacleGrid, m, n, i, j + <span class="hljs-number">1</span>);            <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法三dp-3">方法三：DP</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePathsWithObstacles</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] obstacleGrid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> obstacleGrid.length, n = obstacleGrid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (obstacleGrid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">break</span>;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (obstacleGrid[<span class="hljs-number">0</span>][j] == <span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">break</span>;<br>            dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (obstacleGrid[i][j] == <span class="hljs-number">1</span>)<br>                    <span class="hljs-keyword">continue</span>;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法五dp-滚动数组">方法五：DP + 滚动数组</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePathsWithObstacles</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] obstacleGrid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> obstacleGrid.length, n = obstacleGrid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        dp[<span class="hljs-number">0</span>] = obstacleGrid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (obstacleGrid[i][j] == <span class="hljs-number">1</span>) &#123;<br>                    dp[j] = <span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (j &gt;= <span class="hljs-number">1</span> &amp;&amp; obstacleGrid[i][j - <span class="hljs-number">1</span>] == <span class="hljs-number">0</span>)<br>                    dp[j] += dp[j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<div class="note note-danger">
            <h2 id="不同路径-iii"><a href="https://leetcode.cn/problems/unique-paths-iii/">980. 不同路径 III</a></h2>
          </div>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230804145155501.png" /></p>
<h3 id="方法一回溯-先放错误版本debug1个多小时">方法一：回溯 先放错误版本，debug1个多小时</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePathsIII</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-built_in">this</span>.grid = grid;<br>        m = grid.length;<br>        n = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[] oriIndex = <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">0</span>)<br>                    ++left;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>)<br>                    oriIndex = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, j&#125;;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dfs(oriIndex[<span class="hljs-number">0</span>], oriIndex[<span class="hljs-number">1</span>], left + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> left)</span> &#123;<br>        <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> left == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], col = j + dir[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (isValid(row, col) &amp;&amp; grid[row][col] != -<span class="hljs-number">1</span>) &#123;<br>               <span class="hljs-type">int</span> <span class="hljs-variable">temp1</span> <span class="hljs-operator">=</span> grid[row][col];<br>               grid[row][col] = -<span class="hljs-number">1</span>;<br>                res += dfs(row, col, left - <span class="hljs-number">1</span>);<br>               grid[row][col] = temp1;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &lt; n;<br>    &#125;<br><br>    <span class="hljs-type">int</span>[][] grid, dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;;<br>    <span class="hljs-type">int</span> m, n;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>在错误版本中，是将邻居grid[row][col] = -1;置为以访问状态，那么从i ，j递归到 row, col又可以递归回i,j所以left的次数一定是错的</strong></p>
<h3 id="回溯正确版本">回溯正确版本</h3>
<p><strong>将i,j置为以访问状态</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePathsIII</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-built_in">this</span>.grid = grid;<br>        m = grid.length;<br>        n = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[] oriIndex = <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">0</span>)<br>                    ++left;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>)<br>                    oriIndex = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, j&#125;;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dfs(oriIndex[<span class="hljs-number">0</span>], oriIndex[<span class="hljs-number">1</span>], left + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> left)</span> &#123;<br>        <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> left == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, temp = grid[i][j];<br>        grid[i][j] = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], col = j + dir[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (isValid(row, col) &amp;&amp; (grid[row][col] == <span class="hljs-number">0</span> || grid[row][col] == <span class="hljs-number">2</span>)) &#123;<br>                res += dfs(row, col, left - <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        grid[i][j] = temp;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &lt; n;<br>    &#125;<br><br>    <span class="hljs-type">int</span>[][] grid, dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;;<br>    <span class="hljs-type">int</span> m, n;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="杨辉三角"><a href="https://leetcode.cn/problems/pascals-triangle/">118. 杨辉三角</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230527202837964.png" /></p>
<h3 id="方法一dp">方法一：DP</h3>
<p>最后一行的长度是<code>2n - 1</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">generate</span><span class="hljs-params">(<span class="hljs-type">int</span> numRows)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[numRows][numRows * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>][dp[<span class="hljs-number">0</span>].length / <span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;<br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(Arrays.asList(<span class="hljs-number">1</span>)));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; numRows; ++i) &#123;<br>            List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; dp[<span class="hljs-number">0</span>].length; ++j) &#123;<br>                dp[i][j] = (j &lt; dp[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span> ? dp[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] : <span class="hljs-number">0</span>) + (j &gt;= <span class="hljs-number">1</span> ? dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] : <span class="hljs-number">0</span>);<br>                <span class="hljs-keyword">if</span> (dp[i][j] != <span class="hljs-number">0</span>)<br>                    list.add(dp[i][j]);<br>            &#125;<br>            res.add(list);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230527202820856.png" style="zoom:50%;" /></p>
<h3 id="方法二dp">方法二：DP</h3>
<p><strong>第一列与最后一列是1</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">generate</span><span class="hljs-params">(<span class="hljs-type">int</span> numRows)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        1</span><br><span class="hljs-comment">        1 1</span><br><span class="hljs-comment">        1 2 1</span><br><span class="hljs-comment">        1 3 3 1</span><br><span class="hljs-comment">         */</span><br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        List&lt;Integer&gt; row = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-comment">// 第一行</span><br>        row.add(<span class="hljs-number">1</span>);<br>        res.add(row);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= numRows; ++i) &#123;<br>            row = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>            <span class="hljs-comment">// 第一列</span><br>            row.add(<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; i - <span class="hljs-number">1</span>; ++j) <br>                row.add(res.get(i - <span class="hljs-number">2</span>).get(j - <span class="hljs-number">1</span>) + res.get(i - <span class="hljs-number">2</span>).get(j));<br>            <span class="hljs-comment">// 最后一列</span><br>            row.add(<span class="hljs-number">1</span>);<br>            res.add(row); <span class="hljs-comment">// 在res中的下标为i - 1</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230619144401650.png" /></p>
<h2 id="三角形最小路径和"><a href="https://leetcode.cn/problems/triangle/">120. 三角形最小路径和</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230527202937390.png" /></p>
<div class="note note-info">
            <h3 id="二刷回溯">二刷回溯</h3>
          </div>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumTotal</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        2</span><br><span class="hljs-comment">        3 4</span><br><span class="hljs-comment">        6 5 7</span><br><span class="hljs-comment">        4 1 8 3</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">return</span> dfs(triangle, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; triangle, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i == triangle.size())<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> triangle.get(i).get(j) + Math.min(dfs(triangle, i + <span class="hljs-number">1</span>, j), dfs(triangle, i + <span class="hljs-number">1</span>, j + <span class="hljs-number">1</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<div class="note note-info">
            <h3 id="二刷记忆化搜索">二刷记忆化搜索</h3>
          </div>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumTotal</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        2</span><br><span class="hljs-comment">        3 4</span><br><span class="hljs-comment">        6 5 7</span><br><span class="hljs-comment">        4 1 8 3</span><br><span class="hljs-comment">         */</span><br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[triangle.size()][triangle.size()];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dp)<br>            Arrays.fill(arr, <span class="hljs-number">10001</span>);<br>        <span class="hljs-keyword">return</span> dfs(triangle, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-type">int</span>[][] dp;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; triangle, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i == triangle.size())<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (dp[i][j] != <span class="hljs-number">10001</span>)<br>            <span class="hljs-keyword">return</span> dp[i][j];<br>        <span class="hljs-keyword">return</span> dp[i][j] = triangle.get(i).get(j) + Math.min(dfs(triangle, i + <span class="hljs-number">1</span>, j), dfs(triangle, i + <span class="hljs-number">1</span>, j + <span class="hljs-number">1</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230619155231380.png" /></p>
<h3 id="二刷dp">二刷DP</h3>
<p>dp数组多创建一列，把dp数组初始化为10001，处理第一列没有左上方元素与最后一列没有正上方元素的特殊情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[triangle.size()][triangle.size() + <span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure>
<h4 id="代码">代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumTotal</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        2</span><br><span class="hljs-comment">        3 4</span><br><span class="hljs-comment">        6 5 7</span><br><span class="hljs-comment">        4 1 8 3</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> (triangle.size() == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> triangle.get(<span class="hljs-number">0</span>).get(<span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// dp[i][j]：到达i，j的最短距离</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[triangle.size()][triangle.size() + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> <span class="hljs-number">10001</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dp)<br>            Arrays.fill(arr, <span class="hljs-number">10001</span>);<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = triangle.get(<span class="hljs-number">0</span>).get(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; triangle.size(); ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; triangle.get(i).size(); ++j) &#123;<br>                dp[i][j + <span class="hljs-number">1</span>] = Math.min(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>]) + triangle.get(i).get(j);<br>                <span class="hljs-keyword">if</span> (i == triangle.size() - <span class="hljs-number">1</span>) <br>                    min = Math.min(min, dp[i][j + <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> min;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="从最后一行开始遍历">从最后一行开始遍历</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumTotal</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        2</span><br><span class="hljs-comment">        3 4</span><br><span class="hljs-comment">        6 5 7</span><br><span class="hljs-comment">        4 1 8 3</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-comment">// dp[i][j]：到达i，j的最短距离</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> triangle.size();<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= i; ++j) &#123;<br>                dp[i][j] = Math.min(dp[i + <span class="hljs-number">1</span>][j], dp[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>]) + triangle.get(i).get(j);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法一回溯-3">方法一：回溯</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumTotal</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> triangle.size();<br>        <span class="hljs-type">int</span>[][] list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i + <span class="hljs-number">1</span>; ++j) &#123;<br>                list[i][j] = triangle.get(i).get(j);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dfs(list, n, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] list, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">if</span> (j &gt; i)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (i == n - <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> list[i][j];<br>        <span class="hljs-keyword">return</span> Math.min(dfs(list, n, i + <span class="hljs-number">1</span>, j), dfs(list, n, i + <span class="hljs-number">1</span>, j + <span class="hljs-number">1</span>)) + list[i][j];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二记忆化搜索一">方法二：记忆化搜索一</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumTotal</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> triangle.size();<br>        <span class="hljs-type">int</span>[][] list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dp)<br>            Arrays.fill(arr, Integer.MAX_VALUE);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i + <span class="hljs-number">1</span>; ++j) &#123;<br>                list[i][j] = triangle.get(i).get(j);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dfs(list, n, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-type">int</span>[][] dp;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] list, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">if</span> (j &gt; i)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (i == n - <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> list[i][j];<br>        <span class="hljs-keyword">if</span> (dp[i][j] != Integer.MAX_VALUE)<br>            <span class="hljs-keyword">return</span> dp[i][j];<br>        <span class="hljs-keyword">return</span> dp[i][j] = Math.min(dfs(list, n, i + <span class="hljs-number">1</span>, j), dfs(list, n, i + <span class="hljs-number">1</span>, j + <span class="hljs-number">1</span>)) + list[i][j];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230527211911834.png" /></p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230527210340694.png" alt="image-20230527210340694" style="zoom:50%;" /></p>
<h4 id="优化记忆化搜索">优化记忆化搜索</h4>
<p><strong>只改动了base case</strong></p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230527213356106.png" /></p>
<p>i == n-1就直接返回，会使最后一次dp信息漏掉，如果最后一行很长，那么会多进入dfs很多次</p>
<p>注意最后一行</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230527213643317.png" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumTotal</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> triangle.size();<br>        <span class="hljs-type">int</span>[][] list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dp)<br>            Arrays.fill(arr, Integer.MAX_VALUE);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i + <span class="hljs-number">1</span>; ++j) &#123;<br>                list[i][j] = triangle.get(i).get(j);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dfs(list, n, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-type">int</span>[][] dp;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] list, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">if</span> (j &gt; i)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (i == n)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (dp[i][j] != Integer.MAX_VALUE)<br>            <span class="hljs-keyword">return</span> dp[i][j];<br>        <span class="hljs-keyword">return</span> dp[i][j] = Math.min(dfs(list, n, i + <span class="hljs-number">1</span>, j), dfs(list, n, i + <span class="hljs-number">1</span>, j + <span class="hljs-number">1</span>)) + list[i][j];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法三dp-4">方法三：DP</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumTotal</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> triangle.size();<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dp)<br>            Arrays.fill(arr, Integer.MAX_VALUE);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i + <span class="hljs-number">1</span>; ++j) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">1</span>) &#123;<br>                    pre = dp[i - <span class="hljs-number">1</span>][j];<br>                    <span class="hljs-keyword">if</span> (j &gt;= <span class="hljs-number">1</span>)<br>                        pre = Math.min(pre, dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]);<br>                &#125;<br>                dp[i][j] = triangle.get(i).get(j) + pre;<br>                <span class="hljs-keyword">if</span> (i == n - <span class="hljs-number">1</span>)<br>                    res = Math.min(res, dp[i][j]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230527221851481.png" style="zoom:50%;" /></p>
<div class="note note-success">
            <h3 id="方法四dp-滚动数组">方法四：DP + 滚动数组</h3>
          </div>
<p><strong>和01背包类似，第二次for循环要倒序遍历；如果正序遍历那么pre = dp[j]拿到的是第i行的数据，我们需要的是第i-1行的数据</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumTotal</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> triangle.size();<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Arrays.fill(dp, <span class="hljs-number">1000000</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &gt;= <span class="hljs-number">0</span>; --j) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">1</span>) &#123;<br>                    pre = dp[j];<br>                    <span class="hljs-keyword">if</span> (j &gt;= <span class="hljs-number">1</span>)<br>                        pre = Math.min(pre, dp[j - <span class="hljs-number">1</span>]);<br>                &#125;<br>                dp[j] = triangle.get(i).get(j) + pre;<br>                <span class="hljs-keyword">if</span> (i == n - <span class="hljs-number">1</span>)<br>                    res = Math.min(res, dp[j]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="完全平方数"><a href="https://leetcode.cn/problems/perfect-squares/">279. 完全平方数</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230528163013230.png" /></p>
<p><strong>完全背包问题</strong></p>
<h3 id="方法一dp-1">方法一：DP</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numSquares</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) Math.sqrt(n);<br>        <span class="hljs-type">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            nums[i] = (i + <span class="hljs-number">1</span>) * (i + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-comment">// dp[j]:容量为j的背包最少需要多少个数字填满</span><br>        <span class="hljs-comment">// dp[0] = 0</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; dp.length; ++i)<br>            dp[i] = <span class="hljs-number">10001</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> nums[i]; j &lt;= n; ++j) &#123;<br>                dp[j] = Math.min(dp[j], dp[j - nums[i]] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="组合总和-ⅳ"><a href="https://leetcode.cn/problems/combination-sum-iv/">377. 组合总和 Ⅳ</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230528163035849.png" /></p>
<p><strong>思路：</strong></p>
<ol type="1">
<li><strong>排列问题</strong></li>
<li><strong>爬楼梯问题</strong></li>
</ol>
<h3 id="方法一dp-2">方法一：DP</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">combinationSum4</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-comment">// dp[i]:组成i的排列种数</span><br>        <span class="hljs-comment">// dp[i] += dp[i - nums[j]]</span><br>        <span class="hljs-comment">// dp[0] = 1，后面状态根据1往上加</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[target + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= target; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; nums.length; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (i &gt;= nums[j]) &#123;<br>                    dp[i] += dp[i - nums[j]];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[target];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果要求返回所有排列数，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">package</span> 背包;<br><br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum4</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        backtracking(nums, target, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (target == <span class="hljs-number">0</span>) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> index; i &lt; nums.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (target &lt; nums[i])<br>                <span class="hljs-keyword">break</span>;<br>            path.offerLast(nums[i]);<br>            backtracking(nums, target - nums[i], index);<br>            path.pollLast();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Solution</span> <span class="hljs-variable">solution</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Solution</span>();<br>        System.out.println(solution.combinationSum4(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;, <span class="hljs-number">4</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="最长递增子序列"><a href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230528163054886.png" /></p>
<h3 id="方法一dp-3">方法一：DP</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// dp[j]: 以下标j结尾的最长递增子序列的长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        Arrays.fill(dp, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; nums.length; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (nums[j] &gt; nums[i]) &#123;<br>                    dp[j] = Math.max(dp[j], dp[i] + <span class="hljs-number">1</span>);<br>                &#125;<br>                res = Math.max(res, dp[j]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="二刷dp从前往后">二刷DP：从前往后</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// dp[i]：下标为i前的子数组的最长递增子序列的长度</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];    <br>        Arrays.fill(dp, <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (nums[j] &lt; nums[i]) &#123;<br>                    dp[i] = Math.max(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>                    res = Math.max(res, dp[i]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二贪心-二分">方法二：贪心 + 二分</h3>
<h2 id="最长连续递增序列"><a href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/">674. 最长连续递增序列</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230528163129565.png" /></p>
<h3 id="方法一暴力">方法一：暴力</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findLengthOfLCIS</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// dp[j]: 以下标j为结尾的子数组的长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; nums.length; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (nums[j] &gt; nums[j - <span class="hljs-number">1</span>]) &#123;<br>                    ++length;<br>                res = Math.max(res, length);<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    length = <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230528161933465.png" style="zoom:50%;" /></p>
<h3 id="方法二dp-1">方法二：DP</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findLengthOfLCIS</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// dp[j]: 以下标j为结尾的最长连续递增序列的长度</span><br>        <span class="hljs-comment">// dp[j] = dp[j - 1] + 1</span><br>        <span class="hljs-comment">// dp[:] = 1</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        Arrays.fill(dp, <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; nums[i - <span class="hljs-number">1</span>]) &#123;<br>                dp[i] = dp[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                res = Math.max(res, dp[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法三dp-滚动数组">方法三：DP + 滚动数组</h3>
<p><strong>如果nums[i] &lt;= nums[i-1]，记得dp[i % 2] = 1;</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findLengthOfLCIS</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// dp[j]: 以下标j为结尾的最长连续递增序列的长度</span><br>        <span class="hljs-comment">// dp[j] = dp[j - 1] + 1</span><br>        <span class="hljs-comment">// dp[:] = 1</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>        Arrays.fill(dp, <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; nums[i - <span class="hljs-number">1</span>]) &#123;<br>                dp[i % <span class="hljs-number">2</span>] = dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>] + <span class="hljs-number">1</span>;<br>                res = Math.max(res, dp[i % <span class="hljs-number">2</span>]);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                dp[i % <span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="最长重复子数组"><a href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/">718. 最长重复子数组</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230528163115919.png" /></p>
<p><a href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/solutions/310509/zhe-yao-jie-shi-ken-ding-jiu-dong-liao-by-hyj8/">动动脑子吧你</a></p>
<h4 id="方法一暴力-1">方法一：暴力</h4>
<ol type="1">
<li>时间复杂度：<span class="math inline">\(O(m^2n)\)</span></li>
<li>空间复杂度：<span class="math inline">\(O(1)\)</span></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findLength</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums1.length; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; nums2.length; ++j) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">count1</span> <span class="hljs-operator">=</span> i, count2 = j;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">while</span> (count1 &lt; nums1.length &amp;&amp; count2 &lt; nums2.length &amp;&amp; nums1[count1] == nums2[count2]) &#123;<br>                    ++counter;<br>                    ++count1;<br>                    ++count2;<br>                &#125;<br>                res = Math.max(res, counter);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230418155756679.png" alt="" style="zoom:50%;" /></p>
<h4 id="方法二dp-2">方法二：DP</h4>
<ol type="1">
<li>dp[i][j]:以nums1[i - 1]结尾与以nums2[j - 1]结尾时的最长重复子数组</li>
<li>状态转移公式：当nums1[i - 1] == nums2[j - 1]时，dp[i][j] = dp[i - 1][j - 1] + 1<br />
</li>
<li>初始化：m为nums1的长度，n为nums2的长度，初始化(m + 1) * (n + 1)的二维数组，第一行第一列初始化为0，因为任一数组为空，就不会有重复子数组</li>
<li>注意事项：输出结果是dp数组中的最大值，因为最长的重复子数组不一定是在两数组的结尾处，可以在循环内比较</li>
<li>时间复杂度：<span class="math inline">\(O(mn)\)</span></li>
<li>空间复杂度：<span class="math inline">\(O(mn)\)</span></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findLength</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> nums1.length, n = nums2.length;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (nums1[i - <span class="hljs-number">1</span>] == nums2[j - <span class="hljs-number">1</span>]) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                    result = Math.max(result, dp[i][j]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230418164535723.png" alt="" style="zoom:50%;" /></p>
<p>滚动数组缩减空间复杂度</p>
<ol type="1">
<li><p>dp数组为第二个数组的长度加一</p></li>
<li><p>不相等时要把dp[j]赋0，不然之后会出错</p></li>
<li><p><strong>此时遍历第二个数组的时候，就要从后向前遍历，这样避免重复覆盖</strong>。</p>
<p>比如nums1 = [1, 2, 3, 1],nums2 = [1,6,8,1,3,1,2,3]</p>
<p>i = 1时候，dp数组为[1,0,0,1,0,1,0,0]</p>
<p>i = 2时候，dp数组为[0,0,0,0,0,0,1,0]</p>
<p>i = 3时候，dp数组为[0,0,0,0,1,0,0,2]</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230418180633319.png" alt="image-20230418180633319" style="zoom:50%;" /></p>
<p>i=3时，如果第二层for循环j从前往后遍历，那么dp倒数第二个位置会因为3!=2，被赋0，进而导致dp最后一个位置是1而不是2</p></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findLength</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums2.length + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= nums1.length; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> nums2.length; j &gt; <span class="hljs-number">0</span>; --j) &#123;<br>                <span class="hljs-keyword">if</span> (nums1[i - <span class="hljs-number">1</span>] == nums2[j - <span class="hljs-number">1</span>]) &#123;<br>                    dp[j] = dp[j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    dp[j] = <span class="hljs-number">0</span>;<br>                &#125;<br>                res = Math.max(res, dp[j]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230418175604367.png" alt="" style="zoom:50%;" /></p>
<h2 id="最长公共子序列"><a href="https://leetcode.cn/problems/longest-common-subsequence/">1143. 最长公共子序列</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230528180446840.png" /></p>
<div class="note note-warning">
            <h3 id="方法三滚动数组一行">方法三：滚动数组(一行)</h3>
          </div>
<p>用pre记录左上角的值</p>
<p>计算当前值之前，先用temp保存dp[j + 1]，计算完dp[j + 1]，将temp赋值给pre</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestCommonSubsequence</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> s.length(), n = t.length();<br>        <span class="hljs-comment">// dp[i][j]: s[:i]与t[:j]的最长公共子序列长度</span><br>        <span class="hljs-comment">// if s[i] == t[j]: dp[i][j] = 1 + dp[i - 1][j - 1]</span><br>        <span class="hljs-comment">// else dp[i][j] = max(dp[i][j - 1], dp[i - 1][j]) </span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> dp[j + <span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span> (s.charAt(i) == t.charAt(j))<br>                    dp[j + <span class="hljs-number">1</span>] = pre + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span><br>                    dp[j + <span class="hljs-number">1</span>] = Math.max(dp[j], dp[j + <span class="hljs-number">1</span>]);<br>                pre = temp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法一dp-4">方法一：DP</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestCommonSubsequence</span><span class="hljs-params">(String text1, String text2)</span> &#123;<br>        <span class="hljs-comment">// dp[i][j]: text1以i为结尾，text2以j为结尾的最长公共子序列长度</span><br>        <span class="hljs-comment">// text[i - 1] == text[j - 1]:dp[i][j] = dp[i - 1][j - 1] + 1</span><br>        <span class="hljs-comment">// text[i - 1] != text[j - 1]:dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[text1.length() + <span class="hljs-number">1</span>][text2.length() + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= text1.length(); ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= text2.length(); ++j) &#123;<br>                <span class="hljs-keyword">if</span> (text1.charAt(i - <span class="hljs-number">1</span>) == text2.charAt(j - <span class="hljs-number">1</span>))<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span><br>                    dp[i][j] = Math.max(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[text1.length()][text2.length()];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二dp-滚动数组两行">方法二：DP + 滚动数组(两行)</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestCommonSubsequence</span><span class="hljs-params">(String text1, String text2)</span> &#123;<br>        <span class="hljs-comment">// dp[i][j]: text1以i为结尾，text2以j为结尾的最长公共子序列长度</span><br>        <span class="hljs-comment">// text[i - 1] == text[j - 1]:dp[i][j] = dp[i - 1][j - 1] + 1</span><br>        <span class="hljs-comment">// text[i - 1] != text[j - 1]:dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>][text2.length() + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= text1.length(); ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= text2.length(); ++j) &#123;<br>                <span class="hljs-keyword">if</span> (text1.charAt(i - <span class="hljs-number">1</span>) == text2.charAt(j - <span class="hljs-number">1</span>)) &#123;<br>                    dp[i % <span class="hljs-number">2</span>][j] = dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    dp[i % <span class="hljs-number">2</span>][j] = Math.max(dp[i % <span class="hljs-number">2</span>][j - <span class="hljs-number">1</span>], dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][j]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[text1.length() % <span class="hljs-number">2</span>][text2.length()];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<div class="note note-danger">
            <h2 id="两个字符串的删除操作"><a href="https://leetcode.cn/problems/delete-operation-for-two-strings/">583. 两个字符串的删除操作</a></h2>
          </div>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230528182744262.png" /></p>
<h3 id="方法一最长公共子序列">方法一：最长公共子序列</h3>
<ol type="1">
<li><strong>代码和最长公共子序列一模一样，只是返回值不同</strong></li>
<li>找出最长公共子序列长度为<code>x</code>，然后用<code>word1</code>的长度 + <code>word2</code>的长度 - <code>x</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minDistance</span><span class="hljs-params">(String text1, String text2)</span> &#123;<br>        <span class="hljs-comment">// dp[i][j]: text1以i为结尾，text2以j为结尾的最长公共子序列长度</span><br>        <span class="hljs-comment">// text[i - 1] == text[j - 1]:dp[i][j] = dp[i - 1][j - 1] + 1</span><br>        <span class="hljs-comment">// text[i - 1] != text[j - 1]:dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>][text2.length() + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= text1.length(); ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= text2.length(); ++j) &#123;<br>                <span class="hljs-keyword">if</span> (text1.charAt(i - <span class="hljs-number">1</span>) == text2.charAt(j - <span class="hljs-number">1</span>)) &#123;<br>                    dp[i % <span class="hljs-number">2</span>][j] = dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    dp[i % <span class="hljs-number">2</span>][j] = Math.max(dp[i % <span class="hljs-number">2</span>][j - <span class="hljs-number">1</span>], dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][j]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// return dp[text1.length() % 2][text2.length()];</span><br>        <span class="hljs-keyword">return</span> text1.length() + text2.length() - dp[text1.length() % <span class="hljs-number">2</span>][text2.length()] * <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230528191516369.png" style="zoom:50%;" /></p>
<h3 id="方法二dp-3">方法二：DP</h3>
<ol type="1">
<li><p>dp[i][j]：使得以i为结尾的子串<code>sub1</code>与以j为结尾的子串<code>sub2</code>相同所需的最少删除次数</p></li>
<li><p>m为word1的长度，n为word2的长度，创建大小为(m + 1) * (n + 1)大小的dp数组，首先需要初始化第0行与第0列，初始化第0行表示使为空字符串的<code>sub1</code>与长度为j的子串<code>sub2</code>相同所需的最少删除次数，举例word1 = “sea”，word2 = “eeat”，空字符串与空字符串：0，空字符串与“e”：1，空字符串与“ee”：2，空字符串与“eea”：3，空字符串与“eeat”：4。</p>
<p>初始化第0列类似。以下为初始化dp数组</p>
<table>
<tbody>
<tr class="odd">
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
</tr>
<tr class="even">
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="odd">
<td>2</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>3</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table></li>
<li><p>状态转移方程：</p>
<ol type="1">
<li><p>如果两个字符i、j相同，那么所需删除的次数和没加入这两个字符所需要的次数一致</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (word1.charAt(i - <span class="hljs-number">1</span>)  == word2.charAt(j - <span class="hljs-number">1</span>))<br>    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure></li>
<li><p>如果两个字符i、j不同，所需删除的次数为如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">dp[i][j] = Math.min(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]) + <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure></li>
</ol></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minDistance</span><span class="hljs-params">(String word1, String word2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> word1.length(), n = word2.length();<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= n; ++j)<br>            dp[<span class="hljs-number">0</span>][j] = j;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= m; ++i)<br>            dp[i][<span class="hljs-number">0</span>] = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (word1.charAt(i - <span class="hljs-number">1</span>)  == word2.charAt(j - <span class="hljs-number">1</span>))<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">else</span><br>                    dp[i][j] = Math.min(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]) + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<div class="note note-danger">
            <h2 id="编辑距离"><a href="https://leetcode.cn/problems/edit-distance/">72. 编辑距离</a></h2>
          </div>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230528205231420.png" /></p>
<p><strong><a href="https://leetcode.cn/problems/edit-distance/solution/zi-di-xiang-shang-he-zi-ding-xiang-xia-by-powcai-3/">优质题解</a></strong></p>
<h3 id="方法一dp-5">方法一：DP</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minDistance</span><span class="hljs-params">(String word1, String word2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> word1.length(), n = word2.length();<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; ++i)<br>            dp[i][<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; ++j) <br>            dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch1</span> <span class="hljs-operator">=</span> word1.charAt(i - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (ch1 != word2.charAt(j - <span class="hljs-number">1</span>))<br>                    dp[i][j] = Math.min(Math.min(dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j]), dp[i][j - <span class="hljs-number">1</span>]) + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span><br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230528211721099.png" style="zoom:50%;" /></p>
<h3 id="二刷dp-1">二刷DP</h3>
<p>当 word1[i] == word2[j]，dp[i][j] = dp[i-1][j-1]；</p>
<p>当 word1[i] != word2[j]，dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1</p>
<p>其中，dp[i-1][j-1] 表示替换操作，dp[i-1][j] 表示删除操作，dp[i][j-1] 表示插入操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minDistance</span><span class="hljs-params">(String word1, String word2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> word1.length(), n = word2.length();<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; ++j)<br>            dp[<span class="hljs-number">0</span>][j] = j;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; ++i)<br>            dp[i][<span class="hljs-number">0</span>] = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (word1.charAt(i - <span class="hljs-number">1</span>) == word2.charAt(j - <span class="hljs-number">1</span>))<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">else</span> <br>                    dp[i][j] = Math.min(Math.min(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]), dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<div class="note note-danger">
            <h2 id="回文子串"><a href="https://leetcode.cn/problems/palindromic-substrings/">647. 回文子串</a></h2>
          </div>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230528211746259.png" /></p>
<p><a href="https://leetcode.cn/problems/palindromic-substrings/solutions/154773/liang-dao-hui-wen-zi-chuan-de-jie-fa-xiang-jie-zho/">优质题解</a></p>
<div class="note note-warning">
            <h3 id="二刷看的题解">二刷看的题解</h3>
          </div>
<p>状态：dp[i][j] 表示字符串s在[i,j]区间的子串是否是一个回文串。 状态转移方程：当 s[i] == s[j] &amp;&amp; (j - i &lt; 2 || dp[i + 1][j - 1]) 时，dp[i][j]=true，否则为false 这个状态转移方程是什么意思呢？</p>
<p>当只有一个字符时，比如 a 自然是一个回文串。 当有两个字符时，如果是相等的，比如 aa，也是一个回文串。 当有三个及以上字符时，比如 ababa 这个字符记作串 1，把两边的 a 去掉，也就是 bab 记作串 2，可以看出只要串2是一个回文串，那么左右各多了一个 a 的串 1 必定也是回文串。所以当 s[i]==s[j] 时，自然要看 dp[i+1][j-1] 是不是一个回文串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countSubstrings</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">// dp[i][j]: s[i:j]的回文子串个数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length(), res = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j)  <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= j; ++i) <br>                <span class="hljs-keyword">if</span> (s.charAt(i) == s.charAt(j) &amp;&amp; (j - i &lt;= <span class="hljs-number">1</span> || dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>])) &#123;<br>                    dp[i][j] = <span class="hljs-literal">true</span>;<br>                    ++res;<br>                &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;	<br></code></pre></td></tr></table></figure>
<h3 id="换一种遍历顺序">换一种遍历顺序</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countSubstrings</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">// dp[i][j]: s[i:j]的回文子串个数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length(), res = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i)  <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; n; ++j) <br>                <span class="hljs-keyword">if</span> (s.charAt(i) == s.charAt(j) &amp;&amp; (j - i &lt;= <span class="hljs-number">1</span> || dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>])) &#123;<br>                    dp[i][j] = <span class="hljs-literal">true</span>;<br>                    ++res;<br>                &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法一dp-6">方法一：DP</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countSubstrings</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length(), res = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> j; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>                <span class="hljs-keyword">if</span> (i == j)<br>                    dp[i][j] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> == j)<br>                    dp[i][j] = s.charAt(i) == s.charAt(j) ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = s.charAt(i) == s.charAt(j) &amp;&amp; dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                &#125;<br>                <span class="hljs-keyword">if</span> (dp[i][j])<br>                    ++res;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="最长回文子串"><a href="https://leetcode.cn/problems/longest-palindromic-substring/">5. 最长回文子串</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230920145728928.png" /></p>
<h3 id="方法一dp-7">方法一：DP</h3>
<p>dp[i][j] = ch1 == ch2 &amp;&amp; (dp[i + 1][j - 1] || j - i + 1 &lt;= 2) 从最后一行开始遍历，从左往右、从右往左都可以</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">// dp[i][j] = ch1 == ch2 &amp;&amp; (dp[i + 1][j - 1] || j - i + 1 &lt;= 2)</span><br>        <span class="hljs-comment">// dp[i][j]: s[i:j]是否是回文串</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length(),l = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>, maxLen = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-comment">// for (int j = n - 1; j &gt;= i; --j) 也可以</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (s.charAt(i) == s.charAt(j) &amp;&amp; (j - i + <span class="hljs-number">1</span> &lt;= <span class="hljs-number">2</span> || dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>])) &#123;<br>                    dp[i][j] = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">if</span> (j - i + <span class="hljs-number">1</span> &gt; maxLen) &#123;<br>                        maxLen = j - i + <span class="hljs-number">1</span>;<br>                        l = i;<br>                        r = j;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.substring(l, r + <span class="hljs-number">1</span>);        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<div class="note note-danger">
            <h2 id="最长回文子序列"><a href="https://leetcode.cn/problems/longest-palindromic-subsequence/">516. 最长回文子序列</a></h2>
          </div>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230529095440783.png" /></p>
<h3 id="方法一dp-8">方法一：DP</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestPalindromeSubseq</span><span class="hljs-params">(String s)</span> &#123;<br><span class="hljs-comment">//        dp[i][j]: 字符串从下标i到j的最长回文子序列</span><br><span class="hljs-comment">//        dp[i][j]:</span><br><span class="hljs-comment">//        s[i] == s[j]: d[i + 1][j - 1]</span><br><span class="hljs-comment">//        s[i] != s[j]: max(dp[i + 1][j], dp[i][j - 1])</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> j; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>                <span class="hljs-keyword">if</span> (i == j)<br>                    dp[i][j] = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> == j)<br>                    dp[i][j] = s.charAt(i) == s.charAt(j) ? <span class="hljs-number">2</span> : <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (s.charAt(i) == s.charAt(j))<br>                        dp[i][j] = dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">2</span>;<br>                    <span class="hljs-keyword">else</span><br>                        dp[i][j] = Math.max(dp[i + <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="二刷">二刷</h3>
<table>
<thead>
<tr class="header">
<th>dp[i][j - 1]</th>
<th>dp[i][j]</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>dp[i + 1][j - 1]</td>
<td>dp[i + 1][j]</td>
</tr>
</tbody>
</table>
<ol type="1">
<li>从下往上，从左往右遍历</li>
<li>else if (s.charAt(i) == s.charAt(j))一定要else if不能是if。如果是if会越界(i = n - 1时, dp[i + 1][j - 1]越界)</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestPalindromeSubseq</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (i == j)<br>                    dp[i][j] = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.charAt(i) == s.charAt(j))<br>                    dp[i][j] = dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">2</span>;<br>                <span class="hljs-keyword">else</span> <br>                    dp[i][j] = Math.max(dp[i + <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="剑指-offer-ii-092.-翻转字符">剑指 Offer II 092. 翻转字符</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230623153801605.png" /></p>
<p><strong>注意：(ch == '1' ? 0 : 1)的括号</strong></p>
<h3 id="方法一dp-9">方法一：DP</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minFlipsMonoIncr</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">// dp[i][0]: 经过若干转换使得子串s[:i]有序且最后一位是0的最少翻转次数</span><br>        <span class="hljs-comment">// dp[i][1]：经过若干转换使得子串s[:i]有序且最后一位是1的最少翻转次数</span><br>        <span class="hljs-comment">/* 状态转移：dp[i][0] = dp[i - 1][0] + s[i] == 0 ? 0 : 1;</span><br><span class="hljs-comment">                    dp[i][1] = Math.min(dp[i - 1][0], dp[i - 1][1]) + s[i] == 1 ? 0 : 1;</span><br><span class="hljs-comment">            初始化：dp[0][0] = s[0] == 0 ? 0 : 1;</span><br><span class="hljs-comment">                   dp[0][1] = s[0] == 1 ? 0 : 1;</span><br><span class="hljs-comment">         */</span><br>         <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[s.length()][<span class="hljs-number">2</span>];<br>         dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = s.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;0&#x27;</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;<br>         dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = s.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;1&#x27;</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;<br>         <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; s.length(); ++i) &#123;<br>             <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> s.charAt(i);<br>             dp[i][<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + (ch == <span class="hljs-string">&#x27;0&#x27;</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>);<br>             dp[i][<span class="hljs-number">1</span>] = Math.min(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) + (ch == <span class="hljs-string">&#x27;1&#x27;</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>); <br>         &#125;<br>         <span class="hljs-keyword">return</span> Math.min(dp[s.length() - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[s.length() - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<div class="note note-danger">
            <h2 id="剑指-offer-ii-093.-最长斐波那契数列">剑指 Offer II 093. 最长斐波那契数列</h2>
          </div>
<h3 id="方法一dp-10">方法一：DP</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lenLongestFibSubseq</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            map.put(arr[i], i);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; --j) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> map.getOrDefault(arr[i] - arr[j], -<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span> (k &gt;= <span class="hljs-number">0</span> &amp;&amp; k &lt; j)<br>                    dp[j][i] = Math.max(dp[k][j] + <span class="hljs-number">1</span>, <span class="hljs-number">3</span>);<br>                res = Math.max(res, dp[j][i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<div class="note note-danger">
            <h2 id="分割回文串-ii">分割回文串 II</h2>
          </div>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCut</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">        i &lt; j &amp;&amp; s[i] == s[j], dp[i][j] = dp[i + 1][j - 1]</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; n; ++j) <br>                <span class="hljs-keyword">if</span> (s.charAt(i) == s.charAt(j) &amp;&amp; (j - i &lt;= <span class="hljs-number">1</span> || dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]))<br>                    dp[i][j] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">        if (dp[0][n - 1]) return 0;</span><br><span class="hljs-comment">        if (dp[i][j])</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">int</span>[] memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (dp[<span class="hljs-number">0</span>][i])<br>                memo[i] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> &#123;<br>                memo[i] = i;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= i; ++j) &#123;<br>                    <span class="hljs-keyword">if</span> (dp[j][i]) <br>                        memo[i] = Math.min(memo[i], memo[j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> memo[n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<div class="note note-warning">
            <h2 id="剑指-offer-ii-096.-字符串交织">剑指 Offer II 096. 字符串交织</h2>
          </div>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230624221957058.png" /></p>
<p><strong>初始化出错了，debug半天</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n &amp;&amp; s2.charAt(i - <span class="hljs-number">1</span>) == s3.charAt(i - <span class="hljs-number">1</span>); ++i) <span class="hljs-comment">// 不符合提前终止for循环</span><br>            dp[<span class="hljs-number">0</span>][i] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m &amp;&amp; s1.charAt(i - <span class="hljs-number">1</span>) == s3.charAt(i - <span class="hljs-number">1</span>); ++i)<br>    dp[i][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure>
<h4 id="代码-1">代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isInterleave</span><span class="hljs-params">(String s1, String s2, String s3)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> s1.length(), n = s2.length(), t = s3.length();<br>        <span class="hljs-keyword">if</span> (t != m + n)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// dp[i][j] = (s1[i] == s3[i + j] &amp;&amp; dp[i - 1][j]) || (s2[j] == s3[i + j] &amp;&amp; dp[i][j - 1])</span><br>        <span class="hljs-type">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n &amp;&amp; s2.charAt(i - <span class="hljs-number">1</span>) == s3.charAt(i - <span class="hljs-number">1</span>); ++i)<br>            dp[<span class="hljs-number">0</span>][i] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m &amp;&amp; s1.charAt(i - <span class="hljs-number">1</span>) == s3.charAt(i - <span class="hljs-number">1</span>); ++i)<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; ++i)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; ++j)<br>                <span class="hljs-keyword">if</span> ((s1.charAt(i - <span class="hljs-number">1</span>) == s3.charAt(i + j - <span class="hljs-number">1</span>) &amp;&amp; dp[i - <span class="hljs-number">1</span>][j]) || (s2.charAt(j - <span class="hljs-number">1</span>) == s3.charAt(i + j - <span class="hljs-number">1</span>) &amp;&amp; dp[i][j - <span class="hljs-number">1</span>]))<br>                    dp[i][j] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<div class="note note-primary">
            <h2 id="不同的子序列"><a href="https://leetcode.cn/problems/distinct-subsequences/">115. 不同的子序列</a></h2>
          </div>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230626094058827.png" /></p>
<h3 id="二刷记忆化搜索">二刷记忆化搜索</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numDistinct</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        m = s.length();<br>        n = t.length();<br>        <span class="hljs-built_in">this</span>.s = s;<br>        <span class="hljs-built_in">this</span>.t = t;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dp)<br>            Arrays.fill(arr, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-comment">// t被匹配返回1</span><br>        <span class="hljs-keyword">if</span> (j == n)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// s到最后也没能匹配到t的最后一个字符，返回0</span><br>        <span class="hljs-keyword">if</span> (i == m)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (dp[i][j] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[i][j];<br>        <span class="hljs-comment">// 匹配：选：i，j往下递归；不选：i往下递归</span><br>        <span class="hljs-keyword">if</span> (s.charAt(i) == t.charAt(j))<br>            <span class="hljs-keyword">return</span> dp[i][j] = dfs(i + <span class="hljs-number">1</span>, j + <span class="hljs-number">1</span>) + dfs(i + <span class="hljs-number">1</span>, j);<br>        <span class="hljs-keyword">return</span> dp[i][j] = dfs(i + <span class="hljs-number">1</span>, j);<br>    &#125;<br><br>    <span class="hljs-type">int</span> m, n;<br>    String s, t;<br>    <span class="hljs-type">int</span>[][] dp;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法三滚动数组">方法三：滚动数组</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numDistinct</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> s.length(), n = t.length();<br>        <span class="hljs-comment">// s[:i]中t[:j]出现的次数</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// s,t为空串，匹配</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> n; j &gt;= <span class="hljs-number">1</span>; --j) &#123;<br>                <span class="hljs-keyword">if</span> (s.charAt(i - <span class="hljs-number">1</span>) == t.charAt(j - <span class="hljs-number">1</span>))<br>                    dp[j] += dp[j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法一dp-11">方法一：DP</h3>
<p><strong>注意初始化</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numDistinct</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">        s = &quot;bagg&quot;, t = &quot;bag&quot;</span><br><span class="hljs-comment">        对于bag的最后一个&#x27;g&#x27;，可以使用它，或者不使用它</span><br><span class="hljs-comment">         */</span><br>         <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> s.length(), n = t.length();<br>        <span class="hljs-keyword">if</span> (m &lt; n)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i &lt;= m; ++i)<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (s.charAt(i - <span class="hljs-number">1</span>) == t.charAt(j - <span class="hljs-number">1</span>))<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">1</span>][j];<br>                <span class="hljs-keyword">else</span><br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二记忆化搜索-4">方法二：记忆化搜索</h3>
<p><a href="https://leetcode.cn/problems/distinct-subsequences/solutions/661537/shou-hua-tu-jie-xiang-jie-liang-chong-ji-4r2y/">优质题解</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numDistinct</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        m = s.length();<br>        n = t.length();<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dp)<br>            Arrays.fill(arr, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(s, t, m - <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-type">int</span> m, n;<br>    <span class="hljs-type">int</span>[][] dp;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(String s, String t, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">if</span> (j &lt; <span class="hljs-number">0</span>)	<span class="hljs-comment">// base case 当j指针越界，此时t为空串，s不管是不是空串，匹配方式数都是1</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>)	<span class="hljs-comment">// base case i指针越界，此时s为空串，t不是，s怎么也匹配不了t，方式数0</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (dp[i][j] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[i][j];<br>        <span class="hljs-keyword">if</span> (s.charAt(i) == t.charAt(j))<br>            <span class="hljs-keyword">return</span> dp[i][j] = dfs(s, t, i - <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span>) + dfs(s, t, i - <span class="hljs-number">1</span>, j);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> dp[i][j] = dfs(s, t, i - <span class="hljs-number">1</span>, j);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="判断子序列"><a href="https://leetcode.cn/problems/is-subsequence/">392. 判断子序列</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230626104734498.png" /></p>
<h3 id="方法一dp-12">方法一：DP</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSubsequence</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">        dp[i][j]:s[:i]是否是t[:j]的子序列</span><br><span class="hljs-comment">        dp[i][j] = dp[i][j - 1] || dp[i - 1][j - 1] &amp;&amp; s[i] == t[j]</span><br><span class="hljs-comment">        初始化：s为空，都是t的子串</span><br><span class="hljs-comment">         */</span><br>         <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> s.length(), n = t.length();<br>         <span class="hljs-type">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>         <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= n; ++j) <br>            dp[<span class="hljs-number">0</span>][j] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; ++i) <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; ++j) <br>                dp[i][j] = dp[i][j - <span class="hljs-number">1</span>] || dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] &amp;&amp; s.charAt(i - <span class="hljs-number">1</span>) == t.charAt(j - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="销售利润最大化"><a href="https://leetcode.cn/contest/weekly-contest-359/problems/maximize-the-profit-as-the-salesman/">销售利润最大化</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230820104054745.png" /></p>
<h3 id="方法一线性dp">方法一：线性DP</h3>
<p>相似题目 - <a href="https://leetcode.cn/problems/maximum-earnings-from-taxi/">2008. 出租车的最大盈利</a>（和本题几乎一样）</p>
<ul>
<li><p><a href="https://leetcode.cn/problems/maximum-profit-in-job-scheduling/">1235. 规划兼职工作</a>（数据范围更大的情况，<a href="https://leetcode.cn/problems/maximum-profit-in-job-scheduling/solution/dong-tai-gui-hua-er-fen-cha-zhao-you-hua-zkcg/">我的题解</a>）</p></li>
<li><p><a href="https://leetcode.cn/problems/maximum-number-of-events-that-can-be-attended-ii/">1751. 最多可以参加的会议数目 II</a>（区间个数限制）</p></li>
<li><p><a href="https://leetcode.cn/problems/two-best-non-overlapping-events/">2054. 两个最好的不重叠活动</a></p></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximizeTheProfit</span><span class="hljs-params">(<span class="hljs-type">int</span> n, List&lt;List&lt;Integer&gt;&gt; offers)</span> &#123;<br>        List&lt;<span class="hljs-type">int</span>[]&gt;[] list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[n];<br>        Arrays.setAll(list, e -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        <span class="hljs-keyword">for</span> (List&lt;Integer&gt; offer : offers) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> offer.get(<span class="hljs-number">0</span>), end = offer.get(<span class="hljs-number">1</span>), val = offer.get(<span class="hljs-number">2</span>);<br>            list[end].add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;start, val&#125;);<br>        &#125;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>            dp[i] = dp[i - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : list[i - <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>], val = arr[<span class="hljs-number">1</span>];<br>                dp[i] = Math.max(dp[i], dp[start] + val);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二二分-dp">方法二：二分 + DP</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximizeTheProfit</span><span class="hljs-params">(<span class="hljs-type">int</span> n, List&lt;List&lt;Integer&gt;&gt; offers)</span> &#123;<br>        Collections.sort(offers, (o1, o2) -&gt; o1.get(<span class="hljs-number">1</span>) - o2.get(<span class="hljs-number">1</span>));<br>        <span class="hljs-comment">// 处理标号为0~i的房子能获得的最大利润</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[offers.size() + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; offers.size(); ++i) &#123;<br>            dp[i + <span class="hljs-number">1</span>] = dp[i];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> bisearch(offers, i, offers.get(i).get(<span class="hljs-number">0</span>));<br>            dp[i + <span class="hljs-number">1</span>] = Math.max(dp[i + <span class="hljs-number">1</span>], (j &gt;= -<span class="hljs-number">1</span> ? dp[j + <span class="hljs-number">1</span>] : <span class="hljs-number">0</span>) + offers.get(i).get(<span class="hljs-number">2</span>));<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[offers.size()];<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">bisearch</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; offers, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (offers.get(mid).get(<span class="hljs-number">1</span>) &lt; start)<br>                l = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                r = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="出租车的最大盈利"><a href="https://leetcode.cn/problems/maximum-earnings-from-taxi/">2008. 出租车的最大盈利</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230821161512827.png" /></p>
<h3 id="方法一线性dp-1">方法一：线性DP</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">maxTaxiEarnings</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] rides)</span> &#123;<br>        List&lt;<span class="hljs-type">int</span>[]&gt;[] list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[n + <span class="hljs-number">1</span>];<br>        Arrays.setAll(list, o -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] ride : rides) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">from</span> <span class="hljs-operator">=</span> ride[<span class="hljs-number">0</span>], to = ride[<span class="hljs-number">1</span>], tips = ride[<span class="hljs-number">2</span>];<br>            list[to].add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;from, to - from + tips&#125;);<br>        &#125;<br>        <span class="hljs-type">long</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>            dp[i] = dp[i - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : list[i]) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>], val = arr[<span class="hljs-number">1</span>];<br>                dp[i] = Math.max(dp[i], dp[start] + val);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="规划兼职工作"><a href="https://leetcode.cn/problems/maximum-profit-in-job-scheduling/">1235. 规划兼职工作</a></h2>
<p>数据量<span class="math inline">\(10^9\)</span>，如果用上述方法存储，会爆内存</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230821161850965.png" /></p>
<h3 id="方法一二分-dp">方法一：二分 + DP</h3>
<ul>
<li>将jobs按照结束时间排序，dp[i]：处理前i分工作(做或者不做)能获得的最大利润，dp[0]没有意义(防止溢出)</li>
<li>对于第i份兼职，可以不做dp[i] = dp[i - 1]，或者做dp[i] = dp[j + 1] + prof，其中j是满足jobs[j][1] &lt;= jobs[i][0]的最大下标(dp数组是非递减的)，可以使用二分来找到j</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">jobScheduling</span><span class="hljs-params">(<span class="hljs-type">int</span>[] startTime, <span class="hljs-type">int</span>[] endTime, <span class="hljs-type">int</span>[] profit)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> startTime.length;<br>        <span class="hljs-type">int</span>[][] jobs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][<span class="hljs-number">3</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            jobs[i][<span class="hljs-number">0</span>] = startTime[i];<br>            jobs[i][<span class="hljs-number">1</span>] = endTime[i];<br>            jobs[i][<span class="hljs-number">2</span>] = profit[i];<br>        &#125;<br>        Arrays.sort(jobs, (o1, o2) -&gt; o1[<span class="hljs-number">1</span>] - o2[<span class="hljs-number">1</span>]);<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>            dp[i] = dp[i - <span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> jobs[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], end = jobs[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], p = jobs[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> bisearch(jobs, i, start); <span class="hljs-comment">// 右边界是i，找到最大的下标j，jobs[j][1] &lt;= start</span><br>            dp[i] = Math.max(dp[i], dp[j + <span class="hljs-number">1</span>] + p); <span class="hljs-comment">// dp数组下标都往后移一位</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">bisearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] jobs, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (jobs[mid][<span class="hljs-number">1</span>] &lt;= start)<br>                l = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <br>                r = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<div class="note note-danger">
            <h2 id="最多可以参加的会议数目-ii"><a href="https://leetcode.cn/problems/maximum-number-of-events-that-can-be-attended-ii/">1751. 最多可以参加的会议数目 II</a></h2>
          </div>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230821202827314.png" /></p>
<p><strong>数量限制</strong></p>
<h3 id="方法一二分-二维dp">方法一：二分 + 二维DP</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxValue</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] events, <span class="hljs-type">int</span> k)</span> &#123;<br>        Arrays.sort(events, (o1, o2) -&gt; o1[<span class="hljs-number">1</span>] - o2[<span class="hljs-number">1</span>]);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> events.length;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][k + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> bisearch(events, i, events[i][<span class="hljs-number">0</span>]);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= k; ++j) &#123;<br>                dp[i + <span class="hljs-number">1</span>][j] = Math.max(dp[i][j], dp[p + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + events[i][<span class="hljs-number">2</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][k];<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">bisearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] events, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (events[mid][<span class="hljs-number">1</span>] &lt; start)<br>                l = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <br>                r = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="两个最好的不重叠活动"><a href="https://leetcode.cn/problems/two-best-non-overlapping-events/">2054. 两个最好的不重叠活动</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230821205122715.png" /></p>
<h3 id="方法一二分查找-线性dp">方法一：二分查找 + 线性dp</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxTwoEvents</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] events)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> events.length;<br>        Arrays.sort(events, (o1, o2) -&gt; o1[<span class="hljs-number">1</span>] - o2[<span class="hljs-number">1</span>]);<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][<span class="hljs-number">3</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> bisearch(events, i, events[i][<span class="hljs-number">0</span>]);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">2</span>; ++j) &#123;<br>                dp[i + <span class="hljs-number">1</span>][j] = Math.max(dp[i][j], dp[p + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + events[i][<span class="hljs-number">2</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][<span class="hljs-number">2</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">bisearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] events, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (events[mid][<span class="hljs-number">1</span>] &lt; start)<br>                l = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                r = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="剑指-offer-47.-礼物的最大价值"><a href="https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof/">剑指 Offer 47. 礼物的最大价值</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230829215703664.png" /></p>
<h3 id="方法一记忆化搜索">方法一：记忆化搜索</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxValue</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-built_in">this</span>.grid = grid;<br>        m = grid.length;<br>        n = grid[<span class="hljs-number">0</span>].length;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dp)<br>            Arrays.fill(arr, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i == m &amp;&amp; j == n)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (dp[i][j] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[i][j];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> grid[i][j], max = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], col = j + dir[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (isValid(row, col)) &#123;<br>                max = Math.max(max, dfs(row, col));<br>            &#125;<br>        &#125;<br>        res += max;<br>        <span class="hljs-keyword">return</span> dp[i][j] = res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &lt; m &amp;&amp; j &lt; n;<br>    &#125;<br><br>    <span class="hljs-type">int</span>[][] grid, dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;, dp;<br>    <span class="hljs-type">int</span> m, n;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二简化写法">方法二：简化写法</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxValue</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-built_in">this</span>.grid = grid;<br>        m = grid.length;<br>        n = grid[<span class="hljs-number">0</span>].length;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dp)<br>            Arrays.fill(arr, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i &gt;= m || j &gt;= n)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (dp[i][j] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[i][j];<br>        <span class="hljs-keyword">return</span> dp[i][j] = Math.max(dfs(i + <span class="hljs-number">1</span>, j), dfs(i, j + <span class="hljs-number">1</span>)) + grid[i][j];<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &lt; m &amp;&amp; j &lt; n;<br>    &#125;<br><br>    <span class="hljs-type">int</span>[][] grid, dp;<br>    <span class="hljs-type">int</span> m, n;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法三dp-5">方法三：DP</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxValue</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-built_in">this</span>.grid = grid;<br>        m = grid.length;<br>        n = grid[<span class="hljs-number">0</span>].length;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) <br>                dp[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] = Math.max(dp[i][j + <span class="hljs-number">1</span>], dp[i + <span class="hljs-number">1</span>][j]) + grid[i][j];<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br><br>    <span class="hljs-type">int</span>[][] grid,  dp;<br>    <span class="hljs-type">int</span> m, n;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法四dp-滚动数组-2">方法四：DP + 滚动数组</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxValue</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length, n = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>; j &lt; n; ++j)<br>                dp[j + <span class="hljs-number">1</span>] = grid[i][j] + Math.max(dp[j + <span class="hljs-number">1</span>], dp[j]);<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="下降路径最小和"><a href="https://leetcode.cn/problems/minimum-falling-path-sum/">931. 下降路径最小和</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230829224424408.png" /></p>
<h3 id="方法一记忆化搜索-1">方法一：记忆化搜索</h3>
<p><strong>注意初始化dp数组</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minFallingPathSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-built_in">this</span>.matrix = matrix;<br>        n = matrix.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dp)<br>            Arrays.fill(arr, Integer.MAX_VALUE);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            res = Math.min(res, dfs(<span class="hljs-number">0</span>, i));<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i == n)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (dp[i][j] != Integer.MAX_VALUE)<br>            <span class="hljs-keyword">return</span> dp[i][j];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> j &gt; <span class="hljs-number">0</span> ? dfs(i + <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span>) : Integer.MAX_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> dfs(i + <span class="hljs-number">1</span>, j);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> j &lt; n - <span class="hljs-number">1</span> ? dfs(i + <span class="hljs-number">1</span>, j + <span class="hljs-number">1</span>) : Integer.MAX_VALUE;<br>        <span class="hljs-keyword">return</span> dp[i][j] = Math.min(l, Math.min(d,  r)) + matrix[i][j];<br>    &#125;<br><br>    <span class="hljs-type">int</span>[][] matrix, dp;<br>    <span class="hljs-type">int</span> n;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二简化写法-1">方法二：简化写法</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minFallingPathSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-built_in">this</span>.matrix = matrix;<br>        n = matrix.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dp)<br>            Arrays.fill(arr, Integer.MAX_VALUE);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            res = Math.min(res, dfs(<span class="hljs-number">0</span>, i));<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i == n)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (j &lt; <span class="hljs-number">0</span> || j == n)<br>            <span class="hljs-keyword">return</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">if</span> (dp[i][j] != Integer.MAX_VALUE)<br>            <span class="hljs-keyword">return</span> dp[i][j];<br>        <span class="hljs-keyword">return</span> dp[i][j] = Math.min(dfs(i + <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span>), Math.min(dfs(i + <span class="hljs-number">1</span>, j),  dfs(i + <span class="hljs-number">1</span>, j + <span class="hljs-number">1</span>))) + matrix[i][j];<br>    &#125;<br><br>    <span class="hljs-type">int</span>[][] matrix, dp;<br>    <span class="hljs-type">int</span> n;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法三dp-6">方法三：DP</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minFallingPathSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][n + <span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= n; ++i) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = Integer.MAX_VALUE;<br>            dp[i][n + <span class="hljs-number">1</span>] = Integer.MAX_VALUE;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) <br>                dp[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] = matrix[i][j] + Math.min(dp[i][j], Math.min(dp[i][j + <span class="hljs-number">1</span>], dp[i][j + <span class="hljs-number">2</span>]));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; ++j)<br>            res = Math.min(res, dp[n][j]);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<div class="note note-primary">
            <h3 id="方法四滚动数组">方法四：滚动数组</h3>
          </div>
<p><strong>用pre记录左上角的数</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minFallingPathSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">2</span>];<br>        dp[<span class="hljs-number">0</span>] = Integer.MAX_VALUE;<br>        dp[n + <span class="hljs-number">1</span>] = Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            dp[i + <span class="hljs-number">1</span>] = matrix[<span class="hljs-number">0</span>][i];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> dp[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> pre;<br>                pre = dp[j + <span class="hljs-number">1</span>];<br>                dp[j + <span class="hljs-number">1</span>] = matrix[i][j] + Math.min(temp, Math.min(pre, dp[j + <span class="hljs-number">2</span>]));<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; ++j)<br>            res = Math.min(res, dp[j]);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<div class="note note-danger">
            <h2 id="可被三整除的最大和"><a href="https://leetcode.cn/problems/greatest-sum-divisible-by-three/">1262. 可被三整除的最大和</a></h2>
          </div>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230830152204018.png" /></p>
<h3 id="方法一记忆化搜索-2">方法一：记忆化搜索</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSumDivThree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-built_in">this</span>.nums=  nums;<br>        n = nums.length;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][<span class="hljs-number">3</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dp)<br>            Arrays.fill(arr, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> sum)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == n)<br>            <span class="hljs-keyword">return</span> sum == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : Integer.MIN_VALUE;<br>        <span class="hljs-keyword">if</span> (dp[index][sum] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[index][sum];<br>        <span class="hljs-keyword">return</span> dp[index][sum] = Math.max(dfs(index + <span class="hljs-number">1</span>, sum), dfs(index + <span class="hljs-number">1</span>, (sum + nums[index]) % <span class="hljs-number">3</span>) + nums[index]);<br>    &#125;<br><br>    <span class="hljs-type">int</span>[] nums;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">int</span>[][] dp;<br>&#125;<br></code></pre></td></tr></table></figure>
<div class="note note-danger">
            <h2 id="环形子数组的最大和"><a href="https://leetcode.cn/problems/maximum-sum-circular-subarray/">918. 环形子数组的最大和</a></h2>
          </div>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubarraySumCircular</span><span class="hljs-params">(<span class="hljs-type">int</span>[] A)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, maxSum = A[<span class="hljs-number">0</span>], curMax = <span class="hljs-number">0</span>, minSum = A[<span class="hljs-number">0</span>], curMin = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a : A) &#123;<br>        curMax = Math.max(curMax + a, a);<br>        maxSum = Math.max(maxSum, curMax);<br>        curMin = Math.min(curMin + a, a);<br>        minSum = Math.min(minSum, curMin);<br>        total += a;<br>    &#125;<br>    <span class="hljs-keyword">return</span> minSum != total ? Math.max(maxSum, total - minSum) : maxSum;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="删除一次得到子数组最大和"><a href="https://leetcode.cn/problems/maximum-subarray-sum-with-one-deletion/">1186. 删除一次得到子数组最大和</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230830170807796.png" /></p>
<h3 id="方法四二刷">方法四：二刷</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximumSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        nums = arr;<br>        n = arr.length;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][<span class="hljs-number">2</span>][<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[][] a : dp)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] b : a)<br>                Arrays.fill(b, -<span class="hljs-number">10001</span>);<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> key, <span class="hljs-type">boolean</span> chosen)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == n)<br>            <span class="hljs-keyword">return</span> chosen ? <span class="hljs-number">0</span> : Integer.MIN_VALUE;<br>        <span class="hljs-keyword">if</span> (dp[index][key][chosen ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>] != -<span class="hljs-number">10001</span>)<br>            <span class="hljs-keyword">return</span> dp[index][key][chosen ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> pass;<br>        <span class="hljs-keyword">if</span> (chosen) <br>            pass = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">else</span><br>            pass = dfs(index + <span class="hljs-number">1</span>, key, <span class="hljs-literal">false</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">choose</span> <span class="hljs-operator">=</span> dfs(index + <span class="hljs-number">1</span>, key, <span class="hljs-literal">true</span>) + nums[index], delete = Integer.MIN_VALUE;<br>        <span class="hljs-keyword">if</span> (key == <span class="hljs-number">1</span>) <br>            delete = dfs(index + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, chosen);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Math.max(Math.max(pass, choose), delete);<br>        res = Math.max(res, max);<br>        <span class="hljs-keyword">return</span> dp[index][key][chosen ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>] = max;<br>    &#125;<br><br>    <span class="hljs-type">int</span>[] nums;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>    <span class="hljs-type">int</span>[][][] dp;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法一记忆化搜索-3">方法一：记忆化搜索</h3>
<p>由于至少要选一个元素，不能是空数组，所以复杂特别多</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximumSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        nums = arr;<br>        n = nums.length;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][<span class="hljs-number">2</span>][<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[][] x : dp)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] y : x)<br>                Arrays.fill(y, Integer.MIN_VALUE);<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 选x或者不选</span><br>    <span class="hljs-comment">// 如果选，之后的数可以选择删或者不删</span><br>    <span class="hljs-comment">// 至少要选一个</span><br>    <span class="hljs-comment">// PASS有两种情况：1.前面没选pass；2.选了，后面都pass</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> key, <span class="hljs-type">boolean</span> hasChosen, <span class="hljs-type">boolean</span> stop)</span> &#123;<br>        <span class="hljs-keyword">if</span> (stop)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (index == n)<br>            <span class="hljs-keyword">return</span> hasChosen ? <span class="hljs-number">0</span> : Integer.MIN_VALUE;<br>        <span class="hljs-keyword">if</span> (dp[index][key][hasChosen ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>] != Integer.MIN_VALUE)<br>            <span class="hljs-keyword">return</span> dp[index][key][hasChosen ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pass</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE, delete = Integer.MIN_VALUE, choose = Integer.MIN_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">chooseStop</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE, deleteStop = Integer.MIN_VALUE;<br>        <span class="hljs-keyword">if</span> (!hasChosen)<br>            pass = dfs(index + <span class="hljs-number">1</span>, key, hasChosen, <span class="hljs-literal">false</span>);<br>        choose = dfs(index + <span class="hljs-number">1</span>, key, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>) + nums[index];<br>        chooseStop = dfs(index + <span class="hljs-number">1</span>, key, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>) + nums[index];<br>        <span class="hljs-keyword">if</span> (hasChosen &amp;&amp; key &gt;= <span class="hljs-number">1</span>) &#123;<br>            delete = dfs(index + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);<br>            deleteStop = dfs(index + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> Math.max(pass, Math.max(choose, delete));<br>        temp = Math.max(temp, Math.max(chooseStop, deleteStop));<br>        res = Math.max(res, temp);<br>        <span class="hljs-keyword">return</span> dp[index][key][hasChosen ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>] = temp;<br>    &#125;<br><br>    <span class="hljs-type">int</span>[][][] dp;<br>    <span class="hljs-type">int</span>[] nums;<br>    <span class="hljs-type">int</span> n, res = Integer.MIN_VALUE;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二记忆化搜索-5">方法二：记忆化搜索</h3>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230830211300465.png" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximumSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        nums = arr;<br>        n = arr.length;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] x : dp)<br>            Arrays.fill(x, Integer.MIN_VALUE);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            res = Math.max(res, Math.max(dfs(i, <span class="hljs-number">0</span>), dfs(i, <span class="hljs-number">1</span>)));<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i == n)<br>            <span class="hljs-keyword">return</span> Integer.MIN_VALUE &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (dp[i][j] != Integer.MIN_VALUE)<br>            <span class="hljs-keyword">return</span> dp[i][j];<br>        <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> dp[i][j] = Math.max(dfs(i + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>), <span class="hljs-number">0</span>) + nums[i];<br>        <span class="hljs-keyword">return</span> dp[i][j] = Math.max(dfs(i + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>) + nums[i], dfs(i + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>    &#125;<br><br>    <span class="hljs-type">int</span>[][] dp;<br>    <span class="hljs-type">int</span>[] nums;<br>    <span class="hljs-type">int</span> n, res = Integer.MIN_VALUE;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法三11转换dp">方法三：1:1转换DP</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximumSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length, res = Integer.MIN_VALUE;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][<span class="hljs-number">2</span>];<br>        Arrays.fill(dp[<span class="hljs-number">0</span>], Integer.MIN_VALUE &gt;&gt; <span class="hljs-number">1</span>); <span class="hljs-comment">// if (i == n) return Integer.MIN_VALUE &gt;&gt; 1;</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            dp[i + <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = Math.max(dp[i][<span class="hljs-number">0</span>], <span class="hljs-number">0</span>) + nums[i];<br>            dp[i + <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = Math.max(dp[i][<span class="hljs-number">1</span>] + nums[i], dp[i][<span class="hljs-number">0</span>]);<br>            res = Math.max(res, Math.max(dp[i + <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i + <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]));<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="section"></h3>
]]></content>
      <categories>
        <category>Algorithms</category>
        <category>Dynamic Programming</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Memorization Search</title>
    <url>/2023/05/24/memorization-searcch/</url>
    <content><![CDATA[<h1 id="自顶向下的动态规划记忆化搜索">自顶向下的动态规划——记忆化搜索</h1>
<div class="note note-success">
            <p><strong>记忆化搜索好解决不常见状态转移方程的dp问题</strong></p>
          </div>
<h2 id="打家劫舍"><a href="https://leetcode.cn/problems/house-robber/">198. 打家劫舍</a></h2>
<h3 id="方法一dp">方法一：DP</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 1.dp[j]: 到达标号为j的房屋可获得的最大价值</span><br>        <span class="hljs-comment">// 2.状态转移：dp[j] = max(dp[j - 1], dp[j - 2] + nums[j])</span><br>        <span class="hljs-comment">// 3.初始化：dp[0] = nums[0], dp[1] = max(nums[0], nums[1])</span><br>        <span class="hljs-comment">// 4.遍历顺序：从前往后</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">1</span>] = Math.max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; nums.length; ++i) &#123;<br>            dp[i] = Math.max(dp[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>] + nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[nums.length - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二dp-滚动数组">方法二：DP + 滚动数组</h3>
<p><strong>由状态转移方程可以看出，dp[i]由前面两个状态得出，所以dp数组的长度只需要为3</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 1.dp[j]: 到达标号为j的房屋可获得的最大价值</span><br>        <span class="hljs-comment">// 2.状态转移：dp[j] = max(dp[j - 1], dp[j - 2] + nums[j])</span><br>        <span class="hljs-comment">// 3.初始化：dp[0] = nums[0], dp[1] = max(nums[0], nums[1])</span><br>        <span class="hljs-comment">// 4.遍历顺序：从前往后</span><br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">1</span>] = Math.max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; nums.length; ++i) &#123;<br>            dp[i % <span class="hljs-number">3</span>] = Math.max(dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">3</span>], dp[(i - <span class="hljs-number">2</span>) % <span class="hljs-number">3</span>] + nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[(nums.length - <span class="hljs-number">1</span>) % <span class="hljs-number">3</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法三记忆化搜索">方法三：记忆化搜索</h3>
<p><strong>自顶向下，举个例子nums=[1,2,3,1]</strong></p>
<ol type="1">
<li><p><strong>返回的答案为dfs(3, nums)</strong></p></li>
<li><p><strong>要求，需要知道dfs(3-1,nums)与dfs(3-2,nums)+nums[3]，然后取最大值</strong></p></li>
<li><p><strong>求dfs(2,nums)，需要知道dfs(2-1,nums)与dfs(2-2,nums)+nums[2]，然后取最大值</strong></p>
<p>.......</p></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[] dp;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        Arrays.fill(dp, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(nums.length -  <span class="hljs-number">1</span>, nums);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (dp[index] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[index];<br><span class="hljs-comment">//        int dont = dfs(index - 1, nums);</span><br><span class="hljs-comment">//        int steal = dfs(index - 2, nums) + nums[index];</span><br><span class="hljs-comment">//        return dp[index] = Math.max(dont, steal);</span><br>        <span class="hljs-keyword">return</span> dp[index] = Math.max(dfs(index - <span class="hljs-number">1</span>, nums), dfs(index - <span class="hljs-number">2</span>, nums) + nums[index]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="二刷记忆化搜索">二刷记忆化搜索</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        Arrays.fill(dp, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(nums, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-type">int</span>[] dp;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &gt;= nums.length)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (dp[index] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[index];<br>        <span class="hljs-keyword">return</span> dp[index] = Math.max(dfs(nums, index + <span class="hljs-number">1</span>), dfs(nums, index + <span class="hljs-number">2</span>) + nums[index]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法四回溯">方法四：回溯</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">return</span> dfs(nums, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &gt;= nums.length)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> Math.max(dfs(nums, index + <span class="hljs-number">1</span>), dfs(nums, index + <span class="hljs-number">2</span>) + nums[index]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="打家劫舍-ii"><a href="https://leetcode.cn/problems/house-robber-ii/">213. 打家劫舍 II</a></h2>
<h3 id="方法一dp-1">方法一：DP</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">2</span>) <br>            <span class="hljs-keyword">return</span> Math.max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">return</span> Math.max(process(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>), process(nums, <span class="hljs-number">1</span>, nums.length));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">process</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[end - start];<br>        dp[<span class="hljs-number">0</span>] = nums[start];<br>        dp[<span class="hljs-number">1</span>] = Math.max(nums[start], nums[start + <span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; end - start; ++i) &#123;<br>            dp[i] = Math.max(dp[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>] + nums[i + start]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[end - start - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二dp-滚动数组-1">方法二：DP + 滚动数组</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">2</span>) <br>            <span class="hljs-keyword">return</span> Math.max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">return</span> Math.max(process(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>), process(nums, <span class="hljs-number">1</span>, nums.length));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">process</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<br>        dp[<span class="hljs-number">0</span>] = nums[start];<br>        dp[<span class="hljs-number">1</span>] = Math.max(nums[start], nums[start + <span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; end - start; ++i) &#123;<br>            dp[i % <span class="hljs-number">3</span>] = Math.max(dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">3</span>], dp[(i - <span class="hljs-number">2</span>) % <span class="hljs-number">3</span>] + nums[i + start]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[(end - start - <span class="hljs-number">1</span>) % <span class="hljs-number">3</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法三记忆化搜索-1">方法三：记忆化搜索</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[] dp;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> Math.max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        Arrays.fill(dp, -<span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res1</span> <span class="hljs-operator">=</span> dfs(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">2</span>);<br>        Arrays.fill(dp, -<span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res2</span> <span class="hljs-operator">=</span> dfs(nums, <span class="hljs-number">1</span>,  nums.length - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> Math.max(res1, res2);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &lt; start)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (dp[index] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[index];<br>       <span class="hljs-keyword">return</span> dp[index] = Math.max(dfs(nums, start, index - <span class="hljs-number">1</span>), dfs(nums, start, index - <span class="hljs-number">2</span>) + nums[index]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230524134911876.png" style="zoom:50%;" /></p>
<h3 id="二刷记忆化搜索-1">二刷记忆化搜索</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-built_in">this</span>.nums = nums;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        Arrays.fill(dp, -<span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res1</span> <span class="hljs-operator">=</span>  dfs(<span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>        Arrays.fill(dp, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> Math.max(res1, dfs(<span class="hljs-number">1</span>, nums.length));<br>    &#125;<br><br>    <span class="hljs-type">int</span>[] dp, nums;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-keyword">if</span> (start &gt;= end)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (dp[start] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[start];<br>        <span class="hljs-keyword">return</span> dp[start] = Math.max(dfs(start + <span class="hljs-number">1</span>, end), dfs(start + <span class="hljs-number">2</span>, end) + nums[start]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230619092221983.png" style="zoom:50%;" /></p>
<div class="note note-danger">
            <h2 id="打家劫舍-iii"><a href="https://leetcode.cn/problems/house-robber-iii/">337. 打家劫舍 III</a></h2><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230619092359520.png" /></p>
          </div>
<h3 id="方法一dp-2">方法一：DP</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// steal: 偷当前节点能获得的最大金额</span><br>    <span class="hljs-comment">// pass: 不偷当前节点能获得的最大金额</span><br>    <span class="hljs-comment">// steal(cur) = cur.val + pass(cur.left) + pass(cur.right)</span><br>    <span class="hljs-comment">// pass(cur) = max(steal(cur.left), pass(steal.right)) + max(steal(cur.right), pass(steal.right))</span><br>    Map&lt;TreeNode, Integer&gt; steal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    Map&lt;TreeNode, Integer&gt; pass = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        dfs(root);<br>        <span class="hljs-keyword">return</span> Math.max(steal.getOrDefault(root, <span class="hljs-number">0</span>), pass.getOrDefault(root, <span class="hljs-number">0</span>));<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span>;<br>        dfs(root.left);<br>        dfs(root.right);<br>        steal.put(root, root.val + pass.getOrDefault(root.left, <span class="hljs-number">0</span>) + pass.getOrDefault(root.right, <span class="hljs-number">0</span>));<br>        pass.put(root, Math.max(steal.getOrDefault(root.left, <span class="hljs-number">0</span>), pass.getOrDefault(root.left, <span class="hljs-number">0</span>)) + Math.max(steal.getOrDefault(root.right, <span class="hljs-number">0</span>), pass.getOrDefault(root.right, <span class="hljs-number">0</span>)));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="方法二乱写的的dfs">方法二：乱写的的dfs</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// steal: 偷当前节点能获得的最大金额</span><br>    <span class="hljs-comment">// pass: 不偷当前节点能获得的最大金额</span><br>    <span class="hljs-comment">// steal(cur) = cur.val + pass(cur.left) + pass(cur.right)</span><br>    <span class="hljs-comment">// pass(cur) = max(steal(cur.left), pass(steal.right)) + max(steal(cur.right), pass(steal.right))</span><br>    Map&lt;TreeNode, Integer&gt; steal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    Map&lt;TreeNode, Integer&gt; pass = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">steal</span> <span class="hljs-operator">=</span> dfs(root, <span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pass</span> <span class="hljs-operator">=</span> dfs(root, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> Math.max(steal, pass);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> flag)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">1</span> &amp;&amp; pass.get(root) != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> pass.get(root);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">0</span> &amp;&amp; steal.get(root) != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> steal.get(root);<br>        &#125;<br>        steal.put(root, root.val + pass.getOrDefault(root.left, dfs(root.left, <span class="hljs-number">1</span>)) + pass.getOrDefault(root.right, dfs(root.right, <span class="hljs-number">1</span>)));<br>        pass.put(root, Math.max(steal.getOrDefault(root.left, dfs(root.left, <span class="hljs-number">0</span>)), pass.getOrDefault(root.left, dfs(root.left, <span class="hljs-number">1</span>))) + Math.max(steal.getOrDefault(root.right, dfs(root.right, <span class="hljs-number">0</span>)), pass.getOrDefault(root.right, dfs(root.right, <span class="hljs-number">1</span>))));<br>        <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> steal.getOrDefault(root, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">else</span> <br>            <span class="hljs-keyword">return</span> pass.getOrDefault(root, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<div class="note note-danger">
            <h3 id="方法三记忆化搜索">方法三：记忆化搜索</h3>
          </div>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">return</span> dfs(root);    <br>    &#125;<br><br>    Map&lt;TreeNode, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (map.containsKey(root))<br>            <span class="hljs-keyword">return</span> map.get(root);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (root.left != <span class="hljs-literal">null</span>)<br>            left = dfs(root.left.left) + dfs(root.left.right);<br>        <span class="hljs-keyword">if</span> (root.right != <span class="hljs-literal">null</span>)<br>            right = dfs(root.right.left) + dfs(root.right.right);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">steal</span> <span class="hljs-operator">=</span> root.val + left + right;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pass</span> <span class="hljs-operator">=</span> dfs(root.left) + dfs(root.right);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Math.max(steal, pass);<br>        map.put(root, max);<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="目标和"><a href="https://leetcode.cn/problems/target-sum/">494. 目标和</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230619120524512.png" /></p>
<h3 id="方法一01背包">方法一：01背包</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findTargetSumWays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> Arrays.stream(nums).sum();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">diff</span> <span class="hljs-operator">=</span> sum - target;<br>        <span class="hljs-keyword">if</span> (diff % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> || diff &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        target = diff / <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// dp[j]:装满容量为j的方法数</span><br>        <span class="hljs-comment">// dp[0] = 1,装满容量为0的背包有一种</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[target + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> target; j &gt;= nums[i]; --j) &#123;<br>                dp[j] += dp[j - nums[i]];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[target];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230619120603939.png" style="zoom:50%;" /></p>
<h3 id="方法二回溯">方法二：回溯</h3>
<p>使用sum，对sum作加操作，相当于对target作减操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findTargetSumWays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        backtracking(nums, target, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-keyword">if</span> (start == nums.length) &#123;<br>            <span class="hljs-keyword">if</span> (target == <span class="hljs-number">0</span>)<br>                ++res;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        backtracking(nums, target + nums[start], start + <span class="hljs-number">1</span>);<br>        backtracking(nums, target - nums[start], start + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法三回溯的另一种写法">方法三：回溯的另一种写法</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findTargetSumWays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">return</span> dfs(nums, target, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> sum)</span> &#123;<br>        <span class="hljs-keyword">if</span> (start == nums.length) &#123;<br>            <span class="hljs-keyword">return</span> target == sum ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dfs(nums, target, start + <span class="hljs-number">1</span>, sum - nums[start]) + dfs(nums, target, start + <span class="hljs-number">1</span>, sum + nums[start]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="更加精简的回溯">更加精简的回溯</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findTargetSumWays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>       <span class="hljs-keyword">return</span> dfs(nums, target, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == nums.length)<br>            <span class="hljs-keyword">return</span> target == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> dfs(nums, target - nums[index], index + <span class="hljs-number">1</span>) + dfs(nums, target + nums[index], index + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<div class="note note-danger">
            <h3 id="方法四记忆化搜索">方法四：记忆化搜索</h3>
          </div>
<ol type="1">
<li><strong>相比回溯，使用数组记录已经计算过的结果，return前先赋值给数组memo</strong></li>
<li><strong>每次遍历时，首先检查memo中是否已经有结果(已经计算过了)，有结果直接返回结果</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[][] memo;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findTargetSumWays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length][<span class="hljs-number">2001</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] m : memo)<br>            Arrays.fill(m, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(nums, target, nums.length - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> sum)</span> &#123;<br>        <span class="hljs-keyword">if</span> (start &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> target == sum ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (memo[start][sum + <span class="hljs-number">1000</span>] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> memo[start][sum + <span class="hljs-number">1000</span>];<br>        <span class="hljs-keyword">return</span> memo[start][sum + <span class="hljs-number">1000</span>] = dfs(nums, target, start - <span class="hljs-number">1</span>, sum - nums[start]) + dfs(nums, target, start - <span class="hljs-number">1</span>, sum + nums[start]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="二刷记忆化搜索-2">二刷记忆化搜索</h4>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230619120337222.png" /></p>
<p>需要多开辟一点数组空间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findTargetSumWays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3001</span>][nums.length + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dp)<br>            Arrays.fill(arr, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(nums, target, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-type">int</span>[][] dp;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == nums.length)<br>            <span class="hljs-keyword">return</span> target == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (dp[target + <span class="hljs-number">1000</span>][index] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[target + <span class="hljs-number">1000</span>][index];<br>        <span class="hljs-keyword">return</span> dp[target + <span class="hljs-number">1000</span>][index] = dfs(nums, target - nums[index], index + <span class="hljs-number">1</span>) + dfs(nums, target + nums[index], index + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<div class="note note-danger">
            <h2 id="最小路径和"><a href="https://leetcode.cn/problems/minimum-path-sum/">64. 最小路径和</a></h2><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230619120631298.png" /></p>
          </div>
<h3 id="方法一回溯超时">方法一：回溯超时</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123; &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minPathSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length, n = grid[<span class="hljs-number">0</span>].length;<br>        dfs(grid, m, n, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, grid[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>]); <span class="hljs-comment">// 最后一次答案没有计算，所以在遍历前加上</span><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> sum)</span> &#123;<br>        <span class="hljs-keyword">if</span>(i == m - <span class="hljs-number">1</span> &amp;&amp; j == n - <span class="hljs-number">1</span>) &#123;<br>            res = Math.min(res, sum);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        sum += grid[i][j];<br>        <span class="hljs-keyword">if</span> (isValid(i + <span class="hljs-number">1</span>, j, m, n))<br>            dfs(grid, m, n, i + <span class="hljs-number">1</span>, j, sum);<br>        <span class="hljs-keyword">if</span> (isValid(i, j + <span class="hljs-number">1</span>, m, n))<br>            dfs(grid, m, n, i, j + <span class="hljs-number">1</span>, sum);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">return</span> row &gt;= <span class="hljs-number">0</span> &amp;&amp; col &gt;= <span class="hljs-number">0</span> &amp;&amp; row &lt; m &amp;&amp; col &lt; n;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二记忆化搜索">方法二：记忆化搜索</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>    <span class="hljs-type">int</span> dp[][];<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minPathSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length, n = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-comment">// dp[i][j]:grid[i][j]到右下角的最小距离</span><br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dp)<br>            Arrays.fill(arr, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(grid, m - <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> &amp;&amp; j == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">8000000</span>;<br>        <span class="hljs-keyword">if</span> (dp[i][j] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[i][j];<br>        <span class="hljs-keyword">return</span> dp[i][j] = grid[i][j] + Math.min(dfs(grid, i - <span class="hljs-number">1</span>, j), dfs(grid, i, j - <span class="hljs-number">1</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col)</span> &#123;<br>        <span class="hljs-keyword">return</span> row &gt;= <span class="hljs-number">0</span> &amp;&amp; col &gt;= <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230524183253622.png" alt="" style="zoom:50%;" /></p>
<h3 id="二刷记忆化搜索-3">二刷记忆化搜索</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minPathSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[grid.length][grid[<span class="hljs-number">0</span>].length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dp)<br>            Arrays.fill(arr, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(grid, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-type">int</span>[][] dp;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i == grid.length - <span class="hljs-number">1</span> &amp;&amp; j == grid[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> grid[i][j];<br>        <span class="hljs-keyword">if</span> (dp[i][j] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[i][j];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">40000</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> grid[i][j];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], col = j + dir[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (row &lt; grid.length &amp;&amp; col &lt; grid[<span class="hljs-number">0</span>].length) &#123;<br>                sum += dfs(grid, row, col);<br>                dp[i][j] = res = Math.min(res, sum);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230619130725865.png" style="zoom:50%;" /></p>
<h2 id="不同路径"><a href="https://leetcode.cn/problems/unique-paths/">62. 不同路径</a></h2>
<h3 id="方法一记忆化搜索">方法一：记忆化搜索</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[][] dp;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dp)<br>            Arrays.fill(arr, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(m, n);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span> &amp;&amp; j == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">1</span> || j &lt; <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (dp[i][j] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[i][j];<br>        <span class="hljs-keyword">return</span> dp[i][j] = dfs(i - <span class="hljs-number">1</span>, j) + dfs(i, j - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230524185318223.png" alt="" style="zoom:50%;" /></p>
<h3 id="二刷记忆化搜索-4">二刷记忆化搜索</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, m, n);<br>    &#125;<br><br>    <span class="hljs-type">int</span>[][] dp;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i == m &amp;&amp; j == n)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (i &gt; m || j &gt; n)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (dp[i][j] != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> dp[i][j];<br>        <span class="hljs-keyword">return</span> dp[i][j] = dfs(i + <span class="hljs-number">1</span>, j, m, n) + dfs(i, j + <span class="hljs-number">1</span>, m, n);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="不同路径-ii"><a href="https://leetcode.cn/problems/unique-paths-ii/">63. 不同路径 II</a></h2>
<h3 id="方法一记忆化搜索-1">方法一：记忆化搜索</h3>
<p><strong>obstacleGrid[i][j] == 1的判断要在if (i == 0 &amp;&amp; j == 0)上面，不然会报如下错</strong></p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230524190519092.png" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[][] dp;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePathsWithObstacles</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] obstacleGrid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> obstacleGrid.length, n = obstacleGrid[<span class="hljs-number">0</span>].length;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dp)<br>            Arrays.fill(arr, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(obstacleGrid, m - <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] obstacleGrid, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || obstacleGrid[i][j] == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> &amp;&amp; j == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (dp[i][j] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[i][j];<br>        <span class="hljs-keyword">return</span> dp[i][j] = dfs(obstacleGrid,i - <span class="hljs-number">1</span>, j) + dfs(obstacleGrid, i, j - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230524190551578.png" alt="image-20230524190551578" style="zoom:50%;" /></p>
<h3 id="二刷记忆化搜索-5">二刷记忆化搜索</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePathsWithObstacles</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] obstacleGrid)</span> &#123;<br>        m = obstacleGrid.length;<br>        n = obstacleGrid[<span class="hljs-number">0</span>].length;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">return</span> dfs(obstacleGrid, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-type">int</span>[][] dp;<br>    <span class="hljs-type">int</span> m, n;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] obstacleGrid, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i == m || j == n || obstacleGrid[i][j] == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (i == m - <span class="hljs-number">1</span> &amp;&amp; j == n - <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (dp[i][j] != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> dp[i][j];<br>        <span class="hljs-keyword">return</span> dp[i][j] = dfs(obstacleGrid, i + <span class="hljs-number">1</span>, j) + dfs(obstacleGrid, i, j + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<div class="note note-danger">
            <h2 id="单词拆分"><a href="https://leetcode.cn/problems/word-break/">139. 单词拆分</a></h2>
          </div>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230616142137186.png" /></p>
<h3 id="方法一dp-3">方法一：DP</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// dp[i]:前i个字符是否能被字典中的单词拼接出</span><br>    <span class="hljs-comment">// 状态转移：dp[i] = dp[j] &amp;&amp; set.contains(s.substring(j, i)) (j &lt; i)</span><br>    <span class="hljs-type">boolean</span>[] dp;<br>    Set&lt;String&gt; set;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">wordBreak</span><span class="hljs-params">(String s, List&lt;String&gt; wordDict)</span> &#123;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[s.length() + <span class="hljs-number">1</span>];<br>        set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(wordDict);<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= s.length(); ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (dp[j] &amp;&amp; set.contains(s.substring(j, i))) &#123;<br>                    dp[i] = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[s.length()];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二回溯超时">方法二：回溯(超时)</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    Set&lt;String&gt; set;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">wordBreak</span><span class="hljs-params">(String s, List&lt;String&gt; wordDict)</span> &#123;<br>        set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(wordDict);<br>        <span class="hljs-keyword">return</span> dfs(s, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == s.length())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> index; i &lt; s.length(); ++i) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> s.substring(index, i + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (set.contains(str) &amp;&amp; dfs(s, i + <span class="hljs-number">1</span>)) <br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<div class="note note-primary">
            <h3 id="方法二记忆化搜索">方法二：记忆化搜索</h3>
          </div>
<p><strong>dp[i]：从下标i到结尾，是否拼接出单词</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    Set&lt;String&gt; set;<br>    <span class="hljs-type">int</span>[] dp;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">wordBreak</span><span class="hljs-params">(String s, List&lt;String&gt; wordDict)</span> &#123;<br>        set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(wordDict);<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[s.length() + <span class="hljs-number">1</span>];<br>        Arrays.fill(dp, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(s, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == s.length())<span class="hljs-comment">//能走到这，说明之前的字符串全能被单词拼接</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (dp[index] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[index] == <span class="hljs-number">0</span> ? <span class="hljs-literal">false</span> : <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> index; i &lt; s.length(); ++i) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> s.substring(index, i + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (set.contains(str)) &#123;<br>                dp[i + <span class="hljs-number">1</span>] = dfs(s, i + <span class="hljs-number">1</span>) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span> (dp[i + <span class="hljs-number">1</span>] == <span class="hljs-number">1</span>)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 找到一个答案就返回true</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="整数替换"><a href="https://leetcode.cn/problems/integer-replacement/">397. 整数替换</a></h2>
<h3 id="方法一记忆化搜索-2">方法一：记忆化搜索</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <br>    Map&lt;Long, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">integerReplacement</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">return</span> dfs(n);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">long</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (map.containsKey(n))<br>            <span class="hljs-keyword">return</span> map.get(n);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>            count = dfs(n &gt;&gt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            count = Math.min(dfs(n + <span class="hljs-number">1</span>), dfs(n - <span class="hljs-number">1</span>)) + <span class="hljs-number">1</span>;<br>        &#125;<br>        map.put(n, count);<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230525190447088.png" alt=" " style="zoom:50%;" /></p>
<h2 id="跳跃游戏"><a href="https://leetcode.cn/problems/jump-game/">55. 跳跃游戏</a></h2>
<h3 id="方法一记忆化搜索-3">方法一：记忆化搜索</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[] dp;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canJump</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        <span class="hljs-keyword">return</span> dfs(nums, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &gt;= nums.length - <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (dp[index] != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> dp[index] == <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= nums[index]; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (dfs(nums, index + i)) &#123;<br>                dp[index] = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        dp[index] = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二贪心">方法二：贪心</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canJump</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rightmost</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (i &lt;= rightmost) &#123;<br>                rightmost = Math.max(rightmost, i + nums[i]);<br>                <span class="hljs-keyword">if</span> (rightmost &gt;= n - <span class="hljs-number">1</span>)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;                <br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法三回溯超时">方法三：回溯(超时)</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canJump</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">return</span> dfs(nums, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &gt;= nums.length - <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= nums[index]; ++i) <br>            <span class="hljs-keyword">if</span> (dfs(nums, index + i))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="二刷记忆化搜索-6">二刷记忆化搜索</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-type">int</span>[] dp;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canJump</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        <span class="hljs-keyword">return</span> dfs(nums, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &gt;= nums.length - <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (dp[index] != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> dp[index] == <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= nums[index]; ++i) &#123;<br>            dp[index] = dfs(nums, index + i) == <span class="hljs-literal">true</span> ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (dp[index] == <span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="跳跃游戏-ii"><a href="https://leetcode.cn/problems/jump-game-ii/">45. 跳跃游戏 II</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230616145728891.png" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">jump</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        <span class="hljs-keyword">return</span> dfs(nums, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-type">int</span>[] dp;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">10001</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &gt;= nums.length - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (dp[index] != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> dp[index];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> <span class="hljs-number">10001</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= nums[index]; ++i) &#123;<br>            min = Math.min(min, dfs(nums, index + i) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[index] = min;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二贪心-1">方法二：贪心</h3>
<h2 id="零钱兑换"><a href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换</a></h2>
<h3 id="方法一记忆化搜索-4">方法一：记忆化搜索</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">coinChange</span><span class="hljs-params">(<span class="hljs-type">int</span>[] coins, <span class="hljs-type">int</span> amount)</span> &#123;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[amount + <span class="hljs-number">1</span>];<br>        Arrays.fill(dp, -<span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> dfs(coins, amount);<br>        <span class="hljs-keyword">return</span> res == <span class="hljs-number">10001</span> ? -<span class="hljs-number">1</span> : res;<br>    &#125;<br><br>    <span class="hljs-type">int</span>[] dp;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] coins, <span class="hljs-type">int</span> amount)</span> &#123;<br>        <span class="hljs-keyword">if</span> (amount == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (dp[amount] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[amount];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> <span class="hljs-number">10001</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; coins.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (amount - coins[i] &lt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            min = Math.min(min, dfs(coins, amount - coins[i]) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[amount] = min;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二完全背包">方法二：完全背包</h3>
<h2 id="零钱兑换-ii"><a href="https://leetcode.cn/problems/coin-change-ii/">518. 零钱兑换 II</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230616155217322.png" /></p>
<h3 id="方法一完全背包">方法一：完全背包</h3>
<h3 id="方法二回溯超时-1">方法二：回溯(超时)</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">change</span><span class="hljs-params">(<span class="hljs-type">int</span> amount, <span class="hljs-type">int</span>[] coins)</span> &#123;<br>        Arrays.sort(coins);<br>        dfs(amount, coins, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> amount, <span class="hljs-type">int</span>[] coins, <span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (amount == <span class="hljs-number">0</span>) &#123;<br>            ++res;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> index; i &lt; coins.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (amount &lt; coins[i])<br>                <span class="hljs-keyword">break</span>;<br>            dfs(amount - coins[i], coins, i);<br>        &#125;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="回溯另一种写法">回溯另一种写法</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">change</span><span class="hljs-params">(<span class="hljs-type">int</span> amount, <span class="hljs-type">int</span>[] coins)</span> &#123;<br>    Arrays.sort(coins);<br>    <span class="hljs-keyword">return</span> dfs(amount, coins, <span class="hljs-number">0</span>);<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> amount, <span class="hljs-type">int</span>[] coins, <span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-keyword">if</span> (amount == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> index; i &lt; coins.length; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (amount &lt; coins[i])<br>            <span class="hljs-keyword">break</span>;<br>        count += dfs(amount - coins[i], coins, i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure>
<div class="note note-warning">
            <h3 id="方法三记忆化搜索">方法三：记忆化搜索</h3><p><strong>需要用二位数组存储当前amount，与遍历到的下标</strong></p>
          </div>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">change</span><span class="hljs-params">(<span class="hljs-type">int</span> amount, <span class="hljs-type">int</span>[] coins)</span> &#123;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[amount + <span class="hljs-number">1</span>][coins.length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dp)<br>            Arrays.fill(arr, -<span class="hljs-number">1</span>);<br>        Arrays.sort(coins);<br>        <span class="hljs-keyword">return</span> dfs(amount, coins, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-type">int</span>[][] dp;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> amount, <span class="hljs-type">int</span>[] coins, <span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (amount == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (dp[amount][index] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[amount][index];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> index; i &lt; coins.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (amount &lt; coins[i])<br>                <span class="hljs-keyword">break</span>;<br>            count += dfs(amount - coins[i], coins, i);<br>        &#125;<br>        <span class="hljs-keyword">return</span>  dp[amount][index] = count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="整数拆分"><a href="https://leetcode.cn/problems/integer-break/">343. 整数拆分</a></h2>
<h3 id="方法一记忆化搜索-5">方法一：记忆化搜索</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[] dp;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">integerBreak</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// dp[i]:将i拆分成若干正整数，将他们相乘的最大值</span><br>        <span class="hljs-comment">// dp[1] = 1; dp[2] = 1</span><br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> dfs(n);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (dp[n] != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> dp[n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n - <span class="hljs-number">1</span>; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> n - i;<br>            max = Math.max(max, Math.max(k * dfs(i), k * i));<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n] = max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230526143817625.png" alt="image-20230526143817625" style="zoom:50%;" /></p>
<p>res = Math.max(res, Math.max(i * (n - i), dfs(n - i) * i));这一句后面为什么不是dfs(n - i) * dfs(i)</p>
<p>比如</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230526144614352.png" style="zoom:50%;" /></p>
<p>如果dfs(i) * dfs(k)，那么6和2会被拆分成3， 3，1</p>
<h2 id="买卖股票的最佳时机"><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h2>
<h3 id="方法一贪心">方法一：贪心</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">minStock</span> <span class="hljs-operator">=</span> <span class="hljs-number">10000</span>, maxProfit = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> price : prices) &#123;<br>            <span class="hljs-keyword">if</span> (price &lt; minStock) &#123;<br>                minStock = price;<br>            &#125;<br>            maxProfit = Math.max(maxProfit, price - minStock);<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxProfit;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二回溯-1">方法二：回溯</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>    <span class="hljs-built_in">this</span>.prices = prices;<br>    <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">int</span>[] prices;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> state)</span> &#123;<br>    <span class="hljs-keyword">if</span> (index == prices.length || state == <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (state == <span class="hljs-number">0</span>)<br>        <span class="hljs-comment">// 不操作 买入</span><br>        <span class="hljs-keyword">return</span> Math.max(dfs(index + <span class="hljs-number">1</span>, state), dfs(index + <span class="hljs-number">1</span>, state + <span class="hljs-number">1</span>) - prices[index]);<br>    <span class="hljs-comment">// 不操作 卖出</span><br>    <span class="hljs-keyword">return</span> Math.max(dfs(index + <span class="hljs-number">1</span>, state), dfs(index + <span class="hljs-number">1</span>, state + <span class="hljs-number">1</span>) + prices[index]);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果摸不着头脑救去debug吧！</p>
<p>debug版本</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>    <span class="hljs-built_in">this</span>.prices = prices;<br>    <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">int</span>[] prices;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> state)</span> &#123;<br>    <span class="hljs-keyword">if</span> (index == prices.length || state == <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (state == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">keep0</span> <span class="hljs-operator">=</span> dfs(index + <span class="hljs-number">1</span>, state);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">buy</span> <span class="hljs-operator">=</span> dfs(index + <span class="hljs-number">1</span>, state + <span class="hljs-number">1</span>) - prices[index];<br>        <span class="hljs-keyword">return</span> Math.max(keep0, buy);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">keep1</span> <span class="hljs-operator">=</span> dfs(index + <span class="hljs-number">1</span>, state);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sell</span> <span class="hljs-operator">=</span> dfs(index + <span class="hljs-number">1</span>, state + <span class="hljs-number">1</span>) + prices[index];<br>        <span class="hljs-keyword">return</span> Math.max(keep1, sell);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法三记忆化搜索-2">方法三：记忆化搜索</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-built_in">this</span>.prices = prices;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>][prices.length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dp)<br>            Arrays.fill(arr, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-type">int</span>[] prices;<br>    <span class="hljs-type">int</span>[][] dp;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> state)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == prices.length || state == <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (dp[state][index] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[state][index];<br>        <span class="hljs-keyword">if</span> (state == <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">// 不操作 买入</span><br>            <span class="hljs-keyword">return</span> dp[state][index] = Math.max(dfs(index + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>), dfs(index + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>) - prices[index]);<br>        <span class="hljs-comment">// 不操作 卖出</span><br>        <span class="hljs-keyword">return</span> dp[state][index] = Math.max(dfs(index + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>), dfs(index + <span class="hljs-number">1</span>, <span class="hljs-number">2</span>) + prices[index]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="买卖股票的最佳时机-ii"><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></h2>
<h3 id="记忆化搜索">记忆化搜索</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-built_in">this</span>.prices = prices;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>][prices.length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dp)<br>            Arrays.fill(arr, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-type">int</span>[] prices;<br>    <span class="hljs-type">int</span>[][] dp;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> state)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == prices.length)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (dp[state][index] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[state][index];<br>        <span class="hljs-keyword">if</span> (state == <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">// 不操作 买入</span><br>            <span class="hljs-keyword">return</span> dp[state][index] = Math.max(dfs(index + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>), dfs(index + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>) - prices[index]);<br>        <span class="hljs-comment">// 不操作 卖出</span><br>        <span class="hljs-keyword">return</span> dp[state][index] = Math.max(dfs(index + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>), dfs(index + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>) + prices[index]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="买卖股票的最佳时机-iii"><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">123. 买卖股票的最佳时机 III</a></h2>
<h3 id="记忆化搜索-1">记忆化搜索</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[prices.length][<span class="hljs-number">4</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dp)<br>            Arrays.fill(arr, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(prices, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-type">int</span>[][] dp;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> state)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == prices.length || state == <span class="hljs-number">4</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (dp[index][state] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[index][state];<br>        <span class="hljs-keyword">if</span> (state == <span class="hljs-number">0</span> || state == <span class="hljs-number">2</span>) <span class="hljs-comment">// 不操作，买入</span><br>            <span class="hljs-keyword">return</span> dp[index][state] = Math.max(dfs(prices, index + <span class="hljs-number">1</span>, state), dfs(prices, index + <span class="hljs-number">1</span>, state + <span class="hljs-number">1</span>) - prices[index]);<br>        <span class="hljs-keyword">return</span> dp[index][state] = Math.max(dfs(prices, index + <span class="hljs-number">1</span>, state), dfs(prices, index + <span class="hljs-number">1</span>, state + <span class="hljs-number">1</span>) + prices[index]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="买卖股票的最佳时机-iv"><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">188. 买卖股票的最佳时机 IV</a></h2>
<h3 id="记忆化搜索-2">记忆化搜索</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span>[] prices)</span> &#123;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[prices.length][<span class="hljs-number">2</span> * k];<br>        <span class="hljs-built_in">this</span>.k = k;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dp)<br>            Arrays.fill(arr, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(prices, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-type">int</span>[][] dp;<br>    <span class="hljs-type">int</span> k;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> state)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == prices.length || state == <span class="hljs-number">2</span> * k)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (dp[index][state] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[index][state];<br>        <span class="hljs-keyword">if</span> (state % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) <span class="hljs-comment">// 不操作，买入</span><br>            <span class="hljs-keyword">return</span> dp[index][state] = Math.max(dfs(prices, index + <span class="hljs-number">1</span>, state), dfs(prices, index + <span class="hljs-number">1</span>, state + <span class="hljs-number">1</span>) - prices[index]);<br>        <span class="hljs-keyword">return</span> dp[index][state] = Math.max(dfs(prices, index + <span class="hljs-number">1</span>, state), dfs(prices, index + <span class="hljs-number">1</span>, state + <span class="hljs-number">1</span>) + prices[index]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="买卖股票的最佳时机含手续费"><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714. 买卖股票的最佳时机含手续费</a></h2>
<h3 id="记忆化搜索-3">记忆化搜索</h3>
<p>卖的时候 - fee 或者 买的时候 - fee都可以</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices, <span class="hljs-type">int</span> fee)</span> &#123;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[prices.length][<span class="hljs-number">2</span>];<br>        <span class="hljs-built_in">this</span>.fee = fee;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dp)<br>            Arrays.fill(arr, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(prices, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-type">int</span>[][] dp;<br>    <span class="hljs-type">int</span> fee;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> state)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == prices.length)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (dp[index][state] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[index][state];<br>        <span class="hljs-keyword">if</span> (state == <span class="hljs-number">0</span>) <span class="hljs-comment">// 不操作，买入</span><br>            <span class="hljs-keyword">return</span> dp[index][state] = Math.max(dfs(prices, index + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>), dfs(prices, index + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>) - prices[index]);<br>        <span class="hljs-keyword">return</span> dp[index][state] = Math.max(dfs(prices, index + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>), dfs(prices, index + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>) + prices[index] - fee);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="最佳买卖股票时机含冷冻期"><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309. 最佳买卖股票时机含冷冻期</a></h2>
<h3 id="记忆化搜索-4">记忆化搜索</h3>
<p>卖出:index + 2</p>
<p>base case : index &gt;= prices.length</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[prices.length][<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dp)<br>            Arrays.fill(arr, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(prices, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-type">int</span>[][] dp;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> state)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &gt;= prices.length)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (dp[index][state] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[index][state];<br>        <span class="hljs-keyword">if</span> (state == <span class="hljs-number">0</span>) <span class="hljs-comment">// 不操作，买入</span><br>            <span class="hljs-keyword">return</span> dp[index][state] = Math.max(dfs(prices, index + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>), dfs(prices, index + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>) - prices[index]);<br>        <span class="hljs-keyword">return</span> dp[index][state] = Math.max(dfs(prices, index + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>), dfs(prices, index + <span class="hljs-number">2</span>, <span class="hljs-number">0</span>) + prices[index]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="获得分数的方法数"><a href="https://leetcode.cn/problems/number-of-ways-to-earn-points/">获得分数的方法数</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230819164801464.png" /></p>
<h3 id="方法一记忆化搜索分组背包">方法一：记忆化搜索(分组背包)</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br>    <span class="hljs-type">int</span> n ;<br>    <span class="hljs-type">int</span>[][] types, dp;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">waysToReachTarget</span><span class="hljs-params">(<span class="hljs-type">int</span> target, <span class="hljs-type">int</span>[][] types)</span> &#123;<br>        <span class="hljs-built_in">this</span>.types = types;<br>        n = types.length;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][<span class="hljs-number">1002</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dp)<br>            Arrays.fill(arr, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, target);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == n)<br>            <span class="hljs-keyword">return</span> target == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (dp[index][target] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[index][target];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, count = types[index][<span class="hljs-number">0</span>], marks = types[index][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= Math.min(target / marks, count); ++i)<br>            res = (res + (dfs(index + <span class="hljs-number">1</span>, target - i * marks) % MOD)) % MOD;<br>        <span class="hljs-keyword">return</span> dp[index][target] = res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="最小化目标值与所选元素的差"><a href="https://leetcode.cn/problems/minimize-the-difference-between-target-and-chosen-elements/">1981. 最小化目标值与所选元素的差</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230821214634416.png" /></p>
<h3 id="方法一记忆化搜索-6">方法一：记忆化搜索</h3>
<p><a href="https://leetcode.cn/problems/minimize-the-difference-between-target-and-chosen-elements/solutions/952088/liang-chong-fang-fa-jian-dan-yi-dong-ji-7jugp/">题解</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimizeTheDifference</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] mat, <span class="hljs-type">int</span> target)</span> &#123;<br>        m = mat.length;<br>        n = mat[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-built_in">this</span>.target = target;<br>        <span class="hljs-built_in">this</span>.mat = mat;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">80</span>][<span class="hljs-number">5000</span>];<br>        dfs(<span class="hljs-number">0</span>,  <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> sum)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i == m) &#123;<br>            res = Math.min(res, Math.abs(sum - target));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (sum - target &gt; res || dp[i][sum])<br>            <span class="hljs-keyword">return</span>;<br>        dp[i][sum] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>            dfs(i + <span class="hljs-number">1</span>, sum + mat[i][j]);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-type">int</span> m, n, res = Integer.MAX_VALUE;<br>    <span class="hljs-type">int</span>[][] mat;<br>    <span class="hljs-type">boolean</span>[][] dp;<br>    <span class="hljs-type">int</span> target;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="访问数组中的位置使分数最大"><a href="https://leetcode.cn/problems/visit-array-positions-to-maximize-score/description/">访问数组中的位置使分数最大</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230914214531879.png" /></p>
<h2 id="单词拆分"><a href="https://leetcode.cn/problems/word-break/">139. 单词拆分</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230915160403571.png" /></p>
<h3 id="方法一记忆化搜索-7">方法一：记忆化搜索</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">wordBreak</span><span class="hljs-params">(String s, List&lt;String&gt; wordDict)</span> &#123;<br>        <span class="hljs-built_in">this</span>.s = s;<br>        n = s.length();<br>        set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(wordDict);<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Arrays.fill(dp, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == n)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (dp[index] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[index] == <span class="hljs-number">1</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> index; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">sub</span> <span class="hljs-operator">=</span> s.substring(index, i + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (set.contains(sub)) &#123; <br>                dp[index] = dfs(i + <span class="hljs-number">1</span>) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span> (dp[index] == <span class="hljs-number">1</span>)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> n;<br>    String s;<br>    Set&lt;String&gt; set;<br>    <span class="hljs-type">int</span>[] dp;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="最长递增子序列2"><a href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长递增子序列2</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230915163010624.png" /></p>
<h3 id="方法一记忆化搜索选或不选">方法一：记忆化搜索(选或不选)</h3>
<p><strong>注意额外处理第一个位置</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        n = nums.length;<br>        <span class="hljs-built_in">this</span>.nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">this</span>.nums[<span class="hljs-number">0</span>] = -<span class="hljs-number">10001</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            <span class="hljs-built_in">this</span>.nums[i + <span class="hljs-number">1</span>] = nums[i];<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dp)<br>            Arrays.fill(arr, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> pre)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == n + <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (dp[index][pre] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[index][pre];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> nums[index];<br>        <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span> || x &gt; nums[pre])<br>            <span class="hljs-keyword">return</span> dp[index][pre] = Math.max(dfs(index + <span class="hljs-number">1</span>, index) + <span class="hljs-number">1</span>, dfs(index + <span class="hljs-number">1</span>, pre));<br>        <span class="hljs-keyword">return</span> dp[index][pre] = dfs(index + <span class="hljs-number">1</span>, pre);<br>    &#125;<br><br>    <span class="hljs-type">int</span>[][] dp;<br>    <span class="hljs-type">int</span>[] nums;<br>    <span class="hljs-type">int</span> n;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二记忆化搜索枚举选哪个">方法二：记忆化搜索(枚举选哪个)</h3>
<p>dp不用重复初始化，因为记忆化的是增量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        n = nums.length;<br>        <span class="hljs-built_in">this</span>.nums = nums;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            res = Math.max(res, dfs(i));<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (dp[index] != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> dp[index];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> index + <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; nums[index])<br>                res = Math.max(res, dfs(i) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[index] = res;<br>    &#125;<br><br>    <span class="hljs-type">int</span>[] dp;<br>    <span class="hljs-type">int</span>[] nums;<br>    <span class="hljs-type">int</span> n;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法三dp">方法三：DP</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length, res = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 以i为结尾，最长递增子序列的长度</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Arrays.fill(dp, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (nums[i] &gt; nums[j])<br>                    dp[i] = Math.max(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>            &#125;<br>            res = Math.max(res, dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="分割等和子集"><a href="https://leetcode.cn/problems/partition-equal-subset-sum/">416. 分割等和子集</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230915190924853.png" /></p>
<h3 id="方法一记忆化搜索-8">方法一：记忆化搜索</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canPartition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, n = nums.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : nums)<br>            target += x;<br>        <span class="hljs-keyword">if</span> (target % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        target /= <span class="hljs-number">2</span>;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][target + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dp)<br>            Arrays.fill(arr, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, nums, target);<br>    &#125;<br><br>    <span class="hljs-type">int</span>[][] dp;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == nums.length)<br>            <span class="hljs-keyword">return</span> target == <span class="hljs-number">0</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (dp[index][target] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[index][target] == <span class="hljs-number">1</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">choose</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>, pass = <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> nums[index];<br>        <span class="hljs-keyword">if</span> (target - x &gt;= <span class="hljs-number">0</span>) &#123;<br>            choose = dfs(index + <span class="hljs-number">1</span>, nums, target - x);<br>        &#125;<br>        pass = dfs(index + <span class="hljs-number">1</span>, nums , target);<br>        dp[index][target] = (choose || pass) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> dp[index][target] == <span class="hljs-number">1</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<div class="note note-primary">
            <h2 id="不同的子序列"><a href="https://leetcode.cn/problems/distinct-subsequences/">115. 不同的子序列</a></h2>
          </div>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230626094058827.png" /></p>
<h3 id="二刷记忆化搜索-7">二刷记忆化搜索</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numDistinct</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        m = s.length();<br>        n = t.length();<br>        <span class="hljs-built_in">this</span>.s = s;<br>        <span class="hljs-built_in">this</span>.t = t;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dp)<br>            Arrays.fill(arr, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-comment">// t被匹配返回1</span><br>        <span class="hljs-keyword">if</span> (j == n)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// s到最后也没能匹配到t的最后一个字符，返回0</span><br>        <span class="hljs-keyword">if</span> (i == m)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (dp[i][j] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[i][j];<br>        <span class="hljs-comment">// 匹配：选：i，j往下递归；不选：i往下递归</span><br>        <span class="hljs-keyword">if</span> (s.charAt(i) == t.charAt(j))<br>            <span class="hljs-keyword">return</span> dp[i][j] = dfs(i + <span class="hljs-number">1</span>, j + <span class="hljs-number">1</span>) + dfs(i + <span class="hljs-number">1</span>, j);<br>        <span class="hljs-keyword">return</span> dp[i][j] = dfs(i + <span class="hljs-number">1</span>, j);<br>    &#125;<br><br>    <span class="hljs-type">int</span> m, n;<br>    String s, t;<br>    <span class="hljs-type">int</span>[][] dp;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法三滚动数组">方法三：滚动数组</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numDistinct</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> s.length(), n = t.length();<br>        <span class="hljs-comment">// s[:i]中t[:j]出现的次数</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// s,t为空串，匹配</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> n; j &gt;= <span class="hljs-number">1</span>; --j) &#123;<br>                <span class="hljs-keyword">if</span> (s.charAt(i - <span class="hljs-number">1</span>) == t.charAt(j - <span class="hljs-number">1</span>))<br>                    dp[j] += dp[j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法一dp-4">方法一：DP</h3>
<p><strong>注意初始化</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numDistinct</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">        s = &quot;bagg&quot;, t = &quot;bag&quot;</span><br><span class="hljs-comment">        对于bag的最后一个&#x27;g&#x27;，可以使用它，或者不使用它</span><br><span class="hljs-comment">         */</span><br>         <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> s.length(), n = t.length();<br>        <span class="hljs-keyword">if</span> (m &lt; n)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i &lt;= m; ++i)<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (s.charAt(i - <span class="hljs-number">1</span>) == t.charAt(j - <span class="hljs-number">1</span>))<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">1</span>][j];<br>                <span class="hljs-keyword">else</span><br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二记忆化搜索-1">方法二：记忆化搜索</h3>
<p><a href="https://leetcode.cn/problems/distinct-subsequences/solutions/661537/shou-hua-tu-jie-xiang-jie-liang-chong-ji-4r2y/">优质题解</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numDistinct</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        m = s.length();<br>        n = t.length();<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dp)<br>            Arrays.fill(arr, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(s, t, m - <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-type">int</span> m, n;<br>    <span class="hljs-type">int</span>[][] dp;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(String s, String t, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">if</span> (j &lt; <span class="hljs-number">0</span>)	<span class="hljs-comment">// base case 当j指针越界，此时t为空串，s不管是不是空串，匹配方式数都是1</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>)	<span class="hljs-comment">// base case i指针越界，此时s为空串，t不是，s怎么也匹配不了t，方式数0</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (dp[i][j] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[i][j];<br>        <span class="hljs-keyword">if</span> (s.charAt(i) == t.charAt(j))<br>            <span class="hljs-keyword">return</span> dp[i][j] = dfs(s, t, i - <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span>) + dfs(s, t, i - <span class="hljs-number">1</span>, j);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> dp[i][j] = dfs(s, t, i - <span class="hljs-number">1</span>, j);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="执行操作使两个字符串相等"><a href="https://leetcode.cn/problems/apply-operations-to-make-two-strings-equal/">2896. 执行操作使两个字符串相等</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20231009192344128.png" /></p>
<h3 id="方法一记忆化搜索-9">方法一：记忆化搜索</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minOperations</span><span class="hljs-params">(String s1, String s2, <span class="hljs-type">int</span> x)</span> &#123;<br>        n = s1.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, cnt2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (s1.charAt(i) == <span class="hljs-string">&#x27;1&#x27;</span>)<br>                ++cnt1;<br>            <span class="hljs-keyword">if</span> (s2.charAt(i) == <span class="hljs-string">&#x27;1&#x27;</span>)<br>                ++cnt2;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (cnt1 % <span class="hljs-number">2</span> != cnt2 % <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">this</span>.s1 = s1;<br>        <span class="hljs-built_in">this</span>.s2 = s2;<br>        <span class="hljs-built_in">this</span>.x = x;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n + <span class="hljs-number">1</span>][<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[][] a : dp)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] b : a)<br>                Arrays.fill(b, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> key, <span class="hljs-type">boolean</span> reverse)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &gt;= n)<br>            <span class="hljs-keyword">return</span> key == <span class="hljs-number">0</span> &amp;&amp; !reverse ? <span class="hljs-number">0</span> : inf;<br>        <span class="hljs-keyword">if</span> (dp[index][key][reverse ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[index][key][reverse ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>];<br>        <span class="hljs-type">char</span> <span class="hljs-variable">ch1</span> <span class="hljs-operator">=</span> s1.charAt(index), ch2 = s2.charAt(index);<br>        <span class="hljs-keyword">if</span> ((ch1 == ch2) == !reverse)<br>            <span class="hljs-keyword">return</span> dp[index][key][reverse ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>] = dfs(index + <span class="hljs-number">1</span>, key, <span class="hljs-literal">false</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Math.min(dfs(index + <span class="hljs-number">1</span>, key + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>) + x, dfs(index + <span class="hljs-number">1</span>, key, <span class="hljs-literal">true</span>) + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (key &gt; <span class="hljs-number">0</span>)<br>            res = Math.min(res, dfs(index + <span class="hljs-number">1</span>, key - <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>));<br>        <span class="hljs-keyword">return</span> dp[index][key][reverse ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>] = res;<br>    &#125;<br><br>    String s1, s2;<br>    <span class="hljs-type">int</span> x, inf = Integer.MAX_VALUE &gt;&gt; <span class="hljs-number">1</span>, n;<br>    <span class="hljs-type">int</span>[][][] dp;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="对数组执行操作使平方和最大"><a href="https://leetcode.cn/problems/apply-operations-on-array-to-maximize-sum-of-squares/">2897. 对数组执行操作使平方和最大</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20231009192640117.png" /></p>
<h3 id="方法一位运算">方法一：位运算</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSum</span><span class="hljs-params">(List&lt;Integer&gt; nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> <span class="hljs-number">1_000_000_007</span>;<br>        <span class="hljs-type">int</span>[] cnt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">30</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : nums) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; i++) &#123;<br>                cnt[i] += (x &gt;&gt; i) &amp; <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (k-- &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; i++) &#123;<br>                <span class="hljs-keyword">if</span> (cnt[i] &gt; <span class="hljs-number">0</span>) &#123;<br>                    cnt[i]--;<br>                    x |= <span class="hljs-number">1</span> &lt;&lt; i;<br>                &#125;<br>            &#125;<br>            ans = (ans + (<span class="hljs-type">long</span>) x * x) % MOD;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) ans;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithms</category>
        <category>Memorization Search</category>
      </categories>
      <tags>
        <tag>记忆化搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>Backtracking</title>
    <url>/2023/05/20/backtracking/</url>
    <content><![CDATA[<h1 id="backtracking">Backtracking</h1>
<div class="note note-danger">
            <h2 id="复原-ip-地址"><a href="https://leetcode.cn/problems/restore-ip-addresses/">93. 复原 IP 地址</a></h2>
          </div>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230523092346721.png" /></p>
<p><strong>解题思路</strong>：加“.”分割字符串</p>
<p><strong>注意</strong>：isValid()中，如果得到的子串str为空，说明字符串s已经有三个“.”分割，并且最后一个点在最后一个位置，比如<code>101.0.23.</code>，</p>
<ol type="1">
<li>s = s.substring(0, i + 1) + "." + s.substring(i + 1);得到字符串s = <code>101.0.23.</code></li>
<li>++pointNum;</li>
<li>进入下一轮backtracking(s, i + 2, pointNum); i + 2为<code>.</code>后面一位9</li>
<li>此时pointNum == 3，判断ip是否合法if (isValid(s, start, s.length() - 1))</li>
<li>String str = s.substring(start, end + 1); 此时start为9，end + 1为9，String.subString左闭右开，所以得到的str为空</li>
<li>这种情况返回false</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">restoreIpAddresses</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">if</span> (s.length() &gt; <span class="hljs-number">12</span>)<br>            <span class="hljs-keyword">return</span> res;<br>        backtracking(s, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> pointNum)</span> &#123;<br>        <span class="hljs-keyword">if</span> (pointNum == <span class="hljs-number">3</span>) &#123;<br>            <span class="hljs-keyword">if</span> (isValid(s, start, s.length() - <span class="hljs-number">1</span>))<br>                res.add(s);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; s.length(); ++i) &#123;<br>            <span class="hljs-keyword">if</span> (isValid(s, start, i)) &#123;<br>                s = s.substring(<span class="hljs-number">0</span>, i + <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;.&quot;</span> + s.substring(i + <span class="hljs-number">1</span>);<br>                ++pointNum;<br>                backtracking(s, i + <span class="hljs-number">2</span>, pointNum);<br>                --pointNum;<br>                s = s.substring(<span class="hljs-number">0</span>, i + <span class="hljs-number">1</span>) + s.substring(i + <span class="hljs-number">2</span>); <span class="hljs-comment">// 删除&quot;.&quot;</span><br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> s.substring(start, end + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (str.isEmpty())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> Integer.valueOf(str) &lt;= <span class="hljs-number">255</span> &amp;&amp; (str.equals(<span class="hljs-string">&quot;0&quot;</span>) ||str.charAt(<span class="hljs-number">0</span>) != <span class="hljs-string">&#x27;0&#x27;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230522100005351.png" alt="" style="zoom:50%;" /></p>
<h3 id="方法二回溯stringbuilder">方法二：回溯(StringBuilder)</h3>
<p><strong>需要注意很多细节</strong></p>
<ol type="1">
<li><p>isValid</p>
<ol type="1">
<li><p>首先需要判断字符串是否为空;</p></li>
<li><p>Integer.valueOf(s) &lt;= 255的前提是以下else需要break，不然会超出整型最大值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; s.length(); ++i) &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> s.substring(start, i + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (isValid(str)) &#123;<br>        path.append(str);<br>        path.append(<span class="hljs-string">&quot;.&quot;</span>);<br>        backtracking(s, i + <span class="hljs-number">1</span>, split + <span class="hljs-number">1</span>);<br>        deleteSub();<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>要么为0要么第一个字符不为0，s.equals("0") || s.charAt(0) != '0'</p></li>
</ol></li>
<li><p>删除函数</p>
<p>一般会做两次path.append操作，先append子串，再append <code>.</code>，所以删除操作先把<code>.</code>删除了，再删除上一个<code>.</code>之前的子串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteSub</span><span class="hljs-params">()</span> &#123;<br>    path.deleteCharAt(path.length() - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">while</span> (path.length() != <span class="hljs-number">0</span> &amp;&amp; path.charAt(path.length() - <span class="hljs-number">1</span>) != <span class="hljs-string">&#x27;.&#x27;</span>)<br>        path.deleteCharAt(path.length() - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>注意base case，如果剩余子串满足条件，那么会将子串append到path中，再加到res中，所以在此之后需要回溯一次，将新加入的子串删掉</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (split == <span class="hljs-number">3</span>) &#123;<br>     <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> s.substring(start);<br>    <span class="hljs-keyword">if</span> (isValid(str)) &#123;<br>        path.append(str);<br>        res.add(path.toString());<br>        deleteSub();<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h4 id="代码">代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">restoreIpAddresses</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">if</span> (s.length() &gt; <span class="hljs-number">12</span>)<br>            <span class="hljs-keyword">return</span> res;<br>        backtracking(s, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> split)</span> &#123;<br>        <span class="hljs-keyword">if</span> (split == <span class="hljs-number">3</span>) &#123;<br>             <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> s.substring(start);<br>            <span class="hljs-keyword">if</span> (isValid(str)) &#123;<br>                path.append(str);<br>                res.add(path.toString());<br>                deleteSub();<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; s.length(); ++i) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> s.substring(start, i + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (isValid(str)) &#123;<br>                path.append(str);<br>                path.append(<span class="hljs-string">&quot;.&quot;</span>);<br>                backtracking(s, i + <span class="hljs-number">1</span>, split + <span class="hljs-number">1</span>);<br>                deleteSub();<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteSub</span><span class="hljs-params">()</span> &#123;<br>        path.deleteCharAt(path.length() - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">while</span> (path.length() != <span class="hljs-number">0</span> &amp;&amp; path.charAt(path.length() - <span class="hljs-number">1</span>) != <span class="hljs-string">&#x27;.&#x27;</span>)<br>            path.deleteCharAt(path.length() - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">if</span> (s.isEmpty())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> Integer.valueOf(s) &lt;= <span class="hljs-number">255</span> &amp;&amp; (s.equals(<span class="hljs-string">&quot;0&quot;</span>) || s.charAt(<span class="hljs-number">0</span>) != <span class="hljs-string">&#x27;0&#x27;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230614114451417.png" alt="image-20230614114451417" style="zoom:50%;" /></p>
<h3 id="方法三stringbuilder-剪枝">方法三：StringBuilder + 剪枝</h3>
<p><strong>在方法二的基础上加入剪枝</strong></p>
<p>s.length() - start表示未被选择的子串的长度，记为<code>x</code>吧，举例说明</p>
<p>如果split = 0，表示还没有进行分割，如果x &gt; 12，一定不能满足条件，return；</p>
<p>如果split = 1，表示分割了一段，如果x &gt; 9，一定不能满足条件，return；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (s.length() - start &gt; <span class="hljs-number">3</span> * (<span class="hljs-number">4</span> - split))<br>    <span class="hljs-keyword">return</span>;<br></code></pre></td></tr></table></figure>
<h4 id="代码-1">代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">restoreIpAddresses</span><span class="hljs-params">(String s)</span> &#123;<br>        backtracking(s, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> split)</span> &#123;<br>        <span class="hljs-keyword">if</span> (split == <span class="hljs-number">3</span>) &#123;<br>             <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> s.substring(start);<br>            <span class="hljs-keyword">if</span> (isValid(str)) &#123;<br>                path.append(str);<br>                res.add(path.toString());<br>                deleteSub();<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (s.length() - start &gt; <span class="hljs-number">3</span> * (<span class="hljs-number">4</span> - split))<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; s.length(); ++i) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> s.substring(start, i + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (isValid(str)) &#123;<br>                path.append(str);<br>                path.append(<span class="hljs-string">&quot;.&quot;</span>);<br>                backtracking(s, i + <span class="hljs-number">1</span>, split + <span class="hljs-number">1</span>);<br>                deleteSub();<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteSub</span><span class="hljs-params">()</span> &#123;<br>        path.deleteCharAt(path.length() - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">while</span> (path.length() != <span class="hljs-number">0</span> &amp;&amp; path.charAt(path.length() - <span class="hljs-number">1</span>) != <span class="hljs-string">&#x27;.&#x27;</span>)<br>            path.deleteCharAt(path.length() - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">if</span> (s.isEmpty())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> Integer.valueOf(s) &lt;= <span class="hljs-number">255</span> &amp;&amp; (s.equals(<span class="hljs-string">&quot;0&quot;</span>) || s.charAt(<span class="hljs-number">0</span>) != <span class="hljs-string">&#x27;0&#x27;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230614115544890.png" style="zoom:50%;" /></p>
<h2 id="分割回文串"><a href="https://leetcode.cn/problems/palindrome-partitioning/">131. 分割回文串</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230522184615639.png" /></p>
<h3 id="方法一回溯">方法一：回溯</h3>
<p><strong>二刷</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    List&lt;List&lt;String&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    Deque&lt;String&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">partition</span><span class="hljs-params">(String s)</span> &#123;<br>        backtracking(s, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-keyword">if</span> (start == s.length()) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; s.length(); ++i) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">split</span> <span class="hljs-operator">=</span> s.substring(start, i + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (isValid(split)) &#123;<br>                path.add(split);<br>                backtracking(s, i + <span class="hljs-number">1</span>);<br>                path.pollLast();<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String split)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, end = split.length() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (start &lt; end) &#123;<br>            <span class="hljs-keyword">if</span> (split.charAt(start++) != split.charAt(end--))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230522132532968.png" alt="" style="zoom:50%;" /></p>
<h3 id="方法二回溯-dp预处理">方法二：回溯 + DP预处理</h3>
<p><strong>使用动态规划得到所有子串是否是回文</strong></p>
<p>状态：dp[i][j] 表示字符串s在[i,j]区间的子串是否是一个回文串。 状态转移方程：当 s[i] == s[j] &amp;&amp; (j - i &lt; 2 || dp[i + 1][j - 1]) 时，dp[i][j]=true，否则为false 这个状态转移方程是什么意思呢？</p>
<p>当只有一个字符时，比如 a 自然是一个回文串。 当有两个字符时，如果是相等的，比如 aa，也是一个回文串。 当有三个及以上字符时，比如 ababa 这个字符记作串 1，把两边的 a 去掉，也就是 bab 记作串 2，可以看出只要串2是一个回文串，那么左右各多了一个 a 的串 1 必定也是回文串。所以当 s[i]==s[j] 时，自然要看 dp[i+1][j-1] 是不是一个回文串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">partition</span><span class="hljs-params">(String s)</span> &#123;<br>        n = s.length();<br>        <span class="hljs-built_in">this</span>.s = s;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n][n];<br>        <span class="hljs-comment">// dp[i][j] = ch1 == ch2 &amp;&amp; (j - i + 1 &lt;= 2) || dp[i + 1][j - 1]</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (s.charAt(i) == s.charAt(j) &amp;&amp; (j - i + <span class="hljs-number">1</span> &lt;= <span class="hljs-number">2</span> || dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]))<br>                    dp[i][j] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        dfs(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == n) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> index; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">sub</span> <span class="hljs-operator">=</span> s.substring(index, i + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (dp[index][i]) &#123;<br>                path.add(sub);<br>                dfs(i + <span class="hljs-number">1</span>);<br>                path.pollLast();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">boolean</span>[][] dp;<br><br>    List&lt;List&lt;String&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    Deque&lt;String&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-comment">// StringBuilder sb = new StringBuilder();</span><br>    <span class="hljs-type">int</span> n;<br>    String s;        <br>&#125;<br></code></pre></td></tr></table></figure>
<div class="note note-danger">
            <h2 id="剑指-offer-ii-085.-生成匹配的括号"><a href="https://leetcode.cn/problems/IDBivT/">剑指 Offer II 085. 生成匹配的括号</a></h2>
          </div>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230522184630657.png" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        backtracking(n, n, <span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> leftNum, <span class="hljs-type">int</span> rightNum, String parenthesis)</span> &#123;<br>        <span class="hljs-keyword">if</span> (leftNum == <span class="hljs-number">0</span> &amp;&amp; rightNum == <span class="hljs-number">0</span>) &#123;<br>            res.add(parenthesis);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (leftNum &gt; <span class="hljs-number">0</span>) &#123;<br>            backtracking(leftNum - <span class="hljs-number">1</span>, rightNum, parenthesis + <span class="hljs-string">&quot;(&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (leftNum &lt; rightNum) &#123;<br>            backtracking(leftNum, rightNum - <span class="hljs-number">1</span>, parenthesis + <span class="hljs-string">&quot;)&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230522140516243.png" alt="" style="zoom:50%;" /></p>
<h3 id="方法二stringbuilder">方法二：StringBuilder</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        backtracking(n, n);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-number">0</span> &amp;&amp; right == <span class="hljs-number">0</span>) &#123;<br>            res.add(path.toString());<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (left &gt; <span class="hljs-number">0</span>) &#123;<br>            path.append(<span class="hljs-string">&quot;(&quot;</span>);<br>            backtracking(left - <span class="hljs-number">1</span>, right);<br>            path.deleteCharAt(path.length() - <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (left &lt; right) &#123;<br>            path.append(<span class="hljs-string">&quot;)&quot;</span>);<br>            backtracking(left, right - <span class="hljs-number">1</span>);<br>            path.deleteCharAt(path.length() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230614105320546.png" style="zoom:50%;" /></p>
<h2 id="组合"><a href="https://leetcode.cn/problems/combinations/">77. 组合</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230522184648467.png" /></p>
<h3 id="方法一">方法一：</h3>
<p><strong>剪枝：</strong></p>
<ol type="1">
<li><strong>当前最多用n - i + 1</strong></li>
<li><strong>当前还需要加入k - path.size()个数组</strong></li>
</ol>
<p><strong>n - i + 1 &gt;= k - path.size</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combine</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>        backtracking(n, k, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-keyword">if</span> (path.size() == k) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt;= n - (k - path.size()) + <span class="hljs-number">1</span>; ++i) &#123;<br>            path.add(i);<br>            backtracking(n, k, i + <span class="hljs-number">1</span>);<br>            path.pollLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二">方法二：</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combine</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-comment">// 防止底层扩容</span><br>        Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;(k);<br>        backtracking(path, n, k, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(Deque&lt;Integer&gt; path, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 若n=3，k=2,即从[1,2,3]中选两个数，如果当前什么都没选(k=2)，n - k + 1= 2，</span><br>        <span class="hljs-comment">// 说明至少要从2开始，才能满足选两个数这个要求</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">bound</span> <span class="hljs-operator">=</span> n - k + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (start &gt; bound)<br>            <span class="hljs-keyword">return</span>;<br>        backtracking(path, n, k, start + <span class="hljs-number">1</span>);<br>        path.addLast(start);<br>        backtracking(path, n, k - <span class="hljs-number">1</span>, start + <span class="hljs-number">1</span>);<br>        path.removeLast();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="两种方法的树形结构求子集为例子">两种方法的树形结构（求子集为例子）</h3>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/841d34959b843a14f5c19b937c9c2e1.jpg" /></p>
<h2 id="组合总和-iii"><a href="https://leetcode.cn/problems/combination-sum-iii/">216. 组合总和 III</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230522184744833.png" /></p>
<h3 id="方法一-1">方法一：</h3>
<p><strong>注意：backtracking(k - 1, n - i, i + 1);k - 1，别写成--k!!!</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum3</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n)</span> &#123;<br>        backtracking(k, n, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)<br>                res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt;= <span class="hljs-number">9</span> - (k - path.size()) + <span class="hljs-number">1</span>; ++i) &#123;<br>            path.offerLast(i);<br>            backtracking(k - <span class="hljs-number">1</span>, n - i, i + <span class="hljs-number">1</span>);<br>            path.pollLast();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二-1">方法二：</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum3</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n)</span> &#123;<br>        backtracking(k, n, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)<br>                res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">bound</span> <span class="hljs-operator">=</span> <span class="hljs-number">9</span> - k + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (start &gt; bound)<br>            <span class="hljs-keyword">return</span>;<br>        backtracking(k, n, start + <span class="hljs-number">1</span>);<br>        path.offerLast(start);<br>        backtracking(k - <span class="hljs-number">1</span>, n - start, start + <span class="hljs-number">1</span>);<br>        path.pollLast();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="组合总和"><a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230522184803338.png" /></p>
<p><strong>无重复元素，每个元素可以无限次选取</strong></p>
<h3 id="方法一-2">方法一：</h3>
<p><strong>剪枝：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (target &lt; candidates[i])<br>   <span class="hljs-keyword">break</span>;	<br></code></pre></td></tr></table></figure>
<p><strong>可重复选取，所以backtracking传入的是当前下标i</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">backtracking(candidates, target - candidates[i], i);<br></code></pre></td></tr></table></figure>
<p><strong>剪枝的条件是把数组排序</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Arrays.sort(candidates);<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>    Arrays.sort(candidates);<br>    backtracking(candidates, target, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> start)</span> &#123;<br>    <span class="hljs-keyword">if</span> (target &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (target == <span class="hljs-number">0</span>) &#123;<br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(path));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; candidates.length; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (target &lt; candidates[i])<br>            <span class="hljs-keyword">break</span>;<br>        path.offerLast(candidates[i]);<br>        backtracking(candidates, target - candidates[i], i);<br>        path.pollLast();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二-2">方法二：</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>        Arrays.sort(candidates);<br>        backtracking(candidates, target, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-keyword">if</span> (target &lt; <span class="hljs-number">0</span> || start == candidates.length)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (target == <span class="hljs-number">0</span>) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        backtracking(candidates, target, start + <span class="hljs-number">1</span>);<br>        path.offerLast(candidates[start]);<br>        backtracking(candidates, target - candidates[start], start);<br>        path.pollLast();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="组合总和-ii"><a href="https://leetcode.cn/problems/combination-sum-ii/">40. 组合总和 II</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230522194233770.png" /></p>
<p><strong>数组内有重复元素，每个元素只能使用一次，解集不能包含重复组合</strong></p>
<h3 id="方法一-3">方法一：</h3>
<p><strong>剪枝</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (candidates[i] &gt; target)<br>    <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure>
<p><strong>去重</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (i &gt; start &amp;&amp; candidates[i] == candidates[i - <span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">continue</span>;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>        Arrays.sort(candidates);<br>        backtracking(candidates, target, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-keyword">if</span> (target == <span class="hljs-number">0</span>) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; candidates.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (candidates[i] &gt; target)<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">if</span> (i &gt; start &amp;&amp; candidates[i] == candidates[i - <span class="hljs-number">1</span>])<br>                <span class="hljs-keyword">continue</span>;<br>            path.offerLast(candidates[i]);<br>            backtracking(candidates, target - candidates[i], i + <span class="hljs-number">1</span>);<br>            path.pollLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="子集"><a href="https://leetcode.cn/problems/subsets/">78. 子集</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230523090841520.png" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        backtracking(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-keyword">if</span> (start == nums.length) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        backtracking(nums, start + <span class="hljs-number">1</span>);<br>        path.offerLast(nums[start]);<br>        backtracking(nums, start + <span class="hljs-number">1</span>);<br>        path.pollLast();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<div class="note note-danger">
            <h2 id="递增子序列"><a href="https://leetcode.cn/problems/non-decreasing-subsequences/">491. 递增子序列</a></h2>
          </div>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230523090901456.png" /></p>
<h4 id="方法一顺序dfs">方法一：顺序DFS</h4>
<p><strong>注意：</strong></p>
<ol type="1">
<li><strong>HashSet的位置！！！每进入一层递归，就会在for循环前创建一个HashSet，这样可以保证树层去重，并且树枝不会去重</strong></li>
<li><strong>peekLast()! 不是peek()</strong></li>
</ol>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> Solution &#123;<br>    List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; res = <span class="hljs-built_in">new</span> LinkedList&lt;&gt;();<br>    Deque&lt;<span class="hljs-type">Integer</span>&gt; <span class="hljs-type">path</span> = <span class="hljs-built_in">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-built_in">public</span> List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; findSubsequences(<span class="hljs-type">int</span>[] nums) &#123;<br>        backtracking(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> backtracking(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> <span class="hljs-keyword">start</span>) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-type">path</span>.size() &gt;= <span class="hljs-number">2</span>)<br>            res.<span class="hljs-keyword">add</span>(<span class="hljs-built_in">new</span> LinkedList(<span class="hljs-type">path</span>));<br>        <span class="hljs-keyword">Set</span>&lt;<span class="hljs-type">Integer</span>&gt; <span class="hljs-keyword">set</span> = <span class="hljs-built_in">new</span> HashSet&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-keyword">start</span>; i &lt; nums.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> ((!<span class="hljs-type">path</span>.isEmpty() &amp;&amp; nums[i] &lt; <span class="hljs-type">path</span>.peekLast()))<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">set</span>.contains(nums[i]))<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">set</span>.<span class="hljs-keyword">add</span>(nums[i]);<br>            <span class="hljs-type">path</span>.<span class="hljs-keyword">add</span>(nums[i]);<br>            backtracking(nums, i + <span class="hljs-number">1</span>);<br>            <span class="hljs-type">path</span>.pollLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="全排列"><a href="https://leetcode.cn/problems/permutations/">46. 全排列</a></h2>
<p><strong>把树形结构画出来就懂了</strong></p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/20201209174225145.png" /></p>
<p>for (int i = 0; i &lt; nums.length; ++i) { if (used[i]) continue;与 for (int i = 0; i &lt; nums.length &amp;&amp; !used[i]; ++i) 的区别</p>
<p>这两个循环的区别在于循环终止条件的判断逻辑。</p>
<ol type="1">
<li><p>第一个循环： <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (used[i])<br>        <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-comment">// 其他代码逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure> 这个循环会遍历数组 <code>nums</code> 的所有元素，但在每次迭代中，如果当前元素已经被标记为 <code>used[i]</code>，则会使用 <code>continue</code> 跳过后续的代码逻辑，直接进入下一次迭代。</p></li>
<li><p>第二个循环： <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length &amp;&amp; !used[i]; ++i) &#123;<br>    <span class="hljs-comment">// 其他代码逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure> 这个循环同样会遍历数组 <code>nums</code> 的所有元素，但在每次迭代中，会先检查终止条件 <code>i &lt; nums.length &amp;&amp; !used[i]</code>。只有当两个条件都满足时，才会执行循环体中的代码逻辑。如果其中任何一个条件不满足，循环就会终止。</p></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    Deque&lt;Integer&gt; path;<br>    <span class="hljs-type">boolean</span>[] used;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permute</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 防止底层扩容</span><br>        path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;(nums.length);<br>        used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[nums.length];<br>        backtracking(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-keyword">if</span> (path.size() == nums.length) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (used[i])<br>                <span class="hljs-keyword">continue</span>;<br>            path.offerLast(nums[i]);<br>            used[i] = <span class="hljs-literal">true</span>;<br>            backtracking(nums, i + <span class="hljs-number">1</span>);<br>            used[i] = <span class="hljs-literal">false</span>;<br>            path.pollLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="全排列-ii"><a href="https://leetcode.cn/problems/permutations-ii/">47. 全排列 II</a></h2>
<ol type="1">
<li><strong>为了去重，需要先将数组排序</strong></li>
<li><strong>树层去重，树枝不需要去重</strong></li>
<li><strong>上一个相同的数如果used[i - 1] == false，那么说明已经被遍历过，并且将used数组赋值回false，这个时候就不需要遍历当前nums[i]了；如果used[i - 1] == true，那么说明是在同一路径上</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; !used[i - <span class="hljs-number">1</span>])<br>               <span class="hljs-keyword">continue</span>;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    Deque&lt;Integer&gt; path;<br>    <span class="hljs-type">boolean</span>[] used;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permuteUnique</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 防止底层扩容</span><br>        path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;(nums.length);<br>        used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[nums.length];<br>        Arrays.sort(nums);<br>        backtracking(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-keyword">if</span> (path.size() == nums.length) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (used[i])<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; !used[i - <span class="hljs-number">1</span>])<br>                <span class="hljs-keyword">continue</span>;<br>            path.offerLast(nums[i]);<br>            used[i] = <span class="hljs-literal">true</span>;<br>            backtracking(nums, i + <span class="hljs-number">1</span>);<br>            used[i] = <span class="hljs-literal">false</span>;<br>            path.pollLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<div class="note note-danger">
            <h2 id="划分为k个相等的子集"><a href="https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/">698. 划分为k个相等的子集</a></h2><p><strong>二刷没做出，三刷ac</strong></p>
          </div>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230524095514759.png" /></p>
<p><a href="https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/solution/by-lfool-d9o7/">优质题解</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-type">int</span>[] bucket;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canPartitionKSubsets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> Arrays.stream(nums).sum();<br>        <span class="hljs-keyword">if</span> (sum % k != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> sum / k;<br>        bucket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k];<br>        Arrays.sort(nums);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[l];<br>            nums[l] = nums[r];<br>            nums[r] = temp;<br>            ++l;<br>            --r;<br>        &#125;<br>        <span class="hljs-keyword">return</span> backtracking(nums, k, target, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == nums.length)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; bucket[i - <span class="hljs-number">1</span>] == bucket[i])<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (nums[index] + bucket[i] &gt; target)<br>                <span class="hljs-keyword">continue</span>;<br>            bucket[i] += nums[index];<br>            <span class="hljs-keyword">if</span> (backtracking(nums, k, target, index + <span class="hljs-number">1</span>))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            bucket[i] -= nums[index];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="n-皇后"><a href="https://leetcode.cn/problems/n-queens/">51. N 皇后</a></h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230524095532469.png" /></p>
<h3 id="方法一回溯-1">方法一：回溯</h3>
<p><strong>可以通过(c == colum[i] || r + c == i + colum[i] || r - c == i - colum[i])来判断是否同列，同对角线</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">solveNQueens</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-built_in">this</span>.n = n;<br>        colum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n]; <span class="hljs-comment">// 第i行选择的列号</span><br>        dfs(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == n) &#123; <span class="hljs-comment">// index是行</span><br>            res.add(build());<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123; <span class="hljs-comment">// i是列</span><br>            <span class="hljs-keyword">if</span> (isValid(index, i)) &#123;<br>                colum[index] = i;<br>                dfs(index + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; r; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (c == colum[i] || r + c == i + colum[i] || r - c == i - colum[i])<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">build</span><span class="hljs-params">()</span> &#123;<br>        List&lt;String&gt; s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : colum) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; x; ++i)<br>                sb.append(<span class="hljs-string">&#x27;.&#x27;</span>);<br>            sb.append(<span class="hljs-string">&#x27;Q&#x27;</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - x - <span class="hljs-number">1</span>; ++i)<br>                sb.append(<span class="hljs-string">&#x27;.&#x27;</span>);<br>            s.add(sb.toString());<br>            sb = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br><br>    List&lt;List&lt;String&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    Deque&lt;String&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-type">int</span>[] colum;<br>    <span class="hljs-type">int</span> n;<br><br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="火柴拼正方形"><a href="https://leetcode.cn/problems/matchsticks-to-square/">473. 火柴拼正方形</a></h2>
<p>与<a href="https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/">698. 划分为k个相等的子集</a>一道题</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230614204145750.png" /></p>
<h3 id="方法一回溯-2">方法一：回溯</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-type">int</span>[] bucket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">4</span>];<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">makesquare</span><span class="hljs-params">(<span class="hljs-type">int</span>[] matchsticks)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> Arrays.stream(matchsticks).sum();<br>        <span class="hljs-keyword">if</span> (sum % <span class="hljs-number">4</span> != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> sum / <span class="hljs-number">4</span>, l = <span class="hljs-number">0</span>, r = matchsticks.length - <span class="hljs-number">1</span>;<br>        Arrays.sort(matchsticks);<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> matchsticks[l];<br>            matchsticks[l] = matchsticks[r];<br>            matchsticks[r] = temp;<br>            ++l;<br>            --r;<br>        &#125;<br>        <span class="hljs-keyword">return</span> backtracking(matchsticks, <span class="hljs-number">0</span>, target);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] matchsticks, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == matchsticks.length)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; bucket[i - <span class="hljs-number">1</span>] == bucket[i])<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (matchsticks[index] + bucket[i] &gt; target)<br>                <span class="hljs-keyword">continue</span>;<br>            bucket[i] += matchsticks[index];<br>            <span class="hljs-keyword">if</span> (backtracking(matchsticks, index + <span class="hljs-number">1</span>, target))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            bucket[i] -= matchsticks[index];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230614204206499.png" style="zoom:50%;" /></p>
<div class="note note-danger">
            <h2 id="公平分发饼干"><a href="https://leetcode.cn/problems/fair-distribution-of-cookies/">2305. 公平分发饼干</a></h2><p><a href="https://leetcode.cn/problems/fair-distribution-of-cookies/solution/jian-zhi-hui-su-by-baoya_uncle-7s48/">参考题解</a></p>
          </div>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230614204226326.png" /></p>
<div class="note note-warning">
            <p><strong>这一题和<a href="https://leetcode.cn/problems/split-array-largest-sum/">分割数组的最大值</a>的区别是，这里的cookies不需要连续取！！！！！</strong></p>
          </div>
<h3 id="方法一回溯-3">方法一：回溯</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>    <span class="hljs-type">int</span>[] bucket;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">distributeCookies</span><span class="hljs-params">(<span class="hljs-type">int</span>[] cookies, <span class="hljs-type">int</span> k)</span> &#123;<br>        Arrays.sort(cookies);<br>        bucket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k];<br>        backtracking(cookies, k, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] cookies, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == cookies.length) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">curAns</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> count : bucket)&#123;<br>                curAns = Math.max(curAns, count);<br>            &#125;<br>            res = Math.min(res, curAns);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; bucket[i - <span class="hljs-number">1</span>] == bucket[i])<br>                <span class="hljs-keyword">continue</span>;<br>            bucket[i] += cookies[index];<br>            backtracking(cookies, k, index + <span class="hljs-number">1</span>);<br>            bucket[i] -= cookies[index];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230614222638902.png" style="zoom:50%;" /></p>
<h3 id="方法二回溯-二分">方法二：回溯 + 二分</h3>
<p><strong>求最小的最大值</strong></p>
<ol type="1">
<li><p>用<code>k</code>个框(bucket)装一个数组，所有框统一尺寸，要求框的最小尺寸</p></li>
<li><p><code>left</code>是数组的最大元素，<code>right</code>是数组元素之和，如果把框的尺寸设为<code>left</code>，那么大概率不能容纳所有数组元素：</p>
<p><code>left = mid + 1</code>；如果把框的尺寸设为<code>right</code>，肯定能装下数组所有元素：<code>right = mid - 1</code></p></li>
<li><p>只要check(cookies, mid, k)为true，说明mid刚刚好或者选大了，框的上界可以进一步缩小，</p>
<p><strong>当最后一次满足<code>check(cookies, mid, k)</code>为<code>true</code>并向左滑动右区间，之后只会向右滑动左区间，</strong></p>
<p><strong>最后<code>left = right + 1</code>退出<code>while</code>循环，left就是最小的最大值</strong></p></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[] bucket;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">distributeCookies</span><span class="hljs-params">(<span class="hljs-type">int</span>[] cookies, <span class="hljs-type">int</span> k)</span> &#123;<br>        bucket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k];<br>        Arrays.sort(cookies);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = cookies.length - <span class="hljs-number">1</span>, sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> cookies[l];<br>            cookies[l] = cookies[r];<br>            cookies[r] = temp;<br>            sum += temp + cookies[l];<br>            ++l;<br>            --r;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (cookies.length % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>)<br>            sum += cookies[cookies.length / <span class="hljs-number">2</span>];<br>        l = cookies[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 数组最大值</span><br>        r = sum;<br>        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (check(cookies, mid, k)) <span class="hljs-comment">// mid刚刚好或者选大了，bucket的上界可以进一步缩小</span><br>                r = mid - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> l;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span>[] cookies, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> k)</span> &#123;<br>        bucket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k];<br>        <span class="hljs-keyword">return</span> backtracking(cookies, mid, k, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] cookies, <span class="hljs-type">int</span> limit, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == cookies.length)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 如果能遍历到这一步，说明所有元素都被装入桶中;如果有元素不能放入任意一个桶中，会走完for循环，return false</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; bucket[i - <span class="hljs-number">1</span>] == bucket[i]) <span class="hljs-comment">// 如果两个桶已装容量一致，那么把当前饼干放在哪个桶效果都一样</span><br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (bucket[i] + cookies[index] &gt; limit)<br>                <span class="hljs-keyword">continue</span>;<br>            bucket[i] += cookies[index];<br>            <span class="hljs-keyword">if</span> (backtracking(cookies, limit, k, index + <span class="hljs-number">1</span>))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 如果有一种选择已经满足了，return true</span><br>            bucket[i] -= cookies[index];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230616114154502.png" style="zoom:50%;" /></p>
<div class="note note-danger">
            <h2 id="完成所有工作的最短时间"><a href="https://leetcode.cn/problems/find-minimum-time-to-finish-all-jobs/">1723. 完成所有工作的最短时间</a></h2>
          </div>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230616093347111.png" /></p>
<p>与<a href="https://leetcode.cn/problems/fair-distribution-of-cookies/">2305. 公平分发饼干</a>一模一样</p>
<div class="note note-primary">
            <h3 id="方法一二分-回溯">方法一：二分 + 回溯</h3><p>这里的二分和之前做的二分不太一样</p><ol type="1"><li><strong>要求最小的最大值，我们用二分去测试，如果允许每个bucket的最大值为mid，是否能用k个bucket容纳下jobs的所有元素</strong></li><li>l取jobs中最大的元素，r取jobs的和sum，比如每个bucket的最大值为sum，那么一个bucket就能容纳下jobs的所有元素，那么肯定是要取更小的bucket的最大值</li></ol>
          </div>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[] bucket;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumTimeRequired</span><span class="hljs-params">(<span class="hljs-type">int</span>[] jobs, <span class="hljs-type">int</span> k)</span> &#123;<br>        bucket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k];<br>        Arrays.sort(jobs);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = jobs.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> jobs[l];<br>            jobs[l] = jobs[r];<br>            jobs[r] = temp;<br>            ++l;<br>            --r;<br>        &#125;<br>        l = jobs[<span class="hljs-number">0</span>];<br>        r = Arrays.stream(jobs).sum();<br>        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (check(jobs, mid, k)) <span class="hljs-comment">// mid刚好或者选大了</span><br>                r = mid - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> l;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span>[] jobs, <span class="hljs-type">int</span> limit, <span class="hljs-type">int</span> k)</span> &#123;<br>        bucket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k];<br>        <span class="hljs-keyword">return</span> backtracking(jobs, limit, k, <span class="hljs-number">0</span>);<br>    &#125;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] jobs, <span class="hljs-type">int</span> limit, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == jobs.length)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; bucket[i - <span class="hljs-number">1</span>] == bucket[i])<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (jobs[index] + bucket[i] &gt; limit)<br>                <span class="hljs-keyword">continue</span>;<br>            bucket[i] += jobs[index];<br>            <span class="hljs-keyword">if</span> (backtracking(jobs, limit, k, index + <span class="hljs-number">1</span>))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            bucket[i] -= jobs[index];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230616105731441.png" style="zoom:50%;" /></p>
<h3 id="优化求sum部分">优化求sum部分</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[] bucket;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumTimeRequired</span><span class="hljs-params">(<span class="hljs-type">int</span>[] jobs, <span class="hljs-type">int</span> k)</span> &#123;<br>        bucket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k];<br>        Arrays.sort(jobs);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = jobs.length - <span class="hljs-number">1</span>, sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> jobs[l];<br>            jobs[l] = jobs[r];<br>            jobs[r] = temp;<br>            sum += temp + jobs[l];<br>            ++l;<br>            --r;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (jobs.length % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>)<br>            sum += jobs[jobs.length / <span class="hljs-number">2</span>];<br>        l = jobs[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 数组最大值</span><br>        r = sum;<br>        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (check(jobs, mid, k)) <span class="hljs-comment">// mid刚好或者选大了</span><br>                r = mid - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> l;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span>[] jobs, <span class="hljs-type">int</span> limit, <span class="hljs-type">int</span> k)</span> &#123;<br>        bucket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k];<br>        <span class="hljs-keyword">return</span> backtracking(jobs, limit, k, <span class="hljs-number">0</span>);<br>    &#125;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] jobs, <span class="hljs-type">int</span> limit, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == jobs.length)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; bucket[i - <span class="hljs-number">1</span>] == bucket[i])<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (jobs[index] + bucket[i] &gt; limit)<br>                <span class="hljs-keyword">continue</span>;<br>            bucket[i] += jobs[index];<br>            <span class="hljs-keyword">if</span> (backtracking(jobs, limit, k, index + <span class="hljs-number">1</span>))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            bucket[i] -= jobs[index];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230616112230879.png" style="zoom:50%;" /></p>
<h3 id="二刷">二刷</h3>
<p>省略check，每次在dfs前重新初始化bucket数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumTimeRequired</span><span class="hljs-params">(<span class="hljs-type">int</span>[] jobs, <span class="hljs-type">int</span> k)</span> &#123;<br>    bucket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k];<br>    Arrays.sort(jobs);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = jobs.length - <span class="hljs-number">1</span>, sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> jobs[l];<br>        jobs[l] = jobs[r];<br>        jobs[r] = temp;<br>        sum += temp + jobs[l];<br>        ++l;<br>        --r;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (jobs.length % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)<br>        sum += jobs[jobs.length / <span class="hljs-number">2</span>];<br>    l = jobs[<span class="hljs-number">0</span>];<br>    r = sum;<br>    <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (dfs(jobs, k, mid, <span class="hljs-number">0</span>))<br>            r = mid - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span><br>            l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br><br><br><span class="hljs-type">int</span>[] bucket;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] jobs, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-keyword">if</span> (index == jobs.length) &#123;<br>       bucket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k];<br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; bucket[i - <span class="hljs-number">1</span>] == bucket[i])<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (bucket[i] + jobs[index] &gt; target)<br>            <span class="hljs-keyword">continue</span>;<br>        bucket[i] += jobs[index];<br>        <span class="hljs-keyword">if</span> (dfs(jobs, k, target,index + <span class="hljs-number">1</span>))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        bucket[i] -= jobs[index];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230621100352321.png" /></p>
]]></content>
      <categories>
        <category>Algorithms</category>
        <category>backtracking</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>Algorithms</title>
    <url>/2023/04/07/Algorithms/</url>
    <content><![CDATA[<h1 id="leetcode-solutions">LeetCode Solutions</h1>
<!-- toc -->
<h2 id="dynamic-programming">Dynamic Programming</h2>
<h3 id="debug">debug</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printDp</span><span class="hljs-params">(<span class="hljs-type">int</span>[] dp, <span class="hljs-type">int</span> i)</span> &#123;<br>    System.out.print(i + <span class="hljs-string">&quot;: &quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> maxValue : dp)&#123;<br>        System.out.print(maxValue + <span class="hljs-string">&quot;   &quot;</span>);<br>    &#125;<br>    System.out.println();<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="斐波那契数"><a href="https://leetcode.cn/problems/fibonacci-number/">509. 斐波那契数</a></h3>
<h4 id="方法一dp">方法一：DP</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;<br>            dp[i] = dp[i - <span class="hljs-number">2</span>] + dp[i - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230512102141368.png" alt="image-20230512102141368" style="zoom:50%;" /></p>
<h4 id="方法二dp-滚动数组">方法二：DP + 滚动数组</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;<br>            dp[i % <span class="hljs-number">3</span>] = dp[(i - <span class="hljs-number">2</span>) % <span class="hljs-number">3</span>] + dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">3</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n % <span class="hljs-number">3</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230512102424611.png" alt="image-20230512102424611" style="zoom:50%;" /></p>
<h3 id="爬楼梯"><a href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a></h3>
<h4 id="方法一dp-滚动数组">方法一：DP + 滚动数组</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// 1.dp[i]:爬上第i层楼梯的方法数</span><br>        <span class="hljs-comment">// 2.状态转移方程：dp[i] = dp[i - 1] + dp[i - 2]</span><br>        <span class="hljs-comment">// 3.初始化：爬上第0层楼梯的方法数是1，dp[0] = 1,如果是0，那么dp[2] = 1！</span><br>        <span class="hljs-comment">// 爬上第一层楼梯的方法数是1,dp[1] = 1</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;<br>            dp[i % <span class="hljs-number">3</span>] = dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">3</span>] + dp[(i - <span class="hljs-number">2</span>) % <span class="hljs-number">3</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n % <span class="hljs-number">3</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230512103518672.png" alt="image-20230512103518672" style="zoom:50%;" /></p>
<h3 id="使用最小花费爬楼梯"><a href="https://leetcode.cn/problems/min-cost-climbing-stairs/">746. 使用最小花费爬楼梯</a></h3>
<p><strong>注意：最后一个阶梯之后才是楼顶</strong></p>
<figure>
<img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230512125550663.png" alt="image-20230512125550663" /><figcaption aria-hidden="true">image-20230512125550663</figcaption>
</figure>
<h4 id="方法一dp-滚动数组-1">方法一：DP + 滚动数组</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCostClimbingStairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] cost)</span> &#123;<br>        <span class="hljs-comment">// dp[i]:爬到第i层的最小花费</span><br>        <span class="hljs-comment">// 状态转移方程：dp[i] = min(dp[i - 2] + cost[i - 2], dp[i - 1] + cost[i - 1])</span><br>        <span class="hljs-comment">// 初始化：dp[0] = 0, dp[1] = 0</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> cost.length;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;<br>            dp[i % <span class="hljs-number">3</span>] = Math.min(dp[(i - <span class="hljs-number">2</span>) % <span class="hljs-number">3</span>] + cost[i - <span class="hljs-number">2</span>], dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">3</span>] + cost[i - <span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n % <span class="hljs-number">3</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230512123419045.png" alt="image-20230512123419045" style="zoom:50%;" /></p>
<h3 id="剑指offer-95">剑指Offer 95</h3>
<ol type="1">
<li><p>最优子结构：求<strong>最长</strong>公共子序列，求问题最优解，适合使用dp解决。</p></li>
<li><p>重叠子问题：求第一个字符串中位置0~<span class="math inline">\(i\)</span>构成的子序列与第二个字符串中0~<span class="math inline">\(j\)</span>构成的子序列的最大公共子序列<span class="math inline">\(f(i,j)\)</span>，需要多次使用<span class="math inline">\(f(i-1, j-1), f(i-1,j),f(i,j-1)\)</span>，拥有重叠子问题</p></li>
<li><p>状态转移方程： <span class="math display">\[
f(i,j) = 
\begin{cases}
f(i-1,j-1)+1, &amp; ch[i]==ch[j] \\
max(f(i-1,j),f(i,j-1)), &amp; else \\
\end{cases}
\]</span></p></li>
<li><p>边界条件：dp[0][:] == 0, dp[:][] == 0</p></li>
</ol>
<p>令两个字符串长度分别为<span class="math inline">\(m,n\)</span>，</p>
<p><strong>时间复杂度</strong>：双重for循环，<span class="math inline">\(O(mn)\)</span></p>
<p><strong>空间复杂度</strong>：需要建立大小为(m+1)(n+1)的数组，因此空间复杂度为<span class="math inline">\(O(mn)\)</span></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestCommonSubsequence</span><span class="hljs-params">(String text1, String text2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> text1.length(), n = text2.length();<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (text1.charAt(i - <span class="hljs-number">1</span>) == text2.charAt(j - <span class="hljs-number">1</span>)) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = Math.max(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230418182108971.png" alt="image-20230418182108971" style="zoom:50%;" /></p>
<p><strong>如何优化空间复杂度？</strong></p>
<h3 id="剑指offer-101-分割等和子集"><a href="https://leetcode.cn/problems/partition-equal-subset-sum/">剑指Offer 101 分割等和子集</a></h3>
<p><strong>分析</strong>：只要在数组中找到任意数等于数组累加和的一半，该数组就是等和子集，可抽象为经典0-1背包问题。</p>
<ol type="1">
<li>dp[i][j]:从编号0-i的物品中任选物品(可以都不选)，容量为j的背包能否正好装满</li>
<li>递归公式:dp[i][j] = dp[i-1][j] || j &gt;= num[i] : dp[i-1][j-nums[i]] : false</li>
<li>初始化:
<ol type="1">
<li>当j==0时，即背包容量为0，不管有多少物品，只要什么都不选就能使背包总重量为0，所以f(i,0)=true</li>
<li>当i==0 &amp;&amp; j!= 0时，即物品数量为0，怎样都不能放满容量大于0的背包，所以f(0,i)=false</li>
</ol></li>
<li>遍历顺序：先遍历物品再嵌套从头到尾遍历容量</li>
<li>打印dp数组验证与手写稿是否一致</li>
</ol>
<p><strong>空间复杂度优化</strong>：由于求第i行dp数组只需要用到第i-1行dp数组的信息，所以可以使用一维滑动dp数组代替二维dp数组。</p>
<h3 id="剑指offer-1049-最后一块石头的重量-ii"><a href="https://leetcode.cn/problems/last-stone-weight-ii/">剑指Offer 1049 最后一块石头的重量 II</a></h3>
<p><strong>从 stones数组中选择，凑成总和不超过 <span class="math inline">\(sum/2\)</span> 的最大价值</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lastStoneWeightII</span><span class="hljs-params">(<span class="hljs-type">int</span>[] stones)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> Arrays.stream(stones).sum();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> sum / <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// dp[j]:容量为j的背包能装下不超过target的最大价值</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[target + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; stones.length; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> target; j &gt;= stones[i]; --j) &#123;<br>                dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum - dp[target] * <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="一和零"><a href="https://leetcode.cn/problems/ones-and-zeroes/">一和零</a></h3>
<p><strong>背包问题中，weight里的数据不一定要升序！比如weights=[4,1,3]</strong></p>
<h4 id="方法一dp-1">方法一：DP</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMaxForm</span><span class="hljs-params">(String[] strs, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// dp[i][j]:最多有i个0，j个1，最多能选的字符数量</span><br>        <span class="hljs-type">int</span>[][][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[strs.length + <span class="hljs-number">1</span>][m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; k &lt;= strs.length; ++k) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> strs[k - <span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num0</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, num1 = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; x &lt; str.length(); ++x) &#123;<br>                <span class="hljs-keyword">if</span> (str.charAt(x) == <span class="hljs-string">&#x27;0&#x27;</span>)<br>                    ++num0;<br>                <span class="hljs-keyword">else</span> <br>                    ++num1;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= m; ++i) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= n; ++j) &#123;<br>                    <span class="hljs-keyword">if</span> (i &lt; num0 || j &lt; num1)<br>                        dp[k][i][j] = dp[k - <span class="hljs-number">1</span>][i][j];<br>                    <span class="hljs-keyword">else</span> <br>                        dp[k][i][j] = Math.max(dp[k - <span class="hljs-number">1</span>][i][j], dp[k - <span class="hljs-number">1</span>][i - num0][j - num1] + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[strs.length][m][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230516173459566.png" alt="image-20230516173459566" style="zoom:50%;" /></p>
<h4 id="方法二dp滚动数组">方法二：DP+滚动数组</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMaxForm</span><span class="hljs-params">(String[] strs, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// dp[i][j]:最多有i个0，j个1，最多能选的字符数量</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; k &lt;= strs.length; ++k) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> strs[k - <span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num0</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, num1 = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; x &lt; str.length(); ++x) &#123;<br>                <span class="hljs-keyword">if</span> (str.charAt(x) == <span class="hljs-string">&#x27;0&#x27;</span>)<br>                    ++num0;<br>                <span class="hljs-keyword">else</span> <br>                    ++num1;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> m; i &gt;= num0; --i) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> n; j &gt;= num1; --j) &#123;<br>                    dp[i][j] = Math.max(dp[i][j], dp[i - num0][j - num1] + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230516175116922.png" alt="image-20230516175116922" style="zoom:50%;" /></p>
<h3 id="零钱兑换-ii"><a href="https://leetcode.cn/problems/coin-change-ii/">518. 零钱兑换 II</a></h3>
<p>​ 经典完全背包问题，解题步骤如下：</p>
<ol type="1">
<li>dp[j]：背包容量为j时，放满背包的组合方法数</li>
<li>状态转移公式：dp[j] = dp[j] + dp[j - coins[i]]</li>
<li>初始化dp[0]：背包容量为0时，有一种方法放满背包（什么都不放）</li>
<li>遍历顺序：求组合数，先便利物品，再遍历容量</li>
<li>遍历dp数组</li>
</ol>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230318210753861.png" alt="image-20230318210753861" style="zoom:50%;" /></p>
<p><strong>关于组合和排列的理解</strong>：先遍历物品后遍历背包是这样，比如，外层循环固定coins[1]，在内层循环遍历背包时，随着背包不断增加，coins[1]可以重复被添加进来，而由于外层循环固定了，因此coins[2]只能在下一次外层循环添加进不同大小的背包中，这么看的话，coins[i + 1]只能在coins[i]之后了；如果先遍历背包后遍历物品，那么外层循环先固定背包大小j，然后在大小为j的背包中循环遍历添加物品，然后在下次外层循环背包大小变为j+1，此时仍要执行内层循环遍历添加物品，也就会出现在上一轮外层循环中添加coins[2]的基础上还能再添加coins[1]的情况，那么就有了coins[1]在coins[2]之后的情况了(逆序)。</p>
<p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包。</strong></p>
<p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品。</strong></p>
<h3 id="组合总和-ⅳ"><a href="https://leetcode.cn/problems/combination-sum-iv/">377. 组合总和 Ⅳ</a></h3>
<ol type="1">
<li>先举个例子，nums = [1, 2, 3]，target = 35.</li>
<li>假设用1，2，3拼凑出35的总组合个数为y。我们可以考虑三种情况：</li>
<li>（1）有效组合的末尾数字为1，这类组合的个数为 x1。我们把所有该类组合的末尾1去掉，那么不难发现，我们找到了一个子问题，x1即为在[1，2，3]中凑出35 - 1 = 34的总组合个数。因为我如果得到了和为34的所有组合，我只要在所有组合的最后面，拼接一个1，就得到了和为35且最后一个数字为1的组合个数了。</li>
<li>（2）有效组合的末尾数字为2，这类组合的个数为 x2。我们把所有该类组合的末尾2去掉，那么不难发现，我们找到了一个子问题，x2即为在[1，2，3]中凑出35 - 2 = 33的总组合个数。因为我如果得到了和为33的所有组合，我只要在所有组合的最后面，拼接一个2，就得到了和为35且最后一个数字为2的组合个数了。</li>
<li>（3）有效组合的末尾数字为3，这类组合的个数为 x3。我们把所有该类组合的末尾3去掉，那么不难发现，我们找到了一个子问题，x3即为在[1，2，3]中凑出35 - 3 = 32的总组合个数。因为我如果得到了和为32的所有组合，我只要在所有组合的最后面，拼接一个3，就得到了和为35且最后一个数字为3的组合个数了。</li>
<li>这样就简单了，y = x1 + x2 + x3。而x1，x2，x3又可以用同样的办法从子问题得到。状态转移方程get！</li>
</ol>
<p>全排列问题，转化为完全背包问题</p>
<ol type="1">
<li>dp[j]：在背包容量为j时，放满背包的排列数</li>
<li>状态转移公式：dp[j] = dp[j] + dp[j - nums[i]]</li>
<li>初始化dp[0]：在背包容量为0时，放满背包的排列数量为1（什么都不放）</li>
<li>遍历顺序，排列问题，先遍历背包容量(物品可以逆序放入dp[j - nums[i]])，再遍历物品</li>
<li>打印dp数组</li>
</ol>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230318210708505.png" alt="image-20230318210708505" style="zoom:50%;" /></p>
<h3 id="爬楼梯-1"><a href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a></h3>
<p><strong>完全背包</strong> + 全排列问题，可以重复选择放入物品1与物品2，求放满容量为n的背包的排列数</p>
<ol type="1">
<li>dp[j]：在背包容量为j时，放满背包的排列数</li>
<li>状态转移公式：dp[j] = dp[j] + dp[j - nums[i]]</li>
<li>初始化dp[0]：在背包容量为0时，放满背包的排列数量为1（什么都不放）</li>
<li>遍历顺序，排列问题，先遍历背包容量(物品可以逆序放入dp[j - nums[i]])，再遍历物品</li>
<li>打印dp数组</li>
</ol>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230318210647601.png" alt="image-20230318210647601" style="zoom:50%;" /></p>
<h3 id="零钱兑换"><a href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换</a></h3>
<p><strong>完全背包问题</strong></p>
<ol type="1">
<li>dp[j]：背包容量为j时，凑满背包容量所需的<strong>最少硬币数</strong></li>
<li>状态转移公式：dp[j] = min(dp[j], dp[j - coins[i]] + 1)</li>
<li>初始化dp[0]：背包容量为0时，凑满背包容量所需的最少硬币数时0,其他初始化为Integer.MAX_VALUE</li>
<li>遍历顺序，无所谓</li>
<li>打印dp数组</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">coinChange</span><span class="hljs-params">(<span class="hljs-type">int</span>[] coins, <span class="hljs-type">int</span> amount)</span> &#123;<br>        <span class="hljs-comment">// dp[j]: 凑成整数j所需的最少的硬币书</span><br>        <span class="hljs-comment">// 状态转移方程：dp[j] = min(dp[j], dp[j - nums[i] + 1])</span><br>        <span class="hljs-comment">// 初始化：dp[0] = 0,其他初始化为1</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[amount + <span class="hljs-number">1</span>];<br>        Arrays.fill(dp, Integer.MAX_VALUE);<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; coins.length; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> coins[i]; j &lt;= amount; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (dp[j - coins[i]] != Integer.MAX_VALUE)<br>                    dp[j] = Math.min(dp[j], dp[j - coins[i]] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[amount] == Integer.MAX_VALUE ? -<span class="hljs-number">1</span> : dp[amount];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230318210620287.png" alt="image-20230318210620287" style="zoom:50%;" /></p>
<h3 id="完全平方数"><a href="https://leetcode.cn/problems/perfect-squares/">279. 完全平方数</a></h3>
<ol type="1">
<li><p>dp[j]：装满容量为j的背包，至少要放多少个物品</p></li>
<li><p>状态转移公式：dp[j] = min(dp[j], dp[j - weights[i]] + 1)</p></li>
<li><p>初始化dp[0]:装满容量为0的背包，至少放0个物品；其他设为Integet.MAX_VALUE</p></li>
<li><p>遍历顺序：无所谓</p></li>
<li><p>打印dp数组</p></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numSquares</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// 完全背包问题</span><br>        <span class="hljs-comment">// 定义物品的weights数组，先找到小于等于n的最大完全平方数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">max_weight</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(Math.sqrt(n));  <br>        <span class="hljs-type">int</span>[] weights = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[max_weight];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= max_weight; i++)<br>            weights[i-<span class="hljs-number">1</span>] = i*i;    <br>        <span class="hljs-comment">// 1.dp[j]：装满容量为j的背包，至少要放多少个物品</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 2.状态转移公式：dp[j] = min(dp[j], dp[j - weights[i]] + 1)</span><br>        <span class="hljs-comment">// 3.初始化dp[0]:装满容量为0的背包，至少放0个物品；其他设为Integet.MAX_VALUE</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            dp[i] = Integer.MAX_VALUE;<br>        &#125;<br>        <span class="hljs-comment">// 4.遍历顺序：无所谓</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; weights.length; i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> weights[i]; j &lt;= n; j++) &#123;<br>                <span class="hljs-keyword">if</span>(dp[j - weights[i]] != Integer.MAX_VALUE)<br>                    dp[j] = Math.min(dp[j], dp[j - weights[i]] + <span class="hljs-number">1</span>);<br>            &#125;<br>           <span class="hljs-comment">// printDp(dp, i);</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>        <span class="hljs-comment">// 5.打印dp数组</span><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printDp</span><span class="hljs-params">(<span class="hljs-type">int</span>[] dp, <span class="hljs-type">int</span> i)</span> &#123;<br>        System.out.print(i + <span class="hljs-string">&quot;: &quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> maxValue : dp)&#123;<br>            System.out.print(maxValue + <span class="hljs-string">&quot;   &quot;</span>);<br>        &#125;<br>        System.out.println();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="单词拆分"><a href="https://leetcode.cn/problems/word-break/">139. 单词拆分</a></h3>
<p><strong>背包问题</strong> + <strong>排列</strong>(“leetcode”由“leet”与“code”组成但不能反过来由“code”与“leet”组成 )的变种，建议不要完全抽象成背包问题，便于理解</p>
<ol type="1">
<li>dp[j]：长度为j的字符串，<strong>可以被字典中的单词拆分</strong>。</li>
<li>状态转移公式：if([j, i] 这个区间的子串出现在字典里 &amp;&amp; dp[j]是true) 那么 dp[i] = true， 其中j&lt;i。</li>
<li>初始化dp[0]:dp[i]依赖于前面的dp[j]，所以dp[0]要初始化为true，不然全为false</li>
<li>遍历顺序：先遍历背包容量，再嵌套遍历物品</li>
<li>打印dp数组</li>
</ol>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230320095545766.png" alt="image-20230320095545766" style="zoom:50%;" /></p>
<h3 id="打家劫舍"><a href="https://leetcode.cn/problems/house-robber/">198. 打家劫舍</a></h3>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230327183302703.png" alt="image-20230327183302703" style="zoom:50%;" /></p>
<ol type="1">
<li>dp[j]：偷窃从标号为0到j的房屋所能获得的最大价值</li>
<li>状态转移公式：dp[j] = max(dp[j - 1], dp[j - 2] + nums[j])</li>
<li>初始化：dp[0] = nums[0], dp[1] = max(nums[0], nums[1])</li>
<li>遍历顺序：单序列问题,dp[i] 是根据dp[i - 2] 和 dp[i - 1] 推导出来的，那么一定是从前到后遍历！</li>
<li>遍历dp数组</li>
</ol>
<h4 id="优化空间复杂度">优化空间复杂度</h4>
<p>根据状态转移公式dp[j] = max(dp[j - 1], dp[j - 2] + nums[j])，dp[j]只需要dp[j-1]以及dp[j-2]两个变量即可，可以把数组大小压缩到2。</p>
<h3 id="打家劫舍-ii"><a href="https://leetcode.cn/problems/house-robber-ii/">213. 打家劫舍 II</a></h3>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230328192555408.png" alt="image-20230328192555408" style="zoom:50%;" /></p>
<h3 id="分割等和子集"><a href="https://leetcode.cn/problems/partition-equal-subset-sum/">416. 分割等和子集</a></h3>
<ol type="1">
<li>dp[j]：背包容量为j时，是否能用物品装满</li>
<li>状态转移方程：dp[j] = dp[j] || dp[j - nums[i]]</li>
<li>初始化：背包容量为0时，不把物品装进去即可装满，dp[0] = true</li>
<li>遍历顺序：一维滑动数组，零一背包，先遍历物品后遍历背包容量</li>
</ol>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230328164702918.png" alt="image-20230328164702918" style="zoom:50%;" /></p>
<h3 id="打家劫舍-iii"><a href="https://leetcode.cn/problems/house-robber-iii/">337. 打家劫舍 III</a></h3>
<h4 id="方法一hashmap">方法一：HashMap</h4>
<p>f：偷当前房屋能获得的最大价值；g：不偷当前房屋能获得的最大价值</p>
<ol type="1">
<li>偷当前房屋f(cur) = cur.val + g(cur.left) + g(cur.right)</li>
<li>不偷当前房屋g(cur) = max(f(cur.left), g(cur.left)) + max(f(cur.right), g(cur.right))</li>
</ol>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230329142700228.png" alt="image-20230329142700228" style="zoom:50%;" /></p>
<h4 id="方法二morris-hashmap">方法二：Morris + HashMap</h4>
<p><strong>当作是练习题了！！</strong></p>
<p><strong>注意事项：</strong>在访问的时候，此时需要cur.right，而这个时候已经是逆序过的，cur.right实际上指向的是自己的父节点，所以再用一个hashmap存储cur真正的右节点（或者再逆序一遍）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    Map&lt;TreeNode, Integer&gt; f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    Map&lt;TreeNode, Integer&gt; g = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    Map&lt;TreeNode, TreeNode&gt; right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-comment">// f:偷当前节点能获得的最大价值</span><br>        <span class="hljs-comment">// g:不偷当前节点能获得的最大价值</span><br>       <span class="hljs-comment">//  f(cur) = cur.val + g(cur.left) + g(cur.right)</span><br>       <span class="hljs-comment">//  g(cur) = max(f(cur.left), g(cur.left)) + max(f(cur.right), g(cur.right))</span><br>       <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root, mostRight = <span class="hljs-literal">null</span>;<br>       <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>           mostRight = cur.left;<br>           <span class="hljs-keyword">if</span> (mostRight != <span class="hljs-literal">null</span>) &#123;<br>               <span class="hljs-keyword">while</span> (mostRight.right != <span class="hljs-literal">null</span> &amp;&amp; mostRight.right != cur)<br>                    mostRight = mostRight.right;<br>                <span class="hljs-keyword">if</span> (mostRight.right == <span class="hljs-literal">null</span>) &#123;<br>                    mostRight.right = cur;<br>                    cur = cur.left;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// mostRight.right = cur</span><br>                    mostRight.right = <span class="hljs-literal">null</span>;<br>                    visit(cur.left);<br>                &#125;<br>           &#125;<br>           cur = cur.right;<br>       &#125;<br>       visit(root);<br>       <span class="hljs-keyword">return</span> Math.max(f.getOrDefault(root, <span class="hljs-number">0</span>), g.getOrDefault(root, <span class="hljs-number">0</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(TreeNode cur)</span> &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">tail</span> <span class="hljs-operator">=</span> reverse(cur);<br>        cur = tail;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            f.put(cur, cur.val + g.getOrDefault(cur.left, <span class="hljs-number">0</span>) + g.getOrDefault(right.get(cur), <span class="hljs-number">0</span>));<br>            <span class="hljs-type">int</span> <span class="hljs-variable">maxLeft</span> <span class="hljs-operator">=</span> Math.max(f.getOrDefault(cur.left, <span class="hljs-number">0</span>), g.getOrDefault(cur.left, <span class="hljs-number">0</span>));<br>            <span class="hljs-type">int</span> <span class="hljs-variable">maxRight</span> <span class="hljs-operator">=</span> Math.max(f.getOrDefault(right.get(cur), <span class="hljs-number">0</span>), g.getOrDefault(right.get(cur), <span class="hljs-number">0</span>));<br>            g.put(cur, maxLeft + maxRight);<br>            <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-literal">null</span>) <br>                right.put(cur.right, cur);<br>            cur = cur.right;<br>        &#125;<br>        reverse(tail);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> TreeNode <span class="hljs-title function_">reverse</span><span class="hljs-params">(TreeNode cur)</span> &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> cur.right;<br>            cur.right = pre;<br>            pre = cur;<br>            cur = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230417165305163.png" alt="image-20230417165305163" style="zoom:50%;" /></p>
<h3 id="买卖股票的最佳时机"><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h3>
<h4 id="你根本没在dp">你根本没在dp！</h4>
<h4 id="方法一暴力迭代">方法一：暴力迭代</h4>
<p>超时咯</p>
<figure>
<img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230330094627247.png" alt="image-20230330094627247" /><figcaption aria-hidden="true">image-20230330094627247</figcaption>
</figure>
<h4 id="方法二贪心">方法二：贪心</h4>
<p>从前往后遍历，使用minPrice记录最小值，使用maxProfit记录最大收益</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230330101656109.png" alt="image-20230330101656109" style="zoom:50%;" /></p>
<h4 id="方法三dp">方法三：DP</h4>
<p><strong>DP数组的定义十分重要！</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> prices.length;<br>        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span> || prices == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 1.dp[0][j]:第j天持有股票(之前买入或者当前买入)所拥有的最大价值，dp[1][j]：第j天不持有股票(之前卖出或者当前卖出)所拥有的最大价值</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>][len];<br>        <span class="hljs-comment">// 2.状态转移方程：dp[0][j] = max(dp[0][j-1], -price[j]); dp[1][j] = max(dp[1][j-1], price[j] + dp[0][j - 1])</span><br>        <span class="hljs-comment">// 3.初始化：dp[0][0]必须买入，初始化为-price[0]；dp[1][0]不能卖出任何股票，初始化为0</span><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">// 4.遍历顺序：dp[j]由dp[j-1]决定，所以从前往后遍历</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; len; ++j) &#123;<br>            dp[<span class="hljs-number">0</span>][j] = Math.max(dp[<span class="hljs-number">0</span>][j - <span class="hljs-number">1</span>], -prices[j]);<br>            dp[<span class="hljs-number">1</span>][j] = Math.max(dp[<span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>], prices[j] + dp[<span class="hljs-number">0</span>][j - <span class="hljs-number">1</span>]); <span class="hljs-comment">// 不能当天买入当天卖出所以是dp[0][j - 1]</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">1</span>][len - <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 5.打印dp数组</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230330105858903.png" alt="image-20230330105858903" style="zoom:50%;" /></p>
<h3 id="买卖股票的最佳时机-ii"><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-comment">// 1.dp[0][j]:在第j天持有(之前买入，当前买入)股票时拥有的最大现金;dp[1][j]在第j天不持有(之前卖出，当前卖出)股票拥有的最大现金</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> prices.length;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>][len];<br>        <span class="hljs-comment">// 2.状态转移方程：dp[0][j] = max(dp[0][j - 1], dp[1][j - 1] - price[j]); dp[1][j] = max(dp[1][j - 1], dp[0][j - 1] + price[j])</span><br>        <span class="hljs-comment">// 3.初始化：dp[0][0] = -price[0];dp[1][0] = 0;可以当天出售</span><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">// 4.遍历顺序</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; len; ++j) &#123;<br>            dp[<span class="hljs-number">0</span>][j] = Math.max(dp[<span class="hljs-number">0</span>][j - <span class="hljs-number">1</span>], dp[<span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] - prices[j]);<br>            dp[<span class="hljs-number">1</span>][j] = Math.max(dp[<span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>], dp[<span class="hljs-number">0</span>][j - <span class="hljs-number">1</span>] + prices[j]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">1</span>][len - <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 5.打印dp数组</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230330112546180.png" alt="image-20230330112546180" style="zoom:50%;" /></p>
<h3 id="不同的二叉搜索树"><a href="https://leetcode.cn/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= i; ++j) &#123;<br>                dp[i] += dp[j - <span class="hljs-number">1</span>] * dp[i - j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230418104137551.png" alt="image-20230418104137551" style="zoom:50%;" /></p>
<h4 id="优化空间..">优化空间..</h4>
<h3 id="买卖股票的最佳时机-iii"><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">123. 买卖股票的最佳时机 III</a></h3>
<h3 id="二叉树中的最长交错路径"><a href="https://leetcode.cn/problems/longest-zigzag-path-in-a-binary-tree/">1372. 二叉树中的最长交错路径</a></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>        <span class="hljs-comment">// f(cur)：以cur结尾，且cur是左子树的最大长度</span><br>        <span class="hljs-comment">// g(cur)：以cur结尾，且cur是右子树的最大长度</span><br>        Map&lt;TreeNode, Integer&gt; f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Map&lt;TreeNode, Integer&gt; g = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Queue&lt;TreeNode[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestZigZag</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-comment">// f.put(root, 0);</span><br>        <span class="hljs-comment">// g.put(root, 0);</span><br>        queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>[]&#123;root, <span class="hljs-literal">null</span>&#125;);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            TreeNode[] sonFather = queue.poll();<br>            f.put(sonFather[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>);<br>            g.put(sonFather[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">if</span>(sonFather[<span class="hljs-number">1</span>] != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (sonFather[<span class="hljs-number">1</span>].left == sonFather[<span class="hljs-number">0</span>])<br>                    f.put(sonFather[<span class="hljs-number">0</span>], g.get(sonFather[<span class="hljs-number">1</span>]) + <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span> (sonFather[<span class="hljs-number">1</span>].right == sonFather[<span class="hljs-number">0</span>])<br>                    g.put(sonFather[<span class="hljs-number">0</span>], f.get(sonFather[<span class="hljs-number">1</span>]) + <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (sonFather[<span class="hljs-number">0</span>].left != <span class="hljs-literal">null</span>) <br>                queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>[]&#123;sonFather[<span class="hljs-number">0</span>].left, sonFather[<span class="hljs-number">0</span>]&#125;);<br>            <span class="hljs-keyword">if</span> (sonFather[<span class="hljs-number">0</span>].right != <span class="hljs-literal">null</span>) <br>                queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>[]&#123;sonFather[<span class="hljs-number">0</span>].right, sonFather[<span class="hljs-number">0</span>]&#125;);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>        <span class="hljs-keyword">for</span> (TreeNode node : f.keySet()) &#123;<br>            max = Math.max(max, Math.max(f.get(node), g.get(node)));<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230418131120198.png" alt=" " style="zoom:50%;" /></p>
<h3 id="最长递增子序列"><a href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></h3>
<ol type="1">
<li>dp[i]：以nums[i]结尾的最长递增子序列的长度</li>
<li>从前往后，在i的左开区间进行比较所有的j(j &lt; i)，如果nums[j]&lt;nums[i]，那么dp[i] = max(dp[i], dp[j] + 1)</li>
<li>初始化：令dp数组所有元素为1，最短序列是本身</li>
<li>遍历顺序：第二层从前往后，从后往前都可以，只要把i之前的元素全部遍历了就行</li>
<li>要注意的是，要输出的答案不是dp[dp.length-1]，而是dp数组中的最大值，比如序列为01234512，输出的是结果是dp[5]；所以可以用一个全局变量记录dp数组中的最大值</li>
<li>时间复杂度：<span class="math inline">\(O(n^2)\)</span></li>
<li>空间复杂度：<span class="math inline">\(O(n)\)</span></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Arrays.fill(dp, <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxLenOfSubsequence</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (nums[i] &gt; nums[j]) &#123;<br>                    dp[i] = Math.max(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>            maxLenOfSubsequence = Math.max(maxLenOfSubsequence, dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxLenOfSubsequence;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230418142354562.png" alt="image-20230418142354562" style="zoom:50%;" /></p>
<h3 id="最长连续递增序列"><a href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/">674. 最长连续递增序列</a></h3>
<h4 id="方法一dp-2">方法一：DP</h4>
<ol type="1">
<li>dp[i]：以nums[i]结尾的最长连续递增子序列的长度</li>
<li>当当前数字nums[i]大于nums[i-1]，令dp[i] = dp[i - 1] + 1</li>
<li>初始化：令dp数组所有元素为1，最短序列是本身</li>
<li>时间复杂度：<span class="math inline">\(O(n)\)</span></li>
<li>空间复杂度：<span class="math inline">\(O(n)\)</span></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findLengthOfLCIS</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Arrays.fill(dp, <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxLength</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; nums[i - <span class="hljs-number">1</span>]) &#123;<br>                dp[i] = dp[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            &#125;<br>            maxLength = Math.max(maxLength, dp[i]);<br>        &#125;<br>        <span class="hljs-comment">// for (int i = 0; i &lt; dp.length; ++i) &#123;</span><br>        <span class="hljs-comment">//     System.out.print(dp[i] + &quot; &quot;);</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-keyword">return</span> maxLength;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230418144730307.png" alt="image-20230418144730307" style="zoom:50%;" /></p>
<h4 id="方法二dp-滑动数组">方法二：DP + 滑动数组</h4>
<p><strong>注意：当nums[i] &lt;= nums[i - 1]时，需要把dp[i%2]重置为1</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findLengthOfLCIS</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>        Arrays.fill(dp, <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxLength</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; nums[i - <span class="hljs-number">1</span>]) &#123;<br>                dp[i % <span class="hljs-number">2</span>] = dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>] + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                dp[i % <span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;<br>            &#125;<br>            maxLength = Math.max(maxLength, dp[i % <span class="hljs-number">2</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxLength;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230430213308440.png" alt="image-20230430213308440" style="zoom:50%;" /></p>
<h3 id="最长重复子数组warning"><a href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/">718. 最长重复子数组</a>:warning:</h3>
<h4 id="方法一暴力">方法一：暴力</h4>
<ol type="1">
<li>时间复杂度：<span class="math inline">\(O(m^2n)\)</span></li>
<li>空间复杂度：<span class="math inline">\(O(1)\)</span></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findLength</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums1.length; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; nums2.length; ++j) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">count1</span> <span class="hljs-operator">=</span> i, count2 = j;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">while</span> (count1 &lt; nums1.length &amp;&amp; count2 &lt; nums2.length &amp;&amp; nums1[count1] == nums2[count2]) &#123;<br>                    ++counter;<br>                    ++count1;<br>                    ++count2;<br>                &#125;<br>                res = Math.max(res, counter);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230418155756679.png" alt="image-20230418155756679" style="zoom:50%;" /></p>
<h4 id="方法二dp">方法二：DP</h4>
<ol type="1">
<li>dp[i][j]:以nums1[i - 1]结尾与以nums2[j - 1]结尾时的最长重复子数组</li>
<li>状态转移公式：当nums1[i - 1] == nums2[j - 1]时，dp[i][j] = dp[i - 1][j - 1] + 1<br />
</li>
<li>初始化：m为nums1的长度，n为nums2的长度，初始化(m + 1) * (n + 1)的二维数组，第一行第一列初始化为0，因为任一数组为空，就不会有重复子数组</li>
<li>注意事项：输出结果是dp数组中的最大值，因为最长的重复子数组不一定是在两数组的结尾处，可以在循环内比较</li>
<li>时间复杂度：<span class="math inline">\(O(mn)\)</span></li>
<li>空间复杂度：<span class="math inline">\(O(mn)\)</span></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findLength</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> nums1.length, n = nums2.length;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (nums1[i - <span class="hljs-number">1</span>] == nums2[j - <span class="hljs-number">1</span>]) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                    result = Math.max(result, dp[i][j]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230418164535723.png" alt="image-20230418164535723" style="zoom:50%;" /></p>
<p>滚动数组缩减空间复杂度</p>
<ol type="1">
<li><p>dp数组为第二个数组的长度加一</p></li>
<li><p>不相等时要把dp[j]赋0，不然之后会出错</p></li>
<li><p><strong>此时遍历第二个数组的时候，就要从后向前遍历，这样避免重复覆盖</strong>。</p>
<p>比如nums1 = [1, 2, 3, 1],nums2 = [1,6,8,1,3,1,2,3]</p>
<p>i = 1时候，dp数组为[1,0,0,1,0,1,0,0]</p>
<p>i = 2时候，dp数组为[0,0,0,0,0,0,1,0]</p>
<p>i = 3时候，dp数组为[0,0,0,0,1,0,0,2]</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230418180633319.png" alt="image-20230418180633319" style="zoom:50%;" /></p>
<p>i=3时，如果第二层for循环j从前往后遍历，那么dp倒数第二个位置会因为3!=2，被赋0，进而导致dp最后一个位置是1而不是2</p></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findLength</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums2.length + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= nums1.length; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> nums2.length; j &gt; <span class="hljs-number">0</span>; --j) &#123;<br>                <span class="hljs-keyword">if</span> (nums1[i - <span class="hljs-number">1</span>] == nums2[j - <span class="hljs-number">1</span>]) &#123;<br>                    dp[j] = dp[j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    dp[j] = <span class="hljs-number">0</span>;<br>                &#125;<br>                res = Math.max(res, dp[j]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230418175604367.png" alt="image-20230418175604367" style="zoom:50%;" /></p>
<h4 id="方法三滑动窗口">方法三：滑动窗口</h4>
<h3 id="不同路径"><a href="https://leetcode.cn/problems/unique-paths/">62. 不同路径</a></h3>
<h4 id="方法一dp-omn">方法一：DP O(mn)</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// dp[i][j]:走到i,j位置的路径数</span><br>        <span class="hljs-comment">// 状态转移方程：dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>            dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; ++j) &#123;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125; <br>        <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230515153943754.png" alt="image-20230515153943754" style="zoom:50%;" /></p>
<h4 id="方法二dp滚动数组-on-2行">方法二：DP+滚动数组 O(n) 2行</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// dp[i][j]:走到i,j位置的路径数</span><br>        <span class="hljs-comment">// 状态转移方程：dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; ++i) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>            dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; ++j) &#123;<br>                dp[i % <span class="hljs-number">2</span>][j] = dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][j] + dp[i % <span class="hljs-number">2</span>][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125; <br>        <span class="hljs-keyword">return</span> dp[(m - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;	<br></code></pre></td></tr></table></figure>
<h4 id="方法三dp滚动数组-on-1行">方法三：DP+滚动数组 O(n) 1行</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// dp[i][j]:走到i,j位置的路径数</span><br>        <span class="hljs-comment">// 状态转移方程：dp[j] = dp[j] + dp[j - 1]</span><br>        <span class="hljs-comment">// 初始化：全部初始化为1</span><br>        <span class="hljs-comment">// 遍历顺序：dp[j]依赖dp[j - 1]，所以从左往右遍历</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Arrays.fill(dp, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; ++j) &#123;<br>                dp[j] += dp[j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125; <br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230515161257738.png" alt="image-20230515161257738" style="zoom:50%;" /></p>
<h3 id="不同路径-ii"><a href="https://leetcode.cn/problems/unique-paths-ii/">63. 不同路径 II</a></h3>
<h4 id="方法一dp-3">方法一：DP</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePathsWithObstacles</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] obstacleGrid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> obstacleGrid.length, n = obstacleGrid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (obstacleGrid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j)  &#123;<br>            <span class="hljs-keyword">if</span> (obstacleGrid[<span class="hljs-number">0</span>][j] == <span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">break</span>;<br>            dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (obstacleGrid[i][j] == <span class="hljs-number">1</span>)<br>                    <span class="hljs-keyword">continue</span>;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230515163651187.png" alt="image-20230515163651187" style="zoom:50%;" /></p>
<h3 id="整数拆分warning"><a href="https://leetcode.cn/problems/integer-break/">343. 整数拆分</a>:warning:</h3>
<h4 id="方法一dp-4">方法一：DP</h4>
<figure>
<img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230515170354808.png" alt="image-20230515170354808" /><figcaption aria-hidden="true">image-20230515170354808</figcaption>
</figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">integerBreak</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// dp[j]:j拆分为多个数的最大乘积</span><br>    <br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; i; ++j) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i - j;<br>                dp[i] = Math.max(dp[i], Math.max(k * j, dp[k] * j));<br>            &#125;        <br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230515170235440.png" alt="image-20230515170235440" style="zoom:50%;" />　　</p>
<h3 id="不同的二叉搜索树warning"><a href="https://leetcode.cn/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a>:warning:</h3>
<h3 id="剑指-offer-ii-102.-加减的目标值"><a href="https://leetcode.cn/problems/YaVDxD/">剑指 Offer II 102. 加减的目标值</a></h3>
<h4 id="方法一dp-5">方法一：DP</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findTargetSumWays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> Arrays.stream(nums).sum();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">diff</span> <span class="hljs-operator">=</span> sum - target;<br>        <span class="hljs-keyword">if</span> (diff % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> || diff &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        target = diff / <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// dp[j]:装满容量为j的方法数</span><br>        <span class="hljs-comment">// dp[0] = 1,装满容量为0的背包有一种</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[target + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> target; j &gt;= nums[i]; --j) &#123;<br>                dp[j] += dp[j - nums[i]];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[target];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230516155420333.png" alt="image-20230516155420333" style="zoom:50%;" /></p>
<h3 id="树形dp">树形DP</h3>
<p><a href="https://www.bilibili.com/video/BV13g41157hK?p=15&amp;vd_source=d0a01265c4f3d5026b4e06c76cce4fe9">左神shi'p</a></p>
<h4 id="树形dp题目">树形DP题目</h4>
<p><a href="https://www.luogu.com.cn/problem/P1352#submit">没有上司的舞会</a></p>
<p><a href="https://leetcode.cn/problems/house-robber-iii/">337. 打家劫舍 III</a></p>
<p><a href="https://leetcode.cn/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a></p>
<p><a href="https://leetcode.cn/problems/longest-zigzag-path-in-a-binary-tree/">1372. 二叉树中的最长交错路径</a></p>
<h2 id="binary-tree">Binary Tree</h2>
<h3 id="二叉树的前序遍历"><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></h3>
<h4 id="方法一递归">方法一：递归</h4>
<p>假设树上一共有<em>n</em> 个节点。</p>
<p><strong>时间复杂度</strong>：遍历了整棵树，<span class="math inline">\(O(n)\)</span></p>
<p><strong>空间复杂度</strong>：和递归使用的栈大小相关，递归层数不超过n(一叉树)，<span class="math inline">\(O(n)\)</span></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        dfs(root, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; result)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span>;<br>        result.add(root.val);<br>        dfs(root.left, result);<br>        dfs(root.right, result);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230417103559244.png" alt="image-20230417103559244" style="zoom:50%;" /></p>
<h4 id="方法二非递归">方法二：非递归</h4>
<p>假设树上一共有<em>n</em> 个节点。</p>
<p><strong>时间复杂度</strong>：遍历了整棵树，<span class="math inline">\(O(n)\)</span></p>
<p><strong>空间复杂度</strong>：和递归使用的栈大小相关，递归层数不超过n(一叉树)，<span class="math inline">\(O(n)\)</span></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span> || !stack.isEmpty()) &#123;<br>            <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>                result.add(cur.val);<br>                stack.push(cur);<br>                cur = cur.left;<br>            &#125;<br>            cur = stack.pop();<br>            cur = cur.right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230417104835424.png" alt="image-20230417104835424" style="zoom:50%;" /></p>
<h4 id="方法三morris前序遍历">方法三：Morris前序遍历</h4>
<p>morris遍历利用树的大量空闲指针，实现空间开销的极限缩减。</p>
<p><strong>时间复杂度</strong>：<span class="math inline">\(O(n)\)</span>，其中n是二叉树的节点数。没有左子树的节点只被访问一次，有左子树的节点被访问两次</p>
<p><strong>空间复杂度</strong>：<span class="math inline">\(O(1)\)</span>，只操作已存在的指针（树的空闲指针），因此只需要常数的额外空间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root, mostRight = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            mostRight = cur.left;<br>            <span class="hljs-keyword">if</span> (mostRight != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">while</span> (mostRight.right != <span class="hljs-literal">null</span> &amp;&amp; mostRight.right != cur) <br>                    mostRight = mostRight.right;<br>                <span class="hljs-keyword">if</span> (mostRight.right == <span class="hljs-literal">null</span>) &#123;<br>                    result.add(cur.val);<br>                    mostRight.right = cur;<br>                    cur = cur.left;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// mostRight.right == cur</span><br>                    mostRight.right = <span class="hljs-literal">null</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// cur.left == null</span><br>                result.add(cur.val);<br>            &#125;<br>            cur = cur.right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230417105948516.png" alt="image-20230417105948516" style="zoom:50%;" /></p>
<h3 id="二叉树的中序遍历"><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h3>
<h4 id="方法一递归-1">方法一：递归</h4>
<p><strong>时间复杂度</strong>：<span class="math inline">\(O(n)\)</span>，其中n为树的节点数</p>
<p><strong>空间复杂度</strong>：<span class="math inline">\(O(n)\)</span>，和递归使用的栈大小相关，递归层数不超过n(一叉树)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        dfs(root, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; result)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">null</span>) &#123;<br>            dfs(root.left, result);<br>            result.add(root.val);<br>            dfs(root.right, result);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230417111200608.png" alt="image-20230417111200608" style="zoom:50%;" /></p>
<h4 id="方法二非递归-1">方法二：非递归</h4>
<p><strong>时间复杂度</strong>：<span class="math inline">\(O(n)\)</span>，其中n为树的节点数</p>
<p><strong>空间复杂度</strong>：<span class="math inline">\(O(n)\)</span>，和递归使用的栈大小相关，递归层数不超过n(一叉树)</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span> || !stack.isEmpty()) &#123;<br>            <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>                stack.push(cur);<br>                cur = cur.left;<br>            &#125;<br>            cur = stack.pop();<br>            res.add(cur.val);<br>            cur = cur.right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230417111602240.png" alt="image-20230417111602240" style="zoom:50%;" /></p>
<h4 id="方法三morris中序遍历">方法三：Morris中序遍历</h4>
<p>morris遍历利用树的大量空闲指针，实现空间开销的极限缩减。</p>
<p><strong>时间复杂度</strong>：<span class="math inline">\(O(n)\)</span>，其中n是二叉树的节点数。没有左子树的节点只被访问一次，有左子树的节点被访问两次</p>
<p><strong>空间复杂度</strong>：<span class="math inline">\(O(1)\)</span>，只操作已存在的指针（树的空闲指针），因此只需要常数的额外空间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root, mostRight = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            mostRight = cur.left;<br>            <span class="hljs-keyword">if</span> (mostRight != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">while</span> (mostRight.right != <span class="hljs-literal">null</span> &amp;&amp; mostRight.right != cur)<br>                    mostRight = mostRight.right;<br>                <span class="hljs-keyword">if</span> (mostRight.right == <span class="hljs-literal">null</span>) &#123;<br>                    mostRight.right = cur;<br>                    cur = cur.left;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// mostRight == cur</span><br>                    mostRight.right = <span class="hljs-literal">null</span>;<br>                &#125;<br>            &#125;<br>            res.add(cur.val);<br>            cur = cur.right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="二叉树的后序遍历"><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></h3>
<h4 id="方法一递归-2">方法一：递归</h4>
<h4 id="方法二非递归-2">方法二：非递归</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">postorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root, pre = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span> || !stack.isEmpty()) &#123;<br>            <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>                stack.push(cur);<br>                cur = cur.left;<br>            &#125;<br>            cur = stack.peek();<br>            <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-literal">null</span> &amp;&amp; cur.right != pre) &#123;<br>                cur = cur.right;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                stack.pop();<br>                res.add(cur.val);<br>                pre = cur;<br>                cur = <span class="hljs-literal">null</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230417114718154.png" alt="image-20230417114718154" style="zoom:50%;" /></p>
<h4 id="方法三morris后序遍历">方法三：Morris后序遍历</h4>
<p><strong>时间复杂度</strong>：<span class="math inline">\(O(n)\)</span>，其中n为树的节点数</p>
<p><strong>空间复杂度</strong>：<span class="math inline">\(O(n)\)</span>，和递归使用的栈大小相关，递归层数不超过n(一叉树)</p>
<ol type="1">
<li>如果可以到达一个节点两次(有左子树)，第二次逆序打印左子树上的右边界</li>
<li>最后走出循环后，逆序打印根节点的右边界</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">postorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root, mostRight = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            mostRight = cur.left;<br>            <span class="hljs-keyword">if</span> (mostRight != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">while</span> (mostRight.right != <span class="hljs-literal">null</span> &amp;&amp; mostRight.right != cur)<br>                    mostRight = mostRight.right;<br>                <span class="hljs-keyword">if</span> (mostRight.right == <span class="hljs-literal">null</span>) &#123;<br>                    mostRight.right = cur;<br>                    cur = cur.left;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// mostRight.right = cur</span><br>                    mostRight.right = <span class="hljs-literal">null</span>;<br>                    visit(cur.left, res);<br>                &#125;<br>            &#125;<br>            cur = cur.right;<br>        &#125;<br>        visit(root, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(TreeNode cur, List&lt;Integer&gt; res)</span> &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">tail</span> <span class="hljs-operator">=</span> reverse(cur);<br>        cur = tail;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            res.add(cur.val);<br>            cur = cur.right;<br>        &#125;<br>        reverse(tail);<br>    &#125;<br>    <span class="hljs-keyword">private</span> TreeNode <span class="hljs-title function_">reverse</span><span class="hljs-params">(TreeNode cur)</span> &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> cur.right;<br>            cur.right = pre;<br>            pre = cur;<br>            cur = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230417121837135.png" alt="image-20230417121837135" style="zoom:50%;" /></p>
<h3 id="二叉树的层序遍历"><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h3>
<p>借助队列实现，<strong>关键在于通过queue.size来判断下一层的节点数！</strong></p>
<p><em>Queue.offer(null)的话，size为1！</em></p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230320152504462.png" alt="image-20230320152504462" style="zoom:50%;" /></p>
<h3 id="翻转二叉树"><a href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树</a></h3>
<p>这道题目背后有一个让程序员心酸的故事，听说 Homebrew的作者Max Howell，就是因为没在白板上写出翻转二叉树，最后被Google拒绝了。（真假不做判断，权当一个乐子哈）</p>
<p>要求：左右子树交换位置</p>
<h4 id="方法一bfs层级遍历">方法一：<strong>bfs层级遍历</strong></h4>
<p><strong>时间复杂度</strong>：所有节点都需要入队，出队一次，所以是<span class="math inline">\(O(n)\)</span></p>
<p><strong>空间复杂度</strong>：在最坏的情况下，给定的树是满二叉树，所有叶节点(<span class="math inline">\(n/2 + 1\)</span>)都要入队，所以是<span class="math inline">\(O(n)\)</span></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">invertTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> root;<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.offer(root);<br>        TreeNode cur;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            cur = queue.poll();<br>            reverse(cur);   <br>            <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-literal">null</span>)<br>                queue.offer(cur.left);<br>            <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-literal">null</span>)<br>                queue.offer(cur.right); <br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(TreeNode cur)</span> &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> cur.left;<br>        cur.left = cur.right;<br>        cur.right = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230320161332491.png" alt="image-20230320161332491" style="zoom:50%;" /></p>
<h4 id="方法二dfs">方法二：dfs</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">invertTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-comment">// 反转所有左子树和右子树，对这棵树的所有节点</span><br>        dfs(root);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125; <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span>;<br>        dfs(root.left);<br>        dfs(root.right);<br>        reverse(root);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> root.left;<br>        root.left = root.right;<br>        root.right = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230419090018170.png" alt="image-20230419090018170" style="zoom:50%;" /></p>
<h3 id="对称二叉树"><a href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树</a></h3>
<h4 id="方法一拷贝翻转判断高情商刷一道解三道低情商只会笨方法还是看看远方的复杂度吧">方法一：拷贝+翻转+判断(高情商：刷一道，解三道！低情商：只会笨方法？还是看看远方的复杂度吧)</h4>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230321093745686.png" alt="image-20230321093745686" style="zoom:50%;" /> 写了80行，一题三解！不分析复杂度了。。</p>
<h4 id="方法二bfs">方法二：BFS</h4>
<p>假设树上一共有<em>n</em> 个节点。</p>
<p><strong>时间复杂度</strong>：遍历了整棵树，<span class="math inline">\(O(n)\)</span></p>
<p><strong>空间复杂度</strong>：和使用的队列大小相关，在最坏的情况下，给定的树是满二叉树，所有叶节点(<span class="math inline">\(n/2 + 1\)</span>)都要入队，所以是<span class="math inline">\(O(n)\)</span></p>
<p><strong>注意：</strong>如果p,q都为空，continue！而不是return truel！！！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.offer(root.left);<br>        queue.offer(root.right);<br>        TreeNode p, q;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            p = queue.poll();<br>            q = queue.poll();<br>            <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span> &amp;&amp; q == <span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span> || q == <span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span> (p.val != q.val) <br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            queue.offer(p.left);<br>            queue.offer(q.right);<br>            queue.offer(p.right);<br>            queue.offer(q.left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230419101818857.png" alt="image-20230419101818857" style="zoom:50%;" /></p>
<h4 id="方法三dfs">方法三：DFS</h4>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230321100900158.png" alt="image-20230321100900158" style="zoom:50%;" /> YYDS</p>
<p>假设树上一共有<em>n</em> 个节点。</p>
<p><strong>时间复杂度</strong>：遍历了整棵树，<span class="math inline">\(O(n)\)</span></p>
<p><strong>空间复杂度</strong>：和递归使用的栈大小相关，递归层数不超过n(一叉树)，<span class="math inline">\(O(n)\)</span></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">return</span> dfs(root.left, root.right);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode left, TreeNode right)</span> &#123;<br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">null</span> &amp;&amp; right == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">null</span> || right == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> (left.val == right.val) &amp;&amp; dfs(left.left, right.right) &amp;&amp; dfs(left.right, right.left);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="相同的树"><a href="https://leetcode.cn/problems/same-tree/">100. 相同的树</a></h3>
<p><strong>对称二叉树</strong>方法一中用到了这个笨方法，顺手做了吧。</p>
<h4 id="方法一dfs">方法一：DFS</h4>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230321102148975.png" alt="image-20230321102148975" style="zoom:50%;" /></p>
<p>假设树上一共有<span class="math inline">\(n\)</span>个节点</p>
<p><strong>时间复杂度</strong>：遍历了整棵树，<span class="math inline">\(O(n)\)</span></p>
<p><strong>空间复杂度</strong>：和递归使用的栈大小相关，递归层数不超过n，<span class="math inline">\(O(n)\)</span></p>
<h4 id="方法二bfs-1">方法二：BFS</h4>
<p>只是和<strong>对称二叉树</strong>BFS解法中的入队顺序改变一点。</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230321103126806.png" alt="image-20230321103126806" style="zoom:50%;" /></p>
<p>假设树上一共有<em>n</em> 个节点。</p>
<p><strong>时间复杂度</strong>：遍历了整棵树，<span class="math inline">\(O(n)\)</span></p>
<p><strong>空间复杂度</strong>：和使用的队列大小相关，在最坏的情况下，给定的树是满二叉树，所有叶节点(<span class="math inline">\(n/2 + 1\)</span>)都要入队，所以是<span class="math inline">\(O(n)\)</span></p>
<h3 id="二叉树的最大深度"><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h3>
<h4 id="方法一bfs">方法一：BFS</h4>
<ol type="1">
<li><strong>时间复杂度</strong>：遍历整棵树，<span class="math inline">\(O(n)\)</span></li>
<li><strong>空间复杂度</strong>：和使用的队列大小相关，在最坏情况下，给定的二叉树是满二叉树，<span class="math inline">\(n/2 + 1\)</span>个叶节点要入队，所以是<span class="math inline">\(O(n)\)</span></li>
</ol>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230321110400024.png" alt="image-20230321110400024" style="zoom:50%;" /></p>
<h4 id="方法二dfs-1">方法二：DFS</h4>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230321111653023.png" alt="image-20230321111653023" style="zoom:50%;" /></p>
<p>假设树上一共有<span class="math inline">\(n\)</span>个节点</p>
<p><strong>时间复杂度</strong>：遍历了整棵树，<span class="math inline">\(O(n)\)</span></p>
<p><strong>空间复杂度</strong>：和递归使用的栈大小相关，递归层数不超过n，<span class="math inline">\(O(n)\)</span></p>
<h3 id="n-叉树的最大深度"><a href="https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/">559. N 叉树的最大深度</a></h3>
<p>同上题<strong>二叉树的最大深度</strong>，只是在遍历子节点的时候不同。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; cur.children.size(); i++) &#123;<br>    <span class="hljs-keyword">if</span> (cur.children.get(i) != <span class="hljs-literal">null</span>)<br>        queue.offer(cur.children.get(i));<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230321142849628.png" alt="image-20230321142849628" style="zoom:50%;" /></p>
<h3 id="二叉树的最小深度"><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></h3>
<p><strong>最小深度是从根节点到最近叶子节点的最短路径上的节点数量</strong></p>
<h4 id="方法一dfs-1">方法一：DFS</h4>
<ol type="1">
<li>首先递归左子树和右子树</li>
<li>如果左子树为空，那么返回右子树的高度 + 1；如果右子树为空， 那么返回左子树的高度 + 1</li>
<li>如果左右子树都不为空，那么返回他们最小高度 + 1</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftDepth</span> <span class="hljs-operator">=</span> minDepth(root.left);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rightDepth</span> <span class="hljs-operator">=</span> minDepth(root.right);<br>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> rightDepth + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (root.right == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> leftDepth + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> Math.min(leftDepth, rightDepth) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230321144735136.png" alt="image-20230321144735136" style="zoom:50%;" /></p>
<h4 id="方法二bfs-2">方法二：BFS</h4>
<ol type="1">
<li><strong>通过队列的size知道这是第几层，上一层加入队列节点的个数就是队列的size，在得到size的同时，将记录最小深度的变量minDepth加一</strong></li>
<li><strong>遍历到第一个叶子节点的当前层数就是二叉树的最小深度</strong></li>
<li><strong>时间复杂度</strong>：遍历整棵树，<span class="math inline">\(O(n)\)</span></li>
<li><strong>空间复杂度</strong>：和使用的队列大小相关，在最坏情况下，给定的二叉树是满二叉树，<span class="math inline">\(n/2 + 1\)</span>个叶节点要入队，所以是<span class="math inline">\(O(n)\)</span></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.offer(root);<br>        TreeNode cur;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">minDepth</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>            ++minDepth;<br>            <span class="hljs-keyword">while</span> (size-- &gt; <span class="hljs-number">0</span>) &#123;<br>                cur = queue.poll();<br>                <span class="hljs-keyword">if</span> (cur.left == <span class="hljs-literal">null</span> &amp;&amp; cur.right == <span class="hljs-literal">null</span>)<br>                    <span class="hljs-keyword">return</span> minDepth;<br>                <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-literal">null</span>) <br>                    queue.offer(cur.left);<br>                <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-literal">null</span>)<br>                    queue.offer(cur.right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> minDepth;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230321150754544.png" alt="image-20230321150754544" style="zoom:50%;" /></p>
<h3 id="完全二叉树的节点个数"><a href="https://leetcode.cn/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数</a></h3>
<h4 id="方法一bfs-1">方法一：BFS</h4>
<p><strong>在每层开始遍历时，记录节点个数的变量加上队列里元素个数</strong></p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230321155140257.png" alt="image-20230321155140257" style="zoom:50%;" /></p>
<h4 id="方法二dfs-2">方法二：DFS</h4>
<ol type="1">
<li>边界：如果是空节点，返回0</li>
<li>递归左子树和右子树+1(当前节点)</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countNodes</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">return</span> dfs(root);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + dfs(root.left) + dfs(root.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230420180940972.png" alt="image-20230420180940972" style="zoom:50%;" /></p>
<h3 id="平衡二叉树"><a href="https://leetcode.cn/problems/balanced-binary-tree/">110. 平衡二叉树</a></h3>
<h4 id="方法一先序dfs">方法一：先序DFS</h4>
<ol type="1">
<li>终止条件：如果root为空，返回true</li>
<li>首先求当前节点左右子树高度是否&lt;=1，再判断递归左子树和右子树</li>
<li>时间复杂度：<span class="math inline">\(O(n^2)\)</span></li>
<li>空间复杂度：<span class="math inline">\(O(n)\)</span></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBalanced</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> Math.abs(height(root.left) - height(root.right)) &lt;= <span class="hljs-number">1</span> &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">height</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> Math.max(height(root.left), height(root.right)) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="方法二后序dfswarning">方法二：后序DFS:warning:</h4>
<ol type="1">
<li>只需遍历所有节点一次</li>
<li>时间复杂度<span class="math inline">\(O(n)\)</span></li>
<li>空间复杂度<span class="math inline">\((n)\)</span></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBalanced</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">return</span> height(root) &gt;= <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">height</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftHeight</span> <span class="hljs-operator">=</span> height(root.left);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rightHeight</span> <span class="hljs-operator">=</span> height(root.right);<br>        <span class="hljs-keyword">if</span> (leftHeight == -<span class="hljs-number">1</span> || rightHeight == -<span class="hljs-number">1</span> || Math.abs(leftHeight - rightHeight) &gt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> Math.max(leftHeight, rightHeight) + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="二叉树的所有路径warning"><a href="https://leetcode.cn/problems/binary-tree-paths/">257. 二叉树的所有路径</a>:warning:</h3>
<h4 id="方法一bfs-2">方法一：BFS</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">binaryTreePaths</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;String&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        Queue&lt;Object&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.offer(root);<br>        queue.offer(String.valueOf(root.val));<br>        TreeNode cur;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            cur = (TreeNode)queue.poll();<br>            path = (String)queue.poll();<br>            <span class="hljs-keyword">if</span> (cur.left == <span class="hljs-literal">null</span> &amp;&amp; cur.right == <span class="hljs-literal">null</span>) &#123;<br>                result.add(path);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-literal">null</span>) &#123;<br>                queue.offer(cur.left);<br>                queue.offer(path + <span class="hljs-string">&quot;-&gt;&quot;</span> + String.valueOf(cur.left.val));<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-literal">null</span>) &#123;<br>                queue.offer(cur.right);<br>                queue.offer(path + <span class="hljs-string">&quot;-&gt;&quot;</span> + String.valueOf(cur.right.val));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230422150351347.png" alt="image-20230422150351347" style="zoom:50%;" /></p>
<h4 id="方法二dfs-3">方法二：DFS</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;String&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">binaryTreePaths</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        dfs(root, <span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, String path)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span>;<br>        path += String.valueOf(root.val);<br>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>) &#123;<br>            result.add(path);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            path += <span class="hljs-string">&quot;-&gt;&quot;</span>;<br>            dfs(root.left, path);<br>            dfs(root.right, path);<br>        &#125;<br>    &#125;<br> &#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230422180747250.png" alt="image-20230422180747250" style="zoom:50%;" /></p>
<h3 id="左叶子之和"><a href="https://leetcode.cn/problems/sum-of-left-leaves/">404. 左叶子之和</a></h3>
<h4 id="warning方法一dfs">:warning:方法一：DFS</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumOfLeftLeaves</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> dfs(root);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (root.left != <span class="hljs-literal">null</span>) &#123;<br>            sum += isLeaf(root.left) ? root.left.val : dfs(root.left);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root.right != <span class="hljs-literal">null</span>) &#123;<br>            sum += dfs(root.right);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isLeaf</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">return</span> root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230422182643053.png" alt="image-20230422182643053" style="zoom:50%;" /></p>
<h3 id="找树左下角的值"><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/">513. 找树左下角的值</a></h3>
<h4 id="warning方法一dfs-1">:warning:方法一：DFS</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">curHeight</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">curValue</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findBottomLeftValue</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        dfs(root, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> curValue;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> height)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span>;<br>        ++height;<br>        dfs(root.left, height);<br>        dfs(root.right, height);<br>        <span class="hljs-keyword">if</span> (height &gt; curHeight) &#123;<br>            curHeight = height;<br>            curValue = root.val;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230422184658045.png" alt="image-20230422184658045" style="zoom:50%;" /></p>
<h4 id="方法二bfs-3">方法二：BFS</h4>
<p><strong>从右往左层次遍历，最后一个访问的节点就是树左下角的值！</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findBottomLeftValue</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        TreeNode cur;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.offer(root);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            cur = queue.poll();<br>            <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-literal">null</span>) &#123;<br>                queue.offer(cur.right);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-literal">null</span>) &#123;<br>                queue.offer(cur.left);<br>            &#125;<br>            res = cur.val;<br>        &#125;   <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230422183521606.png" alt="image-20230422183521606" style="zoom:50%;" /></p>
<h3 id="路径总和"><a href="https://leetcode.cn/problems/path-sum/">112. 路径总和</a></h3>
<h4 id="方法一bfs-3">方法一：BFS</h4>
<ol type="1">
<li>初始化一个Object类型队列，用于存放节点与节点的值，首先把根节点和根节点的值offer进队列</li>
<li>开始while循环，循环的执行条件是队列不为空
<ol type="1">
<li>首先按顺序取出节点和节点的值，注意这里需要强转</li>
<li>判断当前节点是否为根节点且节点的值是否为目标值，如果满足，直接return true</li>
<li>如果左子树不为空，先将左子树节点offer进队列，再将左子树的值加上poll出的当前节点的值offer进队列</li>
<li>如果右子树不为空，先将右子树节点offer进队列，再将右子树的值加上poll出的当前节点的值offer进队列</li>
</ol></li>
<li>如果有这么一条路径，那么在while循环中就会return true，不会执行到这；如果没有满足条件的路径，则返回false</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasPathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        Queue&lt;Object&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.offer(root);<br>        queue.offer(root.val);<br>        TreeNode cur;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            cur = (TreeNode)queue.poll();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)queue.poll();<br>            <span class="hljs-keyword">if</span> (cur.left == <span class="hljs-literal">null</span> &amp;&amp; cur.right == <span class="hljs-literal">null</span> &amp;&amp; val == targetSum) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-literal">null</span>) &#123;<br>                queue.offer(cur.left);<br>                queue.offer(val + cur.left.val);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-literal">null</span>) &#123;<br>                queue.offer(cur.right);<br>                queue.offer(val + cur.right.val);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="C:\Users\ning\AppData\Roaming\Typora\typora-user-images\image-20230422190735533.png" alt="image-20230422190735533" style="zoom:50%;" /></p>
<p>|:warning::warning:方法二：DFS</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasPathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>) <br>            <span class="hljs-keyword">return</span> targetSum == root.val;<br>        <span class="hljs-keyword">return</span> hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230422192822798.png" alt="image-20230422192822798" style="zoom:50%;" /></p>
<h3 id="路径总和-ii"><a href="https://leetcode.cn/problems/path-sum-ii/">113. 路径总和 II</a></h3>
<h4 id="方法一bfs-4">方法一：BFS</h4>
<ol type="1">
<li>使用队列存放当前节点和累加节点值</li>
<li>使用HashMap记录每个节点的父节点</li>
<li>当节点满足是叶节点且累加值等于targetSum时，通过HashMap，从该叶子节点遍历到根节点记录到list中，最后把list反转</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <br>            <span class="hljs-keyword">return</span> res;<br>        Queue&lt;Object&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.offer(root);<br>        queue.offer(root.val);<br>        TreeNode cur;<br>        Map&lt;TreeNode, TreeNode&gt; sonFather = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            cur = (TreeNode)queue.poll();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> (Integer)queue.poll();<br>            <span class="hljs-keyword">if</span> (cur.left == <span class="hljs-literal">null</span> &amp;&amp; cur.right == <span class="hljs-literal">null</span> &amp;&amp; val == targetSum) &#123;<br>                res.add(getPath(cur, sonFather));<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-literal">null</span>) &#123;<br>                queue.offer(cur.left);<br>                queue.offer(val + cur.left.val);<br>                sonFather.put(cur.left, cur);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(cur.right != <span class="hljs-literal">null</span>) &#123;<br>                queue.offer(cur.right);<br>                queue.offer(val + cur.right.val);<br>                sonFather.put(cur.right, cur);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> List&lt;Integer&gt; <span class="hljs-title function_">getPath</span><span class="hljs-params">(TreeNode node, Map&lt;TreeNode, TreeNode&gt; sonFather)</span> &#123;<br>        List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        path.add(node.val);<br>        <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">null</span>) &#123;<br>            node = sonFather.get(node);<br>            path.add(node.val);<br>        &#125;<br>        Collections.reverse(path);<br>        <span class="hljs-keyword">return</span> path;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230422200402264.png" alt="image-20230422200402264" style="zoom:50%;" /></p>
<h4 id="warning方法二dfs">:warning:方法二：DFS</h4>
<ol type="1">
<li>使用双端队列，每次dfs将当前节点值放入双端队列队尾，并让targetSum减去当前节点元素</li>
<li>如果当前节点是叶子节点且targetSum等于0，那么说明这条路径满足条件，将path加入结果</li>
<li><strong>每次dfs完左右，再将双端队列最后一个元素移除！！！</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>        dfs(root, targetSum);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <br>            <span class="hljs-keyword">return</span>;<br>        path.offerLast(root.val);<br>        targetSum -= root.val;<br>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span> &amp;&amp; targetSum == <span class="hljs-number">0</span>) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(path));<br>        &#125;<br>        dfs(root.left, targetSum);<br>        dfs(root.right, targetSum);<br>        path.pollLast();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230423090544509.png" alt="image-20230423090544509" style="zoom:50%;" /></p>
<h4 id="star方法三回溯其实方法二也是回溯">:star:方法三：回溯(其实方法二也是回溯)</h4>
<ol type="1">
<li>递归终止条件是：节点为空</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> res;<br>        dfs(root, targetSum);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span>;<br>        path.add(root.val);<br>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span> &amp;&amp; targetSum == root.val) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>(path));<br>        &#125;<br>        dfs(root.left, targetSum - root.val);<br>        dfs(root.right, targetSum - root.val);<br>        path.removeLast();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230425181031967.png" alt="image-20230425181031967" style="zoom:50%;" /></p>
<h3 id="star106.-从中序与后序遍历序列构造二叉树">:star:<a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a></h3>
<ol type="1">
<li>草稿构造一棵二叉树，写出中序和后序序列</li>
<li>确定好边界条件：左闭右闭</li>
<li>后序序列最后一个元素是根，通过HashMap找到根节点下标</li>
<li>根节点左边的长度为lenOfLeft，那么先序序列和后序序列的前lenOfLeft为根节点的左子树</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] inorder, <span class="hljs-type">int</span>[] postorder)</span> &#123;<br>        <span class="hljs-keyword">if</span> (postorder == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; inorder.length; ++i) &#123;<br>            map.put(inorder[i], i);<br>        &#125;<br>        <span class="hljs-comment">// [start, end - 1]左闭右闭</span><br>        <span class="hljs-keyword">return</span> dfs(inorder, <span class="hljs-number">0</span>, inorder.length - <span class="hljs-number">1</span>, postorder, <span class="hljs-number">0</span>, postorder.length - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">private</span> TreeNode <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] inorder, <span class="hljs-type">int</span> inStart, <span class="hljs-type">int</span> inEnd, <span class="hljs-type">int</span>[] postorder, <span class="hljs-type">int</span> postStart, <span class="hljs-type">int</span> postEnd)</span> &#123;<br>        <span class="hljs-keyword">if</span> (inStart &gt; inEnd || postStart &gt; postEnd) <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// 找到postorder最后一个元素的下标，也就是根节点</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">rootValue</span> <span class="hljs-operator">=</span> postorder[postEnd];<br>        <span class="hljs-comment">// 找到inorder中根节点的位置</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">rootIdx</span> <span class="hljs-operator">=</span> map.get(rootValue);<br>        <span class="hljs-comment">// 构造树节点</span><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(rootValue);<br>        <span class="hljs-comment">// 根据inorder切割左子树的大小，那么剩下的就是右子树</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">lenOfLeft</span> <span class="hljs-operator">=</span> rootIdx - inStart;<br>        <span class="hljs-comment">// 按照根节点切割成左子树和右子树</span><br>        root.left = dfs(inorder, inStart, rootIdx - <span class="hljs-number">1</span>, postorder, postStart, postStart + lenOfLeft - <span class="hljs-number">1</span>);<br>        root.right = dfs(inorder, rootIdx + <span class="hljs-number">1</span>, inEnd, postorder, postStart + lenOfLeft, postEnd - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230423101045441.png" alt="image-20230423101045441" style="zoom:50%;" /></p>
<h3 id="从前序与中序遍历序列构造二叉树"><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h3>
<p><strong>注意：int lenOfLeft = rootIdx - inStart; ！！！！！！！！</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] inorder)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> inorder.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; ++i)<br>            map.put(inorder[i], i);<br>        <span class="hljs-comment">// [)左闭右开</span><br>        <span class="hljs-keyword">return</span> dfs(inorder, <span class="hljs-number">0</span>, length, preorder, <span class="hljs-number">0</span>, length);<br>    &#125;<br>    <span class="hljs-keyword">private</span> TreeNode <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] inorder, <span class="hljs-type">int</span> inStart, <span class="hljs-type">int</span> inEnd, <span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span> preStart, <span class="hljs-type">int</span> preEnd)</span> &#123;<br>        <span class="hljs-keyword">if</span> (inStart &gt;= inEnd || preStart &gt;= preEnd)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// 找到根节点</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">rootVal</span> <span class="hljs-operator">=</span> preorder[preStart];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rootIdx</span> <span class="hljs-operator">=</span> map.get(rootVal);<br>        <span class="hljs-comment">// 中序遍历中根节点左边的长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">lenOfLeft</span> <span class="hljs-operator">=</span> rootIdx - inStart;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(rootVal);<br>        root.left = dfs(inorder, inStart, rootIdx, preorder, preStart + <span class="hljs-number">1</span>, preStart + <span class="hljs-number">1</span> + lenOfLeft);<br>        root.right = dfs(inorder, rootIdx + <span class="hljs-number">1</span>, inEnd, preorder, preStart + <span class="hljs-number">1</span> + lenOfLeft, preEnd);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230423105616607.png" alt="image-20230423105616607" style="zoom:50%;" /></p>
<h3 id="star654.-最大二叉树">:star:<a href="https://leetcode.cn/problems/maximum-binary-tree/">654. 最大二叉树</a></h3>
<h4 id="方法一dfs-2">方法一：DFS</h4>
<p>思路同<a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">constructMaximumBinaryTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, nums.length, nums);<br>    &#125;<br>    <span class="hljs-keyword">private</span> TreeNode <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (start &gt;= end)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> start;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxValue</span> <span class="hljs-operator">=</span> nums[start];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; end; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (maxValue &lt; nums[i]) &#123;<br>                maxValue = nums[i];<br>                index = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(maxValue);<br>        root.left = dfs(start, index, nums);<br>        root.right = dfs(index + <span class="hljs-number">1</span>, end, nums);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230423201644238.png" alt="image-20230423201644238" style="zoom:50%;" /></p>
<h3 id="合并二叉树"><a href="https://leetcode.cn/problems/merge-two-binary-trees/">617. 合并二叉树</a></h3>
<p><strong>解题思路</strong>：当树1当前节点的左子树或右子树为空，而树2当前节点左子树或右子树不为空时：使用parentQueue存储树1树2的当前节点parent1，parent2，在遍历到下一层时，使用parent1来指向parent2的左子树或者右子树。</p>
<p><strong>Debug</strong>：如果cur1左子树为空，cur2左子树不为空，将cur1,cur2加入trashQueue；同理右子树。<strong>如果cur1左右子树都为空，cur2左右子树都不为空，将cur1,cur2加入parentQueue两次！！不然之后poll的时候空指针！！</strong></p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230322110219397.png" alt="image-20230322110219397" style="zoom:50%;" /></p>
<h4 id="warning方法二dfs-1">:warning:方法二：DFS</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">mergeTrees</span><span class="hljs-params">(TreeNode root1, TreeNode root2)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root1 == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> root2;<br>        <span class="hljs-keyword">if</span> (root2 == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> root1;<br>        root1.val += root2.val;<br>        root1.left = mergeTrees(root1.left, root2.left);<br>        root1.right = mergeTrees(root1.right, root2.right);<br>        <span class="hljs-keyword">return</span> root1;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230423202828168.png" alt="image-20230423202828168" style="zoom:50%;" /></p>
<h3 id="二叉搜索树中的搜索"><a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索</a></h3>
<h4 id="方法一dfs-3">方法一：DFS</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">searchBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (cur.val == val) &#123;<br>                <span class="hljs-keyword">return</span> cur;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur.val &lt; val) &#123;<br>                cur = cur.right;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                cur = cur.left;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230423203436314.png" alt="image-20230423203436314" style="zoom:50%;" /></p>
<h3 id="star98.-验证二叉搜索树">:star:<a href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h3>
<h4 id="方法一中序遍历">方法一：中序遍历</h4>
<p>中序遍历二叉搜索树应该是升序的，只需要一个记录上一个节点的值的遍历preVal，并与当前节点比较，如果当前节点的值<strong>小于等于</strong>preVal(cur.val应该严格&gt;preVal不能等于)，则返回false;否则，遍历完所有节点返回true。</p>
<p>假设树有n个节点</p>
<p><strong>时间复杂度</strong>：遍历所有节点，<span class="math inline">\(O(n)\)</span></p>
<p><strong>空间复杂度</strong>：和使用的栈相关，在最坏情况(每个节点都只有一个子节点)下，树的高度为n，都需要压栈，所以为<span class="math inline">\(O(n)\)</span></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">preVal</span> <span class="hljs-operator">=</span> Long.MIN_VALUE;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root;<br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span> || !stack.isEmpty()) &#123;<br>            <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>                stack.push(cur);<br>                cur = cur.left;<br>            &#125;<br>            cur = stack.pop();<br>            <span class="hljs-keyword">if</span> (cur.val &lt;= preVal)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            preVal = cur.val;<br>            cur = cur.right; <br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="war方法二递归">:war:方法二：递归</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> dfs(TreeNode root, <span class="hljs-type">long</span>.MIN_VALUE, <span class="hljs-type">long</span>.MAX_VALUE)<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">long</span> pre, <span class="hljs-type">long</span> post)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (root.val &lt;= pre || root.val &gt;= post)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">return</span> dfs(root.left, pre, root.val) &amp;&amp; dfs(root.right, root.val, post);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="方法三morris中序遍历-1">方法三：Morris中序遍历</h4>
<p>Morris遍历利用叶子节点的左右空指针，实现空间开销的极限缩减。</p>
<h5 id="morris遍历的实现原则">morris遍历的实现原则</h5>
<p><strong>记作当前节点为cur。</strong></p>
<ol type="1">
<li><p>如果cur无左孩子，cur向右移动（cur=cur.right）</p></li>
<li><p>如果cur有左孩子，找到cur左子树上最右的节点，记为mostright</p></li>
<li><ol type="1">
<li>如果mostright的right指针指向空，让其指向cur，cur向左移动（cur=cur.left）</li>
<li>如果mostright的right指针指向cur，让其指向空，cur向右移动（cur=cur.right）</li>
</ol></li>
</ol>
<p>实现以上的原则，即实现了morris遍历。</p>
<h5 id="morris遍历的实质">morris遍历的实质</h5>
<blockquote>
<p>建立一种机制，对<strong>于没有左子树的节点只到达一次，对于有左子树的节点会到达两次</strong></p>
</blockquote>
<h5 id="morris中序遍历">Morris中序遍历</h5>
<ol type="1">
<li>如果可以到达一个节点两次(有左子树)，第二次访问</li>
<li>如果可以到达一个节点一次(无左子树)，直接访问</li>
</ol>
<h5 id="举个例子">举个例子</h5>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230417094750640.png" alt="image-20230417094750640" style="zoom:50%;" /></p>
<ol type="1">
<li><p>从根节点5开始遍历，令cur = 根节点5，找到mostRight为节点1</p></li>
<li><p>节点1的右子树为空，将节点1的右子树指向节点5，并让cur移动到左子树(节点1)</p></li>
<li><p>开始遍历节点1，由于节点一无左子树，直接访问，比较节点一与preValue(初始化为最小值)，</p>
<p>1 &lt; Long.MIN_VALUE，将节点1的val赋值给preValue</p></li>
<li><p>将cur(1)移动到右子树，此时cur为之前访问过的根节点5，继续找到cur(5)左子树的最右节点1，发现节点1的右子树为当前节点cur(5)，将节点1的右子树还原为空</p></li>
<li><p>此时是第二次到达节点5，比较节点5与preValue(1)，并将5赋值给preValue，cur向右子树移动，此时cur到达节点4</p></li>
<li><p>找到cur(4)左子树的最右节点3，将节点3的右子树指向cur(4)，cur向左子树移动，此时cur到达节点3</p></li>
<li><p>由于节点3无左子树，直接比较节点3与preValue(5)的值，3&lt;5，返回false。</p></li>
</ol>
<p>可以发现中序遍历的顺序是：15346</p>
<p>Morris中序遍历到达的节点顺序是：5<strong>15</strong>4<strong>346</strong>，其中5和4有左子树，在到底5和4的第二次时作比较。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root, mostRight = <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">preValue</span> <span class="hljs-operator">=</span> Long.MIN_VALUE;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            mostRight = cur.left;<br>            <span class="hljs-keyword">if</span> (mostRight != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">while</span> (mostRight.right != <span class="hljs-literal">null</span> &amp;&amp; mostRight.right != cur) <br>                    mostRight = mostRight.right;<br>                <span class="hljs-keyword">if</span> (mostRight.right == <span class="hljs-literal">null</span>) &#123;<br>                    mostRight.right = cur;<br>                    cur = cur.left;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mostRight.right == cur) &#123;<br>                    mostRight.right = <span class="hljs-literal">null</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cur.val &lt;= preValue) <br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            preValue = cur.val;<br>            cur = cur.right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>时间复杂度</strong>：遍历所有节点，<span class="math inline">\(O(n)\)</span></p>
<p><strong>空间复杂度</strong>：Morris遍历利用叶子节点的左右空指针，实现空间开销的极限缩减，<span class="math inline">\(O(1)\)</span></p>
<h3 id="二叉搜索树的最小绝对差"><a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">530. 二叉搜索树的最小绝对差</a></h3>
<h4 id="方法一中序遍历-1">方法一：中序遍历</h4>
<p>使用中序遍历二叉搜索树得到的结果是升序的。</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230322155627326.png" alt="image-20230322155627326" style="zoom:50%;" /></p>
<h4 id="starwarning方法二双指针">:star::warning:方法二：双指针</h4>
<p><strong>双指针的思想真的很重要！！！</strong></p>
<ol type="1">
<li>初始化全局变量：pre节点初始化为空；diff存储相邻节点差值，初始化为整型最大值</li>
<li>中序遍历过程：第一次遍历，pre是空的，还没遇到第二个节点也就没有相邻节点之间的差值；</li>
<li>把当前节点(root)赋给pre，那么下一个root就是中序遍历顺序pre的下一个节点</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    TreeNode pre;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">diff</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMinimumDifference</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        dfs(root);<br>        <span class="hljs-keyword">return</span> diff;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span>;<br>        dfs(root.left);<br>        <span class="hljs-keyword">if</span> (pre != <span class="hljs-literal">null</span>)<br>            diff = Math.min(diff, root.val - pre.val);<br>        pre = root; <br>        dfs(root.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230425185335018.png" alt="image-20230425185335018" style="zoom:50%;" /></p>
<h4 id="section"></h4>
<h3 id="二叉搜索树中的众数"><a href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/">501. 二叉搜索树中的众数</a></h3>
<p>老样子，中序遍历</p>
<p>遍历的过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (preVal == cur.val) &#123;<br>	++counter;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>	counter = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (!modes.contains(cur.val) &amp;&amp; counter == maxCounter) &#123;<br>	modes.add(cur.val);<br>&#125;<br><br><span class="hljs-keyword">if</span> (counter &gt; maxCounter) &#123;<br>    maxCounter = counter;<br>    modes.removeAll(modes);<br>    modes.add(cur.val);<br>&#125;<br>preVal = cur.val;<br>cur = cur.right;<br></code></pre></td></tr></table></figure>
<h3 id="二叉树的最近公共祖先"><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h3>
<h4 id="方法一用hashmap存储所有父节点用hashset标记是否访问过从p开始向上遍历并标记访问过的父节点再从q开始向上遍历如果当前节点被访问过那么这个节点就是最近公共祖先">方法一：用HashMap存储所有父节点，用HashSet标记是否访问过；从p开始向上遍历，并标记访问过的父节点，再从q开始向上遍历，如果当前节点被访问过，那么这个节点就是最近公共祖先。</h4>
<p><strong>注意：对于p，先设置visisted，再向上移；对于q，先判断当前节点是不是已经被visited，再向上移。</strong>如果p,q任意一者先向上移再操作，都会导致在，p或q是最近公共节点时，返回的却是p或q的父节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>        Map&lt;TreeNode, TreeNode&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Set&lt;TreeNode&gt; visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        dfs(root, map);<br>        <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span>) &#123;<br>            visited.add(p);<br>            p = map.get(p);<br>        &#125;<br>        <span class="hljs-keyword">while</span> (q != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (visited.contains(q)) &#123;<br>                <span class="hljs-keyword">return</span> q;<br>            &#125;<br>            q = map.get(q);<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, Map&lt;TreeNode, TreeNode&gt; map)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (root.left != <span class="hljs-literal">null</span>) &#123;<br>            map.put(root.left, root);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root.right != <span class="hljs-literal">null</span>) &#123;<br>            map.put(root.right, root);<br>        &#125;<br>        dfs(root.left, map);<br>        dfs(root.right, map);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230427092729299.png" alt="image-20230427092729299" style="zoom:50%;" /></p>
<h4 id="warning方法二dfs-2">:warning:方法二：DFS</h4>
<p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/solution/236-er-cha-shu-de-zui-jin-gong-gong-zu-xian-hou-xu/">题解</a></p>
<p>可以不判断非p,q的叶节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>        <span class="hljs-keyword">return</span> dfs(root, p, q);<br>    &#125;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span> || root == p || root == q)<br>            <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> dfs(root.left, p, q);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> dfs(root.right, p, q);<br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> right;<br>        <span class="hljs-keyword">if</span> (right == <span class="hljs-literal">null</span>) <br>            <span class="hljs-keyword">return</span> left;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="二叉搜索树的最近公共祖先"><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先</a></h3>
<h4 id="递归考虑三种情况">递归：考虑三种情况</h4>
<ol type="1">
<li>p,q是root：return root</li>
<li>p,q在root两侧，(p.val &lt; root.val &amp;&amp; q.val &gt; root.val) || (p.val &gt; root.val &amp;&amp; q.val &lt; root.val)， return root</li>
<li>p,q在root同一侧 (p.val &lt; root &amp;&amp; q.val &lt; root.val) || (p.val &gt; root.val &amp;&amp; q.val &gt; root.val)
<ol type="1">
<li>p.val &lt; root &amp;&amp; q.val &lt; root.val: return dfs(left, p, q)</li>
<li>p.val &gt; root.val &amp;&amp; q.val &gt; root.val: return dfs(right, p, q)</li>
</ol></li>
</ol>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230323103301262.png" alt="image-20230323103301262" style="zoom:50%;" /></p>
<h4 id="方法一dfs-4">方法一：DFS</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) <br>            <span class="hljs-keyword">return</span> lowestCommonAncestor(root.left, p, q);<br>        <span class="hljs-keyword">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val)<br>            <span class="hljs-keyword">return</span> lowestCommonAncestor(root.right, p, q);        <br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230427101509170.png" alt="image-20230427101509170" style="zoom:50%;" /></p>
<h3 id="二叉搜索树中的插入操作"><a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">701. 二叉搜索树中的插入操作</a></h3>
<p><strong>要点是：如何记录要插入节点的父节点</strong></p>
<h4 id="方法一栈">方法一：栈</h4>
<ol type="1">
<li>从根节点开始遍历，用栈存储每个遍历过的节点，大于向右小于向左；循环结束，判断插入最后一个被遍历的节点(栈中最顶层节点)，判断大于小于，插入，结束。</li>
<li>遍历过程把所有元素放进栈，空节点跳出循环后，栈顶元素就是要插入节点的父节点</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">insertIntoBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(val);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root;<br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            stack.push(cur);<br>            <span class="hljs-keyword">if</span> (val &lt; cur.val) &#123;<br>                cur = cur.left;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                cur = cur.right;<br>            &#125;<br>        &#125;<br>        cur = stack.pop();<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(val);<br>        <span class="hljs-keyword">if</span> (cur.val &gt; val) &#123;<br>            cur.left =  newNode;<br>        &#125; <br>        <span class="hljs-keyword">else</span> &#123;<br>            cur.right = newNode;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="方法二双指针">方法二：双指针</h4>
<p>用pre指针指向上一个节点，有两个要注意的地方</p>
<ol type="1">
<li>初始化pre指针时，不能初始化为null，如果根节点没有左子树，而要插入的节点小于根节点，<strong>要插入的节点会成为根节点的左子树</strong>，这种情况判断一次就会跳出while循环，此时pre还是null，<strong>所以要把pre初始化为根节点</strong></li>
<li>在while循环中，用pre=cur记录cur的上一个节点，但是，最后cur等于空的时候，pre再记录cur就没有意义了，所以<strong>加上if (cur != null)判断条件</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">insertIntoBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(val);<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root, pre = root;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (cur.val &gt; val)<br>                cur = cur.left;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur.val &lt; val)<br>                cur= cur.right;<br>            <span class="hljs-keyword">if</span> (cur != <span class="hljs-literal">null</span>)<br>                pre = cur;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (val &gt; pre.val)<br>            pre.right = res;<br>        <span class="hljs-keyword">else</span>  <br>            pre.left = res;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="方法三dfs-1">方法三：DFS</h4>
<p>当时想出来了，但是卡在怎么插入这个点上<strong>，其实这里已经用root.left或者root.right来接收 new TreeNode(val)了。</strong>==构造树==！！！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">insertIntoBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(val);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (val &lt; root.val) &#123;<br>            root.left = insertIntoBST(root.left, val);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            root.right = insertIntoBST(root.right, val);<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="x450.-删除二叉搜索树中的节点">x<a href="https://leetcode.cn/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点</a></h3>
<p><strong>解题思路</strong>：</p>
<ol type="1">
<li><p>如果目标节点大于当前节点值，则去右子树中删除；</p></li>
<li><p>如果目标节点小于当前节点值，则去左子树中删除；</p></li>
<li><p>如果目标节点就是当前节点，分为以下三种情况：</p>
<ol type="1">
<li>其无左子：其右子顶替其位置，删除了该节点；</li>
<li>其无右子：其左子顶替其位置，删除了该节点；</li>
<li>其左右子节点都有：其左子树转移到其右子树的最左节点的左子树上，然后右子树顶替其位置，由此删除了该节点。</li>
</ol></li>
</ol>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230323142204001.png" alt="image-20230323142204001" style="zoom:50%;" /></p>
<p>写了快100行，重构一下代码。。</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230323142217741.png" alt="image-20230323142217741" style="zoom:50%;" /></p>
<h4 id="方法一迭代">方法一：迭代</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">deleteNode</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root, pre = root;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (cur.val == key) &#123;<br>                <span class="hljs-keyword">if</span> (cur.left == <span class="hljs-literal">null</span> &amp;&amp; cur.right == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 叶子节点</span><br>                    <span class="hljs-keyword">if</span> (pre.val &lt; key) <br>                        pre.right = <span class="hljs-literal">null</span>;<br>                    <span class="hljs-keyword">else</span> <br>                        pre.left = <span class="hljs-literal">null</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (cur.left !=  <span class="hljs-literal">null</span> &amp;&amp; cur.right != <span class="hljs-literal">null</span>) &#123;<br>                     <span class="hljs-comment">// 找到要删除节点右子树上的最左节点，再把要删除节点左子树挂上去</span><br>                        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> cur.left, right = cur.right;<br>                        cur = cur.right;<br>                        <span class="hljs-keyword">while</span> (cur.left != <span class="hljs-literal">null</span>) <br>                            cur = cur.left;<br>                        cur.left = left;<br>                        <span class="hljs-keyword">if</span> (pre.val &lt; key) <br>                            pre.right = right;<br>                        <span class="hljs-keyword">else</span> <br>                            pre.left = right;                        <br>                    &#125;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur.left == <span class="hljs-literal">null</span> &amp;&amp; cur.right != <span class="hljs-literal">null</span>) &#123;<br>                        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> cur.right;<br>                        <span class="hljs-keyword">if</span> (pre.val &lt; key)<br>                            pre.right = right;<br>                        <span class="hljs-keyword">else</span> <br>                            pre.left = right;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-literal">null</span> &amp;&amp; cur.right == <span class="hljs-literal">null</span>) &#123;<br>                        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> cur.left;<br>                        <span class="hljs-keyword">if</span> (pre.val &lt; key)<br>                            pre.right = left;<br>                        <span class="hljs-keyword">else</span> <br>                            pre.left = left;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur.val &lt; key) &#123;<br>                pre = cur;<br>                cur = cur.right;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                pre = cur;<br>                cur = cur.left;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root.val == key) &#123;<br>            <span class="hljs-keyword">return</span> root.left == <span class="hljs-literal">null</span> ? root.right : root.left;            <br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230427114811046.png" alt="image-20230427114811046" style="zoom:50%;" /></p>
<h4 id="star方法二dfs">:star:方法二：DFS</h4>
<p><strong>注意代码注释部分是完全冗余的！</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">deleteNode</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">if</span> (key &lt; root.val)<br>            root.left = deleteNode(root.left, key);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &gt; root.val)<br>            root.right = deleteNode(root.right, key);<br>        <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//(key == root.val) &#123;</span><br>            <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> root.right;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.left != <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> root.left;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root.right;<br>                <span class="hljs-keyword">while</span> (cur.left != <span class="hljs-literal">null</span>) <br>                    cur = cur.left;<br>                cur.left = root.left;<br>                <span class="hljs-keyword">return</span> root.right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// if (root.val == key) &#123;</span><br>        <span class="hljs-comment">//     if (root.left == null &amp;&amp; root.right == null)</span><br>        <span class="hljs-comment">//         return null;</span><br>        <span class="hljs-comment">//     else &#123;</span><br>        <span class="hljs-comment">//         return root.left == null ? root.right : root.left;</span><br>        <span class="hljs-comment">//     &#125;</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230427121231313.png" alt="image-20230427121231313" style="zoom:50%;" /></p>
<h3 id="warning669.-修剪二叉搜索树">:warning:<a href="https://leetcode.cn/problems/trim-a-binary-search-tree/">669. 修剪二叉搜索树</a></h3>
<p>借上一题的思路直接速通了</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230323144126141.png" alt="image-20230323144126141" style="zoom:50%;" /></p>
<h3 id="将有序数组转换为二叉搜索树"><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树</a></h3>
<h4 id="方法一二分dfs左闭右闭">方法一：二分DFS[左闭右闭]</h4>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230323150830325.png" alt="image-20230323150830325" style="zoom:50%;" /></p>
<h4 id="方法二dfs左闭右开开区间元素在record的数值要--闭区间元素在record的位置要开区间元素和闭区间元素都为a所以s的下标1以b开始的子串ba也是变位词">方法二：DFS[左闭右开)]，开区间元素在record的数值要--，闭区间元素在record的位置要++，开区间元素和闭区间元素都为‘a’，所以s的下标1以‘b’开始的子串“ba”也是变位词！</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">findAnagrams</span><span class="hljs-params">(String s, String p)</span> &#123;<br>        List&lt;Integer&gt; index = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (s.length() &lt; p.length())<br>            <span class="hljs-keyword">return</span> index;<br>        <span class="hljs-type">int</span>[] record = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; p.length(); ++i) &#123;<br>            ++record[p.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>];<br>            --record[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (areZeros(record)) &#123;<br>            index.add(<span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> p.length(); i &lt; s.length(); ++i) &#123;<br>            ++record[s.charAt(i - p.length()) - <span class="hljs-string">&#x27;a&#x27;</span>];<br>            --record[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>];<br>            <span class="hljs-keyword">if</span> (areZeros(record)) &#123;<br>                index.add(i - p.length() + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> index;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">areZeros</span><span class="hljs-params">(<span class="hljs-type">int</span>[] record)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> element : record)<br>            <span class="hljs-keyword">if</span> (element != <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230413180235628.png" alt="image-20230413180235628" style="zoom:50%;" /></p>
<h4 id="尽可能使字符串相等warning"><a href="https://leetcode.cn/problems/get-equal-substrings-within-budget/">1208. 尽可能使字符串相等</a>:warning:</h4>
<h4 id="方法一滑动窗口">方法一：滑动窗口</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">equalSubstring</span><span class="hljs-params">(String s, String t, <span class="hljs-type">int</span> maxCost)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span>[] diff = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            diff[i] = Math.abs(s.charAt(i) - t.charAt(i));<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, start = <span class="hljs-number">0</span>, sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; end &lt; n; ++end) &#123;<br>            sum += diff[end];<br>            <span class="hljs-keyword">while</span> (maxCost &lt; sum) &#123;<br>                sum -= diff[start++];<br>            &#125;<br>            res = Math.max(res, end - start + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230519140212424.png" alt="image-20230519140212424" style="zoom:50%;" /></p>
<h3 id="string补充知识">String补充知识</h3>
<h4 id="string与char数组stringbuilder之间相互转换">String与char数组，StringBuilder之间相互转换</h4>
<p>将String转换为char数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">codeString</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-type">char</span>[] charArray = str.toCharArray();<br></code></pre></td></tr></table></figure>
<p>将char数组转换为String：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">codechar[] charArray = &#123;<span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>&#125;;<br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(charArray);<br></code></pre></td></tr></table></figure>
<p>将String转换为StringBuilder：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.</span><br><span class="hljs-type">codeString</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(str);<br><span class="hljs-comment">//2.</span><br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>sb.append(str);<br></code></pre></td></tr></table></figure>
<p>将StringBuilder转换为String：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">codeStringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>sb.append(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> sb.toString();<br></code></pre></td></tr></table></figure>
<p>将char数组转换为StringBuilder：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">codechar[] charArray = &#123;<span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>&#125;;<br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>sb.append(charArray);<br></code></pre></td></tr></table></figure>
<p>将StringBuilder转换为char数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">codeStringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-type">char</span>[] charArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[sb.length()];<br>sb.getChars(<span class="hljs-number">0</span>, sb.length(), charArray, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure>
<p>需要注意的是，在将String转换为char数组或char时，如果字符串为空，或者字符串中的字符数量为0，则可能会导致越界异常或其他异常。因此，在进行这些转换操作时，需要进行有效性检查和异常处理。</p>
<p>单个字符char转换为String</p>
<p>在Java中，将单个字符（char）转换为字符串（String）有以下两种方法：</p>
<p>1.使用字符串连接符</p>
<p>您可以使用字符串连接符"+"来连接一个空字符串和单个字符，从而将其转换为字符串。例如：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">arduinoCopy codechar c</span> = <span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-attribute">String s</span> = <span class="hljs-string">&quot;&quot;</span> + c;<br></code></pre></td></tr></table></figure>
<p>在上面的代码中，首先创建一个空字符串，然后使用字符串连接符将其与字符"c"连接起来，从而将字符"c"转换为字符串。现在，字符串<code>s</code>将包含字符"c"的字符串。</p>
<p>2.使用String.valueOf()方法</p>
<p>另一种将单个字符转换为字符串的方法是使用String类的<code>valueOf()</code>方法。例如：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino">arduinoCopy codechar c = <span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-type">String</span> s = <span class="hljs-type">String</span>.<span class="hljs-built_in">valueOf</span>(c);<br></code></pre></td></tr></table></figure>
<p>在上面的代码中，将字符"c"传递给<code>valueOf()</code>方法，并将返回的字符串分配给变量<code>s</code>。</p>
<p>无论使用哪种方法，您都可以将单个字符转换为字符串，从而可以对其进行各种字符串操作。</p>
<h4 id="stringbuilder的append可以是char或者string">StringBuilder的append可以是char或者String</h4>
<p>StringBuilder的append()方法可以接受char类型和String类型的参数。append()方法的作用是在StringBuilder对象的末尾追加指定的字符序列，这可以是char、String、StringBuilder或其他CharSequence实例。</p>
<p>以下是使用StringBuilder的append()方法追加char和String类型参数的示例代码：</p>
<p>追加char类型参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">codeStringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span>;<br>sb.append(c);<br></code></pre></td></tr></table></figure>
<p>追加String类型参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">codeStringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>sb.append(str);<br></code></pre></td></tr></table></figure>
<p>需要注意的是，使用append()方法追加char类型参数时，会自动将char类型转换为String类型。因此，如果需要在StringBuilder中追加一个char类型的字符，可以直接使用append()方法，而不需要先将其转换为String类型。</p>
<h3 id="kmp算法">KMP算法</h3>
<p><a href="https://www.zhihu.com/question/21923021/answer/281346746">生成next数组讲得很透彻</a></p>
<h2 id="array">Array</h2>
<h3 id="二分查找"><a href="https://leetcode.cn/problems/binary-search/">704. 二分查找</a></h3>
<h4 id="方法一左闭右开">方法一：左闭右开</h4>
<ol type="1">
<li>区间：[left, right)</li>
<li>初始化：right = nums.length</li>
<li>while循环终止条件应为left &lt; right（右开，right不能等于left）</li>
<li>当nums[mid] &lt; target时，nums[0]~nums[mid]都小于target，此时有效的有边界是mid - 1，又因为右边界是开区间，所以另right = mid</li>
<li>时间复杂度：<span class="math inline">\(O(logn)\)</span>，由于每次查找都会将查找范围缩小一半，因此二分查找的时间复杂度是<span class="math inline">\(O(logn)\)</span>，其中 <em>n</em> 是数组的长度</li>
<li>空间复杂度：<span class="math inline">\(O(1)\)</span></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length;<br>        <span class="hljs-comment">// [left, right)</span><br>        <span class="hljs-keyword">while</span>(left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + ((right - left) &gt;&gt; <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (nums[mid] == target)<br>                <span class="hljs-keyword">return</span> mid;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target)<br>                left = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <br>                right = mid;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="方法二左闭右闭">方法二：左闭右闭</h4>
<ol type="1">
<li>区间：[left, right]</li>
<li>初始化：right = nums.length - 1</li>
<li>while循环终止条件应为left &lt;= right</li>
<li>当nums[mid] &lt; target时，nums[0]~nums[mid]都小于target，另right = mid - 1</li>
<li>时间复杂度：<span class="math inline">\(O(logn)\)</span>，由于每次查找都会将查找范围缩小一半，因此二分查找的时间复杂度是<span class="math inline">\(O(logn)\)</span>，其中 <em>n</em> 是数组的长度</li>
<li>空间复杂度：<span class="math inline">\(O(1)\)</span></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> right - ((right - left) &gt;&gt; <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (nums[mid] &gt; target) <br>                right = mid - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target)<br>                left = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <br>                <span class="hljs-keyword">return</span> mid;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="移除元素"><a href="https://leetcode.cn/problems/remove-element/">27. 移除元素</a></h3>
<h4 id="方法一暴力-1">方法一：暴力</h4>
<ol type="1">
<li>每当发现一个数相等，那么从当前数组的下一个数开始，全部往前移一位。</li>
<li><strong>注意</strong>：因为移位后，下一个要访问的数组元素j会到当前i的位置，然后for循环结束i自增，会错过访j，所以移位后要--i。</li>
<li>时间复杂度：<span class="math inline">\(O(n^2)\)</span></li>
<li>空间复杂度：<span class="math inline">\(O(1)\)</span></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">newLen</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span> (newLen == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; newLen; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] == val) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; newLen; j++) &#123;<br>                    nums[j - <span class="hljs-number">1</span>] = nums[j];<br>                &#125;<br>                --newLen;<br>                --i;<br>            &#125;<br>         &#125;<br><br>        <span class="hljs-keyword">return</span> newLen;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="方法二双指针-1">方法二：双指针</h4>
<ol type="1">
<li>初始化慢指针为0</li>
<li>for循环遍历快指针，当nums[fast] != val时，令nums[slow] = nums[fast]，slow指针往后移。也就是说，如果快指针找到了val，那么慢指针停在val位置，之后快指针遍历到非val的位置时，将该非val数据覆盖到慢指针的指向数组位置的数据。</li>
<li>最后返回慢指针(慢指针大小代表新数组的大小)</li>
<li>时间复杂度：<span class="math inline">\(O(n)\)</span></li>
<li>空间复杂度：<span class="math inline">\(O(1)\)</span></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; fast &lt; nums.length; ++fast) &#123;<br>            <span class="hljs-keyword">if</span> (nums[fast] != val) &#123;<br>                nums[slow] = nums[fast];<br>                ++slow;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="方法三相向双指针">方法三：相向双指针</h4>
<p><strong>避免了需要保留的元素的重复赋值操作</strong>。</p>
<ol type="1">
<li><p>初始化：left=0, right=nums.length-1，左闭右闭区间，所以while语句的执行条件是</p>
<p>left &lt;= right(如果没有等于，left会少后移一次)</p></li>
<li><p>循环：当nums[left]不等于val时，left指针后移；当nums[left]等于val时，将nums[right]赋值给nums[left]，right指针前移；如果赋值过来的元素恰好也等于val，可以继续把右指针 right指向的元素的值赋值过来，直到左指针指向的元素的值不等于 val为止。</p></li>
<li><p>时间复杂度：<span class="math inline">\(O(n)\)</span></p></li>
<li><p>空间复杂度：<span class="math inline">\(O(1)\)</span></p></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// [left, right]</span><br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-keyword">if</span> (nums[left] == val) &#123;<br>                nums[left] = nums[right];<br>                --right;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                ++left;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="有序数组的平方"><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977. 有序数组的平方</a></h3>
<h4 id="双指针">双指针</h4>
<p>left,right指针指向数组两端，将较大的平方数放入result数组里。</p>
<ol type="1">
<li>时间复杂度：<span class="math inline">\(O(n)\)</span></li>
<li>空间复杂度：<span class="math inline">\(O(n)\)</span></li>
</ol>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230406132631275.png" alt="image-20230406132631275" style="zoom:50%;" /></p>
<h3 id="长度最小的子数组"><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a></h3>
<h4 id="numsi先执行自增操作还是数组寻址操作">nums[++i]先执行自增操作还是数组寻址操作?</h4>
<p>在Java中，表达式<code>nums[++i]</code>中的<code>++i</code>是先自增还是先寻址是有规定的。按照Java的运算符优先级规定，前置自增运算符<code>++i</code>的优先级高于数组下标运算符<code>[]</code>，因此在执行这个表达式时，先进行<code>++i</code>自增运算，然后再进行数组下标运算，即先自增再寻址。</p>
<p>因此，<code>nums[++i]</code>相当于先将变量<code>i</code>自增1，然后使用自增后的<code>i</code>作为数组下标去访问<code>nums</code>数组中的元素。如果<code>i</code>的初始值为0，那么<code>nums[++i]</code>将访问<code>nums[1]</code>位置上的元素，而不是<code>nums[0]</code>。如果数组<code>nums</code>越界，将会抛出<code>ArrayIndexOutOfBoundsException</code>异常。</p>
<h4 id="numsi先执行自增操作还是数组寻址操作-1">nums[i++]先执行自增操作还是数组寻址操作?</h4>
<p>在这种情况下，nums[i++]实际上会先执行数组寻址操作，然后再对i进行自增操作。这是因为数组寻址操作的优先级比自增操作的优先级高。</p>
<p>具体来说，这个表达式会先使用i的当前值来计算nums数组中第i个元素的地址，然后将地址作为结果返回，接着才会将i的值加1。</p>
<h4 id="int-a-i-是先赋值还是先自增">int a = ++i 是先赋值还是先自增</h4>
<p>这行代码会先自增变量 i 的值，然后将自增后的结果赋值给变量 a。所以，变量 a 的值等于自增后的变量 i 的值。这个过程中，变量 i 的值会被修改，而变量 a 的值则是这个修改后的值。</p>
<p>可以将这行代码拆分成两步：</p>
<ol type="1">
<li>i = i + 1； // 自增 i 的值</li>
<li>a = i； // 将自增后的 i 的值赋值给 a</li>
</ol>
<p>所以，最终变量 a 的值等于自增后的变量 i 的值。</p>
<h4 id="int-a-i-是先赋值还是先自增-1">int a = i++ 是先赋值还是先自增</h4>
<p>这行代码会先将变量 i 的值赋值给变量 a，然后再将变量 i 的值自增。所以，变量 a 的值等于变量 i 的值，而变量 i 的值会被自增。</p>
<p>可以将这行代码拆分成两步：</p>
<ol type="1">
<li>a = i； // 将 i 的值赋值给 a</li>
<li>i = i + 1； // 自增 i 的值</li>
</ol>
<p>所以，最终变量 a 的值等于变量 i 的初始值，而变量 i 的值则是初始值加一。</p>
<h4 id="while--index-先---后比较index0">while(--index) 先-- 后比较index&gt;0</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><span class="hljs-keyword">while</span> (--index &gt; <span class="hljs-number">0</span>) &#123;<br>    System.out.print(index);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>stdout</p>
<p>1</p>
<h4 id="whileindex---先比较-后--">while(index--) 先比较 后--</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><span class="hljs-keyword">while</span> (index-- &gt; <span class="hljs-number">0</span>) &#123;<br>    System.out.print(index);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>stdout</p>
<p>10</p>
<h4 id="system.out.print--index-先---后打印">System.out.print(--index) 先-- 后打印</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><span class="hljs-keyword">while</span> (index &gt; <span class="hljs-number">0</span>) &#123;<br>    System.out.print(--index);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>stdout</p>
<p>10</p>
<h4 id="滑动窗口">滑动窗口</h4>
<ol type="1">
<li><p>注意：为了确保有些案例，sum一直小于target，最后输出判断：如果</p>
<p>result == Integer.MAX_VALUE，就输出0。</p></li>
<li><p>result记录最小的长度</p></li>
<li><p>时间复杂度：<span class="math inline">\(O(n)\)</span></p></li>
<li><p>空间复杂度：<span class="math inline">\(O(1)\)</span></p></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, result = Integer.MAX_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i) &#123;<br>            ++counter;<br>            sum += nums[i];<br>            <span class="hljs-keyword">while</span> (sum &gt;= target) &#123;<br>                result = Math.min(result, counter);<br>                sum -= nums[i - (--counter)];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result == Integer.MAX_VALUE ? <span class="hljs-number">0</span> : result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230418152625221.png" alt="image-20230418152625221" style="zoom:50%;" /></p>
<h3 id="螺旋矩阵-ii"><a href="https://leetcode.cn/problems/spiral-matrix-ii/">59. 螺旋矩阵 II</a></h3>
<ol type="1">
<li><p>遍历顺序：从左到右(左闭右开)，从上到下(上闭下开)，从右到左(右闭左开)，从下到上(下闭上开)</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230406151317898.png" alt="image-20230406151317898" style="zoom: 25%;" /></p></li>
<li><p>思路见代码注释部分</p></li>
<li><p>时间复杂度：<span class="math inline">\(O(n^2)\)</span></p></li>
<li><p>空间复杂度：<span class="math inline">\(O(1)\)</span></p></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] generateMatrix(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-comment">// 用笔画一个n=5的矩阵作为例子</span><br>        <span class="hljs-comment">// 遍历顺序：从左到右(左闭右开)，从上到下(上闭下开)，从右到左(右闭左开)，从下到上(下闭上开)</span><br>        <span class="hljs-comment">// 建立n行n列的矩阵</span><br>        <span class="hljs-type">int</span>[][] matrix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-comment">// 遍历次数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">traverseTime</span> <span class="hljs-operator">=</span> n / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> i, j;<br>        <span class="hljs-comment">// 写入数组的数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// cur:当前遍历伦茨</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; cur &lt; traverseTime; ++cur) &#123;<br>            <span class="hljs-comment">// 从左到右(左闭右开)</span><br>            <span class="hljs-keyword">for</span> (j = cur; j &lt; n - cur - <span class="hljs-number">1</span>; ++j) &#123;<br>                matrix[cur][j] = data++;<br>            &#125;<br>            <span class="hljs-comment">// 从上到下(上闭下开)</span><br>            <span class="hljs-keyword">for</span> (i = cur; i &lt; n - cur - <span class="hljs-number">1</span>; ++i) &#123;<br>                matrix[i][j] = data++;<br>            &#125;<br>            <span class="hljs-comment">// 从右到左(右闭左开)</span><br>            <span class="hljs-keyword">for</span> (; j &gt; cur; --j) &#123;<br>                matrix[i][j] = data++;<br>            &#125;<br>            <span class="hljs-comment">// 从下到上(下闭上开)</span><br>            <span class="hljs-keyword">for</span> (; i &gt; cur; --i) &#123;<br>                matrix[i][j] = data++;<br>            &#125;<br>            <span class="hljs-comment">// debug</span><br>            <span class="hljs-comment">// for (int a = 0; a &lt; n; ++a) &#123;</span><br>            <span class="hljs-comment">//     for (int b = 0; b &lt; n; ++b) &#123;</span><br>            <span class="hljs-comment">//         System.out.print(matrix[a][b]);</span><br>            <span class="hljs-comment">//     &#125;</span><br>            <span class="hljs-comment">// &#125;</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)<br>            matrix[traverseTime][traverseTime] = n * n;<br>        <span class="hljs-keyword">return</span> matrix;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230406150937452.png" alt="image-20230406150937452" style="zoom:50%;" /></p>
<h3 id="区域和检索---数组不可变"><a href="https://leetcode.cn/problems/range-sum-query-immutable/">303. 区域和检索 - 数组不可变</a></h3>
<h4 id="方法一暴力-2">方法一：暴力</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumArray</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] nums;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NumArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-built_in">this</span>.nums = nums;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumRange</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> left; i &lt;= right; ++i) &#123;<br>            sum += nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your NumArray object will be instantiated and called as such:</span><br><span class="hljs-comment"> * NumArray obj = new NumArray(nums);</span><br><span class="hljs-comment"> * int param_1 = obj.sumRange(left,right);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230511104924605.png" alt="image-20230511104924605" style="zoom:50%;" /></p>
<h4 id="方法二前缀和">方法二：前缀和</h4>
<ol type="1">
<li><p>建立一个长度为n+1的数组preSum</p></li>
<li><p>初始化preSum[0] = 0;</p></li>
<li><p>preSum[i]表示数组nums从下标0到下标i-1的和</p>
<figure>
<img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230511111212882.png" alt="image-20230511111212882" /><figcaption aria-hidden="true">image-20230511111212882</figcaption>
</figure></li>
<li><p>区间[left,right]的和为preSum[right + 1] - preSum[left];</p>
<p>preSum[right + 1]表示数组从下标0到right的和，preSum[left]表示数组从下标0到left-1的和</p></li>
<li><p>将前缀和数组preSum的长度设为n+1的目标是为了方便计算sumRange(left, right)时，不需要对left=0的情况做特殊处理</p></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumArray</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] preSum;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NumArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        preSum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; preSum.length; ++i) &#123;<br>            preSum[i] = preSum[i - <span class="hljs-number">1</span>] + nums[i - <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumRange</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-keyword">return</span> preSum[right + <span class="hljs-number">1</span>] - preSum[left];<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your NumArray object will be instantiated and called as such:</span><br><span class="hljs-comment"> * NumArray obj = new NumArray(nums);</span><br><span class="hljs-comment"> * int param_1 = obj.sumRange(left,right);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230511110351502.png" alt="image-20230511110351502" style="zoom: 50%;" /></p>
<h4 id="前缀和前缀和数组为n需要对left0时做特殊处理">前缀和：前缀和数组为n，需要对left=0时做特殊处理</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumArray</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] preSum;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NumArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        preSum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        preSum[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; preSum.length; ++i) &#123;<br>            preSum[i] = preSum[i - <span class="hljs-number">1</span>] + nums[i];<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumRange</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> preSum[right];<br>        &#125;<br>        <span class="hljs-keyword">return</span> preSum[right] - preSum[left - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your NumArray object will be instantiated and called as such:</span><br><span class="hljs-comment"> * NumArray obj = new NumArray(nums);</span><br><span class="hljs-comment"> * int param_1 = obj.sumRange(left,right);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230511112006002.png" alt="image-20230511112006002" style="zoom:50%;" /></p>
<h3 id="二维区域和检索---矩阵不可变"><a href="https://leetcode.cn/problems/range-sum-query-2d-immutable/">304. 二维区域和检索 - 矩阵不可变</a></h3>
<h4 id="方法一前缀和warning">方法一：前缀和:warning:</h4>
<p><strong>需要重刷！</strong></p>
<p><a href="https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-48c1d/xiao-er-me-03265/">题解</a></p>
<figure>
<img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230511124326460.png" alt="image-20230511124326460" /><figcaption aria-hidden="true">image-20230511124326460</figcaption>
</figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumMatrix</span> &#123;<br>    <span class="hljs-type">int</span>[][] preSum;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NumMatrix</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        preSum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[matrix.length + <span class="hljs-number">1</span>][matrix[<span class="hljs-number">0</span>].length + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= matrix.length; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= matrix[<span class="hljs-number">0</span>].length; ++j) &#123;<br>                preSum[i][j] = matrix[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + preSum[i - <span class="hljs-number">1</span>][j] + preSum[i][j - <span class="hljs-number">1</span>] - preSum[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;        <br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumRegion</span><span class="hljs-params">(<span class="hljs-type">int</span> row1, <span class="hljs-type">int</span> col1, <span class="hljs-type">int</span> row2, <span class="hljs-type">int</span> col2)</span> &#123;<br>        <span class="hljs-keyword">return</span> preSum[row2 + <span class="hljs-number">1</span>][col2 + <span class="hljs-number">1</span>] - preSum[row2 + <span class="hljs-number">1</span>][col1] - preSum[row1][col2 + <span class="hljs-number">1</span>] + preSum[row1][col1];<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your NumMatrix object will be instantiated and called as such:</span><br><span class="hljs-comment"> * NumMatrix obj = new NumMatrix(matrix);</span><br><span class="hljs-comment"> * int param_1 = obj.sumRegion(row1,col1,row2,col2);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230511124011443.png" alt="image-20230511124011443" style="zoom:50%;" /></p>
<h3 id="航班预订统计"><a href="https://leetcode.cn/problems/corporate-flight-bookings/">1109. 航班预订统计</a></h3>
<h2 id="linkedlist">LinkedList</h2>
<h3 id="移除链表元素"><a href="https://leetcode.cn/problems/remove-linked-list-elements/">203. 移除链表元素</a></h3>
<h4 id="解题思路在面对链表树有关创建删除操作使用dummyhead能省去不少边界判定的功夫">解题思路：在面对链表、树有关创建、删除操作，使用dummyHead！能省去不少边界判定的功夫。</h4>
<ol type="1">
<li>初始化：dummyHead指向head，dummyHead赋值给pre，head赋值给cur</li>
<li>当cur的值等于所求val，pre指向cur的下一个节点</li>
<li>当cur的值不等于val，pre移动到cur，cur往后移一位</li>
<li>返回dummyHead的下一个节点。</li>
</ol>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230407173513851.png" alt="image-20230407173513851" style="zoom:50%;" /></p>
<h3 id="设计链表"><a href="https://leetcode.cn/problems/design-linked-list/">707. 设计链表</a></h3>
<h4 id="注意事项dummyhead-size"><strong>注意事项：DummyHead + size</strong></h4>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230407211111582.png" alt="image-20230407211111582" style="zoom:50%;" /></p>
<h3 id="反转链表"><a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></h3>
<p>用笔模拟一下指针pre，cur，next的过程</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230407213816337.png" alt="image-20230407213816337" style="zoom:50%;" /></p>
<ol type="1">
<li><p>时间复杂度：<span class="math inline">\(O(n^2)\)</span></p></li>
<li><p>空间复杂度：<span class="math inline">\(O(1)\)</span></p></li>
</ol>
<h3 id="两两交换链表中的节点"><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></h3>
<h4 id="注意要点用纸和笔模拟一下指针precurnext的过程记得创建dummyhead">注意要点：用纸和笔模拟一下指针pre，cur，next的过程，记得创建dummyHead</h4>
<ol type="1">
<li><p>时间复杂度：<span class="math inline">\(O(n)\)</span></p></li>
<li><p>空间复杂度：<span class="math inline">\(O(1)\)</span></p></li>
</ol>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230408115746409.png" alt=" " style="zoom:50%;" /></p>
<h3 id="删除链表的倒数第-n-个结点"><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h3>
<ol type="1">
<li>使用dummyHead，从dummyHead，找到倒数第N个节点的前一个节点node，需要走链表长度size - N步，即可把node指向下一个节点的下一个节点即可完成删除操作。<br />
</li>
<li>但是链表的长度是未知的，可以先遍历一遍链表的长度，求出size，再走size-N步完成删除操作。</li>
<li>也可以使用快慢指针，fast与slow的起始点都为dummyHead，fast先走N步，再让fast与slow一起右移，当fast走到最后一个节点时(fast.next == null时)，slow右移了size - N步，到达倒数第N个节点的上一个节点，即可完成删除操作。</li>
<li>时间复杂度：<span class="math inline">\(O(n)\)</span></li>
<li>空间复杂度：<span class="math inline">\(O(1)\)</span></li>
</ol>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230408131407107.png" alt="image-20230408131407107" style="zoom:50%;" /></p>
<h3 id="面试题-02.07.-链表相交"><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/">面试题 02.07. 链表相交</a></h3>
<h4 id="方法一hashset">方法一：HashSet</h4>
<ol type="1">
<li>用指针A,B分别指向两个链表头</li>
<li>开始循环，循环的终止条件为A,B都为空，每次循环先将A,B指向的节点放入HashSet，再向后移</li>
<li>当遍历到某个已经存入HashSet的节点时，这个节点就是相交节点；否则没有相交节点</li>
<li>时间复杂度：<span class="math inline">\(O(m + n)\)</span>，其中m，n分别为两个链表的长度</li>
<li>空间复杂度：<span class="math inline">\(O(m + n)\)</span></li>
</ol>
<h4 id="方法二双指针-2">方法二：双指针</h4>
<p><strong>解题思路</strong>：A,B分别指向headA,headB，如果有公共节点，设公共节点长度为c，链表A和B长度分别为a,b。向右遍历，如何为空，则指向另一个链表的头。如果两个链表相交，则A向右移动了a+c+b步，B向右移动了b+c+a时相交，返回A；如果两个链表不相交，则A向右移动了a+b步，B向右移动了b+a步，都为空，退出循环返回null。</p>
<ol type="1">
<li>用指针A,B分别指向两个链表头headA,headB</li>
<li>开始循环，循环的条件是A和B不都为空，如果A为空，则A指向headB，否则向后移；如果B为空，则B指向headA，否则向后移</li>
<li>开始循环，循环的终止条件为A,B都为空，每次循环先将A,B指向的节点放入HashSet，再向后移</li>
<li>当遍历到某个已经存入HashSet的节点时，这个节点就是相交节点；否则没有相交节点</li>
<li>时间复杂度：<span class="math inline">\(O(m + n)\)</span>，其中m，n分别为两个链表的长度</li>
<li>空间复杂度：<span class="math inline">\(O(m + n)\)</span></li>
</ol>
<p>一个错误代码实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> &#123;<br>        <span class="hljs-keyword">if</span> (headA == <span class="hljs-literal">null</span> || headB == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pA</span> <span class="hljs-operator">=</span> headA, pB = headB;<br>        <span class="hljs-keyword">while</span> (pA != <span class="hljs-literal">null</span> || pB != <span class="hljs-literal">null</span>) &#123;<br>            pA = pA == <span class="hljs-literal">null</span> ? headB : pA.next;<br>            pB = pB == <span class="hljs-literal">null</span> ? headA : pB.next;<br>            <span class="hljs-keyword">if</span> (pA == pB)<br>                <span class="hljs-keyword">return</span> pA;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>错误如下，当两个链表只有公共部分节点1时，上述代码没有先判断，先向右移，结果指向A,B都为空，返回空。</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230408141854779.png" alt="image-20230408141854779" style="zoom:50%;" /></p>
<p>所以解决方案是把判断AB相等的语句放在指针移动上面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> &#123;<br>        <span class="hljs-keyword">if</span> (headA == <span class="hljs-literal">null</span> || headB == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pA</span> <span class="hljs-operator">=</span> headA, pB = headB;<br>        <span class="hljs-keyword">while</span> (pA != <span class="hljs-literal">null</span> || pB != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (pA == pB)<br>                <span class="hljs-keyword">return</span> pA;<br>            pA = pA == <span class="hljs-literal">null</span> ? headB : pA.next;<br>            pB = pB == <span class="hljs-literal">null</span> ? headA : pB.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>成功</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230408142109879.png" alt="image-20230408142109879" style="zoom:50%;" /></p>
<h6 id="优化">优化</h6>
<ol type="1">
<li>当A,B只有公共部分时，直接返回结果</li>
<li>当A,B有自己的部分也相交时
<ol type="1">
<li>当A,B公共部分前面节点数量相同时，遍历到相交节点直接返回结果</li>
<li>当A,B公共部分前面节点数量不同时，遍历a+b+c步也会相交，返回结果</li>
</ol></li>
<li>当A,B不相交时，遍历完a+ 1(null) + b + 1(null) 步后，A和B都为null，返回的A为null，表示不相交</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> &#123;<br>        <span class="hljs-keyword">if</span> (headA == <span class="hljs-literal">null</span> || headB == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pA</span> <span class="hljs-operator">=</span> headA, pB = headB;<br>        <span class="hljs-keyword">while</span> (pA != pB) &#123;<br>            pA = pA == <span class="hljs-literal">null</span> ? headB : pA.next;<br>            pB = pB == <span class="hljs-literal">null</span> ? headA : pB.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pA;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="环形链表-ii"><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h4>
<p><strong>解题思路：</strong>快慢指针，慢指针走一步，快指针走两步，如果有环，快指针总能在环中追上慢指针。当快指针和慢指针指向同一节点时，把快节点指向头节点，慢节点不动，快慢指针一起走，再次相遇时，指向的节点就是入环的第一个节点。</p>
<ol type="1">
<li>时间复杂度：<span class="math inline">\(O(m + n)\)</span>，其中m，n分别为两个链表的长度</li>
<li>空间复杂度：<span class="math inline">\(O(m + n)\)</span></li>
</ol>
<hr />
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">detectCycle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head.next.next, slow = head.next;<br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>) &#123;<br>            fast = fast.next.next;<br>            slow = slow.next;<br>            <span class="hljs-keyword">if</span> (fast == slow) &#123;<br>                fast = head;<br>                <span class="hljs-keyword">while</span> (fast != slow) &#123;<br>                    fast = fast.next;<br>                    slow = slow.next;<br>                &#125;<br>            <span class="hljs-keyword">return</span> fast;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230408150523230.png" alt="image-20230408150523230" style="zoom:50%;" /></p>
<h3 id="剑指-offer-ii-026.-重排链表"><a href="https://leetcode.cn/problems/LGjMqU/">剑指 Offer II 026. 重排链表</a></h3>
<h4 id="方法一翻转合并">方法一：翻转合并</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reorderList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head, fast = head.next;<br>        <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>) &#123;<br>            fast = fast.next.next;<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> cur;<br>        fast = mid.next;<br>        mid.next = <span class="hljs-literal">null</span>;<br>        fast = reverse(fast);<br>        cur = head;<br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">next1</span> <span class="hljs-operator">=</span> cur.next, next2 = fast.next;<br>            cur.next = fast;<br>            fast.next = next1;<br>            cur = next1;<br>            fast = next2;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> ListNode <span class="hljs-title function_">reverse</span><span class="hljs-params">(ListNode cur)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>, next = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            next = cur.next;<br>            cur.next = pre;<br>            pre = cur;<br>            cur = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;	<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230518161042144.png" alt="image-20230518161042144" style="zoom:50%;" /></p>
<h3 id="剑指-offer-ii-025.-链表中的两数相加"><a href="https://leetcode.cn/problems/lMSNwu/">剑指 Offer II 025. 链表中的两数相加</a></h3>
<h4 id="方法一翻转三次">方法一：翻转三次</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">addTwoNumbers</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>        l1 = reverse(l1);<br>        l2 = reverse(l2);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> addReversedList(l1, l2);<br>        <span class="hljs-keyword">return</span> reverse(res);<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> ListNode <span class="hljs-title function_">addReversedList</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">carry</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-literal">null</span> || l2 != <span class="hljs-literal">null</span>) &#123;<br>            l1 = l1 == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : l1;<br>            l2 = l2 == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : l2;<br>            sum = (l1 == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : l1.val) + (l2 == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : l2.val) + carry;<br>            carry = sum &gt;= <span class="hljs-number">10</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>            sum = sum &gt;= <span class="hljs-number">10</span> ? sum - <span class="hljs-number">10</span> : sum;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(sum);<br>            cur.next = newNode;<br>            cur = cur.next;<br>            l1 = l1 == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : l1.next;<br>            l2 = l2 == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : l2.next;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (carry == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">1</span>);<br>            cur.next = newNode;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> ListNode <span class="hljs-title function_">reverse</span><span class="hljs-params">(ListNode cur)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>, next = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            next = cur.next;<br>            cur.next = pre;<br>            pre = cur;<br>            cur = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230518164308933.png" alt="image-20230518164308933" style="zoom:50%;" /></p>
<h4 id="方法二翻转两次最后一次不需要翻转">方法二：翻转两次(最后一次不需要翻转)</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">addTwoNumbers</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>        l1 = reverse(l1);<br>        l2 = reverse(l2);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> addReversedList(l1, l2);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> ListNode <span class="hljs-title function_">addReversedList</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">carry</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-literal">null</span> || l2 != <span class="hljs-literal">null</span>) &#123;<br>            l1 = l1 == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : l1;<br>            l2 = l2 == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : l2;<br>            sum = (l1 == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : l1.val) + (l2 == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : l2.val) + carry;<br>            carry = sum &gt;= <span class="hljs-number">10</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>            sum = sum &gt;= <span class="hljs-number">10</span> ? sum - <span class="hljs-number">10</span> : sum;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(sum);<br>            cur = dummy.next;<br>            dummy.next = newNode;<br>            newNode.next = cur;<br><br>            l1 = l1 == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : l1.next;<br>            l2 = l2 == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : l2.next;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (carry == <span class="hljs-number">1</span>) &#123;<br>            cur = dummy.next;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">1</span>);<br>            dummy.next = newNode;<br>            newNode.next = cur;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> ListNode <span class="hljs-title function_">reverse</span><span class="hljs-params">(ListNode cur)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>, next = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            next = cur.next;<br>            cur.next = pre;<br>            pre = cur;<br>            cur = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230518164954170.png" alt="image-20230518164954170" style="zoom:50%;" /></p>
<h2 id="hash-table">Hash Table</h2>
<h3 id="有效的字母异位词"><a href="https://leetcode.cn/problems/valid-anagram/">242. 有效的字母异位词</a></h3>
<h4 id="方法一双hashmap记录词频">方法一：双HashMap记录词频</h4>
<ol type="1">
<li>判断s与t的长度，若不相等，则一定不是字母异位词</li>
<li>建立两个HashMap&lt;Character, Integer&gt;</li>
<li>遍历字符串，将每个字符存入map中，并将值+1</li>
<li>如果map1与map2的size不相等，则一定不是字母异位词</li>
<li>遍历map1(我遍历的是字符串)，get字符串s，t的每一个字符出现了的次数，判断是否相同，如果不同，则一定不是字母异位词。</li>
<li>时间复杂度：<span class="math inline">\(O(n)\)</span>，其中n为第一个字符串的长度</li>
<li>空间复杂度：<span class="math inline">\(O(1)\)</span></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAnagram</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-keyword">if</span> (len != t.length())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <br>        Map&lt;Character, Integer&gt; map1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(), map2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">sChar</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-type">char</span> <span class="hljs-variable">tChar</span> <span class="hljs-operator">=</span> t.charAt(i);<br>            map1.put(sChar, map1.getOrDefault(sChar, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            map2.put(tChar, map2.getOrDefault(tChar, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sSize</span> <span class="hljs-operator">=</span> map1.get(s.charAt(i));<br>            <span class="hljs-type">int</span> <span class="hljs-variable">tSize</span> <span class="hljs-operator">=</span> map2.getOrDefault(s.charAt(i), <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">if</span> (sSize != tSize) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="C:\Users\ning\AppData\Roaming\Typora\typora-user-images\image-20230410091052990.png" alt="image-20230410091052990" style="zoom:50%;" /></p>
<h4 id="方法二数组">方法二：数组</h4>
<ol type="1">
<li><strong>数组其实就是一个简单哈希表</strong>，而且这道题目中字符串只有小写字符，那么就可以定义一个数组，来记录字符串s里字符出现的次数。</li>
<li>定一个数组record，大小为26 ，初始化为0，因为字符a到字符z的ASCII也是26个连续的数值。</li>
<li>遍历第一个字符串s时，只需要将s.charAt(i) - ‘a’所在的元素+1，这样统计了字符串s中每个字符出现的次数。</li>
<li>同样，遍历第二个字符串t时，只需要将t.charAt(i) - ‘a’所在的元素-1。</li>
<li>如果record全部元素为0，那么s和t是字母异位词；否则不是。</li>
<li>时间复杂度：<span class="math inline">\(O(n)\)</span>，其中n为第一个字符串的长度</li>
<li>空间复杂度：<span class="math inline">\(O(1)\)</span>，只使用了常数大小的辅助数组。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAnagram</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-keyword">if</span> (s.length() != t.length())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span>[] record = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); ++i)  &#123;<br>            ++record[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>];<br>            --record[t.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; ++i) <br>            <span class="hljs-keyword">if</span> (record[i] != <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230410095746919.png" alt="image-20230410095746919" style="zoom:50%;" /></p>
<h3 id="两个数组的交集"><a href="https://leetcode.cn/problems/intersection-of-two-arrays/">349. 两个数组的交集</a></h3>
<h4 id="解题思路双hashset">解题思路：双HashSet</h4>
<ol type="1">
<li>首先使用一个HashSet命名为set，记录第一个数组中不包含重复的所有元素</li>
<li>再用一个HashSet命名为intersection，遍历第二个数组，如果第二个数组中的元素在set中，则加入intersection中</li>
<li>最后将intersection转换为数组，并返回</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] intersection(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2) &#123;<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        Set&lt;Integer&gt; intersection = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums1.length; ++i)<br>            set.add(nums1[i]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums2.length; ++i) <br>            <span class="hljs-keyword">if</span> (set.contains(nums2[i]))<br>                intersection.add(nums2[i]);<br>        <span class="hljs-type">int</span>[] result  = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[intersection.size()];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> element : intersection) &#123;<br>            result[i++] = element;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230410102254619.png" alt="image-20230410102254619" style="zoom:50%;" /></p>
<h3 id="快乐数"><a href="https://leetcode.cn/problems/happy-number/">202. 快乐数</a></h3>
<p><strong>求和的过程中，sum会重复出现，用HashSet记录每一次求和，如果有重复，那么必定不是快乐数。</strong></p>
<p><strong>注意：</strong>sum += (n % 10) * (n % 10);+=的优先级高于%。</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230410105016176.png" alt="image-20230410105016176" style="zoom:50%;" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHappy</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (n != <span class="hljs-number">1</span> &amp;&amp; !set.contains(n)) &#123;<br>            set.add(n);<br>            n = getSum(n);<br>        &#125;<br>        <span class="hljs-keyword">return</span> n == <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSum</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) &#123;<br>            sum += (n % <span class="hljs-number">10</span>) * (n % <span class="hljs-number">10</span>);<br>            n /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230410104545810.png" alt="image-20230410104545810" style="zoom:50%;" /></p>
<h3 id="两数之和"><a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></h3>
<h4 id="方法一暴力-3">方法一：暴力</h4>
<p><strong>注意初始化int数组：new int[]{i, j};</strong></p>
<ol type="1">
<li>时间复杂度：<span class="math inline">\(O(n^2)\)</span>，其中n为第一个字符串的长度</li>
<li>空间复杂度：<span class="math inline">\(O(1)\)</span>，只使用了常数大小的辅助数组。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">1</span>; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j  &lt; nums.length; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (nums[i] + nums[j] == target) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, j&#125;;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="方法二hashmap">方法二：HashMap</h4>
<p><strong>解题思路</strong>：</p>
<ol type="1">
<li>建立一个HashMap，key为数组的值，value为数组索引</li>
<li>遍历一遍，每次遍历判断哈希表中是否存在key为target-nums[i]，如果有，则这个key对应的value与i即为所求</li>
<li>时间复杂度：<span class="math inline">\(O(n)\)</span></li>
<li>空间复杂度：<span class="math inline">\(O(n)\)</span></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (map.containsKey(target - nums[i])) <br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;map.get(target - nums[i]), i&#125;;<br>            map.put(nums[i], i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230410113139219.png" alt="image-20230410113139219" style="zoom:50%;" /></p>
<h3 id="四数相加-ii"><a href="https://leetcode.cn/problems/4sum-ii/">454. 四数相加 II</a></h3>
<h4 id="解题思路">解题思路：</h4>
<ol type="1">
<li>用HashMap用两层循环记录前两个数组每个元素之和为key，<code>和</code>出现的次数为value</li>
<li>再两次循环后两个数组，如果map.containsKey(- i - j)，那么- i - j与当前i + j之和为0，即为本题所求，则把result加上和为<code>- i - j</code>的数量</li>
<li>时间复杂度：<span class="math inline">\(O(n^2)\)</span>，两层循环</li>
<li>空间复杂度：<span class="math inline">\(O(n^2)\)</span>，在最坏情况下，前两个数组的元素各不相同，map占n * n</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fourSumCount</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2, <span class="hljs-type">int</span>[] nums3, <span class="hljs-type">int</span>[] nums4)</span> &#123;<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums1.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                map.put(nums1[i] + nums2[j], map.getOrDefault(nums1[i] + nums2[j], <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : nums3) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j : nums4) &#123;<br>                <span class="hljs-keyword">if</span> (map.containsKey(- i - j))<br>                    result += map.get(- i - j);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230411090436663.png" alt="image-20230411090436663" style="zoom:50%;" /></p>
<h3 id="赎金信"><a href="https://leetcode.cn/problems/ransom-note/">383. 赎金信</a></h3>
<h4 id="解题思路字母表">解题思路：字母表</h4>
<ol type="1">
<li>如果ransomNote的长度大于magazine的长度，直接返回false</li>
<li>新建一个长度为26的字母表，以及一个HashMap，key为字母-‘a’，value为字母出现的次数，将magazine中的每个字符put进map</li>
<li>遍历ransomNote的所有字符i，如果map中key为字符i的value大于0，那么把这个value减一；如果map中key为字符i的value小于等于0，说明magazine不存在字符i或者字符i的个数小于ransomNote中字符i的个数，那么 <code>ransomNote</code> 能不能由 <code>magazine</code> 里面的字符构成，返回false</li>
<li>时间复杂度：<span class="math inline">\(O(n)\)</span>，两层循环</li>
<li>空间复杂度：<span class="math inline">\(O(1)\)</span>，只需要常数大小的辅助空间</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canConstruct</span><span class="hljs-params">(String ransomNote, String magazine)</span> &#123;<br>        <span class="hljs-keyword">if</span> (ransomNote.length() &gt; magazine.length())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">char</span>[] record = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">26</span>];<br>        Map&lt; Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; magazine.length(); ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> magazine.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            map.put(index, map.getOrDefault(index, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125; <br>           <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; ransomNote.length(); ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> ransomNote.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (map.getOrDefault(index, <span class="hljs-number">0</span>) &gt; <span class="hljs-number">0</span>) &#123;<br>                map.put(index, map.get(index) - <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230411092655653.png" alt="image-20230411092655653" style="zoom:50%;" /></p>
<h3 id="x15.-三数之和"><a href="https://leetcode.cn/problems/3sum/">x15. 三数之和</a></h3>
<p><strong>题目要求：</strong></p>
<ol type="1">
<li>nums[i],nums[j],nums[k]中i,j,k各不相同</li>
<li>输出的nums[i],nums[j],nums[k]不能重复，如果结果集合中有{1,2,3}了，就不能再加入一个{1,2,3}</li>
<li><strong>不能有重复的三元组，但三元组内的元素是可以重复的！</strong>{0,0,0},{-1,-1,2}是允许的</li>
</ol>
<h4 id="方法一暴力-4">方法一：暴力</h4>
<ol type="1">
<li><p><strong>注意</strong>：{1，2，3}和{3， 2， 1}是不同的元素！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">set.add(Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>));<br>set.add(Arrays.asList(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>));<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>[<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure></li>
<li><p>找到符合的元素先排序，如何hashset中不存在再加入list中。</p></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">threeSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Set&lt;List&lt;Integer&gt;&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        List&lt;List&lt;Integer&gt;&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">2</span>; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j  &lt;nums.length - <span class="hljs-number">1</span>; ++j) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> j + <span class="hljs-number">1</span>; k &lt; nums.length; ++k) &#123;<br>                    <span class="hljs-keyword">if</span> (nums[i] + nums[j] + nums[k] == <span class="hljs-number">0</span>) &#123;<br>                        List&lt;Integer&gt; temp = Arrays.asList(nums[i], nums[j], nums[k]);<br>                        Collections.sort(temp);<br>                        <span class="hljs-keyword">if</span> (!set.contains(temp)) &#123;<br>                            set.add(temp);<br>                            list.add(temp);<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>超时</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230411100538160.png" alt="image-20230411100538160" style="zoom:50%;" /></p>
<h4 id="方法二排序-双指针">方法二：排序 + 双指针</h4>
<ol type="1">
<li><strong>去重思路</strong></li>
<li><strong>边界判断</strong></li>
<li>时间复杂度：<span class="math inline">\(O(n^2)\)</span>，两层循环</li>
<li>空间复杂度：<span class="math inline">\(O(1)\)</span></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">threeSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        Arrays.sort(nums);<br>        <span class="hljs-comment">// window: [nums[i], left, right]</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">2</span>; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">// 去重</span><br>            <span class="hljs-comment">// 为什么不是nums[i] = nums[i + 1]?</span><br>            <span class="hljs-comment">// 比如&#123;-1，-1，2&#125;</span><br>            <span class="hljs-comment">// 如果是nums[i] = nums[i + 1]，那么&#123;-1，-1，2&#125;这个结果不会被选中</span><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) <br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>, right = nums.length - <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 只能选取数组中不同下标的三个数，所以left == right时会使用同一个数，不执行</span><br>            <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> nums[i] + nums[left] + nums[right];<br>                <span class="hljs-keyword">if</span> (sum &lt; <span class="hljs-number">0</span>)<br>                    ++left;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; <span class="hljs-number">0</span>)<br>                    --right;<br>                <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// sum == 0</span><br>                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));<br>                    <span class="hljs-comment">// 去重</span><br>                    <span class="hljs-comment">// 必须在添加完结果后去重，不然第一次的结果可能无法添加</span><br>                    <span class="hljs-keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>])<br>                        --right;<br>                    <span class="hljs-keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>])<br>                        ++left;<br>                    <span class="hljs-comment">// 为什么两个指针都移动？去重之后，只移动一个，结果必定不等于0</span><br>                    --right;<br>                    ++left;<br>                &#125; <br><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230411110927008.png" alt="image-20230411110927008" style="zoom:50%;" /></p>
<h3 id="四数之和"><a href="https://leetcode.cn/problems/4sum/">18. 四数之和</a></h3>
<ol type="1">
<li><p><strong>注意事项</strong>：nums[i]的范围，如果4个数都等于<span class="math inline">\(10^9\)</span>，</p>
<p>那么将大于<span class="math inline">\(2^{31} - 1= 2147483648 &lt; 2.15 * 10^9\)</span>(int最大的正数)，所以要用long记录四数之和</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230411112910460.png" alt=" " style="zoom:50%;" /></p></li>
<li><p>在三数之和的基础上，再增加一层循环，</p>
<p>区间为[nums[i], nums[left], nums[right], nums[j]]</p></li>
<li><p>时间复杂度：<span class="math inline">\(O(n^3)\)</span>，三层循环</p></li>
<li><p>空间复杂度：<span class="math inline">\(O(n)\)</span>，排序使用了额外的数组存储数组nums的副本</p></li>
</ol>
<h4 id="剪枝">剪枝</h4>
<ol type="1">
<li><p><strong>第一层循环中，如果最小的四数之和大于target，那么后面的数更大，break</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">\\ 第一层循环<br><span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span>) nums[i] + nums[i + <span class="hljs-number">1</span>] + nums[i + <span class="hljs-number">2</span>] + nums[i + <span class="hljs-number">1</span>] &gt; target)<br>    <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure></li>
<li><p><strong>第二层循环中，如果最大的四数之和小于target，那么前面的数更小，break</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">\\ 第二层循环<br><span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span>) nums[i] + nums[j] + nums[j - <span class="hljs-number">1</span>] + nums[j - <span class="hljs-number">2</span>] &lt; target)<br>    <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure></li>
</ol>
<p>完整代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">fourSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span> (length &lt; <span class="hljs-number">4</span>)<br>            <span class="hljs-keyword">return</span> result;<br>        Arrays.sort(nums);<br>        <span class="hljs-comment">// window: [nums[i], nums[left], nums[right], nums[j]]</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length - <span class="hljs-number">3</span>; ++i) &#123;<br>            <span class="hljs-comment">// 去重</span><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>])<br>                <span class="hljs-keyword">continue</span>;<br>            <br>            <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span>) nums[i] + nums[i + <span class="hljs-number">1</span>] + nums[i + <span class="hljs-number">2</span>] + nums[i + <span class="hljs-number">1</span>] &gt; target)<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">// 第4个数从尾开始遍历，举例&#123;-1, -1, 0, 2&#125;来确定j &gt; 2这个边界条件</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> length - <span class="hljs-number">1</span>; j &gt; <span class="hljs-number">2</span>; --j) &#123;<br>                <span class="hljs-comment">// 去重，如果使用nums[j] == nums[j - 1]判断，nums[j - 1]属于right的范围</span><br>                <span class="hljs-comment">// 那么&#123;-1，-1，1, 1&#125;这个结果不会被选中</span><br>                <span class="hljs-keyword">if</span> (j &lt; length - <span class="hljs-number">1</span> &amp;&amp; nums[j] == nums[j + <span class="hljs-number">1</span>])<br>                    <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span>) nums[i] + nums[j] + nums[j - <span class="hljs-number">1</span>] + nums[j - <span class="hljs-number">2</span>] &lt; target)<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>, right = j - <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">// 只能选取数组中不同下标的三个数，所以left == right时会使用同一个数，不执行</span><br>                <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>                    <span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> (<span class="hljs-type">long</span>) nums[i] + nums[left] + nums[right] + nums[j];<br>                    <span class="hljs-keyword">if</span> (sum &lt; target)<br>                        ++left;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; target)<br>                        --right;<br>                    <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// sum == target</span><br>                        result.add(Arrays.asList(nums[i], nums[left], nums[right], nums[j]));<br>                        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>])<br>                            ++left;<br>                        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>])<br>                            --right;<br>                        ++left;<br>                        --right;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230411121859458.png" alt="image-20230411121859458" style="zoom:50%;" /></p>
<h3 id="剑指-offer-ii-030.-插入删除和随机访问都是-o1-的容器"><a href="https://leetcode.cn/problems/FortPu/">剑指 Offer II 030. 插入、删除和随机访问都是 O(1) 的容器</a></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RandomizedSet</span> &#123;<br><br>    List&lt;Integer&gt; list;<br>    Map&lt;Integer, Integer&gt; map;<br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RandomizedSet</span><span class="hljs-params">()</span> &#123;<br>        list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Inserts a value to the set. Returns true if the set did not already contain the specified element. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span> (map.containsKey(val))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        list.add(val);<br>        map.put(val, list.size() - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Removes a value from the set. Returns true if the set contained the specified element. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!map.containsKey(val))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> map.get(val);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">lastVal</span> <span class="hljs-operator">=</span> list.get(list.size() - <span class="hljs-number">1</span>);<br>        list.set(index, lastVal);<br>        list.remove(list.size() - <span class="hljs-number">1</span>);<br>        map.put(lastVal ,index);<br>        map.remove(val);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Get a random element from the set. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getRandom</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>        <span class="hljs-keyword">return</span> list.get(random.nextInt(list.size()));<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your RandomizedSet object will be instantiated and called as such:</span><br><span class="hljs-comment"> * RandomizedSet obj = new RandomizedSet();</span><br><span class="hljs-comment"> * boolean param_1 = obj.insert(val);</span><br><span class="hljs-comment"> * boolean param_2 = obj.remove(val);</span><br><span class="hljs-comment"> * int param_3 = obj.getRandom();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230510160353588.png" alt="image-20230510160353588" style="zoom:50%;" /></p>
<h3 id="剑指-offer-ii-031.-最近最少使用缓存"><a href="https://leetcode.cn/problems/OrIXps/">剑指 Offer II 031. 最近最少使用缓存</a></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;<br>        <span class="hljs-type">int</span> key;<br>        <span class="hljs-type">int</span> val;<br>        ListNode pre;<br>        ListNode next;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">ListNode</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> val)</span> &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>            <span class="hljs-built_in">this</span>.key = key;<br>        &#125;<br>    &#125;<br>    ListNode head, tail;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;<br>    Map&lt;Integer, ListNode&gt; map;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LRUCache</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>        head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>);<br>        tail = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>);<br>        head.next = tail;<br>        tail.pre = head;<br>        map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!map.containsKey(key))<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        moveToTail(key);<br>        <span class="hljs-keyword">return</span> map.get(key).val;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-keyword">if</span> (map.containsKey(key)) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> map.get(key);<br>            node.val = value;<br>            map.put(key, node);<br>            moveToTail(key);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// do not exist</span><br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(key, value);<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.capacity != map.size()) &#123; <span class="hljs-comment">// not full</span><br>                insertAtTail(node);<br>                map.put(key, node);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// full</span><br>                <span class="hljs-type">ListNode</span> <span class="hljs-variable">toDelete</span> <span class="hljs-operator">=</span> head.next;<br>                delete(toDelete);<br>                map.remove(toDelete.key);<br>                insertAtTail(node);<br>                map.put(key, node);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveToTail</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> map.get(key);<br>        <span class="hljs-keyword">if</span> (node.next == tail)<br>            <span class="hljs-keyword">return</span>;<br>        delete(node);<br>        insertAtTail(node);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(ListNode node)</span> &#123;<br>        node.pre.next = node.next;<br>        node.next.pre = node.pre;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertAtTail</span><span class="hljs-params">(ListNode node)</span> &#123;<br>        node.pre = tail.pre;<br>        node.next = tail;<br>        node.pre.next = node;<br>        tail.pre = node;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your LRUCache object will be instantiated and called as such:</span><br><span class="hljs-comment"> * LRUCache obj = new LRUCache(capacity);</span><br><span class="hljs-comment"> * int param_1 = obj.get(key);</span><br><span class="hljs-comment"> * obj.put(key,value);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230510164346020.png" alt="image-20230510164346020" style="zoom:50%;" /></p>
<h2 id="stack-and-queue">Stack and Queue</h2>
<h3 id="用栈实现队列"><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></h3>
<p><strong>解题思路</strong>：使用两个栈，inStack,outStack来实现队列。</p>
<p>push：直接将元素push进inStack</p>
<p>pop：如果outStack不为空，则弹出outStack顶部元素；如果outStack为空，则将inStack中的元素全部弹入inStack，再弹出outStack顶部元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; inStack;<br>    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; outStack;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyQueue</span><span class="hljs-params">()</span> &#123;<br>        inStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        outStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    &#125;<br>    <br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        inStack.push(x);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (outStack.isEmpty()) &#123;<br>           pushIntoOut();<br>        &#125;<br>        <span class="hljs-keyword">return</span> outStack.pop();<br><br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (outStack.isEmpty()) <br>            pushIntoOut();<br>        <span class="hljs-keyword">return</span> outStack.peek();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">empty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> inStack.isEmpty() &amp;&amp; outStack.isEmpty();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pushIntoOut</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (!inStack.isEmpty()) &#123;<br>            outStack.push(inStack.pop());<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyQueue obj = new MyQueue();</span><br><span class="hljs-comment"> * obj.push(x);</span><br><span class="hljs-comment"> * int param_2 = obj.pop();</span><br><span class="hljs-comment"> * int param_3 = obj.peek();</span><br><span class="hljs-comment"> * boolean param_4 = obj.empty();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230414093413671.png" alt="image-20230414093413671" style="zoom:50%;" /></p>
<h3 id="用队列实现栈"><a href="https://leetcode.cn/problems/implement-stack-using-queues/">225. 用队列实现栈</a></h3>
<h4 id="方法一单队列">方法一：单队列</h4>
<p>push：直接将元素加入queue</p>
<p>pop()：首先将队列元素移除并重新加入queue.size() - 1次，这样底部的元素就在队列首部了，poll出来即可</p>
<p>peek()：首先将队列元素移除并重新加入queue.size() - 1次，这样底部的元素就在队列首部了，<strong>先用result接收queue.peek()，再将这个元素移除并重新加入，最后返回result</strong>，peek()操作是不能改变内部数据的！！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Queue&lt;Integer&gt; queue;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyStack</span><span class="hljs-params">()</span> &#123;<br>        queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        queue.offer(x);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        catchBottom();<br>        <span class="hljs-keyword">return</span> queue.poll();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>        catchBottom();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> queue.peek();<br>        queue.offer(queue.poll());<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">empty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> queue.isEmpty();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">catchBottom</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; queue.size() - <span class="hljs-number">1</span>; ++i) &#123;<br>            queue.offer(queue.poll());<br>        &#125;<br>    &#125;<br>&#125;	<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230414095606813.png" alt="image-20230414095606813" style="zoom:50%;" /></p>
<h5 id="优化-1"><strong>优化</strong></h5>
<p><strong>在面对大量需要查看顶部元素业务的时候，每次都要重新出队入队n次，不如在push的时候就排好序，</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    queue.offer(x);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; queue.size() - <span class="hljs-number">1</span>; ++i) &#123;<br>        queue.offer(queue.poll());<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> queue.poll();<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> queue.peek();<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="方法二双队列">方法二：双队列</h4>
<p>push：先在辅助队列supportQueue中加入目标数据，再将主队列queue中的数据全部弹出并加入到supportQueue中，这个时候supportQueue就是先进后出的排列顺序，最后将queue和support交换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack</span> &#123;<br><br>    Queue&lt;Integer&gt; queue, supportQueue;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyStack</span><span class="hljs-params">()</span> &#123;<br>        queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        supportQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        supportQueue.offer(x);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            supportQueue.offer(queue.poll());<br>        &#125;<br>        Queue&lt;Integer&gt; temp = queue;<br>        queue = supportQueue;<br>        supportQueue = temp;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> queue.poll();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> queue.peek();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">empty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> queue.isEmpty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230414105115572.png" alt="image-20230414105115572" style="zoom:50%;" /></p>
<h3 id="有效的括号"><a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></h3>
<h4 id="方法一hashmap-stack">方法一：HashMap + Stack</h4>
<p><strong>注意事项：</strong>如果是左括号，直接push进栈</p>
<p>如果是右括号，如果栈为空那么匹配不了；如果右括号和栈顶部的左括号不匹配，也不满足</p>
<p>最后如果栈空，则是有效的括号；否则不是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String s)</span> &#123;<br>        Map&lt;Character, Character&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-string">&#x27;&#123;&#x27;</span>, <span class="hljs-string">&#x27;&#125;&#x27;</span>);<br>        map.put(<span class="hljs-string">&#x27;(&#x27;</span>, <span class="hljs-string">&#x27;)&#x27;</span>);<br>        map.put(<span class="hljs-string">&#x27;[&#x27;</span>, <span class="hljs-string">&#x27;]&#x27;</span>);<br>        Stack&lt;Character&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); ++i) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-keyword">if</span> (map.containsKey(c))<br>                stack.push(c);<br>            <span class="hljs-keyword">else</span> &#123;    <br>                <span class="hljs-keyword">if</span> (stack.isEmpty() || map.get(stack.pop()) != c) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack.isEmpty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230414114954260.png" alt="image-20230414114954260" style="zoom:50%;" /></p>
<h3 id="删除字符串中的所有相邻重复项"><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">1047. 删除字符串中的所有相邻重复项</a></h3>
<h4 id="方法一stringbuilder">方法一：StringBuilder</h4>
<p>如果当前字符和前一个字符相等，则删除当前字符；否则加入当前字符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">removeDuplicates</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); ++i) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-keyword">if</span> (sb.length() == <span class="hljs-number">0</span> || c != sb.charAt(index)) &#123;<br>                sb.append(c);<br>                ++index;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                sb.deleteCharAt(index);<br>                --index;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230414133222696.png" alt="image-20230414133222696" style="zoom:50%;" /></p>
<h3 id="逆波兰表达式求值"><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值</a></h3>
<p><strong>解题思路</strong>： 遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">evalRPN</span><span class="hljs-params">(String[] tokens)</span> &#123;<br>        Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; tokens.length; ++i) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> tokens[i];<br>            <span class="hljs-keyword">if</span> (isNumber(token)) <br>                stack.push(Integer.parseInt(token));<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> stack.pop(), a = stack.pop();<br>                <span class="hljs-keyword">switch</span> (token) &#123;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;+&quot;</span>:<br>                        stack.push(a + b);<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;-&quot;</span>:<br>                        stack.push(a - b);<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;*&quot;</span>:<br>                        stack.push(a * b);<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/&quot;</span>:<br>                        stack.push(a / b);<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">default</span>:<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack.pop();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isNumber</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">return</span> !(s.equals(<span class="hljs-string">&quot;+&quot;</span>) || s.equals(<span class="hljs-string">&quot;-&quot;</span>) || s.equals(<span class="hljs-string">&quot;*&quot;</span>) || s.equals(<span class="hljs-string">&quot;/&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230414143824186.png" alt="image-20230414143824186" style="zoom:50%;" /></p>
<p><strong>注意事项</strong>：</p>
<p>在Java中，<code>==</code>和<code>.equals()</code>都是用于比较两个对象是否相等的操作符。但是它们之间存在着不同的用法和含义。</p>
<p><code>==</code>用于比较两个对象的引用是否相等，也就是判断这两个对象是否是同一个对象。当比较两个基本数据类型的值时，它们的值相等时返回true；当比较两个引用类型的对象时，如果它们所指向的内存地址相同，也就是它们是同一个对象时，返回true；否则返回false。</p>
<p><code>.equals()</code>方法用于比较两个对象的内容是否相等。默认情况下，<code>.equals()</code>方法比较的是两个对象的引用是否相等，也就是使用<code>==</code>比较，但是我们可以通过重写<code>.equals()</code>方法来自定义比较规则，比如根据对象的属性值来比较是否相等。</p>
<p>对于字符串类型的变量来说，<code>==</code>和<code>.equals()</code>方法的区别如下：</p>
<ul>
<li><code>==</code>比较的是字符串对象的引用是否相等，也就是它们是否指向同一个内存地址。</li>
<li><code>.equals()</code>方法比较的是字符串对象的内容是否相等，也就是它们包含的字符序列是否相同。</li>
</ul>
<p>因为Java中字符串是一个特殊的对象类型，为了方便字符串的比较操作，Java中提供了一种特殊的机制，也就是"字符串常量池"，它可以缓存字符串对象，使得多个字符串对象可以共享同一个对象，也就是它们的引用相等。在这种情况下，<code>==</code>操作符会返回true。但是在其他情况下，如果不是使用相同的字符串字面量来创建字符串对象，<code>==</code>操作符会返回false，此时需要使用<code>.equals()</code>方法来进行字符串的内容比较。</p>
<h3 id="滑动窗口最大值"><a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></h3>
<h4 id="方法一暴力超时">方法一：暴力（超时）</h4>
<ol type="1">
<li>时间复杂度：<span class="math inline">\(O(kn)\)</span></li>
<li>空间复杂度：<span class="math inline">\(O(n)\)</span>，存储结果的数组</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] maxSlidingWindow(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n - k + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (k &gt; n)<br>            <span class="hljs-keyword">return</span> result;<br>        <span class="hljs-comment">// [i, i + k)</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; result.length; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; i + k; ++j) &#123;<br>                max = Math.max(max, nums[j]);<br>            &#125;<br>            result[i] = max;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230414150733050.png" alt="image-20230414150733050" style="zoom:50%;" /></p>
<h4 id="方法二单调队列">方法二：单调队列</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] maxSlidingWindow(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length - k + <span class="hljs-number">1</span>;<br>        Deque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>            <span class="hljs-keyword">while</span> (!deque.isEmpty() &amp;&amp; nums[i] &gt; nums[deque.peekLast()]) &#123;<br>                deque.pollLast();<br>            &#125;<br>            deque.offerLast(i);<br>        &#125;<br>        <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        result[<span class="hljs-number">0</span>] = nums[deque.peekFirst()];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k; i &lt; nums.length; ++i) &#123;<br>            <span class="hljs-keyword">while</span> (!deque.isEmpty() &amp;&amp; nums[i] &gt; nums[deque.peekLast()]) &#123;<br>                deque.pollLast();<br>            &#125;<br>            deque.offerLast(i);<br>            <span class="hljs-comment">// 如果i的左区间在队首元素右边，则要移除队首元素; 用if就可以了(while也行)</span><br>            <span class="hljs-keyword">if</span> (deque.peekFirst() &lt;= i - k) &#123;<br>                deque.pollFirst();<br>            &#125;<br>            result[i - k + <span class="hljs-number">1</span>] = nums[deque.peekFirst()];<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230414162623319.png" alt="image-20230414162623319" style="zoom:50%;" /></p>
<h3 id="前-k-个高频元素"><a href="https://leetcode.cn/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] topKFrequent(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i) &#123;<br>            map.put(nums[i], map.getOrDefault(nums[i], <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;<span class="hljs-type">int</span>[]&gt;() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">int</span>[] m, <span class="hljs-type">int</span>[] n)</span> &#123;<br>                <span class="hljs-keyword">return</span> m[<span class="hljs-number">1</span>] - n[<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry: map.entrySet()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> entry.getKey(), count = entry.getValue();<br>            <span class="hljs-keyword">if</span> (queue.size() == k) &#123;<br>                <span class="hljs-keyword">if</span> (count &gt; queue.peek()[<span class="hljs-number">1</span>]) &#123;<br>                    queue.poll();<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;num, count&#125;);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;num, count&#125;);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>            result[i] = queue.poll()[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230414172344927.png" alt="image-20230414172344927" style="zoom:50%;" /></p>
<h3 id="优先级队列大根堆小根堆">优先级队列（大根堆、小根堆）</h3>
<p>Java中可以使用PriorityQueue类来创建优先级队列，它实现了一个基于优先级堆的无界优先级队列。</p>
<p>要创建一个大根堆，需要使用Comparator.reverseOrder()方法来创建一个反转自然顺序的比较器，示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">PriorityQueue&lt;Integer&gt; maxHeap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(Comparator.reverseOrder());<br>maxHeap.add(<span class="hljs-number">5</span>);<br>maxHeap.add(<span class="hljs-number">1</span>);<br>maxHeap.add(<span class="hljs-number">10</span>);<br>System.out.println(maxHeap.poll()); <span class="hljs-comment">// 输出10</span><br></code></pre></td></tr></table></figure>
<p>要创建一个小根堆，只需要使用默认的比较器即可，示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">PriorityQueue&lt;Integer&gt; minHeap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>minHeap.add(<span class="hljs-number">5</span>);<br>minHeap.add(<span class="hljs-number">1</span>);<br>minHeap.add(<span class="hljs-number">10</span>);<br>System.out.println(minHeap.poll()); <span class="hljs-comment">// 输出1</span><br></code></pre></td></tr></table></figure>
<p>在上述示例中，我们首先创建了一个空的优先级队列，然后使用add()方法向其中添加元素，使用poll()方法从队列中取出元素并删除。由于大根堆和小根堆的比较器不同，它们会按照不同的顺序取出元素。</p>
<p>除了示例中用到的add()和poll()方法之外，PriorityQueue类还提供了一些其他常用的方法，下面对一些常用方法进行补充说明：</p>
<p>offer(E e): 添加元素到队列中，如果队列已满则抛出异常。</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><code class="hljs lasso">arduinoCopy codePriorityQueue&lt;<span class="hljs-built_in">Integer</span>&gt; <span class="hljs-built_in">queue</span> = <span class="hljs-literal">new</span> PriorityQueue&lt;&gt;();<br><span class="hljs-built_in">queue</span>.offer(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>
<p>peek(): 获取但不删除队列的头部元素，如果队列为空则返回null。</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><code class="hljs lasso">arduinoCopy codePriorityQueue&lt;<span class="hljs-built_in">Integer</span>&gt; <span class="hljs-built_in">queue</span> = <span class="hljs-literal">new</span> PriorityQueue&lt;&gt;();<br><span class="hljs-built_in">queue</span>.offer(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">queue</span>.offer(<span class="hljs-number">2</span>);<br>System.out.println(<span class="hljs-built_in">queue</span>.peek()); <span class="hljs-comment">// 输出1</span><br></code></pre></td></tr></table></figure>
<p>remove(Object o): 从队列中删除指定的元素，如果队列中不存在该元素则返回false。</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><code class="hljs lasso">arduinoCopy codePriorityQueue&lt;<span class="hljs-built_in">Integer</span>&gt; <span class="hljs-built_in">queue</span> = <span class="hljs-literal">new</span> PriorityQueue&lt;&gt;();<br><span class="hljs-built_in">queue</span>.offer(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">queue</span>.offer(<span class="hljs-number">2</span>);<br><span class="hljs-built_in">queue</span>.offer(<span class="hljs-number">3</span>);<br>System.out.println(<span class="hljs-built_in">queue</span>.remove(<span class="hljs-number">2</span>)); <span class="hljs-comment">// 输出true</span><br>System.out.println(<span class="hljs-built_in">queue</span>.remove(<span class="hljs-number">4</span>)); <span class="hljs-comment">// 输出false</span><br>System.out.println(<span class="hljs-built_in">queue</span>); <span class="hljs-comment">// 输出[3, 1]</span><br></code></pre></td></tr></table></figure>
<p>size(): 返回队列中元素的数量。</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><code class="hljs lasso">arduinoCopy codePriorityQueue&lt;<span class="hljs-built_in">Integer</span>&gt; <span class="hljs-built_in">queue</span> = <span class="hljs-literal">new</span> PriorityQueue&lt;&gt;();<br><span class="hljs-built_in">queue</span>.offer(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">queue</span>.offer(<span class="hljs-number">2</span>);<br><span class="hljs-built_in">queue</span>.offer(<span class="hljs-number">3</span>);<br>System.out.println(<span class="hljs-built_in">queue</span>.size()); <span class="hljs-comment">// 输出3</span><br></code></pre></td></tr></table></figure>
<p>clear(): 删除队列中的所有元素。</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><code class="hljs lasso">arduinoCopy codePriorityQueue&lt;<span class="hljs-built_in">Integer</span>&gt; <span class="hljs-built_in">queue</span> = <span class="hljs-literal">new</span> PriorityQueue&lt;&gt;();<br><span class="hljs-built_in">queue</span>.offer(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">queue</span>.offer(<span class="hljs-number">2</span>);<br><span class="hljs-built_in">queue</span>.offer(<span class="hljs-number">3</span>);<br><span class="hljs-built_in">queue</span>.clear();<br>System.out.println(<span class="hljs-built_in">queue</span>); <span class="hljs-comment">// 输出[]</span><br></code></pre></td></tr></table></figure>
<p>还有一些其他的方法，如toArray()、contains()、addAll()等，可以参考Java官方文档进行学习。</p>
<h2 id="greedy">Greedy</h2>
<h3 id="分发饼干"><a href="https://leetcode.cn/problems/assign-cookies/">455. 分发饼干</a></h3>
<h4 id="方法一从小胃口开始喂小饼干">方法一：从小胃口开始喂小饼干</h4>
<ol type="1">
<li>先把两个数组都升序排序，从左往右遍历</li>
<li>如果孩子满足度小于等于饼干满足度，那么++res，并让两个指针都往后移动一位</li>
<li>如果孩子满足度大于饼干满足度，使饼干的指针向后移动一位</li>
<li>直到任意一个指针超出数组范围为止</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findContentChildren</span><span class="hljs-params">(<span class="hljs-type">int</span>[] children, <span class="hljs-type">int</span>[] cookies)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Arrays.sort(children);<br>        Arrays.sort(cookies);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; children.length &amp;&amp; j &lt; cookies.length) &#123;<br>                <span class="hljs-keyword">if</span> (children[i] &lt;= cookies[j]) &#123;<br>                    ++res;<br>                    ++i;<br>                    ++j;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    ++j;                    <br>                &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230419130746268.png" alt="image-20230419130746268" style="zoom:50%;" /></p>
<h4 id="方法二从大胃口开始喂大饼干">方法二：从大胃口开始喂大饼干</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findContentChildren</span><span class="hljs-params">(<span class="hljs-type">int</span>[] children, <span class="hljs-type">int</span>[] cookies)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Arrays.sort(children);<br>        Arrays.sort(cookies);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> children.length - <span class="hljs-number">1</span>, j = cookies.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (children[i] &lt;= cookies[j]) &#123;<br>                ++res;<br>                --i;<br>                --j;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                --i;                    <br>            &#125;   <br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230419132114268.png" alt="image-20230419132114268" style="zoom:50%;" /></p>
<h3 id="摆动序列"><a href="https://leetcode.cn/problems/wiggle-subsequence/">376. 摆动序列</a></h3>
<h4 id="方法一排序删除连续重复元素dp不推荐">方法一：排序+删除连续重复元素+dp(不推荐)</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">wiggleMaxLength</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 1.dp[i]:以nums[i]为结尾，最长的摆动序列</span><br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        list.add(nums[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] != nums[i - <span class="hljs-number">1</span>])<br>                list.add(nums[i]);<br>        &#125;<br>        Integer[] dummy = list.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[<span class="hljs-number">0</span>]);<br><br>        <span class="hljs-keyword">if</span> (dummy.length == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (dummy.length == <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[dummy.length];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// 2.状态转移方程：</span><br>        <span class="hljs-comment">// 1)nums[i] - nums[i - 1]与nums[i - 1] - nums[i- 2]异号：dp[i] = dp[i - 1] + 1</span><br>        <span class="hljs-comment">// 2)nums[i] - nums[i - 1]与nums[i - 1] - nums[i- 2]同号：dp[i] = dp[i - 1]</span><br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; dummy.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> ((dummy[i] - dummy[i - <span class="hljs-number">1</span>]) * (dummy[i - <span class="hljs-number">1</span>] - dummy[i - <span class="hljs-number">2</span>]) &lt; <span class="hljs-number">0</span>) &#123;<br>                dp[i] = dp[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((dummy[i] - dummy[i - <span class="hljs-number">1</span>]) * (dummy[i - <span class="hljs-number">1</span>] - dummy[i - <span class="hljs-number">2</span>]) &gt; <span class="hljs-number">0</span>) &#123;<br>                dp[i] = dp[i - <span class="hljs-number">1</span>];<br>            &#125;<br><br>            res = Math.max(res, dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230419144434630.png" alt="image-20230419144434630" style="zoom:50%;" /></p>
<h4 id="方法二贪心-1">方法二：贪心</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">wiggleMaxLength</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">preDiff</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, postDiff = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">1</span>; ++i) &#123;<br>            postDiff = nums[i + <span class="hljs-number">1</span>] - nums[i];<br>            <span class="hljs-keyword">if</span> ((preDiff &lt;= <span class="hljs-number">0</span> &amp;&amp; postDiff &gt; <span class="hljs-number">0</span>) || (preDiff &gt;= <span class="hljs-number">0</span> &amp;&amp; postDiff &lt; <span class="hljs-number">0</span>)) &#123;<br>                ++result;<br>                preDiff = postDiff;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="C:\Users\ning\AppData\Roaming\Typora\typora-user-images\image-20230505220242464.png" alt="image-20230505220242464" style="zoom:50%;" /></p>
<h4 id="方法三dp-1">方法三：DP</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">wiggleMaxLength</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-type">int</span>[] up = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n], down = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        up[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        down[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; nums[i - <span class="hljs-number">1</span>]) &#123;<br>                up[i] = Math.max(up[i - <span class="hljs-number">1</span>], down[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>                down[i] = down[i - <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] &lt; nums[i - <span class="hljs-number">1</span>]) &#123;<br>                up[i] = up[i - <span class="hljs-number">1</span>];<br>                down[i] = Math.max(down[i - <span class="hljs-number">1</span>], up[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                up[i] = up[i - <span class="hljs-number">1</span>];<br>                down[i] = down[i - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.max(up[n - <span class="hljs-number">1</span>], down[n - <span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230505225359864.png" alt="image-20230505225359864" style="zoom:50%;" /></p>
<h3 id="最大子数组和"><a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></h3>
<h4 id="方法一dp-6">方法一：DP</h4>
<ol type="1">
<li>dp[i]：<strong>以nums[i]结尾的子数组的最大数组和</strong></li>
<li>状态转移方程：
<ol type="1">
<li>当dp[i - 1] &gt;= 0 时候，dp[i] = dp[i - 1] + nums[i]</li>
<li>当dp[i - 1] &lt; 0时候， dp[i] = nums[i]</li>
</ol></li>
<li>初始化：dp[0] = nums[0]</li>
<li>时间复杂度：<span class="math inline">\(O(n)\)</span></li>
<li>空间复杂度：<span class="math inline">\(O(n)\)</span></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">// dp[i]：以nums[i]结尾的子数组的最数组和</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> dp[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (dp[i - <span class="hljs-number">1</span>] &gt;= <span class="hljs-number">0</span>) &#123;<br>                dp[i] = dp[i - <span class="hljs-number">1</span>] + nums[i];<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// dp[i - 1] &lt; 0</span><br>                dp[i] = nums[i];<br>            &#125;<br>            res = Math.max(res, dp[i]);<br>        &#125;  <br>        <span class="hljs-keyword">return</span> res;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230419153618838.png" alt="image-20230419153618838" style="zoom:50%;" /></p>
<h4 id="方法二优化空间的dp">方法二：优化空间的DP</h4>
<p><strong>由于dp[i]只依赖dp[i - 1]，所以可以用一个长度为2的数组记录dp</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">// dp[i]：以nums[i]结尾的子数组的最数组和</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>] &gt;= <span class="hljs-number">0</span>) &#123;<br>                dp[i % <span class="hljs-number">2</span>] = dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>] + nums[i];<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// dp[i - 1] &lt; 0</span><br>                dp[i % <span class="hljs-number">2</span>] = nums[i];<br>            &#125;<br>            res = Math.max(res, dp[i % <span class="hljs-number">2</span>]);<br>        &#125;  <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="贪心">贪心</h4>
<ol type="1">
<li>首先把记录结果的result初始化为最小值，以及count=0</li>
<li>遍历数组，count加上当前元素，如果count大于result，讲count值赋给result</li>
<li>如果count等于负数了，令count等于0，从下一个数开始重新计算</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i) &#123;<br>            count += nums[i];<br>            <span class="hljs-keyword">if</span> (count &gt; result) <br>                result = count;<br>            <span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">0</span>)<br>                count = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230419155937924.png" alt="image-20230419155937924" style="zoom:50%;" /></p>
<h3 id="买卖股票的最佳时机-ii-1"><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></h3>
<p><strong>只要下一天股票价格高于当天，那么就买入当前股票并在下一天卖出</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; prices.length - <span class="hljs-number">1</span>; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">diff</span> <span class="hljs-operator">=</span> prices[i + <span class="hljs-number">1</span>] - prices[i];<br>            <span class="hljs-keyword">if</span> (diff &gt; <span class="hljs-number">0</span>) &#123;<br>                res += diff;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230419161040019.png" alt="image-20230419161040019" style="zoom:50%;" /></p>
<h3 id="跳跃游戏"><a href="https://leetcode.cn/problems/jump-game/">55. 跳跃游戏</a></h3>
<h4 id="方法一贪心">方法一：贪心</h4>
<ol type="1">
<li>初始化一个available数组，available[i]表示是否可以到底数组元素i</li>
<li>如果当前节点是可到达的，令i=0前往后遍历，把available数组从i+1开始，后nums[i]个元素都赋true</li>
<li>初始化：第一个元素是肯定能到达的，初始化为true</li>
<li>时间复杂度：<span class="math inline">\(O(n^2)\)</span>，最坏情况下，所有节点都刚好能到达数组倒数第二个元素，且倒数第二个元素的值为0，如[n - 2, n - 3, ..., 1, 0, 1]，需要遍历<span class="math inline">\(\frac{(n-1)(n-2)}{2}\)</span>次</li>
<li>空间复杂度：<span class="math inline">\(O(n)\)</span></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canJump</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">boolean</span>[] available = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n];<br>        available[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (available[i]) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; nums[i] + i + <span class="hljs-number">1</span>; ++j) &#123;<br>                    <span class="hljs-keyword">if</span> (j == n - <span class="hljs-number">1</span>)<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                    available[j] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> available[n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230419170117014.png" alt="image-20230419170117014" style="zoom:50%;" /></p>
<h4 id="方法二贪心优化空间复杂度">方法二：贪心（优化空间复杂度）</h4>
<p><strong>不必要用一个boolean数组来表示是否可以到达当前数组元素，可以用一个整数rightmost来判断</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canJump</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rightmost</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (i &lt;= rightmost) &#123;<br>                rightmost = Math.max(rightmost, i + nums[i]);<br>                <span class="hljs-keyword">if</span> (rightmost &gt;= n - <span class="hljs-number">1</span>)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;                <br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230419172725786.png" alt="image-20230419172725786" style="zoom:50%;" /></p>
<h3 id="跳跃游戏-ii"><a href="https://leetcode.cn/problems/jump-game-ii/">45. 跳跃游戏 II</a></h3>
<h4 id="方法一dp-7">方法一：dp</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">jump</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-comment">// 1.dp[i]：到达i的最小跳数</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Arrays.fill(dp, Integer.MAX_VALUE);<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; i + <span class="hljs-number">1</span> + nums[i]; ++j) &#123;<br>                dp[j] = Math.min(dp[j], dp[i] + <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span> (j == n - <span class="hljs-number">1</span>)<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;  <br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230419181353135.png" alt="image-20230419181353135" style="zoom:50%;" /></p>
<h4 id="方法二贪心-2">方法二：贪心</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">jump</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxDistance</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, end = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++i) &#123;<br>            maxDistance = Math.max(maxDistance, i + nums[i]);<br>            <span class="hljs-keyword">if</span> (i == end) &#123;<br>                end = maxDistance;<br>                ++result;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230420092238469.png" alt="image-20230420092238469" style="zoom:50%;" /></p>
<h3 id="k-次取反后最大化的数组和"><a href="https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/">1005. K 次取反后最大化的数组和</a></h3>
<ol type="1">
<li>先创建一个小根堆，把数组所有元素都放进去</li>
<li>取反小根堆堆顶元素再放回小根堆，循环k次</li>
<li>时间复杂度：<span class="math inline">\(O(n)\)</span></li>
<li>空间复杂度：<span class="math inline">\(O(n)\)</span></li>
</ol>
<p>如果小根堆堆顶是负数<span class="math inline">\(x\)</span>，那么一定是最小的负数，取反后会是比较大的正数<span class="math inline">\(-x\)</span>；</p>
<p>如果小根堆堆顶是正数<span class="math inline">\(x\)</span>，那么是最小的正数，取反后是负数<span class="math inline">\(-x\)</span>，由于此时只有这一个负数，所以<span class="math inline">\(-x\)</span>是最小值，再放入堆顶，再取反又是最小的正数，循环到k为0为止。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">largestSumAfterKNegations</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-comment">// 先创建一个小根堆，把数组所有元素都放进去</span><br>        <span class="hljs-comment">// 取反小根堆堆顶元素再放回小根堆，循环k次</span><br>        PriorityQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n : nums)<br>            queue.offer(n);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty() &amp;&amp; k &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> queue.poll();<br>            queue.offer(-<span class="hljs-number">1</span> * cur);<br>            --k;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            sum += queue.poll();<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230420094255341.png" alt="image-20230420094255341" style="zoom:50%;" /></p>
<h4 id="方法二优化方法一">方法二：优化方法一</h4>
<ol type="1">
<li>先创建一个小根堆，把数组所有元素都放进去</li>
<li>首先小根堆弹出的元素<span class="math inline">\(x\)</span>如果是负数，就取反(最小的负数取反是比较大的正数),再放回小根堆</li>
<li>小根堆弹出的元素<span class="math inline">\(x\)</span>如果是是正数：此时<span class="math inline">\(k\)</span>值如果能被2整除，那么重复取反堆顶元素<span class="math inline">\(x\)</span>，最终<span class="math inline">\(x\)</span>不变，直接将<span class="math inline">\(x\)</span>加入堆中；如果<span class="math inline">\(k\)</span>值如果不能被2整除，那么将-x加入堆中</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">largestSumAfterKNegations</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-comment">// 先创建一个小根堆，把数组所有元素都放进去</span><br>        <span class="hljs-comment">// 要取反k次，首先小根堆弹出的元素x如果是负数，就取反(最小的负数取反是比较大的正数),再放回小根堆</span><br>        <span class="hljs-comment">// 小根堆弹出的元素x如果是是正数：此时k值如果能被2整除，那么重复取反堆顶元素x，最终x不变，直接将x加入堆中；如果k值如果不能被2整除，那么将-x加入堆中</span><br>        PriorityQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n : nums)<br>            queue.offer(n);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty() &amp;&amp; k &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> queue.poll();<br>            <span class="hljs-keyword">if</span> (cur &lt; <span class="hljs-number">0</span>) &#123;<br>                queue.offer(-<span class="hljs-number">1</span> * cur);<br>                --k;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// cur &gt;= 0</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">negPart</span> <span class="hljs-operator">=</span> k % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span>	 : -<span class="hljs-number">1</span>;<br>                queue.offer(cur * negPart);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            sum += queue.poll();<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="方法三贪心二刷">方法三：贪心(二刷)</h4>
<ol type="1">
<li><p>首先将数组升序排序</p></li>
<li><p>进入for循环，<strong>注意循环的条件有两个，i &lt; nums.length || k &gt; 0</strong></p></li>
<li><p>当k==0时，说明已经翻转了k次，不需要继续执行程序了，break即可</p></li>
<li><p>if (i == nums.length)留到最后讲解</p></li>
<li><p>如果，nums[i] &lt;= 0，直接翻转即可；如果nums[i] &gt; 0，那么说明此时数组里已经没有负数了，那么需要找到最小的正数，并且将剩余需要翻转的次数都对这个数使用：最小的正数只可能是当前的数或者前一个位置的数，比如数组[-5, -4, -3, 2, 3, 5]，需要翻转四次，翻转四次后数组为[5, 4, 3, 2, 3, 5]，即负数部分翻转后是降序。如果k能被2整除，那么翻转k次后这个数还是保持不变；如果不能被2整除，翻转一次即可。最后break退出for循环</p></li>
<li><p>如果i == nums.length，但是k的次数还没用完，这种情况只可能是数组元素全为负的情况，如果有一个正数，k都会在</p>
<p>if (nums[i] &gt;= 0 &amp;&amp; i &gt; 0) 语句下被消化。这种情况下，一定是最后一个数最小，如果k不能被2整除，就nums[i - 1]翻转即可。比如数组为[-4, -3, -2]，需要翻转4次，翻转3次后数组为</p>
<p>[4, 3, 2]，此时i == nums.length，翻转2即可</p></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">largestSumAfterKNegations</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        Arrays.sort(nums);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length || k &gt; <span class="hljs-number">0</span>; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">if</span> (i == nums.length)<br>                 i--;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt;= <span class="hljs-number">0</span> &amp;&amp; i &gt; <span class="hljs-number">0</span>) &#123;<br>                i = nums[i] &gt; nums[i - <span class="hljs-number">1</span>] ? i - <span class="hljs-number">1</span> : i;<br>                <span class="hljs-keyword">if</span> (k % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>                    nums[i] *= -<span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            nums[i] *= -<span class="hljs-number">1</span>;<br>            --k;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Arrays.stream(nums).sum();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230508095011395.png" alt="image-20230508095011395" style="zoom:50%;" /></p>
<h3 id="加油站warning"><a href="https://leetcode.cn/problems/gas-station/">134. 加油站</a>:warning:</h3>
<h4 id="方法一贪心-1">方法一：贪心</h4>
<p><strong>首先如果总油量减去总消耗大于等于零那么一定可以跑完一圈</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">canCompleteCircuit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] gas, <span class="hljs-type">int</span>[] cost)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">curSum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">totalSum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; gas.length; i++) &#123;<br>            curSum += gas[i] - cost[i];<br>            totalSum += gas[i] - cost[i];<br>            <span class="hljs-keyword">if</span> (curSum &lt; <span class="hljs-number">0</span>) &#123;<br>                index = (i + <span class="hljs-number">1</span>) % gas.length ; <br>                curSum = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (totalSum &lt; <span class="hljs-number">0</span>) ? -<span class="hljs-number">1</span> : index;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230420114302981.png" alt="image-20230420114302981" style="zoom:50%;" /></p>
<h4 id="方法二最小累计值的下一站">方法二：最小累计值的下一站</h4>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230508115857758.png" alt="image-20230508115857758" style="zoom:50%;" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">canCompleteCircuit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] gas, <span class="hljs-type">int</span>[] cost)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rest</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">minDiff</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">minIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; gas.length; ++i) &#123;<br>            rest += gas[i] - cost[i];<br>            <span class="hljs-keyword">if</span> (rest &lt; minDiff) &#123;<br>                minDiff = rest;<br>                minIndex = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> rest &lt; <span class="hljs-number">0</span> ? -<span class="hljs-number">1</span> : (minIndex + <span class="hljs-number">1</span>) % gas.length;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230508114341620.png" alt="image-20230508114341620" style="zoom:50%;" /></p>
<h3 id="分发糖果"><a href="https://leetcode.cn/problems/candy/">135. 分发糖果</a></h3>
<p>先从左往右，再从右往左</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">candy</span><span class="hljs-params">(<span class="hljs-type">int</span>[] ratings)</span> &#123;<br>        <span class="hljs-type">int</span>[] candy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[ratings.length];<br>        Arrays.fill(candy, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; candy.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (ratings[i] &gt; ratings[i - <span class="hljs-number">1</span>]) <br>                candy[i] += candy[i - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> candy.length - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-keyword">if</span> (ratings[i - <span class="hljs-number">1</span>] &gt; ratings[i]) &#123;<br>                candy[i - <span class="hljs-number">1</span>] = Math.max(candy[i - <span class="hljs-number">1</span>], candy[i] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Arrays.stream(candy).sum();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230420134656982.png" alt="image-20230420134656982" style="zoom:50%;" /></p>
<h3 id="柠檬水找零"><a href="https://leetcode.cn/problems/lemonade-change/">860. 柠檬水找零</a></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">lemonadeChange</span><span class="hljs-params">(<span class="hljs-type">int</span>[] bills)</span> &#123;<br>        <span class="hljs-keyword">if</span> (bills[<span class="hljs-number">0</span>] != <span class="hljs-number">5</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">five</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, ten = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; bills.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (bills[i] == <span class="hljs-number">5</span>) &#123;<br>                ++five;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bills[i] == <span class="hljs-number">10</span>) &#123;<br>                <span class="hljs-keyword">if</span> (five &gt; <span class="hljs-number">0</span>) &#123;<br>                    --five;<br>                    ++ten;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (five &gt; <span class="hljs-number">0</span> &amp;&amp; ten &gt; <span class="hljs-number">0</span>) &#123;<br>                    --five;<br>                    --ten;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (five &gt;= <span class="hljs-number">3</span>) &#123;<br>                    five -= <span class="hljs-number">3</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230420143510176.png" alt="image-20230420143510176" style="zoom:50%;" /></p>
<h3 id="根据身高重建队列-warning"><a href="https://leetcode.cn/problems/queue-reconstruction-by-height/">406. 根据身高重建队列</a> :warning:</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] reconstructQueue(<span class="hljs-type">int</span>[][] people) &#123;<br>        <span class="hljs-comment">// 先按照身高进行降序排序，再按照k进行升序排序</span><br>        Arrays.sort(people, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;<span class="hljs-type">int</span>[]&gt;() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">int</span>[] person1, <span class="hljs-type">int</span>[] person2)</span> &#123;<br>                <span class="hljs-keyword">if</span> (person1[<span class="hljs-number">0</span>] != person2[<span class="hljs-number">0</span>]) &#123;<br>                    <span class="hljs-keyword">return</span> person2[<span class="hljs-number">0</span>] - person1[<span class="hljs-number">0</span>];<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">return</span> person1[<span class="hljs-number">1</span>] - person2[<span class="hljs-number">1</span>];<br>                &#125;<br>            &#125;<br>        &#125;);<br>        List&lt;<span class="hljs-type">int</span>[]&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] person : people) &#123;<br>            list.add(person[<span class="hljs-number">1</span>], person);<br>        &#125;<br>        <span class="hljs-keyword">return</span> list.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[list.size()][]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230420153338251.png" alt="image-20230420153338251" style="zoom:50%;" /></p>
<h3 id="用最少数量的箭引爆气球"><a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/">452. 用最少数量的箭引爆气球</a></h3>
<p><strong>注意事项</strong>：</p>
<ol type="1">
<li>compare方法用return p1[0] - p2[0]会越界！</li>
<li>从左往右遍历，如果左边气球的右边界大于等于右边气球的左边界，那么可以一箭双球，此时有可能有第三个气球和前面两个气球有重合，但是<strong>把第一个气球的右边界设置为重合气球右边界的最小值</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMinArrowShots</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] points)</span> &#123;<br>        Arrays.sort(points, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;<span class="hljs-type">int</span>[]&gt;() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">int</span>[] point1, <span class="hljs-type">int</span>[] point2)</span> &#123;<br>                <span class="hljs-keyword">return</span> Integer.compare(point1[<span class="hljs-number">0</span>], point2[<span class="hljs-number">0</span>]);<br>            &#125;<br>        &#125;);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">arrow</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">1</span>; j &lt; points.length; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (points[i][<span class="hljs-number">1</span>] &gt;= points[j][<span class="hljs-number">0</span>]) &#123;<br>                points[i][<span class="hljs-number">1</span>] = Math.min(points[i][<span class="hljs-number">1</span>], points[j][<span class="hljs-number">1</span>]);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                ++arrow;<br>                i = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> arrow;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230420161543557.png" alt="image-20230420161543557" style="zoom:50%;" /></p>
<h3 id="无重叠区间"><a href="https://leetcode.cn/problems/non-overlapping-intervals/">435. 无重叠区间</a></h3>
<h4 id="方法一">方法一：</h4>
<p>比较器按以下方法来，不然容易出错！！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Arrays.sort(intervals, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;<span class="hljs-type">int</span>[]&gt;() &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">int</span>[] p1, <span class="hljs-type">int</span>[] p2)</span> &#123;<br>        <span class="hljs-keyword">if</span> (p1[<span class="hljs-number">0</span>] == p2[<span class="hljs-number">0</span>]) &#123;<br>            <span class="hljs-keyword">return</span> Integer.compare(p1[<span class="hljs-number">1</span>], p2[<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> Integer.compare(p1[<span class="hljs-number">0</span>], p2[<span class="hljs-number">0</span>]);<br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>
<ol type="1">
<li>先定义比较器，如果p1, p2第一个元素不相等，则按照第一个元素升序排序；如果第一个元素相等，则按照第二个元素升序排序</li>
<li>双指针从前往后遍历，初始i=0，j=1</li>
<li>当intervals[i]与intervals[j]的第一个元素相等，那么必定要移除其中一个，由于比较器的排序，intervals[j]的区间更大，那么选择移除intervals[j]，答案只需要返回最少移除了多少个数，所以将表示删除元素个数的变量erase加一，让j后移即可</li>
<li>当intervals[i]与intervals[j]的第一个元素不相等时候，分两种情况讨论
<ol type="1">
<li>如果intervals[i]的第二个元素 &gt; intervals[j]的第一个元素，此时区间重合，删除第二个元素即可，将表示删除元素个数的变量erase加一；如果此时intervals[i]的第二个元素 &gt; intervals[j]的第二个元素，说明intervals[i]包含 intervals[j]，那么此时必定删除 intervals[i]，将i指向j表示删除 intervals[i]这个元素</li>
<li>如果intervals[i]的第二个元素 &lt;= intervals[j]的第一个元素，那么i与j之间的元素都不重复，将i移动到j的位置</li>
</ol></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">eraseOverlapIntervals</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] intervals)</span> &#123;<br>        Arrays.sort(intervals, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;<span class="hljs-type">int</span>[]&gt;() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">int</span>[] p1, <span class="hljs-type">int</span>[] p2)</span> &#123;<br>                <span class="hljs-keyword">if</span> (p1[<span class="hljs-number">0</span>] == p2[<span class="hljs-number">0</span>]) &#123;<br>                    <span class="hljs-keyword">return</span> Integer.compare(p1[<span class="hljs-number">1</span>], p2[<span class="hljs-number">1</span>]);<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">return</span> Integer.compare(p1[<span class="hljs-number">0</span>], p2[<span class="hljs-number">0</span>]);<br>                &#125;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">erase</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, n = intervals.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">1</span>; j &lt; n; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (intervals[i][<span class="hljs-number">0</span>] == intervals[j][<span class="hljs-number">0</span>]) &#123;<br>                ++erase;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (intervals[i][<span class="hljs-number">1</span>] &gt; intervals[j][<span class="hljs-number">0</span>]) &#123;<br>                    ++erase;<br>                    <span class="hljs-keyword">if</span> (intervals[i][<span class="hljs-number">1</span>] &gt;= intervals[j][<span class="hljs-number">1</span>]) &#123;<br>                        i = j;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// intervals[i][1] &lt;= intervals[j][0]</span><br>                    i = j;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> erase;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230420170213502.png" alt="image-20230420170213502" style="zoom:50%;" /></p>
<h4 id="方法二右边界取最小的">方法二：右边界取最小的</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">eraseOverlapIntervals</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] intervals)</span> &#123;<br>        Arrays.sort(intervals, (a,b)-&gt; &#123;<br>            <span class="hljs-keyword">return</span> Integer.compare(a[<span class="hljs-number">0</span>],b[<span class="hljs-number">0</span>]);<br>        &#125;);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i &lt; intervals.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(intervals[i][<span class="hljs-number">0</span>] &lt; intervals[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>])&#123;<br>                ++count;<br>                intervals[i][<span class="hljs-number">1</span>] = Math.min(intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], intervals[i][<span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] is : intervals) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : is) &#123;<br>                System.out.print(i + <span class="hljs-string">&quot;,&quot;</span>);<br>            &#125;<br>            System.out.println();<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230421092251721.png" alt="image-20230421092251721" style="zoom:50%;" /></p>
<h4 id="二刷左边界升序排序">二刷：左边界升序排序</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">eraseOverlapIntervals</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] intervals)</span> &#123;<br>        Arrays.sort(intervals, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;<span class="hljs-type">int</span>[]&gt;() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span>[] b)</span> &#123;<br>                <span class="hljs-keyword">if</span> (a[<span class="hljs-number">0</span>] == b[<span class="hljs-number">0</span>])<br>                    <span class="hljs-keyword">return</span> Integer.compare(a[<span class="hljs-number">1</span>], b[<span class="hljs-number">1</span>]);<br>                <span class="hljs-keyword">else</span> <br>                    <span class="hljs-keyword">return</span> Integer.compare(a[<span class="hljs-number">0</span>], b[<span class="hljs-number">0</span>]);<br>            &#125;<br>        &#125;);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">1</span>; j &lt; intervals.length; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (intervals[i][<span class="hljs-number">1</span>] &gt; intervals[j][<span class="hljs-number">0</span>]) &#123;<br>                intervals[i][<span class="hljs-number">1</span>] = Math.min(intervals[i][<span class="hljs-number">1</span>], intervals[j][<span class="hljs-number">1</span>]);<br>                ++res;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                i = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230510141839941.png" alt="image-20230510141839941" style="zoom:50%;" /></p>
<h3 id="划分字母区间-warning"><a href="https://leetcode.cn/problems/partition-labels/">763. 划分字母区间</a> :warning:</h3>
<h4 id="方法一贪心-2">方法一：贪心</h4>
<ol type="1">
<li>首先创建一个长度为26的整型数组，统计每次字符出现的最远位置</li>
<li>遍历字符串，不断更新右边界的值</li>
<li>当当前下标i与右边界相等时，那么就将right-i+1记录</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">partitionLabels</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span>[] ch = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); ++i) &#123;<br>            ch[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>] = i;<br>        &#125;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); ++i) &#123;<br>            right = Math.max(right, ch[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]);<br>            <span class="hljs-keyword">if</span> (i == right) &#123;<br>                res.add(right - left + <span class="hljs-number">1</span>);<br>                left = i + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;   <br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230421101328612.png" alt="image-20230421101328612" style="zoom:50%;" /></p>
<h3 id="合并区间"><a href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间</a></h3>
<h4 id="方法一-1">方法一：</h4>
<ol type="1">
<li>遍历数组，如果后一个元素的左边界大于等于前一个元素的右边界，那么修改后一个元素的左边界为两元素左边界最小的值，修改后一个元素的右边界为两元素右边界最大的值</li>
<li>如果后一个元素左边界大于前一个元素的右边界，直接把前一个元素加入结果list中</li>
<li>最后再把最后一个元素(修改过)加入结果list中</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] merge(<span class="hljs-type">int</span>[][] intervals) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> intervals.length;<br>        Arrays.sort(intervals, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;<span class="hljs-type">int</span>[]&gt;() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">int</span>[] p1, <span class="hljs-type">int</span>[] p2)</span> &#123;<br>                <span class="hljs-keyword">return</span> Integer.compare(p1[<span class="hljs-number">0</span>], p2[<span class="hljs-number">0</span>]);<br>            &#125;<br>        &#125;);<br>        List&lt;<span class="hljs-type">int</span>[]&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (intervals[i + <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] &lt;= intervals[i][<span class="hljs-number">1</span>]) &#123;<br>                intervals[i + <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = Math.min(intervals[i + <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], intervals[i][<span class="hljs-number">0</span>]);<br>                intervals[i + <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = Math.max(intervals[i + <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], intervals[i][<span class="hljs-number">1</span>]); <br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;intervals[i][<span class="hljs-number">0</span>], intervals[i][<span class="hljs-number">1</span>]&#125;);<br>            &#125;<br>        &#125;<br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;intervals[n - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], intervals[n - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]&#125;);<br>        <span class="hljs-keyword">return</span> res.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[res.size()][]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230421105346150.png" alt="image-20230421105346150" style="zoom:50%;" /></p>
<h4 id="方法二射气球的思路">方法二：射气球的思路</h4>
<ol type="1">
<li><p>首先将数组按照左边界升序排序</p></li>
<li><p>当intervals[i][1] &gt;= intervals[j][0]，那么这两个元素一定是要合并的，因为是intervals数组是按照左边界升序排序的，那么合并区间[a, b]的a一定是intervals[i][0]，将intervals[i][1]赋值为intervals[i][1]与intervals[j][1]的最大值</p></li>
<li><p>当intervals[i][1] &lt; intervals[j][0]，那么这个两个区间是不重合的，先把上一个重合区间加入结果集，再把j赋值给i，进行下一轮循环</p></li>
<li><p>当j == intervals.length - 1时候，</p>
<ol type="1">
<li>如果intervals[i][1] &gt;= intervals[j][0]，那么会将intervals[i][1]取intervals[i][1]与intervals[j][1]的最大值</li>
<li>如果intervals[i][1] &lt; intervals[j][0]，那么会将之前的重合区间存入结果集，并将j赋值给i</li>
</ol>
<p>所以出循环，只需要把intervals[i]加入结果集就好！</p></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] merge(<span class="hljs-type">int</span>[][] intervals) &#123;<br>        Arrays.sort(intervals, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;<span class="hljs-type">int</span>[]&gt;() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span>[] b)</span> &#123;<br>                <span class="hljs-keyword">if</span> (a[<span class="hljs-number">0</span>] == b[<span class="hljs-number">0</span>])<br>                    <span class="hljs-keyword">return</span> Integer.compare(a[<span class="hljs-number">1</span>], b[<span class="hljs-number">1</span>]);<br>                <span class="hljs-keyword">else</span><br>                    <span class="hljs-keyword">return</span> Integer.compare(a[<span class="hljs-number">0</span>], b[<span class="hljs-number">0</span>]);<br>            &#125;<br>        &#125;);<br>        List&lt;<span class="hljs-type">int</span>[]&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; intervals.length; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (intervals[i][<span class="hljs-number">1</span>] &gt;= intervals[j][<span class="hljs-number">0</span>]) &#123;<br>                intervals[i][<span class="hljs-number">1</span>] = Math.max(intervals[i][<span class="hljs-number">1</span>], intervals[j][<span class="hljs-number">1</span>]);<br>            &#125;<br>            <span class="hljs-keyword">else</span>  &#123; <span class="hljs-comment">//  (intervals[i][1] &lt; intervals[j][0])</span><br>                res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;intervals[i][<span class="hljs-number">0</span>], intervals[i][<span class="hljs-number">1</span>]&#125;);<br>                i = j;<br>            &#125;<br>        &#125;<br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;intervals[i][<span class="hljs-number">0</span>], intervals[i][<span class="hljs-number">1</span>]&#125;);<br>        <span class="hljs-keyword">return</span> res.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[res.size()][]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230510145844887.png" alt="image-20230510145844887" style="zoom:50%;" /></p>
<h3 id="单调递增的数字"><a href="https://leetcode.cn/problems/monotone-increasing-digits/">738. 单调递增的数字</a></h3>
<ol type="1">
<li><strong>从后往前遍历，如果有后一个数大于前一个数，那么就用flag记录后一个数的位置，循环结束后，从flag开始，把后面的数全部赋值‘9’</strong></li>
<li><strong>注意边界！！！</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">monotoneIncreasingDigits</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> String.valueOf(n);<br>        <span class="hljs-type">char</span>[] ch = str.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> ch.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> ch.length - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-keyword">if</span> (ch[i - <span class="hljs-number">1</span>] &gt; ch[i]) &#123;<br>                --ch[i - <span class="hljs-number">1</span>];<br>                flag = i;<br>            &#125;<br>        &#125;     <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> flag; i &lt; ch.length; ++i) &#123;<br>            ch[i] = <span class="hljs-string">&#x27;9&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Integer.parseInt(String.valueOf(ch));<br>    &#125;   <br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230421115750194.png" alt=" " style="zoom:50%;" /></p>
<h3 id="监控二叉树star"><a href="https://leetcode.cn/problems/binary-tree-cameras/">968. 监控二叉树</a>:star:</h3>
<h4 id="方法一贪心-3">方法一：贪心</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCameraCover</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-comment">// dfs后检查根节点是否被覆盖</span><br>        <span class="hljs-keyword">if</span> (dfs(root) == <span class="hljs-number">404</span>)<br>            ++result;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-comment">// state 404:未覆盖</span><br>        <span class="hljs-comment">// state 200:覆盖</span><br>        <span class="hljs-comment">// state 201:有监控</span><br>        <span class="hljs-comment">//叶节点的左右空孩子需要返回被覆盖，这样才不会在叶子节点上装监控</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">200</span>;<br>        <span class="hljs-comment">// post traversal</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftState</span> <span class="hljs-operator">=</span> dfs(root.left);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rightState</span> <span class="hljs-operator">=</span> dfs(root.right);<br>        <span class="hljs-comment">// 1.如果左右子树都被覆盖</span><br>        <span class="hljs-keyword">if</span> (leftState == <span class="hljs-number">200</span> &amp;&amp; rightState == <span class="hljs-number">200</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">404</span>;<br>        <span class="hljs-comment">// 2.如果左右子树至少有一个没被覆盖</span><br>        <span class="hljs-keyword">if</span> (leftState == <span class="hljs-number">404</span> || rightState == <span class="hljs-number">404</span>) &#123;<br>            ++result;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">201</span>;<br>        &#125;<br>        <span class="hljs-comment">// 3.如果左右子树至少有一个监控</span><br>        <span class="hljs-keyword">if</span> (leftState == <span class="hljs-number">201</span> || rightState == <span class="hljs-number">201</span>) <br>            <span class="hljs-keyword">return</span> <span class="hljs-number">200</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">666</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230511102457495.png" alt="image-20230511102457495" style="zoom:50%;" /></p>
<h2 id="backtracing">BackTracing</h2>
<h3 id="开始回溯前要知道的">开始回溯前要知道的</h3>
<p><a href="https://leetcode.cn/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/">详细讲解</a></p>
<figure>
<img src="https://pic.leetcode-cn.com/0bf18f9b86a2542d1f6aa8db6cc45475fce5aa329a07ca02a9357c2ead81eec1-image.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h5 id="注意"><strong>注意</strong></h5>
<p>如果递归终止条件是这个，那么结果回事全空</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (depth == len) &#123;<br>    res.add(path);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>执行 <code>main</code> 方法以后输出如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">[[], [], [], [], [], []]<br></code></pre></td></tr></table></figure>
<p>变量 <code>path</code> 所指向的列表 <strong>在深度优先遍历的过程中只有一份</strong> ，深度优先遍历完成以后，回到了根结点，成为空列表。</p>
<p>在 Java 中，参数传递是 <strong>值传递</strong>，对象类型变量在传参的过程中，复制的是变量的地址。这些地址被添加到 <code>res</code> 变量，但实际上指向的是同一块内存地址，因此我们会看到 6 个空的列表对象。解决的方法很简单，在 <code>res.add(path);</code> 这里做一次拷贝即可。</p>
<p>修改的部分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (depth == len) &#123;<br>    res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="算法模板">算法模板</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(参数)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (终止条件) &#123;<br>        存放结果;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>        处理节点;<br>        <span class="hljs-built_in">backtracking</span>(路径，选择列表); <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="组合"><a href="https://leetcode.cn/problems/combinations/">77. 组合</a></h3>
<h4 id="方法一回溯">方法一：回溯</h4>
<ol type="1">
<li>由于已知结果要存放的数组大小为k，所以res使用ArrayList</li>
<li>List没有removeLast方法，但是LinkedList中有！</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combine</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>        backtracing(n, k, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracing</span> <span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-keyword">if</span> (path.size() == k) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt;= n; ++i) &#123;<br>            path.add(i);<br>            backtracing(n, k, i + <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">// path.removeLast();</span><br>            path.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230424094647964.png" alt="image-20230424094647964" style="zoom:50%;" /></p>
<h4 id="方法二方法一剪枝">方法二：方法一+剪枝</h4>
<p>for循环横向遍历时候，i的执行条件为i &lt;= n - (k - path.size()) + 1</p>
<p>例如，当i = 2，path里已经有1，需要组合k=3个元素，n为4，那么 4 - (3 - 1) + 1 = 3，说明i最多等于3，组成path[1, 3, 4]，如果此时i = 4，那么就不能组成3个元素，只能组成[1,4]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combine</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>        backtracing(n, k, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracing</span> <span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-keyword">if</span> (path.size() == k) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt;= n - (k - path.size()) + <span class="hljs-number">1</span>; ++i) &#123;<br>            path.add(i);<br>            backtracing(n, k, i + <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">// path.removeLast();</span><br>            path.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230424094939069.png" alt="image-20230424094939069" style="zoom:50%;" /></p>
<h4 id="方法二选或不选">方法二：选或不选</h4>
<ol type="1">
<li><p>防止底层扩容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;(k);<br></code></pre></td></tr></table></figure></li>
<li><p>若n=3，k=2,即从[1,2,3]中选两个数，如果当前什么都没选(k=2)，n - k + 1= 2，说明至少要从2开始，才能满足选两个数这个要求</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">bound</span> <span class="hljs-operator">=</span> n - k + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (start &gt; bound)<br>    <span class="hljs-keyword">return</span>;<br></code></pre></td></tr></table></figure></li>
</ol>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combine</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-comment">// 防止底层扩容</span><br>        Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;(k);<br>        backtracking(path, n, k, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(Deque&lt;Integer&gt; path, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 若n=3，k=2,即从[1,2,3]中选两个数，如果当前什么都没选(k=2)，n - k + 1= 2，</span><br>        <span class="hljs-comment">// 说明至少要从2开始，才能满足选两个数这个要求</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">bound</span> <span class="hljs-operator">=</span> n - k + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (start &gt; bound)<br>            <span class="hljs-keyword">return</span>;<br>        backtracking(path, n, k, start + <span class="hljs-number">1</span>);<br>        path.addLast(start);<br>        backtracking(path, n, k - <span class="hljs-number">1</span>, start + <span class="hljs-number">1</span>);<br>        path.removeLast();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="组合总和-iii"><a href="https://leetcode.cn/problems/combination-sum-iii/">216. 组合总和 III</a></h3>
<h4 id="方法一回溯剪枝">方法一：回溯+剪枝</h4>
<p>i那里的剪枝可以这么理解，假设从i开始取，则从i到n一共有n-i+1个元素，而当前还需要k-path.size()个元素，所以必须满足n-i+1&gt;=k-path.size()，移项就可以得到i&lt;=n+1-(k-path.size())</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum3</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n)</span> &#123;<br>        backtracking(k, n, <span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;(k));<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> start, Deque&lt;Integer&gt; path)</span> &#123;<br>        <span class="hljs-keyword">if</span> (path.size() == k) &#123;<br>            <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)<br>                res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt;= <span class="hljs-number">9</span> - (k - path.size()) + <span class="hljs-number">1</span>; ++i) &#123;<br>            path.add(i);<br>            backtracking(k, n - i, i + <span class="hljs-number">1</span>, path);<br>            path.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230424123751408.png" alt="image-20230424123751408" style="zoom:50%;" /></p>
<h4 id="方法二选或不选-1">方法二：选或不选</h4>
<p><strong>注意：int bound = 9 - k + 1;而不是9 - (k - path.size()) + 1</strong>，因为这里的递归终止条件是k==0，==k的语义是还剩多少元素没选！！！==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum3</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n)</span> &#123;<br>        backtracking(k, n, <span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;(k));<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> start, Deque&lt;Integer&gt; path)</span> &#123;<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)<br>                res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">bound</span> <span class="hljs-operator">=</span> <span class="hljs-number">9</span> - k + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (start &gt; bound)<br>            <span class="hljs-keyword">return</span>;<br>        backtracking(k, n, start + <span class="hljs-number">1</span>, path);<br>        path.add(start);<br>        backtracking(k - <span class="hljs-number">1</span>, n - start, start + <span class="hljs-number">1</span>, path);<br>        path.removeLast();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230425125522905.png" alt="image-20230425125522905" style="zoom:50%;" /></p>
<h3 id="电话号码的字母组合"><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></h3>
<p><strong>注意边界条件！</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    String[] alphabet = &#123;<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;def&quot;</span>, <span class="hljs-string">&quot;ghi&quot;</span>, <span class="hljs-string">&quot;jkl&quot;</span>, <span class="hljs-string">&quot;mno&quot;</span>, <span class="hljs-string">&quot;pqrs&quot;</span>, <span class="hljs-string">&quot;tuv&quot;</span>, <span class="hljs-string">&quot;wxyz&quot;</span>&#125;;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">letterCombinations</span><span class="hljs-params">(String digits)</span> &#123;<br>        <span class="hljs-keyword">if</span> (digits == <span class="hljs-literal">null</span> || digits.length() == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> res;<br>        backtracing(digits, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracing</span><span class="hljs-params">(String digits, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-keyword">if</span> (path.length() == digits.length()) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> digits.charAt(start);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> alphabet[num - <span class="hljs-string">&#x27;0&#x27;</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; str.length(); ++i) &#123;<br>            path.append(str.charAt(i));<br>            backtracing(digits, start + <span class="hljs-number">1</span>);<br>            path.deleteCharAt(path.length() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230424134515914.png" alt="image-20230424134515914" style="zoom:50%;" /></p>
<h3 id="组合总和"><a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></h3>
<p>与前面两题不同的是，可以选取相同元素；以及组合不能重复，如[3，5]与[5，3]是同一个组合</p>
<p><strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong></p>
<p><a href="https://leetcode.cn/problems/combination-sum/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-2/">解析</a></p>
<h4 id="方法一回溯-1">方法一：回溯</h4>
<p>去重：遇到这一类相同元素不计算顺序的问题，我们在搜索的时候就需要 <strong>按某种顺序搜索</strong>。具体的做法是：每一次搜索的时候设置 <strong>下一轮搜索的起点</strong> <code>begin</code>，请看下图。</p>
<figure>
<img src="https://pic.leetcode-cn.com/1598091943-GPoHAJ-file_1598091940246" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>        backtracing(candidates, target, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracing</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-keyword">if</span> (target &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (target == <span class="hljs-number">0</span>) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; candidates.length; ++i) &#123;<br>            path.add(candidates[i]);<br>            backtracing(candidates, target - candidates[i], i);<br>            path.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230424143933670.png" alt="image-20230424143933670" style="zoom:50%;" /></p>
<h4 id="方法二回溯剪枝">方法二：回溯+剪枝</h4>
<p><strong>注意：</strong></p>
<ol type="1">
<li><p>是i不是start！！！</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230425144819762.png" alt="image-20230425144819762" style="zoom:50%;" /></p></li>
<li><p>回溯前要排序！！！</p></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-comment">// 排序是剪枝的前提</span><br>        Arrays.sort(candidates);<br>        backtracing(candidates, target, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracing</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-keyword">if</span> (target == <span class="hljs-number">0</span>) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; candidates.length; ++i) &#123;<br>            <span class="hljs-comment">// 由于进入更深层的时候，小于 0 的部分被剪枝，因此递归终止条件值只判断等于 0 的情况</span><br>            <span class="hljs-keyword">if</span> (target - candidates[i] &lt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;<br>            path.add(candidates[i]);<br>            backtracing(candidates, target - candidates[i], i);<br>            path.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230424144256280.png" alt=" " style="zoom:50%;" /></p>
<h3 id="组合总和-ii"><a href="https://leetcode.cn/problems/combination-sum-ii/">40. 组合总和 II</a></h3>
<p><strong>树层去重，树枝不需要去重</strong></p>
<p><strong>去重和39题(上一题)以及三数之和差不多</strong></p>
<h4 id="方法一-2">方法一：</h4>
<p><strong>注意：if判断条件是i &gt; start， 不是i &gt; 0</strong></p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><code class="hljs crystal">这个避免重复当思想是在是太重要了。<br>这个方法最重要的作用是，可以让同一层级，不出现相同的元素。即<br>                  <span class="hljs-number">1</span><br>                 <span class="hljs-regexp">/ \</span><br><span class="hljs-regexp">                2   2  这种情况不会发生 但是却允许了不同层级之间的重复即：</span><br><span class="hljs-regexp">               /</span>     \<br>              <span class="hljs-number">5</span>       <span class="hljs-number">5</span><br>                例<span class="hljs-number">2</span><br>                  <span class="hljs-number">1</span><br>                 <span class="hljs-regexp">/</span><br><span class="hljs-regexp">                2      这种情况确是允许的</span><br><span class="hljs-regexp">               /</span><br>              <span class="hljs-number">2</span>  <br>                <br>为何会有这种神奇的效果呢？<br>首先 cur-<span class="hljs-number">1</span> == cur 是用于判定当前元素是否和之前元素相同的语句。这个语句就能砍掉例<span class="hljs-number">1</span>。<br>可是问题来了，如果把所有当前与之前一个元素相同的都砍掉，那么例二的情况也会消失。 <br>因为当第二个<span class="hljs-number">2</span>出现的时候，他就和前一个<span class="hljs-number">2</span>相同了。<br>                <br>那么如何保留例<span class="hljs-number">2</span>呢？<br>那么就用cur &gt; <span class="hljs-keyword">begin</span> 来避免这种情况，你发现例<span class="hljs-number">1</span>中的两个<span class="hljs-number">2</span>是处在同一个层级上的，<br>例<span class="hljs-number">2</span>的两个<span class="hljs-number">2</span>是处在不同层级上的。<br>在一个<span class="hljs-keyword">for</span>循环中，所有被遍历到的数都是属于一个层级的。我们要让一个层级中，<br>必须出现且只出现一个<span class="hljs-number">2</span>，那么就放过第一个出现重复的<span class="hljs-number">2</span>，但不放过后面出现的<span class="hljs-number">2</span>。<br>第一个出现的<span class="hljs-number">2</span>的特点就是 cur == <span class="hljs-keyword">begin</span>. 第二个出现的<span class="hljs-number">2</span> 特点是cur &gt; <span class="hljs-keyword">begin</span>.<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>        Arrays.sort(candidates);<br>        backtracing(candidates, target, <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracing</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-keyword">if</span> (target == <span class="hljs-number">0</span>) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; candidates.length; ++i) &#123;<br>            <span class="hljs-comment">// 剪枝</span><br>            <span class="hljs-keyword">if</span> (candidates[i] &gt; target)<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">// 去重</span><br>            <span class="hljs-keyword">if</span> (i &gt; start &amp;&amp; candidates[i] == candidates[i - <span class="hljs-number">1</span>])<br>                <span class="hljs-keyword">continue</span>;<br>            path.add(candidates[i]);<br>            backtracing(candidates, target - candidates[i], i + <span class="hljs-number">1</span>);<br>            path.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230424155818816.png" alt="image-20230424155818816" style="zoom: 50%;" /></p>
<h4 id="方法二used数组">方法二：used数组</h4>
<p>多debug</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>        Arrays.sort(candidates);<br>        <span class="hljs-type">boolean</span>[] used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[candidates.length];<br>        backtracking(candidates, used, target, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">boolean</span>[] used, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-keyword">if</span> (target == <span class="hljs-number">0</span>) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; candidates.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (target &lt; candidates[i])<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="hljs-number">1</span>] &amp;&amp; !used[i - <span class="hljs-number">1</span>])<br>                <span class="hljs-keyword">continue</span>;<br>            path.add(candidates[i]);<br>            used[i] = <span class="hljs-literal">true</span>;<br>            backtracking(candidates, used,  target - candidates[i], i + <span class="hljs-number">1</span>);<br>            used[i] = <span class="hljs-literal">false</span>;<br>            path.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230428153014536.png" alt="image-20230428153014536" style="zoom:50%;" /></p>
<h4 id="方法三选或不选">方法三：选或不选</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>        Arrays.sort(candidates);<br>        backtracking(candidates, <span class="hljs-literal">false</span>, target, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">boolean</span> choosePre, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-keyword">if</span> (target == <span class="hljs-number">0</span>) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (target &lt; <span class="hljs-number">0</span> || start == candidates.length)<br>            <span class="hljs-keyword">return</span>;<br>        backtracking(candidates, <span class="hljs-literal">false</span>, target, start + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (start &gt; <span class="hljs-number">0</span> &amp;&amp; !choosePre &amp;&amp; candidates[start] == candidates[start - <span class="hljs-number">1</span>])<br>            <span class="hljs-keyword">return</span>;<br>        path.add(candidates[start]);<br>        backtracking(candidates, <span class="hljs-literal">true</span>, target - candidates[start], start + <span class="hljs-number">1</span>);<br>        path.removeLast();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="分割回文串warning"><a href="https://leetcode.cn/problems/palindrome-partitioning/">131. 分割回文串</a>:warning:</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;String&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    Deque&lt;String&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">partition</span><span class="hljs-params">(String s)</span> &#123;<br>        backtracking(s.toCharArray(), <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">char</span>[] ch, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-keyword">if</span> (start == ch.length) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; ch.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (isPalindrome(ch, start, i)) &#123;<br>                path.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(ch, start, i - start + <span class="hljs-number">1</span>));<br>                backtracking(ch, i + <span class="hljs-number">1</span>);<br>                path.removeLast();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(<span class="hljs-type">char</span>[] ch, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-keyword">while</span> (start &lt; end) &#123;<br>            <span class="hljs-keyword">if</span> (ch[start++] != ch[end--])<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="star93.-复原-ip-地址">:star:<a href="https://leetcode.cn/problems/restore-ip-addresses/">93. 复原 IP 地址</a></h3>
<p>重做</p>
<h4 id="方法一回溯-2">方法一：回溯</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure>
<h3 id="子集"><a href="https://leetcode.cn/problems/subsets/">78. 子集</a></h3>
<p><strong>以下两种方法的区别：</strong></p>
<ol type="1">
<li>方法二有横向for循环，使用i进入递归方法</li>
<li>方法一有两个递归方法，分别表示选与不选，用start进入递归犯法</li>
</ol>
<h4 id="方法一选或不选">方法一：选或不选</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        backtracking(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-keyword">if</span> (start == nums.length) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        backtracking(nums, start + <span class="hljs-number">1</span>);<br>        path.add(nums[start]);<br>        backtracking(nums, start + <span class="hljs-number">1</span>);<br>        path.removeLast();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230425163311801.png" alt="image-20230425163311801" style="zoom:50%;" /></p>
<h4 id="方法二for循环横向顺序遍历">方法二：for循环横向顺序遍历</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        backtracking(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start)</span> &#123;<br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>(path));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; nums.length; i++) &#123;<br>            path.add(nums[i]);<br>            backtracking(nums, i + <span class="hljs-number">1</span>);<br>            path.removeLast();	<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230425163737735.png" alt="image-20230425163737735" style="zoom:50%;" /></p>
<h3 id="子集-ii"><a href="https://leetcode.cn/problems/subsets-ii/">90. 子集 II</a></h3>
<h4 id="方法一选或不选-1">方法一：选或不选</h4>
<p>如果前后两个数相等，如[1,2,2]，那么只有在第一个2被选择了，才能选择第二个2，不然会重复</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsetsWithDup</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Arrays.sort(nums);<br>        backtracking(nums, <span class="hljs-literal">false</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">boolean</span> choosePre, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-keyword">if</span> (start == nums.length) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        backtracking(nums, <span class="hljs-literal">false</span>, start + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (start &gt; <span class="hljs-number">0</span> &amp;&amp; !choosePre &amp;&amp; nums[start - <span class="hljs-number">1</span>] == nums[start])<br>            <span class="hljs-keyword">return</span>;<br>        path.add(nums[start]);<br>        backtracking(nums, <span class="hljs-literal">true</span>, start + <span class="hljs-number">1</span>);<br>        path.removeLast();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230428171902037.png" alt="image-20230428171902037" style="zoom:50%;" /></p>
<h4 id="方法二顺序递归">方法二：顺序递归</h4>
<p><strong>注意：if判断条件是i &gt; start， 不是i &gt; 0</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsetsWithDup</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Arrays.sort(nums);<br>        backtracking(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start)</span> &#123;<br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>(path));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; nums.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; start &amp;&amp; nums[i - <span class="hljs-number">1</span>] == nums[i])<br>                <span class="hljs-keyword">continue</span>;<br>            path.add(nums[i]);<br>            backtracking(nums, i + <span class="hljs-number">1</span>);<br>            path.removeLast();  <br>        &#125;     <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230429114756521.png" alt="image-20230429114756521" style="zoom:50%;" /></p>
<h3 id="递增子序列warning"><a href="https://leetcode.cn/problems/non-decreasing-subsequences/">491. 递增子序列</a>:warning:</h3>
<h4 id="方法一顺序dfs">方法一：顺序DFS</h4>
<p><strong>注意：HashSet的位置！！！每进入一层递归，就会在for循环前创建一个HashSet，这样可以保证树层去重，并且树枝不会qu'chong</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">findSubsequences</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        backtracking(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-keyword">if</span> (path.size() &gt;= <span class="hljs-number">2</span>)<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>(path));<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; nums.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> ((!path.isEmpty() &amp;&amp; nums[i] &lt; path.peekLast()))<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (set.contains(nums[i]))<br>                <span class="hljs-keyword">continue</span>;<br>            set.add(nums[i]);<br>            path.add(nums[i]);<br>            backtracking(nums, i + <span class="hljs-number">1</span>);<br>            path.pollLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230429182016324.png" alt="image-20230429182016324" style="zoom: 50%;" /></p>
<h3 id="全排列"><a href="https://leetcode.cn/problems/permutations/">46. 全排列</a></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-type">boolean</span>[] used;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permute</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[nums.length];<br>        backtracking(nums);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (path.size() == nums.length) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (!used[i]) &#123;<br>                path.add(nums[i]);<br>                used[i] = <span class="hljs-literal">true</span>;<br>                backtracking(nums);<br>                used[i] = <span class="hljs-literal">false</span>;<br>                path.pollLast();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230430161908436.png" alt="image-20230430161908436" style="zoom:50%;" /></p>
<h3 id="全排列-ii"><a href="https://leetcode.cn/problems/permutations-ii/">47. 全排列 II</a></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-type">boolean</span>[] used;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permuteUnique</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Arrays.sort(nums);<br>        used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[nums.length];<br>        backtracking(nums);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (path.size() == nums.length) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; !used[i - <span class="hljs-number">1</span>] &amp;&amp; nums[i - <span class="hljs-number">1</span>] == nums[i])<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (!used[i]) &#123;<br>                path.add(nums[i]);<br>                used[i] = <span class="hljs-literal">true</span>;<br>                backtracking(nums);<br>                used[i] = <span class="hljs-literal">false</span>;<br>                path.pollLast();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230430163444957.png" alt="image-20230430163444957" style="zoom:50%;" /></p>
<h3 id="n-皇后"><a href="https://leetcode.cn/problems/n-queens/">51. N 皇后</a></h3>
<h4 id="方法一二维数组存表盘">方法一：二维数组存表盘</h4>
<ol type="1">
<li>时间复杂度<span class="math inline">\(O(n^n)\)</span></li>
<li>空间复杂度<span class="math inline">\(O(n^2)\)</span></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;String&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">solveNQueens</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">char</span>[][] chessboard = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span>[] row : chessboard)<br>            Arrays.fill(row, <span class="hljs-string">&#x27;.&#x27;</span>);<br>        backtracking(<span class="hljs-number">0</span>, chessboard, n);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">char</span>[][] chessboard, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (row == n) &#123;<br>            res.add(toList(chessboard));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; col &lt; n; ++col) &#123;<br>            <span class="hljs-keyword">if</span> (isValid(row, col, chessboard, n)) &#123;<br>                chessboard[row][col] = <span class="hljs-string">&#x27;Q&#x27;</span>;<br>                backtracking(row + <span class="hljs-number">1</span>, chessboard, n);<br>                chessboard[row][col] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, <span class="hljs-type">char</span>[][] chessboard, <span class="hljs-type">int</span> n)</span> &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; row; ++i)<br>        <span class="hljs-keyword">if</span> (chessboard[i][col] == <span class="hljs-string">&#x27;Q&#x27;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> row - <span class="hljs-number">1</span>, j = col - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>; --i, --j) &#123;<br>            <span class="hljs-keyword">if</span> (chessboard[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> row - <span class="hljs-number">1</span>, j = col + <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; n; --i, ++j)<br>            <span class="hljs-keyword">if</span> (chessboard[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">private</span> List&lt;String&gt; <span class="hljs-title function_">toList</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] chessboard)</span> &#123;<br>        List&lt;String&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span>[] ch : chessboard) &#123;<br>            path.add(String.copyValueOf(ch));<br>        &#125;<br>        <span class="hljs-keyword">return</span> path;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230504144435692.png" alt="image-20230504144435692" style="zoom:50%;" /></p>
<h4 id="方法二一维数组存储每行皇后的列信息">方法二：一维数组存储每行皇后的列信息</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;String&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-type">int</span>[] chessboard;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">solveNQueens</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        chessboard = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        backtracking(<span class="hljs-number">0</span>, n);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (row == n) &#123;<br>            res.add(generatePath(n));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; col &lt; n; ++col) &#123;<br>            <span class="hljs-keyword">if</span> (isValid(row, col, n)) &#123;<br>                chessboard[row] = col;<br>                backtracking(row + <span class="hljs-number">1</span>, n);<br>                chessboard[row] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; row; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (chessboard[i] == col || Math.abs(col - chessboard[i]) == Math.abs(row - i))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">private</span> List&lt;String&gt; <span class="hljs-title function_">generatePath</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        List&lt;String&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (j == chessboard[i])<br>                    sb.append(<span class="hljs-string">&#x27;Q&#x27;</span>);<br>                <span class="hljs-keyword">else</span> <br>                    sb.append(<span class="hljs-string">&#x27;.&#x27;</span>);<br>            &#125;<br>            path.add(sb.toString());<br>        &#125;<br>        <span class="hljs-keyword">return</span> path;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="方法三位运算加速">方法三：位运算加速</h4>
<h3 id="路径总和-ii-1"><a href="https://leetcode.cn/problems/path-sum-ii/">113. 路径总和 II</a></h3>
<h2 id="graph">Graph</h2>
<h3 id="所有可能的路径"><a href="https://leetcode.cn/problems/all-paths-from-source-to-target/">797. 所有可能的路径</a></h3>
<p><a href="https://leetcode.cn/problems/number-of-islands/solution/dao-yu-lei-wen-ti-de-tong-yong-jie-fa-dfs-bian-li-/">优质题解</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">allPathsSourceTarget</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] graph)</span> &#123;<br>        path.offerLast(<span class="hljs-number">0</span>);<br>        backtracking(<span class="hljs-number">0</span>, graph);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span>[][] graph)</span> &#123;<br>        <span class="hljs-keyword">if</span> (start == graph.length - <span class="hljs-number">1</span>) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : graph[start]) &#123;<br>            path.offerLast(x);<br>            backtracking(x, graph);<br>            path.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230504162550393.png" alt="image-20230504162550393" style="zoom:50%;" /></p>
<h3 id="岛屿数量"><a href="https://leetcode.cn/problems/number-of-islands/">200. 岛屿数量</a></h3>
<h4 id="方法一dfs-5">方法一：DFS</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numIslands</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; row &lt; grid.length; ++row) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; col &lt; grid[<span class="hljs-number">0</span>].length; ++col) &#123;<br>                <span class="hljs-keyword">if</span> (grid[row][col] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                    ++res;<br>                    dfs(row, col, grid);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, <span class="hljs-type">char</span>[][] grid)</span> &#123;<br>        <span class="hljs-keyword">if</span> (row &lt; <span class="hljs-number">0</span> || row &gt; grid.length - <span class="hljs-number">1</span> || col &lt; <span class="hljs-number">0</span> || col &gt; grid[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span> || grid[row][col] != <span class="hljs-string">&#x27;1&#x27;</span>) <br>            <span class="hljs-keyword">return</span>;<br>        grid[row][col] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>        dfs(row - <span class="hljs-number">1</span>, col, grid);<br>        dfs(row + <span class="hljs-number">1</span>, col, grid);<br>        dfs(row, col - <span class="hljs-number">1</span>, grid);<br>        dfs(row, col + <span class="hljs-number">1</span>, grid);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230504175718301.png" alt="image-20230504175718301" style="zoom:50%;" /></p>
<h4 id="方法二bfs-4">方法二：BFS</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numIslands</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] grid)</span> &#123;<br>        Queue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                    ++res;<br>                    grid[i][j] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, j&#125;);<br>                    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>                        <span class="hljs-type">int</span>[] coor = queue.poll();<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> coor[<span class="hljs-number">0</span>], col = coor[<span class="hljs-number">1</span>];<br>                        <span class="hljs-keyword">if</span> (row - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; grid[row - <span class="hljs-number">1</span>][col] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                            queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;row -<span class="hljs-number">1</span>, col&#125;);<br>                            grid[row - <span class="hljs-number">1</span>][col] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">if</span> (row + <span class="hljs-number">1</span> &lt; m &amp;&amp; grid[row + <span class="hljs-number">1</span>][col] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                            queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;row + <span class="hljs-number">1</span>, col&#125;);<br>                            grid[row + <span class="hljs-number">1</span>][col] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">if</span> (col - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; grid[row][col - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                            queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;row, col - <span class="hljs-number">1</span>&#125;);<br>                            grid[row][col - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">if</span> (col + <span class="hljs-number">1</span> &lt; n &amp;&amp; grid[row][col + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                            queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;row, col + <span class="hljs-number">1</span>&#125;);<br>                            grid[row][col + <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;        <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230504182457481.png" alt="image-20230504182457481" style="zoom:50%;" /></p>
<h4 id="方法三不修改输入数据的dfsf">方法三：不修改输入数据的DFSF</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numIslands</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">boolean</span>[][] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[grid.length][grid[<span class="hljs-number">0</span>].length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; row &lt; grid.length; ++row) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; col &lt; grid[<span class="hljs-number">0</span>].length; ++col) &#123;<br>                <span class="hljs-keyword">if</span> (!visited[row][col] &amp;&amp; grid[row][col] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                    ++res;<br>                    dfs(row, col, grid, visited);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, <span class="hljs-type">char</span>[][] grid, <span class="hljs-type">boolean</span>[][] visited)</span> &#123;<br>        <span class="hljs-keyword">if</span> (row &gt;= <span class="hljs-number">0</span> &amp;&amp; col &gt;= <span class="hljs-number">0</span> &amp;&amp; row &lt; grid.length &amp;&amp; col &lt; grid[<span class="hljs-number">0</span>].length &amp;&amp; !visited[row][col] &amp;&amp; grid[row][col] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>            visited[row][col] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;&#125;;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir :  dirs) &#123;<br>                dfs(row + dir[<span class="hljs-number">0</span>], col + dir[<span class="hljs-number">1</span>], grid, visited);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="岛屿的最大面积"><a href="https://leetcode.cn/problems/max-area-of-island/">695. 岛屿的最大面积</a></h3>
<h4 id="方法一dfs-6">方法一：DFS</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxAreaOfIsland</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; grid.length; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; grid[<span class="hljs-number">0</span>].length; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>) &#123;<br>                    size = <span class="hljs-number">0</span>;<br>                    dfs(i, j, grid);<br>                    System.out.println(res);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || i == grid.length || j == grid[<span class="hljs-number">0</span>].length || grid[i][j] != <span class="hljs-number">1</span>) <br>            <span class="hljs-keyword">return</span>;<br>        grid[i][j] = <span class="hljs-number">2</span>;<br>        res = Math.max(res, ++size);<br>        dfs(i - <span class="hljs-number">1</span>, j, grid);<br>        dfs(i + <span class="hljs-number">1</span>, j, grid);<br>        dfs(i, j - <span class="hljs-number">1</span>, grid);<br>        dfs(i, j + <span class="hljs-number">1</span>, grid);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230504193543595.png" alt="image-20230504193543595" style="zoom:50%;" /></p>
<h4 id="不修改输入的dfs">不修改输入的DFS</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxAreaOfIsland</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">boolean</span>[][] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[grid.length][grid[<span class="hljs-number">0</span>].length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; grid.length; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; grid[<span class="hljs-number">0</span>].length; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (!visited[i][j] &amp;&amp; grid[i][j] == <span class="hljs-number">1</span>) &#123;<br>                    res = Math.max(res, dfs(i, j, grid, visited));<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span>[][] grid, <span class="hljs-type">boolean</span>[][] visited)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || i == grid.length || j == grid[<span class="hljs-number">0</span>].length || grid[i][j] != <span class="hljs-number">1</span> || visited[i][j]) <br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        visited[i][j] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>            res += dfs(i + dir[<span class="hljs-number">0</span>], j + dir[<span class="hljs-number">1</span>], grid, visited);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="方法三dfs标准写法">方法三：DFS标准写法</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxAreaOfIsland</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length, n = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>) &#123;<br>                    res = Math.max(res, dfs(i, j, grid));<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;           <br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        grid[i][j] = <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], col = j + dir[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (isValid(row, col, grid.length, grid[<span class="hljs-number">0</span>].length) &amp;&amp; grid[row][col] == <span class="hljs-number">1</span>) &#123;<br>                grid[row][col] = <span class="hljs-number">2</span>;<br>                res += dfs(row, col, grid);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">return</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &lt; n);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="最大人工岛warningstar"><a href="https://leetcode.cn/problems/making-a-large-island/">827. 最大人工岛</a>:warning::star:</h3>
<p><a href="https://leetcode.cn/problems/making-a-large-island/solution/java-jie-fa-by-nettee/">优质题解</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">largestIsland</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        Map&lt;Integer, Integer&gt; idToArea = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length, n = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>) &#123;<br>                    idToArea.put(id, getSingleArea(i, j, grid, id));<br>                    ++id;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                res = Math.max(res, dfs(i, j, grid, idToArea));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span>[][] grid, Map&lt;Integer,Integer&gt; idToArea)</span> &#123;<br>        <span class="hljs-comment">// if (i &lt; 0 || j &lt; 0 || i == grid.length || j == grid[0].length)</span><br>        <span class="hljs-comment">//     return 0;</span><br>        <span class="hljs-keyword">if</span> (grid[i][j] &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> idToArea.get(grid[i][j]);<br>        &#125;<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>            <span class="hljs-keyword">if</span> (i + dir[<span class="hljs-number">0</span>] &lt; <span class="hljs-number">0</span> || j + dir[<span class="hljs-number">1</span>] &lt; <span class="hljs-number">0</span> || i + dir[<span class="hljs-number">0</span>] == grid.length || j + dir[<span class="hljs-number">1</span>] == grid[<span class="hljs-number">0</span>].length)<br>                <span class="hljs-keyword">continue</span>;<br>            set.add(grid[i + dir[<span class="hljs-number">0</span>]][j + dir[<span class="hljs-number">1</span>]]);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> element : set) &#123;<br>            res += idToArea.getOrDefault(element, <span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSingleArea</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span>[][] grid, <span class="hljs-type">int</span> id)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || i == grid.length || j == grid.length || grid[i][j] != <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        grid[i][j] = id;<br>        <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>            res += getSingleArea(i + dir[<span class="hljs-number">0</span>], j + dir[<span class="hljs-number">1</span>], grid, id);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="二刷">二刷</h4>
<p>注意hashmap与hashset的使用细节</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">largestIsland</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; grid.length; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; grid[<span class="hljs-number">0</span>].length; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>) &#123;<br>                    map.put(id, getArea(i, j, grid, id));<br>                    ++id;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; grid.length; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; grid[<span class="hljs-number">0</span>].length; ++j) &#123;<br>                res = Math.max(res, dfs(i, j, grid, map));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span>[][] grid, Map&lt;Integer, Integer&gt; map)</span> &#123;<br>        <span class="hljs-keyword">if</span> (grid[i][j] &gt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> map.get(grid[i][j]);<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], col = j + dir[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (isValid(row, col, grid)) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> grid[row][col];<br>                set.add(id);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> id : set) &#123;<br>            res += map.getOrDefault(id, <span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getArea</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span>[][] grid, <span class="hljs-type">int</span> id)</span> &#123;<br>        grid[i][j] = id;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], col = j + dir[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (isValid(row, col, grid) &amp;&amp; grid[row][col] == <span class="hljs-number">1</span>) &#123;<br>                grid[row][col] = id;<br>                res += getArea(row, col, grid, id);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-keyword">return</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; grid.length &amp;&amp; j &lt; grid[<span class="hljs-number">0</span>].length);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="岛屿的周长"><a href="https://leetcode.cn/problems/island-perimeter/">463. 岛屿的周长</a></h3>
<h4 id="方法一dfs-7">方法一：DFS</h4>
<p>岛屿的上下左右如果是水域或者超出边界，那么周长加一</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">islandPerimeter</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; grid.length; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; grid[<span class="hljs-number">0</span>].length; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>) &#123;<br>                    grid[i][j] = <span class="hljs-number">2</span>;<br>                    <span class="hljs-keyword">return</span> dfs(i, j, grid);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], col = j + dir[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (isValid(row, col, grid) &amp;&amp; grid[row][col] == <span class="hljs-number">1</span>) &#123;<br>                grid[row][col] = <span class="hljs-number">2</span>;<br>                res += dfs(row, col, grid);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (!isValid(row, col, grid) || grid[row][col] == <span class="hljs-number">0</span>)<br>                    ++res;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-keyword">return</span> !(i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || i == grid.length || j == grid[<span class="hljs-number">0</span>].length);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230505110513862.png" alt="image-20230505110513862" style="zoom:50%;" /></p>
<h3 id="飞地的数量warning"><a href="https://leetcode.cn/problems/number-of-enclaves/">1020. 飞地的数量</a>:warning:</h3>
<p>遇到一个陆地，只会返回numEnclaves进入dfs返回的值，因为相连的陆地在grid中会被修改，numEnclaves循环中不会再次fang'wen</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numEnclaves</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; grid.length; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; grid[<span class="hljs-number">0</span>].length; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>) &#123;<br>                    grid[i][j] = <span class="hljs-number">2</span>;<br>                    res += dfs(i, j, grid);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], col = j + dir[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (!isValid(row, col, grid)) &#123;<br>                grid[i][j] = <span class="hljs-number">3</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (grid[row][col] == <span class="hljs-number">1</span>) &#123;<br>                grid[row][col] = <span class="hljs-number">2</span>;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> dfs(row, col, grid);<br>                <span class="hljs-keyword">if</span> (ans == <span class="hljs-number">0</span>) &#123;<br>                    grid[i][j] = <span class="hljs-number">3</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <br>                    res += ans;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> grid[i][j] == <span class="hljs-number">3</span> ? <span class="hljs-number">0</span> : res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; grid.length &amp;&amp; j &lt; grid[<span class="hljs-number">0</span>].length;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230505115024363.png" alt="image-20230505115024363" style="zoom:50%;" /></p>
<h3 id="被围绕的区域"><a href="https://leetcode.cn/problems/surrounded-regions/">130. 被围绕的区域</a></h3>
<ol type="1">
<li><strong>从边界(第一行，最后一行以及第一列和最后一列)找到O，这些O肯定不会被围绕，把这些O都标记为#</strong></li>
<li>把其他位置的O全部赋值为X，将#还原为O</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">solve</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> board.length, n = board[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">if</span> (m &lt;= <span class="hljs-number">2</span> || n &lt;= <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i += m - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;O&#x27;</span>) &#123;<br>                    board[i][j] = <span class="hljs-string">&#x27;#&#x27;</span>;<br>                    dfs(i, j, board);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j += n - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>                <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;O&#x27;</span>) &#123;<br>                    board[i][j] = <span class="hljs-string">&#x27;#&#x27;</span>;<br>                    dfs(i, j, board);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;O&#x27;</span>)<br>                    board[i][j] = <span class="hljs-string">&#x27;X&#x27;</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;#&#x27;</span>)<br>                    board[i][j] = <span class="hljs-string">&#x27;O&#x27;</span>;                <br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">char</span>[][] board)</span> &#123;<br>        <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][] &#123;&#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], col = j + dir[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (isValid(row, col, board) &amp;&amp; board[row][col] == <span class="hljs-string">&#x27;O&#x27;</span>) &#123;<br>                board[row][col] = <span class="hljs-string">&#x27;#&#x27;</span>;<br>                dfs(row, col, board);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">char</span>[][] board)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; board[<span class="hljs-number">0</span>].length &amp;&amp; i &lt; board.length;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="太平洋大西洋水流问题star"><a href="https://leetcode.cn/problems/pacific-atlantic-water-flow/">417. 太平洋大西洋水流问题</a>:star:</h3>
<h4 id="方法一dfs-8">方法一：DFS</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">pacificAtlantic</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] heights)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> heights.length, n = heights[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">boolean</span>[][] pacific = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n], atlantic = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) <br>            dfs(<span class="hljs-number">0</span>, j, heights, pacific);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; ++i)<br>            dfs(i, <span class="hljs-number">0</span>, heights, pacific);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j)<br>            dfs(m - <span class="hljs-number">1</span>, j, heights, atlantic);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m - <span class="hljs-number">1</span>; ++i)<br>            dfs(i, n - <span class="hljs-number">1</span>, heights, atlantic);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (pacific[i][j] &amp;&amp; atlantic[i][j]) &#123;<br>                    List&lt;Integer&gt; temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(<span class="hljs-number">2</span>);<br>                    temp.add(i);<br>                    temp.add(j);<br>                    res.add(temp);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;   <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span>[][] heights, <span class="hljs-type">boolean</span>[][] ocean)</span> &#123;<br>        <span class="hljs-keyword">if</span> (ocean[i][j])<br>            <span class="hljs-keyword">return</span>;<br>        ocean[i][j] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], col = j + dir[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (isValid(row, col, heights) &amp;&amp; heights[row][col] &gt;= heights[i][j])<br>                dfs(row, col, heights, ocean);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span>[][] heights)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; heights.length &amp;&amp; j &lt; heights[<span class="hljs-number">0</span>].length;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230509151119008.png" alt="image-20230509151119008" style="zoom:50%;" /></p>
<h3 id="单词接龙"><a href="https://leetcode.cn/problems/word-ladder/">127. 单词接龙</a></h3>
<h4 id="方法一单向广度优先搜索">方法一：单向广度优先搜索</h4>
<ol type="1">
<li><p>需要两个队列存储邻居，第一个队列存储的邻居neighbor1距离beginWord的距离是d，将neighbor1的邻居neighbor2存储在queue2中，neighbor2距离beginWord的距离是d + 1</p></li>
<li><p>每当把访问完所有queue1中的neighbor1，并且将neighbor2加入到queue2中，那么需要访问新一轮邻居，于是把queue1指向queue2(queue2赋值给queue1)，queue2再新开辟一段空间，<strong>此时length(距离)需要加一</strong></p></li>
<li><p>开始时需要使用一个HashSet，并将单词表直接放进去，Set&lt;String&gt; set = new HashSet&lt;&gt;(wordList)。函数getNeibours用于找到当前单词所有可能的邻居单词(只有一个字母不同)，对比set中的单词表，如果set中有对应的邻居单词x，则把x加入queue1，并且从set中移除x(如果不移除x，则会重复计算，比如hot的邻居有lot,如果不移除lot，那么下次，如下图</p>
<figure>
<img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230509162229556.png" alt="image-20230509162229556" /><figcaption aria-hidden="true">image-20230509162229556</figcaption>
</figure></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ladderLength</span><span class="hljs-params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> &#123;<br>        Queue&lt;String&gt; queue1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        Queue&lt;String&gt; queue2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(wordList);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        queue1.offer(beginWord);<br>        <span class="hljs-keyword">while</span> (!queue1.isEmpty()) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">word</span> <span class="hljs-operator">=</span> queue1.poll();<br>            <span class="hljs-keyword">if</span> (word.equals(endWord))<br>                <span class="hljs-keyword">return</span> length;<br>            List&lt;String&gt; neibours = getNeibours(word);<br>            <span class="hljs-keyword">for</span> (String str : neibours) &#123;<br>                <span class="hljs-keyword">if</span> (set.contains(str)) &#123;<br>                    queue2.offer(str);<br>                    set.remove(str);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (queue1.isEmpty()) &#123;<br>                ++length;<br>                queue1 = queue2;<br>                queue2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">getNeibours</span><span class="hljs-params">(String word)</span> &#123;<br>        List&lt;String&gt; neibours = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">char</span>[] ch = word.toCharArray();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; ch.length; ++i) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">original</span> <span class="hljs-operator">=</span> ch[i];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span>; j &lt;= <span class="hljs-string">&#x27;z&#x27;</span>; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (j != original) &#123;<br>                    ch[i] = j;<br>                    neibours.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(ch));<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// backtracking</span><br>            ch[i] = original;<br>        &#125;<br>        <span class="hljs-keyword">return</span> neibours;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230509160526312.png" alt="image-20230509160526312" style="zoom:50%;" /></p>
<h3 id="剑指-offer-ii-109.-开密码锁"><a href="https://leetcode.cn/problems/zlDJc7/">剑指 Offer II 109. 开密码锁</a></h3>
<p><strong>注意visited的位置！！！同上一题，在入队时就在visited加入该邻居，避免之后的重复访问</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">openLock</span><span class="hljs-params">(String[] deadends, String target)</span> &#123;<br>        Set&lt;String&gt; deadSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(Arrays.asList(deadends)), visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">init</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;0000&quot;</span>;<br>        <span class="hljs-keyword">if</span> (deadSet.contains(init) || deadSet.contains(target)) <br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        visited.add(init);<br>        Queue&lt;String&gt; queue1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(), queue2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue1.offer(init);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!queue1.isEmpty()) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> queue1.poll();<br>            <span class="hljs-keyword">if</span> (code.equals(target))<br>                <span class="hljs-keyword">return</span> res;<br>            List&lt;String&gt; neibors = getNeibors(code);<br>            <span class="hljs-keyword">for</span> (String neibor : neibors) &#123;<br>                <span class="hljs-keyword">if</span> (!deadSet.contains(neibor) &amp;&amp; !visited.contains(neibor)) &#123;<br>                    queue2.offer(neibor);<br>                    visited.add(neibor);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (queue1.isEmpty()) &#123;<br>                ++res;<br>                queue1 = queue2;<br>                queue2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">getNeibors</span><span class="hljs-params">(String code)</span> &#123;<br>        List&lt;String&gt; neibors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; code.length(); ++i) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> code.charAt(i);<br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(code);<br>            <span class="hljs-comment">// down</span><br>            <span class="hljs-type">char</span> <span class="hljs-variable">changed</span> <span class="hljs-operator">=</span> cur == <span class="hljs-string">&#x27;0&#x27;</span> ? <span class="hljs-string">&#x27;9&#x27;</span> : (<span class="hljs-type">char</span>) (cur - <span class="hljs-number">1</span>);<br>            sb.setCharAt(i, changed);<br>            neibors.add(sb.toString());<br>            <span class="hljs-comment">// up</span><br>            changed = cur == <span class="hljs-string">&#x27;9&#x27;</span> ? <span class="hljs-string">&#x27;0&#x27;</span> : (<span class="hljs-type">char</span>) (cur + <span class="hljs-number">1</span>);<br>            sb.setCharAt(i, changed);<br>            neibors.add(sb.toString());<br>        &#125;<br>        <span class="hljs-keyword">return</span> neibors;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230509182826126.png" alt="image-20230509182826126" style="zoom:50%;" /></p>
<h3 id="剑指-offer-ii-106.-二分图warning"><a href="https://leetcode.cn/problems/vEAB3K/">剑指 Offer II 106. 二分图</a>:warning:</h3>
<h4 id="方法一dfs-9">方法一：DFS</h4>
<p><strong>染色法需要二刷</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">UNCOLORED</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">RED</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">BLUE</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] colorArray;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBipartite</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] graph)</span> &#123;<br>        colorArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[graph.length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; graph.length &amp;&amp; res; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (colorArray[i] == UNCOLORED) &#123;<br>                dfs(i, graph, RED);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span>[][] graph, <span class="hljs-type">int</span> color)</span> &#123;<br>        colorArray[i] = color;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">neighborColor</span> <span class="hljs-operator">=</span> color == RED ? BLUE : RED;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> neibor : graph[i]) &#123;<br>            <span class="hljs-keyword">if</span> (colorArray[neibor] == UNCOLORED) &#123;<br>                dfs(neibor, graph, neighborColor);<br>                <span class="hljs-keyword">if</span> (!res)<br>                    <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (colorArray[neibor] == neighborColor) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                res = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230512141330516.png" alt="image-20230512141330516" style="zoom:50%;" /></p>
<h4 id="方法二bfs-5">方法二：BFS</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">UNCOLORED</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">RED</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">BLUE</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] colorArray;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBipartite</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] graph)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> graph.length;<br>        colorArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[graph.length];<br>        Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (colorArray[i] == UNCOLORED) &#123;<br>                queue.offer(i);<br>                colorArray[i] = RED;<br>                <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> queue.poll();<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">neiborColor</span> <span class="hljs-operator">=</span> colorArray[cur] == RED ? BLUE : RED;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> neibor : graph[cur]) &#123;<br>                        <span class="hljs-keyword">if</span> (colorArray[neibor] == UNCOLORED) &#123;<br>                            queue.offer(neibor);<br>                            colorArray[neibor] = neiborColor;<br>                        &#125;<br>                        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (colorArray[neibor] != neiborColor)<br>                            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;        <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230512143824018.png" alt="image-20230512143824018" style="zoom:50%;" /></p>
<h3 id="剑指-offer-ii-107.-矩阵中的距离"><a href="https://leetcode.cn/problems/2bCMpM/">剑指 Offer II 107. 矩阵中的距离</a></h3>
<h4 id="方法一bfs-5">方法一：BFS</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] updateMatrix(<span class="hljs-type">int</span>[][] mat) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> mat.length, n = mat[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[][] dist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-type">boolean</span>[][] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n];<br>        Queue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; mat.length; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; mat[i].length; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (mat[i][j] == <span class="hljs-number">0</span>) &#123;<br>                    visited[i][j] = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-comment">// dist[i][j] = 0;</span><br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, j&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span>[] pos = queue.poll();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">distance</span> <span class="hljs-operator">=</span> dist[pos[<span class="hljs-number">0</span>]][pos[<span class="hljs-number">1</span>]];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> pos[<span class="hljs-number">0</span>] + dir[<span class="hljs-number">0</span>], col = pos[<span class="hljs-number">1</span>] + dir[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span> (isValid(row, col, m, n) &amp;&amp; !visited[row][col]) &#123;<br>                    visited[row][col] = <span class="hljs-literal">true</span>;<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;row, col&#125;);<br>                    dist[row][col] = distance + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dist;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &lt; n;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230513143656362.png" alt="image-20230513143656362" style="zoom:50%;" /></p>
<h3 id="剑指-offer-ii-111.-计算除法warning"><a href="https://leetcode.cn/problems/vlzXQL/">剑指 Offer II 111. 计算除法</a>:warning:</h3>
<h4 id="方法一bfs-6">方法一：BFS</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span>[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, <span class="hljs-type">double</span>[] values, List&lt;List&lt;String&gt;&gt; queries) &#123;<br>        <span class="hljs-type">double</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[queries.size()];<br>        Map&lt;String, Map&lt;String, Double&gt;&gt; graph = buildGraph(equations, values);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; queries.size(); ++i) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">from</span> <span class="hljs-operator">=</span> queries.get(i).get(<span class="hljs-number">0</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">to</span> <span class="hljs-operator">=</span> queries.get(i).get(<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (!graph.containsKey(from) || !graph.containsKey(to))<br>                res[i] = -<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> &#123;<br>                Set&lt;String&gt; visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>                res[i] = dfs(graph, visited, from, to);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;    <br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(Map&lt;String, Map&lt;String, Double&gt;&gt; graph, Set&lt;String&gt; visited, String from, String to)</span> &#123;<br>        <span class="hljs-keyword">if</span> (from.equals(to)) <br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span>;<br>        visited.add(from);<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;String, Double&gt; entry: graph.get(from).entrySet()) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> entry.getKey();<br>            <span class="hljs-type">double</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> entry.getValue();<br>            <span class="hljs-keyword">if</span> (!visited.contains(key)) &#123;<br>                <span class="hljs-type">double</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> dfs(graph, visited, key, to);<br>                <span class="hljs-keyword">if</span> (res != -<span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">return</span> res * val;<br>                &#125;<br>            &#125;<br>        &#125;<br>        visited.remove(from);<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1.0</span>;<br>    &#125;<br>    <span class="hljs-keyword">private</span> Map&lt;String, Map&lt;String, Double&gt;&gt; <span class="hljs-title function_">buildGraph</span><span class="hljs-params">(List&lt;List&lt;String&gt;&gt; equations, <span class="hljs-type">double</span>[] values)</span> &#123;<br>        Map&lt;String, Map&lt;String, Double&gt;&gt; graph = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; equations.size(); ++i) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">var1</span> <span class="hljs-operator">=</span> equations.get(i).get(<span class="hljs-number">0</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">var2</span> <span class="hljs-operator">=</span> equations.get(i).get(<span class="hljs-number">1</span>);<br>            graph.putIfAbsent(var1, <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;());<br>            graph.get(var1).put(var2, values[i]);<br>            graph.putIfAbsent(var2, <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;());<br>            graph.get(var2).putIfAbsent(var1, <span class="hljs-number">1.0</span> / values[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> graph;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230513165232508.png" alt="image-20230513165232508" style="zoom:50%;" /></p>
<h3 id="剑指-offer-ii-112.-最长递增路径star"><a href="https://leetcode.cn/problems/fpTFWP/">剑指 Offer II 112. 最长递增路径</a>:star:</h3>
<h4 id="方法一dfs-10">方法一：DFS</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-type">int</span>[][] path;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestIncreasingPath</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, m = matrix.length, n = matrix[<span class="hljs-number">0</span>].length;<br>        path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">dist</span> <span class="hljs-operator">=</span> dfs(i, j, m, n, matrix);<br>                res = Math.max(res, dist);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-keyword">if</span> (path[i][j] != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> path[i][j];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], col = j + dir[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (isValid(row, col, m, n) &amp;&amp; matrix[row][col] &gt; matrix[i][j]) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">dist</span> <span class="hljs-operator">=</span> dfs(row, col, m, n, matrix);<br>                max = Math.max(max, dist + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;        <br>        path[i][j] = max;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &lt; n;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230513175541175.png" alt="image-20230513175541175" style="zoom:50%;" /></p>
<h3 id="剑指-offer-ii-113.-课程顺序"><a href="https://leetcode.cn/problems/QA2IGt/">剑指 Offer II 113. 课程顺序</a></h3>
<h4 id="方法一拓扑排序">方法一：拓扑排序</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] findOrder(<span class="hljs-type">int</span> numCourses, <span class="hljs-type">int</span>[][] prerequisites) &#123;<br>        Map&lt;Integer, List&lt;Integer&gt;&gt; graph = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numCourses; ++i)<br>            graph.put(i, <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;());<br>        <span class="hljs-type">int</span>[] inDegrees = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[numCourses];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; prerequisites.length; ++i) &#123;<br>            ++inDegrees[prerequisites[i][<span class="hljs-number">0</span>]];<br>            graph.get(prerequisites[i][<span class="hljs-number">1</span>]).add(prerequisites[i][<span class="hljs-number">0</span>]);<br>        &#125;<br>        List&lt;Integer&gt; order = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numCourses; ++i)<br>            <span class="hljs-keyword">if</span> (inDegrees[i] == <span class="hljs-number">0</span>)<br>                queue.offer(i);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>            order.add(node);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> next : graph.get(node)) &#123;<br>                <span class="hljs-keyword">if</span> (--inDegrees[next] == <span class="hljs-number">0</span>) &#123;<br>                    queue.offer(next);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> order.size() == numCourses ? order.stream().mapToInt(Integer::intValue).toArray() : <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="C:\Users\ning\AppData\Roaming\Typora\typora-user-images\image-20230513205516894.png" alt="image-20230513205516894" style="zoom:50%;" /></p>
<h3 id="剑指-offer-ii-114.-外星文字典"><a href="https://leetcode.cn/problems/Jf1JuT/">剑指 Offer II 114. 外星文字典</a></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">alienOrder</span><span class="hljs-params">(String[] words)</span> &#123;<br>        Map&lt;Character, Set&lt;Character&gt;&gt; graph = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Map&lt;Character, Integer&gt; inDegrees = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (String word : words) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : word.toCharArray()) &#123;<br>                graph.putIfAbsent(ch, <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;());<br>                inDegrees.putIfAbsent(ch, <span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; words.length; ++i) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">word1</span> <span class="hljs-operator">=</span> words[i - <span class="hljs-number">1</span>];<br>            <span class="hljs-type">String</span> <span class="hljs-variable">word2</span> <span class="hljs-operator">=</span> words[i];<br>            <span class="hljs-keyword">if</span> (word1.startsWith(word2) &amp;&amp; !word1.equals(word2))<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; word1.length() &amp;&amp; j &lt; word2.length(); ++j) &#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">ch1</span> <span class="hljs-operator">=</span> word1.charAt(j);<br>                <span class="hljs-type">char</span> <span class="hljs-variable">ch2</span> <span class="hljs-operator">=</span> word2.charAt(j);<br>                <span class="hljs-keyword">if</span> (ch1 != ch2) &#123;<br>                    <span class="hljs-keyword">if</span> (!graph.get(ch1).contains(ch2)) &#123;<br>                        graph.get(ch1).add(ch2);<br>                        inDegrees.put(ch2, inDegrees.get(ch2) + <span class="hljs-number">1</span>);<br>                    &#125;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        Queue&lt;Character&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;Character, Integer&gt; entry : inDegrees.entrySet()) &#123;<br>            <span class="hljs-keyword">if</span> (entry.getValue() == <span class="hljs-number">0</span>) &#123;<br>                queue.offer(entry.getKey());<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> queue.poll();<br>            res.append(ch);<br>            Set&lt;Character&gt; nexts = graph.get(ch);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> next : nexts) &#123;<br>                inDegrees.put(next, inDegrees.get(next) - <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span> (inDegrees.get(next) == <span class="hljs-number">0</span>)<br>                    queue.offer(next);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res.length() == graph.size() ? res.toString() : <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230514152639854.png" alt="image-20230514152639854" style="zoom:50%;" /></p>
<h3 id="剑指-offer-ii-115.-重建序列"><a href="https://leetcode.cn/problems/ur2n8P/">剑指 Offer II 115. 重建序列</a></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">sequenceReconstruction</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span>[][] sequences)</span> &#123;<br>        Map&lt;Integer, Set&lt;Integer&gt;&gt; graph = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Map&lt;Integer, Integer&gt; inDegrees = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] sequence : sequences) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : sequence) &#123;<br>                graph.putIfAbsent(num, <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;());<br>                inDegrees.put(num, <span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; sequences.length; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; sequences[i].length; ++j) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">num1</span> <span class="hljs-operator">=</span> sequences[i][j - <span class="hljs-number">1</span>], num2 = sequences[i][j];<br>                <span class="hljs-keyword">if</span> (!graph.get(num1).contains(num2)) &#123;<br>                    graph.get(num1).add(num2);<br>                    inDegrees.put(num2, inDegrees.get(num2) + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : inDegrees.entrySet()) &#123;<br>            <span class="hljs-keyword">if</span> (entry.getValue() == <span class="hljs-number">0</span>) &#123;<br>                queue.offer(entry.getKey());<br>            &#125;<br>        &#125;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (queue.size() == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> queue.poll();<br>            res.add(num);<br>            Set&lt;Integer&gt; nexts = graph.get(num);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> next : nexts) &#123;<br>                inDegrees.put(next, inDegrees.get(next) - <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span> (inDegrees.get(next) == <span class="hljs-number">0</span>)<br>                    queue.offer(next);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span>[] resToArr = res.stream().mapToInt(Integer::intValue).toArray();<br>        <span class="hljs-keyword">return</span> Arrays.equals(resToArr, nums);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="C:\Users\ning\AppData\Roaming\Typora\typora-user-images\image-20230514170017608.png" alt="image-20230514170017608" style="zoom:50%;" /></p>
<h3 id="剑指-offer-ii-116.-省份数量"><a href="https://leetcode.cn/problems/bLyHh0/">剑指 Offer II 116. 省份数量</a></h3>
<h4 id="方法一dfs-11">方法一：DFS</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findCircleNum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] isConnected)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> isConnected.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (!visited[i]) &#123;<br>                visited[i] = <span class="hljs-literal">true</span>;<br>                dfs(i, n, visited, isConnected);<br>                ++res;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> n, <span class="hljs-type">boolean</span>[] visited, <span class="hljs-type">int</span>[][] isConnected)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (isConnected[i][j] == <span class="hljs-number">1</span> &amp;&amp; !visited[j]) &#123;<br>                visited[j] = <span class="hljs-literal">true</span>;<br>                dfs(j, n, visited, isConnected);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="C:\Users\ning\AppData\Roaming\Typora\typora-user-images\image-20230514183621868.png" alt="image-20230514183621868" style="zoom:50%;" /></p>
<h4 id="方法二bfs-6">方法二：BFS</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findCircleNum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] isConnected)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> isConnected.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n];<br>        Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (!visited[i]) &#123;<br>                ++res;<br>                queue.offer(i);<br>                <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">province</span> <span class="hljs-operator">=</span> queue.poll();<br>                    visited[province] = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                        <span class="hljs-keyword">if</span> (isConnected[province][j] == <span class="hljs-number">1</span> &amp;&amp; !visited[j]) &#123;<br>                            visited[j] = <span class="hljs-literal">true</span>;<br>                            queue.offer(j);<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230515092815433.png" alt="image-20230515092815433" style="zoom:50%;" /></p>
<h4 id="方法三并查集">方法三：并查集</h4>
<p><a href="https://zhuanlan.zhihu.com/p/93647900">并查集的讲解</a></p>
<ol type="1">
<li>findFather一定要return fathers[i]，而不是return i，因为当0的father是1的时候，return 1 而不是return 0！</li>
<li>两层for循环第二层j = i + 1，因为首先j = i的话，是遍历两个相同的节点没意义；其次，i之前的节点在之前就已经合并过了，所以不需要再遍历了</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findCircleNum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] isConnected)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> isConnected.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> n;<br>        <span class="hljs-type">int</span>[] fathers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            fathers[i] = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (isConnected[i][j] == <span class="hljs-number">1</span> &amp;&amp; union(i, j, fathers)) &#123;<br>                    --res;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span>[] fathers)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">fatherOfI</span> <span class="hljs-operator">=</span> findFather(i, fathers);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">fatherOfJ</span> <span class="hljs-operator">=</span> findFather(j, fathers);<br>        <span class="hljs-keyword">if</span> (fatherOfI != fatherOfJ) &#123;<br>            fathers[fatherOfI] = fatherOfJ;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span>  <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findFather</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span>[] fathers)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i != fathers[i])<br>            fathers[i] = findFather(fathers[i], fathers);<br>        <span class="hljs-keyword">return</span> fathers[i];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="C:\Users\ning\AppData\Roaming\Typora\typora-user-images\image-20230515095537722.png" alt="image-2023051509 5537722" style="zoom:50%;" /></p>
<h3 id="剑指-offer-ii-117.-相似的字符串"><a href="https://leetcode.cn/problems/H6lPxb/">剑指 Offer II 117. 相似的字符串</a></h3>
<h4 id="方法一并查集">方法一：并查集</h4>
<ol type="1">
<li>判断是否是相似字符串的函数isAnalogical之前用的蠢方法，还要拷贝再交换，直接判断不同字符num的个数就行
<ol type="1">
<li>如果num==0，那么相似</li>
<li>由于题目给出的字符串数组中，所有字符串互为 <strong>字母异位词</strong>(字母顺序不同)，所以num == 2时，是交换了两个字符，如果num &gt; 2，就不符合题意了</li>
</ol></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numSimilarGroups</span><span class="hljs-params">(String[] strs)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> strs.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> n;<br>        <span class="hljs-type">int</span>[] fathers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            fathers[i] = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> strs[i], str2 = strs[j];<br>                <span class="hljs-keyword">if</span> (isAnalogical(str1, str2) &amp;&amp; union(i, j, fathers)) &#123;<br>                    --res;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span>[] fathers)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">fatherOfI</span> <span class="hljs-operator">=</span> findFather(i, fathers);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">fatherOfJ</span> <span class="hljs-operator">=</span> findFather(j, fathers);<br>        <span class="hljs-keyword">if</span> (fatherOfI != fatherOfJ) &#123;<br>            fathers[fatherOfI] = fatherOfJ;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findFather</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span>[] fathers)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i != fathers[i])<br>            fathers[i] = findFather(fathers[i], fathers);<br>        <span class="hljs-keyword">return</span> fathers[i];<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAnalogical</span><span class="hljs-params">(String a, String b)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; a.length(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (a.charAt(i) != b.charAt(i)) &#123;<br>                num++;<br>                <span class="hljs-keyword">if</span> (num &gt; <span class="hljs-number">2</span>) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230515111701411.png" alt="image-20230515111701411" style="zoom:50%;" /></p>
<h3 id="剑指-offer-ii-118.-多余的边"><a href="https://leetcode.cn/problems/7LpjUW/">剑指 Offer II 118. 多余的边</a></h3>
<h4 id="方法一并查集-1">方法一：并查集</h4>
<figure>
<img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230515135402396.png" alt="image-20230515135402396" /><figcaption aria-hidden="true">image-20230515135402396</figcaption>
</figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] findRedundantConnection(<span class="hljs-type">int</span>[][] edges) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> edges.length;<br>        <span class="hljs-type">int</span>[] fathers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            fathers[i] = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] edge : edges) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">node1</span> <span class="hljs-operator">=</span> edge[<span class="hljs-number">0</span>], node2 = edge[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (!union(node1, node2, fathers))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;node1, node2&#125;;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span>[] fathers)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">fatherOfI</span> <span class="hljs-operator">=</span> findFather(i, fathers);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">fatherOfJ</span> <span class="hljs-operator">=</span> findFather(j, fathers);<br>        <span class="hljs-keyword">if</span> (fatherOfI != fatherOfJ) &#123;<br>            fathers[fatherOfI] = fatherOfJ;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findFather</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span>[] fathers)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i != fathers[i])<br>            fathers[i] = findFather(fathers[i], fathers);<br>        <span class="hljs-keyword">return</span> fathers[i];<br>    &#125;<br>&#125;           <br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230515135336208.png" alt="image-20230515135336208" style="zoom:50%;" /></p>
<h3 id="剑指-offer-ii-119.-最长连续序列"><a href="https://leetcode.cn/problems/WhsWhI/">剑指 Offer II 119. 最长连续序列</a></h3>
<h4 id="方法一暴力-5">方法一：暴力</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestConsecutive</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        Arrays.sort(nums);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : nums)<br>            System.out.print(i + <span class="hljs-string">&quot; &quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, cur = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] == nums[i - <span class="hljs-number">1</span>])<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (nums[i] - nums[i - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span>) &#123;<br>                ++cur;<br>                res = Math.max(res, cur);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                cur = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230515140831174.png" alt="image-20230515140831174" style="zoom:50%;" /></p>
<h4 id="方法二并查集">方法二：并查集</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestConsecutive</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Map&lt;Integer, Integer&gt; fathers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(), count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            fathers.put(num, num);<br>            count.put(num, <span class="hljs-number">1</span>);<br>            set.add(num);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-keyword">if</span> (set.contains(num + <span class="hljs-number">1</span>)) &#123;<br>                union(num, num + <span class="hljs-number">1</span>, fathers, count);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (set.contains(num - <span class="hljs-number">1</span>)) &#123;<br>                union(num, num - <span class="hljs-number">1</span>, fathers, count);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> val : count.values()) &#123;<br>            res = Math.max(res, val);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, Map&lt;Integer, Integer&gt; fathers, Map&lt;Integer, Integer&gt; count)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">fatherOfI</span> <span class="hljs-operator">=</span> findFather(i, fathers);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">fatherOfJ</span> <span class="hljs-operator">=</span> findFather(j, fathers);<br>        <span class="hljs-keyword">if</span> (fatherOfI != fatherOfJ) &#123;<br>            fathers.put(fatherOfI, fatherOfJ);<br>            count.put(fatherOfJ, count.get(fatherOfI) + count.get(fatherOfJ));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findFather</span><span class="hljs-params">(<span class="hljs-type">int</span> i, Map&lt;Integer, Integer&gt; fathers)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">fatherOfI</span> <span class="hljs-operator">=</span> fathers.get(i);<br>        <span class="hljs-keyword">if</span> (i != fatherOfI) &#123;<br>            fathers.put(i, findFather(fatherOfI, fathers));<br>        &#125;<br>        <span class="hljs-keyword">return</span> fathers.get(i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230515152018466.png" alt="image-20230515152018466" style="zoom:50%;" /></p>
<h2 id="binary-search">Binary Search</h2>
<h3 id="剑指-offer-ii-068.-查找插入位置"><a href="https://leetcode.cn/problems/N6YdxV/">剑指 Offer II 068. 查找插入位置</a></h3>
<h4 id="方法一-3">方法一：</h4>
<ol type="1">
<li><p>如果nums中有target，那么会被找到并被返回</p></li>
<li><p>如果nums中没有target，那么有三种情况，这个数应该被插入道</p>
<ol type="1">
<li>第一个位置</li>
<li>最后一个位置</li>
<li>中间</li>
</ol>
<p>这三种情况的索引都是退出循环后的left！！！</p></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">searchInsert</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> right - ((right - left) &gt;&gt; <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (nums[mid] == target)<br>                <span class="hljs-keyword">return</span> mid;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) <br>                right = mid - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二">方法二：</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">searchInsert</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> right - ((right - left) &gt;&gt; <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (nums[mid] &gt;= target) &#123;<br>                <span class="hljs-keyword">if</span> (mid == <span class="hljs-number">0</span> || nums[mid - <span class="hljs-number">1</span>] &lt; target)<br>                    <span class="hljs-keyword">return</span> mid;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums.length;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="heap">Heap</h2>
<h3 id="剑指-offer-ii-059.-数据流的第-k-大数值"><a href="https://leetcode.cn/problems/jBjn9C/">剑指 Offer II 059. 数据流的第 K 大数值</a></h3>
<h4 id="方法一小根堆">方法一：小根堆</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">KthLargest</span> &#123;<br><br>    <span class="hljs-keyword">private</span> PriorityQueue&lt;Integer&gt; queue;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">KthLargest</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>        size = k;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            add(num);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        queue.offer(val);<br>        <span class="hljs-keyword">if</span> (queue.size() &gt;  size) &#123;<br>            queue.poll();<br>        &#125;<br>        <span class="hljs-keyword">return</span> queue.peek();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your KthLargest object will be instantiated and called as such:</span><br><span class="hljs-comment"> * KthLargest obj = new KthLargest(k, nums);</span><br><span class="hljs-comment"> * int param_1 = obj.add(val);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230515190222119.png" alt="image-20230515190222119" style="zoom:50%;" /></p>
<h4 id="方法二小根堆另一种写法">方法二：小根堆另一种写法</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">KthLargest</span> &#123;<br><br>    <span class="hljs-keyword">private</span> PriorityQueue&lt;Integer&gt; queue;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> k;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">KthLargest</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>        <span class="hljs-built_in">this</span>.k = k;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            add(num);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span> (queue.size() &lt; k) &#123;<br>            queue.offer(val);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (queue.size() == k &amp;&amp; queue.peek() &lt; val) &#123;<br>            queue.poll();<br>            queue.offer(val);<br>        &#125;<br>        <span class="hljs-keyword">return</span> queue.peek();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your KthLargest object will be instantiated and called as such:</span><br><span class="hljs-comment"> * KthLargest obj = new KthLargest(k, nums);</span><br><span class="hljs-comment"> * int param_1 = obj.add(val);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230515192704724.png" alt="image-20230515192704724" style="zoom:50%;" /></p>
<h3 id="剑指-offer-ii-060.-出现频率最高的-k-个数字"><a href="https://leetcode.cn/problems/g5c51o/">剑指 Offer II 060. 出现频率最高的 k 个数字</a></h3>
<h4 id="方法一小根堆-1">方法一：小根堆</h4>
<ol type="1">
<li>小根堆的比较方式</li>
<li>小根堆的类型是Map.Entry</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] topKFrequent(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        Map&lt;Integer, Integer&gt; count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            count.put(num, count.getOrDefault(num, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; minHeap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(<br>                (e1, e2) -&gt; e1.getValue() - e2.getValue());<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : count.entrySet()) &#123;<br>            <span class="hljs-keyword">if</span> (minHeap.size() &lt; k) &#123;<br>                minHeap.offer(entry);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (entry.getValue() &gt; minHeap.peek().getValue()) &#123;<br>                minHeap.poll();<br>                minHeap.offer(entry);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!minHeap.isEmpty()) <br>            res[i++] = minHeap.poll().getKey();<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230516095717058.png" alt="image-20230516095717058" style="zoom:50%;" /></p>
<h3 id="剑指-offer-ii-061.-和最小的-k-个数对"><a href="https://leetcode.cn/problems/qn8gGX/">剑指 Offer II 061. 和最小的 k 个数对</a></h3>
<h4 id="方法一大根堆">方法一：大根堆</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">kSmallestPairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2, <span class="hljs-type">int</span> k)</span> &#123;<br>        PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; maxHeap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(<br>                (o1, o2) -&gt; o2[<span class="hljs-number">0</span>] + o2[<span class="hljs-number">1</span>] - o1[<span class="hljs-number">0</span>] - o1[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; Math.min(k, nums1.length); ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; Math.min(k, nums2.length); ++j) &#123;<br>                <span class="hljs-keyword">if</span> (maxHeap.size() &lt; k)<br>                    maxHeap.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;nums1[i], nums2[j]&#125;);<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (maxHeap.peek()[<span class="hljs-number">0</span>] + maxHeap.peek()[<span class="hljs-number">1</span>] &gt; nums1[i] + nums2[j]) &#123;<br>                    maxHeap.poll();<br>                    maxHeap.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;nums1[i], nums2[j]&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (!maxHeap.isEmpty()) &#123;<br>            <span class="hljs-type">int</span>[] temp = maxHeap.poll();<br>            res.add(Arrays.asList(temp[<span class="hljs-number">0</span>], temp[<span class="hljs-number">1</span>]));<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230516101216749.png" alt="image-20230516101216749" style="zoom:50%;" /></p>
<h2 id="排序">排序</h2>
<h3 id="快速排序">快速排序</h3>
<p>边界问题：end &gt; start。当start == end的时候，已经是排序好的一个数，不需要在进行partition</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] sortArray(<span class="hljs-type">int</span>[] nums) &#123;<br>        quickSort(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-keyword">if</span> (end &gt; start) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">pivot</span> <span class="hljs-operator">=</span> partition(nums, start, end);<br>            quickSort(nums, start, pivot - <span class="hljs-number">1</span>);<br>            quickSort(nums, pivot + <span class="hljs-number">1</span>, end);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">partition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(end - start + <span class="hljs-number">1</span>) + start;<br>        swap(nums, random, end);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">small</span> <span class="hljs-operator">=</span> start - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; end; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &lt; nums[end]) &#123;<br>                ++small;<br>                swap(nums, small, i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 没有小于pivot的数了</span><br>        ++small;<br>        swap(nums, small, end);<br>        <span class="hljs-keyword">return</span> small;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> random, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-keyword">if</span> (random != end) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[end];<br>            nums[end] = nums[random];<br>            nums[random] = temp;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>&#125;;<br>        <span class="hljs-type">int</span>[] clone = nums.clone();<br>        <span class="hljs-type">QuickSort</span> <span class="hljs-variable">quickSort</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">QuickSort</span>();<br>        quickSort.sortArray(nums);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums)<br>            System.out.print(num + <span class="hljs-string">&quot; &quot;</span>);<br>        System.out.println();<br>        Arrays.sort(clone);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> cl : clone)<br>            System.out.print(cl + <span class="hljs-string">&quot; &quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure>
<h3 id="剑指-offer-ii-076.-数组中的第-k-大的数字"><a href="https://leetcode.cn/problems/xx4gT2/">剑指 Offer II 076. 数组中的第 k 大的数字</a></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findKthLargest</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> nums.length - k;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, end = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pivot</span> <span class="hljs-operator">=</span> partition(nums, start, end);<br>        <span class="hljs-keyword">while</span> (pivot != target) &#123;<br>            <span class="hljs-keyword">if</span> (pivot &gt; target) &#123;<br>                end = pivot - <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                start = pivot + <span class="hljs-number">1</span>;<br>            &#125;<br>            pivot = partition(nums, start, end);<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[pivot];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">partition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start , <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(end - start + <span class="hljs-number">1</span>) + start;<br>        swap(nums, random, end);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">small</span> <span class="hljs-operator">=</span> start - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; end; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &lt; nums[end]) &#123;<br>                ++small;<br>                swap(nums, small, i);<br>            &#125;<br>        &#125;<br>        ++small;<br>        swap(nums, small, end);<br>        <span class="hljs-keyword">return</span> small;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> index1, <span class="hljs-type">int</span> index2)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index1 != index2) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[index1];<br>            nums[index1] = nums[index2];<br>            nums[index2] = temp;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230516114230333.png" alt="image-20230516114230333" style="zoom:50%;" /></p>
<h2 id="前缀树">前缀树</h2>
<h3 id="剑指-offer-ii-062.-实现前缀树"><a href="https://leetcode.cn/problems/QC3q1f/">剑指 Offer II 062. 实现前缀树</a></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TrieNode</span> &#123;<br>        TrieNode[] children;<br>        <span class="hljs-type">boolean</span> isWord;<br><br>        <span class="hljs-keyword">public</span>  <span class="hljs-title function_">TrieNode</span><span class="hljs-params">()</span> &#123;<br>            children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>[<span class="hljs-number">26</span>];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> TrieNode root;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Trie</span><span class="hljs-params">()</span> &#123;<br>        root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>();<br>    &#125;<br><br>    <span class="hljs-comment">/** Inserts a word into the trie. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">TrieNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : word.toCharArray()) &#123;<br>            <span class="hljs-keyword">if</span> (cur.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">null</span>) &#123;<br>                cur.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>();<br>            &#125;<br>            cur = cur.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        cur.isWord = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/** Returns if the word is in the trie. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">search</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">TrieNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : word.toCharArray()) &#123;<br>            <span class="hljs-keyword">if</span> (cur.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            cur = cur.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> cur.isWord;<br>    &#125;<br><br>    <span class="hljs-comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">startsWith</span><span class="hljs-params">(String prefix)</span> &#123;<br>        <span class="hljs-type">TrieNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : prefix.toCharArray()) &#123;<br>            <span class="hljs-keyword">if</span> (cur.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            cur = cur.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230517105800114.png" alt="image-20230517105800114" style="zoom:50%;" /></p>
<h3 id="剑指-offer-ii-063.-替换单词"><a href="https://leetcode.cn/problems/UhWRSj/">剑指 Offer II 063. 替换单词</a></h3>
<h4 id="方法一前缀树">方法一：前缀树</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TrieNode</span> &#123;<br>        <span class="hljs-keyword">private</span> TrieNode[] children;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> isWord;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">TrieNode</span><span class="hljs-params">()</span> &#123;<br>            children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>[<span class="hljs-number">26</span>];<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">replaceWords</span><span class="hljs-params">(List&lt;String&gt; dictionary, String sentence)</span> &#123;<br>        <span class="hljs-type">TrieNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> buildTrie(dictionary);<br>        String[] words = sentence.split(<span class="hljs-string">&quot; &quot;</span>);<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; words.length; ++i) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">prefix</span> <span class="hljs-operator">=</span> findPrefix(root, words[i]);<br>            <span class="hljs-keyword">if</span> (!prefix.isEmpty()) &#123;<br>                words[i] = prefix;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> String.join(<span class="hljs-string">&quot; &quot;</span>, words);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">findPrefix</span><span class="hljs-params">(TrieNode root, String word)</span> &#123;<br>        <span class="hljs-type">TrieNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : word.toCharArray()) &#123;<br>            <span class="hljs-keyword">if</span> (cur.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">null</span> || cur.isWord)<br>                <span class="hljs-keyword">break</span>;<br>            sb.append(ch);<br>            cur = cur.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> cur.isWord == <span class="hljs-literal">true</span> ? sb.toString() : <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> TrieNode <span class="hljs-title function_">buildTrie</span><span class="hljs-params">(List&lt;String&gt; dictionary)</span> &#123;<br>        <span class="hljs-type">TrieNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>();<br>        <span class="hljs-keyword">for</span> (String str : dictionary) &#123;<br>            <span class="hljs-type">TrieNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : str.toCharArray()) &#123;<br>                <span class="hljs-keyword">if</span> (cur.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">null</span>)<br>                    cur.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>();<br>                cur = cur.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>];<br>            &#125;<br>            cur.isWord = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230517152321077.png" alt="image-20230517152321077" style="zoom:50%;" /></p>
<h3 id="剑指-offer-ii-064.-神奇的字典warning"><a href="https://leetcode.cn/problems/US1pGT/">剑指 Offer II 064. 神奇的字典</a>:warning:</h3>
<h4 id="方法一前缀树-1">方法一：前缀树</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MagicDictionary</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TrieNode</span> &#123;<br>        <span class="hljs-keyword">private</span> TrieNode[] children;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> isWord;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">TrieNode</span><span class="hljs-params">()</span> &#123;<br>            children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>[<span class="hljs-number">26</span>];<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-keyword">private</span> TrieNode root;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MagicDictionary</span><span class="hljs-params">()</span> &#123;<br>        root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildDict</span><span class="hljs-params">(String[] dictionary)</span> &#123;<br>        <span class="hljs-keyword">for</span> (String str : dictionary) &#123;<br>            <span class="hljs-type">TrieNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : str.toCharArray()) &#123;<br>                <span class="hljs-keyword">if</span> (cur.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">null</span>)<br>                    cur.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>();<br>                cur = cur.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>];<br>            &#125;<br>            cur.isWord = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">search</span><span class="hljs-params">(String searchWord)</span> &#123;<br>        <span class="hljs-keyword">return</span> dfs(root, searchWord, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TrieNode root, String searchWord, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> modifiedNum)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (root.isWord &amp;&amp; index == searchWord.length() &amp;&amp; modifiedNum == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (modifiedNum &lt;= <span class="hljs-number">1</span> &amp;&amp; index &lt; searchWord.length()) &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">found</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">26</span> &amp;&amp; !found; ++j) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> j == searchWord.charAt(index) - <span class="hljs-string">&#x27;a&#x27;</span> ? modifiedNum : modifiedNum + <span class="hljs-number">1</span>;<br>                found = dfs(root.children[j], searchWord, index + <span class="hljs-number">1</span>, next);<br>            &#125;<br>            <span class="hljs-keyword">return</span> found;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MagicDictionary object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MagicDictionary obj = new MagicDictionary();</span><br><span class="hljs-comment"> * obj.buildDict(dictionary);</span><br><span class="hljs-comment"> * boolean param_2 = obj.search(searchWord);</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//leetcode submit region end(Prohibit modification and deletion)</span><br><br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230517162222403.png" alt="image-20230517162222403" style="zoom:50%;" /></p>
<h3 id="剑指-offer-ii-065.-最短的单词编码warningstar"><a href="https://leetcode.cn/problems/iSwD2y/">剑指 Offer II 065. 最短的单词编码</a>:warning::star:</h3>
<h4 id="方法一前缀树-2">方法一：前缀树</h4>
<p><strong>这种DFS技巧非常重要！！！</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TrieNode</span> &#123;<br>        <span class="hljs-keyword">private</span> TrieNode[] children;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> isEnd;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">TrieNode</span><span class="hljs-params">()</span> &#123;<br>            children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>[<span class="hljs-number">26</span>];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumLengthEncoding</span><span class="hljs-params">(String[] words)</span> &#123;<br>        <span class="hljs-type">TrieNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> buildTree(words);<br>        dfs(root, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TrieNode root, <span class="hljs-type">int</span> length)</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isLeaf</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (TrieNode child : root.children) &#123;<br>            <span class="hljs-keyword">if</span> (child != <span class="hljs-literal">null</span>) &#123;<br>                isLeaf = <span class="hljs-literal">false</span>;<br>                dfs(child, length + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (isLeaf)<br>            res += length;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> TrieNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(String[] words)</span> &#123;<br>        <span class="hljs-type">TrieNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; words.length; ++i) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">word</span> <span class="hljs-operator">=</span> words[i];<br>            <span class="hljs-type">TrieNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> word.length() - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; --j) &#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> word.charAt(j);<br>                <span class="hljs-keyword">if</span> (cur.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">null</span>)<br>                    cur.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>();<br>                cur = cur.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>];<br>            &#125;<br>            cur.isEnd = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230517174243394.png" alt="image-20230517174243394" style="zoom:50%;" /></p>
<h3 id="剑指-offer-ii-066.-单词之和"><a href="https://leetcode.cn/problems/z1R5dt/">剑指 Offer II 066. 单词之和</a></h3>
<h4 id="方法一前缀树-3">方法一：前缀树</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MapSum</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TrieNode</span> &#123;<br>        <span class="hljs-keyword">private</span> TrieNode[] children;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> val;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">TrieNode</span><span class="hljs-params">()</span> &#123;<br>            children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>[<span class="hljs-number">26</span>];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> TrieNode root;<br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MapSum</span><span class="hljs-params">()</span> &#123;<br>        root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String key, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">TrieNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : key.toCharArray()) &#123;<br>            <span class="hljs-keyword">if</span> (cur.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">null</span>)<br>                cur.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>();<br>            cur = cur.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        cur.val = val;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(String prefix)</span> &#123;<br>        <span class="hljs-type">TrieNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : prefix.toCharArray()) &#123;<br>            <span class="hljs-keyword">if</span> (cur.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            cur = cur.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dfs(cur);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TrieNode cur)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> cur.val;<br>        <span class="hljs-keyword">for</span> (TrieNode child : cur.children) &#123;<br>            <span class="hljs-keyword">if</span> (child != <span class="hljs-literal">null</span>)<br>                sum += dfs(child);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MapSum</span> <span class="hljs-variable">mapSum</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MapSum</span>();<br>        mapSum.insert(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-number">3</span>);<br>        mapSum.sum(<span class="hljs-string">&quot;ap&quot;</span>);<br>        mapSum.insert(<span class="hljs-string">&quot;app&quot;</span>, <span class="hljs-number">2</span>);<br>        mapSum.sum(<span class="hljs-string">&quot;ap&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MapSum object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MapSum obj = new MapSum();</span><br><span class="hljs-comment"> * obj.insert(key,val);</span><br><span class="hljs-comment"> * int param_2 = obj.sum(prefix);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230517181655506.png" alt="image-20230517181655506" style="zoom:50%;" /></p>
<h3 id="剑指-offer-ii-067.-最大的异或"><a href="https://leetcode.cn/problems/ms70jA/">剑指 Offer II 067. 最大的异或</a></h3>
<h4 id="方法一前缀树-4">方法一：前缀树</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TrieNode</span> &#123;<br>        <span class="hljs-keyword">private</span> TrieNode[] children;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">TrieNode</span><span class="hljs-params">()</span> &#123;<br>            children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>[<span class="hljs-number">2</span>];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMaximumXOR</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">TrieNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> buildTrie(nums);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-type">TrieNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">xor</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">31</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">bit</span> <span class="hljs-operator">=</span> (num &gt;&gt; i) &amp; <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (cur.children[<span class="hljs-number">1</span> - bit] != <span class="hljs-literal">null</span>) &#123;<br>                    cur = cur.children[<span class="hljs-number">1</span> - bit];<br>                    xor = (xor &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    cur = cur.children[bit];<br>                    xor = xor &lt;&lt; <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>            max = Math.max(max, xor);<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> TrieNode <span class="hljs-title function_">buildTrie</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">TrieNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-type">TrieNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">31</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">bit</span> <span class="hljs-operator">=</span> (num &gt;&gt; i) &amp; <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (cur.children[bit] == <span class="hljs-literal">null</span>) &#123;<br>                    cur.children[bit] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>();<br>                &#125;<br>                cur = cur.children[bit];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230517145848750.png" alt="image-20230517145848750" style="zoom:50%;" /></p>
<h2 id="tips">tips</h2>
<h3 id="新建数组时赋值">新建数组时赋值</h3>
<p>int[] array = new int[]{3, 4}；</p>
<h3 id="链表转数组">链表转数组</h3>
<h4 id="方法一-4">方法一：</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] intArray = linkedList.stream().mapToInt(Integer::intValue).toArray();<br></code></pre></td></tr></table></figure>
<p>这行代码可以分解为以下几个部分：</p>
<ol type="1">
<li><code>linkedList.stream()</code>: 将LinkedList转换为Stream。</li>
<li><code>mapToInt(Integer::intValue)</code>: 将Stream中的每一个元素转换为int类型。
<ul>
<li><code>Integer::intValue</code>是一个方法引用，表示调用Integer对象的<code>intValue()</code>方法，将其转换为对应的int值。</li>
</ul></li>
<li><code>toArray()</code>: 将转换后的元素放到一个int数组中。
<ul>
<li><code>toArray()</code>的作用是将Stream中的所有元素转换为一个数组，返回值是一个<code>int[]</code>类型的数组。</li>
</ul></li>
</ol>
<p>综上所述，<code>int[] intArray = linkedList.stream().mapToInt(Integer::intValue).toArray();</code>的语义是将LinkedList中的所有元素转换为int类型，并将其放入一个int数组中。在这个过程中，我们使用了Java 8引入的Stream API，它提供了许多方便的操作，可以简化代码的编写和调试。</p>
<h4 id="方法二-1">方法二：</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">res.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[res.size()][]);	<br></code></pre></td></tr></table></figure>
<h3 id="创建长度二维数组其中一维数组的长度不确定">创建长度二维数组，其中一维数组的长度不确定</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">3</span>&#125;, &#123;&#125;&#125;<br></code></pre></td></tr></table></figure>
<h3 id="char转intstring转int">char转int，String转int</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 将字符转换为整数</span><br><span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;8&#x27;</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> Character.getNumericValue(c); <span class="hljs-comment">// num = 8</span><br><br><span class="hljs-comment">// 将字符串转换为整数</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123&quot;</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">num2</span> <span class="hljs-operator">=</span> Integer.parseInt(str); <span class="hljs-comment">// num2 = 123</span><br></code></pre></td></tr></table></figure>
<h3 id="string转int时什么时候用parseint什么时候用valueof">String转int时，什么时候用parseInt什么时候用valueOf</h3>
<p>在Java中，parseInt和valueOf都可以将字符串转换为整数。parseInt方法将字符串转换为基本数据类型int，而valueOf方法将字符串转换为对象类型Integer。因此，使用哪个方法取决于你要使用返回的数据类型。</p>
<p>如果你只需要一个基本数据类型int，那么使用parseInt是最好的选择，因为它会返回一个原始类型，不会产生额外的对象开销。</p>
<p>例如：</p>
<p>java Copy code String str = "123"; int num = Integer.parseInt(str);</p>
<p>如果你需要一个对象类型Integer，则使用valueOf方法是最好的选择。valueOf方法返回一个Integer对象，这在某些情况下非常有用。</p>
<p>例如：</p>
<p>java Copy code String str = "123"; Integer num = Integer.valueOf(str);</p>
<p>总之，如果你只需要一个基本数据类型，那么使用parseInt方法，否则使用valueOf方法。</p>
<h3 id="使用scanner.nextline读取行末的换行符">使用scanner.nextLine()读取行末的换行符</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>       <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>       <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>       scanner.nextLine();<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>           <span class="hljs-type">String</span> <span class="hljs-variable">word</span> <span class="hljs-operator">=</span> scanner.nextLine();<br>           System.out.println(<span class="hljs-string">&quot;word: &quot;</span> + word);<br>           <span class="hljs-type">Main</span> <span class="hljs-variable">main</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Main</span>();<br>           <span class="hljs-type">String</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> main.process(word);<br>           System.out.println(ans);<br>       &#125;<br></code></pre></td></tr></table></figure>
<p>这段代码首先从标准输入中读取一个整数n，然后通过调用scanner.nextLine()读取掉n后面的换行符。接下来，通过for循环n次，读取n行字符串，每次读取一行字符串后，调用process方法进行处理，最后将处理结果打印到标准输出中。</p>
<p>需要注意的是，在使用Scanner读取完整行时，由于nextInt只读取整数，因此需要在nextInt后面调用nextLine读取行末的换行符。这样做是为了防止接下来的nextLine方法误读取行末的换行符。</p>
<h3 id="创建长度不同的二维数组">创建长度不同的二维数组</h3>
<p>在Java中，可以创建长度不同的二维数组。以下是创建长度不同的二维数组的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[][] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>][];<br>arr[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>arr[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<br>arr[<span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">4</span>];<br></code></pre></td></tr></table></figure>
<p>在这个示例中，我们创建了一个3 x n的二维数组，其中n的长度不同。第一行有两个元素，第二行有三个元素，第三行有四个元素。我们可以通过以下方式访问数组的元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">arr[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>arr[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>arr[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">3</span>;<br>arr[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">4</span>;<br>arr[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">5</span>;<br>arr[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">6</span>;<br>arr[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">7</span>;<br>arr[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">8</span>;<br>arr[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] = <span class="hljs-number">9</span>;<br></code></pre></td></tr></table></figure>
<p>请注意，当您创建长度不同的二维数组时，每行的长度必须在运行时确定。因此，您必须在运行时动态地为每行分配内存空间。</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><code class="hljs basic"><span class="hljs-number">1</span><br><span class="hljs-number">8</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span><br><span class="hljs-number">0</span><br><span class="hljs-number">0</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<h3 id="数组拷贝ch.clone与arrays.copyof的区别">数组拷贝：ch.clone与Arrays.copyOf的区别</h3>
<p>对基础类型的拷贝都是值传递的拷贝(深拷贝)，对对象的拷贝都是拷贝的引用(浅拷贝)</p>
<h3 id="idea创建live-template">IDEA创建live template</h3>
<p>在 IntelliJ IDEA 中使用 Live Template 来创建并查集的固定代码，可以按照以下步骤进行操作：</p>
<ol type="1">
<li><p>打开 IntelliJ IDEA，进入设置面板。你可以通过点击菜单栏的 "File" -&gt; "Settings" (Windows/Linux) 或 "IntelliJ IDEA" -&gt; "Preferences" (Mac) 打开设置面板。</p></li>
<li><p>在设置面板中，选择 "Editor" -&gt; "Live Templates"。</p></li>
<li><p>在左侧的面板中，选择你想要创建代码模板的语言，比如 "Java"。</p></li>
<li><p>点击右侧面板的 "+" 按钮，添加一个新的模板。</p></li>
<li><p>在 "Abbreviation" 输入框中输入一个简短的缩写，用于触发代码模板。</p></li>
<li><p>在 "Template text" 输入框中输入代码模板的内容，例如：</p></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 并查集初始化</span><br><span class="hljs-type">int</span>[] parent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    parent[i] = i;<br>&#125;<br><br><span class="hljs-comment">// 并查集查找根节点</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    <span class="hljs-keyword">if</span> (parent[x] != x) &#123;<br>        parent[x] = find(parent[x]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> parent[x];<br>&#125;<br><br><span class="hljs-comment">// 并查集合并两个集合</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">rootX</span> <span class="hljs-operator">=</span> find(x);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">rootY</span> <span class="hljs-operator">=</span> find(y);<br>    <span class="hljs-keyword">if</span> (rootX != rootY) &#123;<br>        parent[rootX] = rootY;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ol start="7" type="1">
<li><p>点击 "Define" 按钮，选择模板的定义范围，比如选择 "Java"。</p></li>
<li><p>点击 "Apply" 或 "OK" 完成模板的创建。</p></li>
</ol>
<p>现在，你可以在代码编辑器中输入你设定的缩写，比如 "uf"，然后按下 Tab 键，就会自动插入你定义的并查集代码模板。你可以根据需要修改模板中的变量名和其他细节，以适应你的项目要求。</p>
<h1 id="笔试面试">笔试面试</h1>
<h2 id="小红书">5.8小红书</h2>
<h3 id="第一题.">第一题.</h3>
<h3 id="第二题.">第二题.</h3>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">最大最小值<br>        时间限制： 1000MS<br>        内存限制： 65536KB<br>        题目描述：<br>        有一个长度为n的序列，其中第i个元素ai，你现在可以对这个序列进行最多k次操作，每次可选择一个连续的区间将其中的元素删掉，但剩余的元素个数必须大于0。 现在想让剩余元素的最小值尽可能大，求上述情况下的最大值。<br><br><br><br>        输入描述<br>        第一行两个正整数n和k，分别表示初始序列中元素的个数以及最多的操作次数。<br><br>        接下来1行，n个正整数，其中第i个数为ai。<br><br>        对于所有数据，1&lt;=n&lt;=10<span class="hljs-built_in">^</span>5，0&lt;=k&lt;=10<span class="hljs-built_in">^</span>5，1&lt;=ai &lt;=10<span class="hljs-built_in">^</span>6。<br><br>        输出描述<br>        输出仅包含一个正整数，表示答案。<br><br><br>        样例输入<br>        8 1<br>        58 57 86 89 25 26 61 42<br>        样例输出<br>        58<br></code></pre></td></tr></table></figure>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">这道题是要求给定一个序列，你可以进行最多k次操作，每次操作可以删除序列中的某个连续区间，但是最后删除后剩余元素的最小值尽可能大。你需要输出这个最大的最小值。<br><br>举个例子，对于样例输入 [58, 57, 86, 89, 25, 26, 61, 42]，可以进行1次操作，比如删除区间[86,89]，剩下的序列为[58, 57, 25, 26, 61, 42]，此时剩余元素的最小值为25，最大的最小值就是25。你需要编写一个程序来自动寻找最大的最小值。<br></code></pre></td></tr></table></figure>
<h3 id="第三题.">第三题.</h3>
<h2 id="微众银行">5.10 微众银行</h2>
<h3 id="第一题">第一题</h3>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/Snipaste_2023-05-10_19-14-07.jpg" alt="Snipaste_2023-05-10_19-14-07" style="zoom:50%;" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">```<br><br><br><br>![<span class="hljs-number">1</span>](https:<span class="hljs-comment">//leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/1.jpg) </span><br><br>### 第二题<br><br>![第二题](https:<span class="hljs-comment">//leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/第二题.jpg) </span><br><br>```java<br><span class="hljs-keyword">package</span> 面试题.微众银行暑期实习.第<span class="hljs-number">2</span>题;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.Array;<br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Main</span> <span class="hljs-variable">main</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Main</span>();<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        scanner.nextLine();<br>        <span class="hljs-type">long</span>[] energy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n], score = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            energy[i] = scanner.nextLong();<br>        &#125;<br>        scanner.nextLine();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            score[i] = scanner.nextLong();<br>        &#125;<br>        <span class="hljs-type">long</span>[] res = main.process(n, k, energy, score);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> i : res)<br>            System.out.print(i + <span class="hljs-string">&quot; &quot;</span>);<br>    &#125;<br>    Queue&lt;Long&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span>[] process(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">long</span>[] energy, <span class="hljs-type">long</span>[] score) &#123;<br>        <span class="hljs-type">long</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n];<br>        Map&lt;Long, Long&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            map.put(energy[i], score[i]);<br>        &#125;<br>        <span class="hljs-type">long</span>[] oriEnery = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            oriEnery[i] = energy[i];<br>        Arrays.sort(energy);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> map.get(energy[i]);<br>            queue.offer(s);<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> map.get(energy[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; k; ++i) &#123;<br>            res[i] = sum;<br>            sum += map.get(energy[i]);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k; i &lt; n; ++i) &#123;<br>            res[i] = getKMax();<br>            <span class="hljs-type">long</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> map.get(energy[i]);<br>            <span class="hljs-keyword">if</span> (s &gt; queue.peek()) &#123;<br>                queue.poll();<br>                queue.offer(s);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">long</span>[] res2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n]; <span class="hljs-comment">//resAsOriginalSequence</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> oriEnery[i];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (; index &lt; n; ++index) &#123;<br>                <span class="hljs-keyword">if</span> (energy[index] == e)<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>            res2[i] = res[index];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res2;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getKMax</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Queue&lt;Long&gt; queue2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> queue.poll();<br>            sum += temp;<br>            queue2.offer(temp);<br>        &#125;<br>        queue = queue2;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/第二题AC.jpg" /></p>
<h3 id="第三题">第三题</h3>
<figure>
<img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/第三题.jpg" alt="第三题" /><figcaption aria-hidden="true">第三题</figcaption>
</figure>
]]></content>
  </entry>
</search>
