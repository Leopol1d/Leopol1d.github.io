{"meta":{"title":"Leopold's Blog","subtitle":"Algorithms","description":"For offers","author":"Leopold","url":"https://leopol1d.github.io","root":"/"},"pages":[],"posts":[{"title":"Algorithms","slug":"Algorithms","date":"2023-04-07T08:06:11.000Z","updated":"2023-04-27T07:40:54.632Z","comments":true,"path":"2023/04/07/Algorithms/","link":"","permalink":"https://leopol1d.github.io/2023/04/07/Algorithms/","excerpt":"","text":"LeetCode Solutions# Dynamic Programming debug 剑指Offer 95 剑指Offer 101 分割等和子集 剑指Offer 1049 最后一块石头的重量 II 518. 零钱兑换 II 377. 组合总和 Ⅳ 70. 爬楼梯 322. 零钱兑换 279. 完全平方数 139. 单词拆分 198. 打家劫舍 213. 打家劫舍 II 416. 分割等和子集 337. 打家劫舍 III 121. 买卖股票的最佳时机 122. 买卖股票的最佳时机 II 96. 不同的二叉搜索树 123. 买卖股票的最佳时机 III 1372. 二叉树中的最长交错路径 300. 最长递增子序列 674. 最长连续递增序列 718. 最长重复子数组 树形DP Binary Tree 144. 二叉树的前序遍历 94. 二叉树的中序遍历 145. 二叉树的后序遍历 102. 二叉树的层序遍历 226. 翻转二叉树 101. 对称二叉树 100. 相同的树 104. 二叉树的最大深度 559. N 叉树的最大深度 111. 二叉树的最小深度 222. 完全二叉树的节点个数 110. 平衡二叉树 :warning:[257. 二叉树的所有路径](https://leetcode.cn/problems/binary-tree-paths/) 404. 左叶子之和 513. 找树左下角的值 112. 路径总和 113. 路径总和 II :star:[106. 从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/) 105. 从前序与中序遍历序列构造二叉树 :star:[654. 最大二叉树](https://leetcode.cn/problems/maximum-binary-tree/) 617. 合并二叉树 700. 二叉搜索树中的搜索 :star:[98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/) 530. 二叉搜索树的最小绝对差 501. 二叉搜索树中的众数 236. 二叉树的最近公共祖先 235. 二叉搜索树的最近公共祖先 701. 二叉搜索树中的插入操作 x[450. 删除二叉搜索树中的节点](https://leetcode.cn/problems/delete-node-in-a-bst/) :warning:[669. 修剪二叉搜索树](https://leetcode.cn/problems/trim-a-binary-search-tree/) 108. 将有序数组转换为二叉搜索树 538. 把二叉搜索树转换为累加树 [106. 从中序与后序遍历序列构造二叉树 [[105. 从前序与中序遍历序列构造二叉树]](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/) 剑指 Offer II 047. 二叉树剪枝 x[剑指 Offer II 048. 序列化与反序列化二叉树](https://leetcode.cn/problems/h54YBf/) 剑指 Offer II 049. 从根节点到叶节点的路径数字之和 x[剑指 Offer II 050. 向下的路径节点之和](https://leetcode.cn/problems/6eUYwP/) 同[437. 路径总和 III](https://leetcode.cn/problems/path-sum-iii/) 剑指 Offer II 053. 二叉搜索树中的中序后继 剑指 Offer II 054. 所有大于等于节点的值之和 剑指 Offer II 055. 二叉搜索树迭代器 :star:Morris遍历 124. 二叉树中的最大路径和 String 344. 反转字符串 x[541. 反转字符串 II](https://leetcode.cn/problems/reverse-string-ii/) 剑指 Offer 05. 替换空格 151. 反转字符串中的单词 剑指 Offer 58 - II. 左旋转字符串 28. 找出字符串中第一个匹配项的下标 x459. 重复的子字符串 剑指 Offer II 014. 字符串中的变位词 剑指 Offer II 015. 字符串中的所有变位词 String补充知识 KMP算法 Array 704. 二分查找 27. 移除元素 方法一：暴力 977. 有序数组的平方 209. 长度最小的子数组 59. 螺旋矩阵 II LinkedList 203. 移除链表元素 707. 设计链表 206. 反转链表 24. 两两交换链表中的节点 19. 删除链表的倒数第 N 个结点 面试题 02.07. 链表相交 Hash Table 242. 有效的字母异位词 349. 两个数组的交集 202. 快乐数 1. 两数之和 454. 四数相加 II 383. 赎金信 x15. 三数之和 18. 四数之和 Stack and Queue 232. 用栈实现队列 225. 用队列实现栈 20. 有效的括号 1047. 删除字符串中的所有相邻重复项 150. 逆波兰表达式求值 239. 滑动窗口最大值 347. 前 K 个高频元素 优先级队列（大根堆、小根堆） Greedy 455. 分发饼干 376. 摆动序列 53. 最大子数组和 122. 买卖股票的最佳时机 II 55. 跳跃游戏 45. 跳跃游戏 II 1005. K 次取反后最大化的数组和 134. 加油站 135. 分发糖果 860. 柠檬水找零 406. 根据身高重建队列 452. 用最少数量的箭引爆气球 435. 无重叠区间 763. 划分字母区间 56. 合并区间 738. 单调递增的数字 968. 监控二叉树 BackTracing 开始回溯前要知道的 77. 组合 216. 组合总和 III 17. 电话号码的字母组合 39. 组合总和 40. 组合总和 II :warning:[131. 分割回文串](https://leetcode.cn/problems/palindrome-partitioning/) :star:[93. 复原 IP 地址](https://leetcode.cn/problems/restore-ip-addresses/) 78. 子集 113. 路径总和 II tips 新建数组时赋值 Dynamic Programming# debug# private static void printDp(int[] dp, int i) &#123; System.out.print(i + \": \"); for (int maxValue : dp)&#123; System.out.print(maxValue + \" \"); &#125; System.out.println(); &#125; 剑指Offer 95# 最优子结构：求最长公共子序列，求问题最优解，适合使用dp解决。 重叠子问题：求第一个字符串中位置0~\\(i\\)构成的子序列与第二个字符串中0~\\(j\\)构成的子序列的最大公共子序列\\(f(i,j)\\)，需要多次使用\\(f(i-1, j-1), f(i-1,j),f(i,j-1)\\)，拥有重叠子问题 状态转移方程： \\[ f(i,j) = \\begin{cases} f(i-1,j-1)+1, &amp; ch[i]==ch[j] \\\\ max(f(i-1,j),f(i,j-1)), &amp; else \\\\ \\end{cases} \\] 边界条件：dp[0][:] == 0, dp[:][] == 0 令两个字符串长度分别为\\(m,n\\)， 时间复杂度：双重for循环，\\(O(mn)\\) 空间复杂度：需要建立大小为(m+1)(n+1)的数组，因此空间复杂度为\\(O(mn)\\) class Solution &#123; public int longestCommonSubsequence(String text1, String text2) &#123; int m = text1.length(), n = text2.length(); int[][] dp = new int[m + 1][n + 1]; for (int i = 1; i &lt;= m; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; if (text1.charAt(i - 1) == text2.charAt(j - 1)) &#123; dp[i][j] = dp[i - 1][j - 1] + 1; &#125; else &#123; dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]); &#125; &#125; &#125; return dp[m][n]; &#125; &#125; 如何优化空间复杂度？ # 分析：只要在数组中找到任意数等于数组累加和的一半，该数组就是等和子集，可抽象为经典0-1背包问题。 dp[i][j]:从编号0-i的物品中任选物品(可以都不选)，容量为j的背包能否正好装满 递归公式:dp[i][j] = dp[i-1][j] || j &gt;= num[i] : dp[i-1][j-nums[i]] : false 初始化: 当j==0时，即背包容量为0，不管有多少物品，只要什么都不选就能使背包总重量为0，所以f(i,0)=true 当i==0 &amp;&amp; j!= 0时，即物品数量为0，怎样都不能放满容量大于0的背包，所以f(0,i)=false 遍历顺序：先遍历物品再嵌套从头到尾遍历容量 打印dp数组验证与手写稿是否一致 空间复杂度优化：由于求第i行dp数组只需要用到第i-1行dp数组的信息，所以可以使用一维滑动dp数组代替二维dp数组。 # 从 stones数组中选择，凑成总和不超过 \\(sum/2\\) 的最大价值 # ​ 经典完全背包问题，解题步骤如下： dp[j]：背包容量为j时，放满背包的组合方法数 状态转移公式：dp[j] = dp[j] + dp[j - coins[i]] 初始化dp[0]：背包容量为0时，有一种方法放满背包（什么都不放） 遍历顺序：求组合数，先便利物品，再遍历容量 遍历dp数组 关于组合和排列的理解：先遍历物品后遍历背包是这样，比如，外层循环固定coins[1]，在内层循环遍历背包时，随着背包不断增加，coins[1]可以重复被添加进来，而由于外层循环固定了，因此coins[2]只能在下一次外层循环添加进不同大小的背包中，这么看的话，coins[i + 1]只能在coins[i]之后了；如果先遍历背包后遍历物品，那么外层循环先固定背包大小j，然后在大小为j的背包中循环遍历添加物品，然后在下次外层循环背包大小变为j+1，此时仍要执行内层循环遍历添加物品，也就会出现在上一轮外层循环中添加coins[2]的基础上还能再添加coins[1]的情况，那么就有了coins[1]在coins[2]之后的情况了(逆序)。 如果求组合数就是外层for循环遍历物品，内层for遍历背包。 如果求排列数就是外层for遍历背包，内层for循环遍历物品。 # 全排列问题，转化为完全背包问题 dp[j]：在背包容量为j时，放满背包的排列数 状态转移公式：dp[j] = dp[j] + dp[j - nums[i]] 初始化dp[0]：在背包容量为0时，放满背包的排列数量为1（什么都不放） 遍历顺序，排列问题，先遍历背包容量(物品可以逆序放入dp[j - nums[i]])，再遍历物品 打印dp数组 # 完全背包 + 全排列问题，可以重复选择放入物品1与物品2，求放满容量为n的背包的排列数 dp[j]：在背包容量为j时，放满背包的排列数 状态转移公式：dp[j] = dp[j] + dp[j - nums[i]] 初始化dp[0]：在背包容量为0时，放满背包的排列数量为1（什么都不放） 遍历顺序，排列问题，先遍历背包容量(物品可以逆序放入dp[j - nums[i]])，再遍历物品 打印dp数组 # 完全背包问题 dp[j]：背包容量为j时，凑满背包容量所需的最少硬币数 状态转移公式：dp[j] = min(dp[j], dp[j - coins[i]] + 1) 初始化dp[0]：背包容量为0时，凑满背包容量所需的最少硬币数时0,其他初始化为Integer.MAX_VALUE 遍历顺序，无所谓 打印dp数组 # dp[j]：装满容量为j的背包，至少要放多少个物品 状态转移公式：dp[j] = min(dp[j], dp[j - weights[i]] + 1) 初始化dp[0]:装满容量为0的背包，至少放0个物品；其他设为Integet.MAX_VALUE 遍历顺序：无所谓 打印dp数组 # 背包问题 + 排列(“leetcode”由“leet”与“code”组成但不能反过来由“code”与“leet”组成 )的变种，建议不要完全抽象成背包问题，便于理解 dp[j]：长度为j的字符串，可以被字典中的单词拆分。 状态转移公式：if([j, i] 这个区间的子串出现在字典里 &amp;&amp; dp[j]是true) 那么 dp[i] = true， 其中j&lt;i。 初始化dp[0]:dp[i]依赖于前面的dp[j]，所以dp[0]要初始化为true，不然全为false 遍历顺序：先遍历背包容量，再嵌套遍历物品 打印dp数组 # dp[j]：偷窃从标号为0到j的房屋所能获得的最大价值 状态转移公式：dp[j] = max(dp[j - 1], dp[j - 2] + nums[j]) 初始化：dp[0] = nums[0], dp[1] = max(nums[0], nums[1]) 遍历顺序：单序列问题,dp[i] 是根据dp[i - 2] 和 dp[i - 1] 推导出来的，那么一定是从前到后遍历！ 遍历dp数组 优化空间复杂度# 根据状态转移公式dp[j] = max(dp[j - 1], dp[j - 2] + nums[j])，dp[j]只需要dp[j-1]以及dp[j-2]两个变量即可，可以把数组大小压缩到2。 # # dp[j]：背包容量为j时，是否能用物品装满 状态转移方程：dp[j] = dp[j] || dp[j - nums[i]] 初始化：背包容量为0时，不把物品装进去即可装满，dp[0] = true 遍历顺序：一维滑动数组，零一背包，先遍历物品后遍历背包容量 # 方法一：HashMap# f：偷当前房屋能获得的最大价值；g：不偷当前房屋能获得的最大价值 偷当前房屋f(cur) = cur.val + g(cur.left) + g(cur.right) 不偷当前房屋g(cur) = max(f(cur.left), g(cur.left)) + max(f(cur.right), g(cur.right)) 方法二：Morris + HashMap# 当作是练习题了！！ 注意事项：在访问的时候，此时需要cur.right，而这个时候已经是逆序过的，cur.right实际上指向的是自己的父节点，所以再用一个hashmap存储cur真正的右节点（或者再逆序一遍）。 class Solution &#123; Map&lt;TreeNode, Integer> f = new HashMap&lt;>(); Map&lt;TreeNode, Integer> g = new HashMap&lt;>(); Map&lt;TreeNode, TreeNode> right = new HashMap&lt;>(); public int rob(TreeNode root) &#123; // f:偷当前节点能获得的最大价值 // g:不偷当前节点能获得的最大价值 // f(cur) = cur.val + g(cur.left) + g(cur.right) // g(cur) = max(f(cur.left), g(cur.left)) + max(f(cur.right), g(cur.right)) TreeNode cur = root, mostRight = null; while (cur != null) &#123; mostRight = cur.left; if (mostRight != null) &#123; while (mostRight.right != null &amp;&amp; mostRight.right != cur) mostRight = mostRight.right; if (mostRight.right == null) &#123; mostRight.right = cur; cur = cur.left; continue; &#125; else &#123; // mostRight.right = cur mostRight.right = null; visit(cur.left); &#125; &#125; cur = cur.right; &#125; visit(root); return Math.max(f.getOrDefault(root, 0), g.getOrDefault(root, 0)); &#125; private void visit(TreeNode cur) &#123; TreeNode tail = reverse(cur); cur = tail; while (cur != null) &#123; f.put(cur, cur.val + g.getOrDefault(cur.left, 0) + g.getOrDefault(right.get(cur), 0)); int maxLeft = Math.max(f.getOrDefault(cur.left, 0), g.getOrDefault(cur.left, 0)); int maxRight = Math.max(f.getOrDefault(right.get(cur), 0), g.getOrDefault(right.get(cur), 0)); g.put(cur, maxLeft + maxRight); if (cur.right != null) right.put(cur.right, cur); cur = cur.right; &#125; reverse(tail); &#125; private TreeNode reverse(TreeNode cur) &#123; TreeNode pre = null; while (cur != null) &#123; TreeNode next = cur.right; cur.right = pre; pre = cur; cur = next; &#125; return pre; &#125; &#125; # 你根本没在dp！# 方法一：暴力迭代# 超时咯 image-20230330094627247 方法二：贪心# 从前往后遍历，使用minPrice记录最小值，使用maxProfit记录最大收益 方法三：DP# DP数组的定义十分重要！ class Solution &#123; public int maxProfit(int[] prices) &#123; int len = prices.length; if (len == 0 || prices == null) return 0; // 1.dp[0][j]:第j天持有股票(之前买入或者当前买入)所拥有的最大价值，dp[1][j]：第j天不持有股票(之前卖出或者当前卖出)所拥有的最大价值 int[][] dp = new int[2][len]; // 2.状态转移方程：dp[0][j] = max(dp[0][j-1], -price[j]); dp[1][j] = max(dp[1][j-1], price[j] + dp[0][j - 1]) // 3.初始化：dp[0][0]必须买入，初始化为-price[0]；dp[1][0]不能卖出任何股票，初始化为0 dp[0][0] = -prices[0]; // 4.遍历顺序：dp[j]由dp[j-1]决定，所以从前往后遍历 for (int j = 1; j &lt; len; ++j) &#123; dp[0][j] = Math.max(dp[0][j - 1], -prices[j]); dp[1][j] = Math.max(dp[1][j - 1], prices[j] + dp[0][j - 1]); // 不能当天买入当天卖出所以是dp[0][j - 1] &#125; return dp[1][len - 1]; // 5.打印dp数组 &#125; &#125; # class Solution &#123; public int maxProfit(int[] prices) &#123; // 1.dp[0][j]:在第j天持有(之前买入，当前买入)股票时拥有的最大现金;dp[1][j]在第j天不持有(之前卖出，当前卖出)股票拥有的最大现金 int len = prices.length; int[][] dp = new int[2][len]; // 2.状态转移方程：dp[0][j] = max(dp[0][j - 1], dp[1][j - 1] - price[j]); dp[1][j] = max(dp[1][j - 1], dp[0][j - 1] + price[j]) // 3.初始化：dp[0][0] = -price[0];dp[1][0] = 0;可以当天出售 dp[0][0] = -prices[0]; // 4.遍历顺序 for (int j = 1; j &lt; len; ++j) &#123; dp[0][j] = Math.max(dp[0][j - 1], dp[1][j - 1] - prices[j]); dp[1][j] = Math.max(dp[1][j - 1], dp[0][j - 1] + prices[j]); &#125; return dp[1][len - 1]; // 5.打印dp数组 &#125; &#125; # class Solution &#123; public int numTrees(int n) &#123; int[] dp = new int[n + 1]; dp[0] = 1; dp[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= i; ++j) &#123; dp[i] += dp[j - 1] * dp[i - j]; &#125; &#125; return dp[n]; &#125; &#125; 优化空间..# # # class Solution &#123; // f(cur)：以cur结尾，且cur是左子树的最大长度 // g(cur)：以cur结尾，且cur是右子树的最大长度 Map&lt;TreeNode, Integer> f = new HashMap&lt;>(); Map&lt;TreeNode, Integer> g = new HashMap&lt;>(); Queue&lt;TreeNode[]> queue = new LinkedList&lt;>(); public int longestZigZag(TreeNode root) &#123; // f.put(root, 0); // g.put(root, 0); queue.offer(new TreeNode[]&#123;root, null&#125;); while (!queue.isEmpty()) &#123; TreeNode[] sonFather = queue.poll(); f.put(sonFather[0], 0); g.put(sonFather[0], 0); if(sonFather[1] != null) &#123; if (sonFather[1].left == sonFather[0]) f.put(sonFather[0], g.get(sonFather[1]) + 1); if (sonFather[1].right == sonFather[0]) g.put(sonFather[0], f.get(sonFather[1]) + 1); &#125; if (sonFather[0].left != null) queue.offer(new TreeNode[]&#123;sonFather[0].left, sonFather[0]&#125;); if (sonFather[0].right != null) queue.offer(new TreeNode[]&#123;sonFather[0].right, sonFather[0]&#125;); &#125; int max = Integer.MIN_VALUE; for (TreeNode node : f.keySet()) &#123; max = Math.max(max, Math.max(f.get(node), g.get(node))); &#125; return max; &#125; &#125; # dp[i]：以nums[i]结尾的最长递增子序列的长度 从前往后，在i的左开区间进行比较所有的j(j &lt; i)，如果nums[j]&lt;nums[i]，那么dp[i] = max(dp[i], dp[j] + 1) 初始化：令dp数组所有元素为1，最短序列是本身 遍历顺序：第二层从前往后，从后往前都可以，只要把i之前的元素全部遍历了就行 要注意的是，要输出的答案不是dp[dp.length-1]，而是dp数组中的最大值，比如序列为01234512，输出的是结果是dp[5]；所以可以用一个全局变量记录dp数组中的最大值 时间复杂度：\\(O(n^2)\\) 空间复杂度：\\(O(n)\\) class Solution &#123; public int lengthOfLIS(int[] nums) &#123; int n = nums.length; if (n == 1) return 1; int[] dp = new int[n]; Arrays.fill(dp, 1); int maxLenOfSubsequence = 0; for (int i = 1; i &lt; n; ++i) &#123; for (int j = 0; j &lt; i; ++j) &#123; if (nums[i] > nums[j]) &#123; dp[i] = Math.max(dp[i], dp[j] + 1); &#125; &#125; maxLenOfSubsequence = Math.max(maxLenOfSubsequence, dp[i]); &#125; return maxLenOfSubsequence; &#125; &#125; # dp[i]：以nums[i]结尾的最长连续递增子序列的长度 当当前数字nums[i]大于nums[i-1]，令dp[i] = dp[i - 1] + 1 初始化：令dp数组所有元素为1，最短序列是本身 时间复杂度：\\(O(n)\\) 空间复杂度：\\(O(n)\\) class Solution &#123; public int findLengthOfLCIS(int[] nums) &#123; int n = nums.length; if (n == 1) return 1; int[] dp = new int[n]; Arrays.fill(dp, 1); int maxLength = 0; for (int i = 1; i &lt; n; ++i) &#123; if (nums[i] > nums[i - 1]) &#123; dp[i] = dp[i - 1] + 1; &#125; maxLength = Math.max(maxLength, dp[i]); &#125; // for (int i = 0; i &lt; dp.length; ++i) &#123; // System.out.print(dp[i] + \" \"); // &#125; return maxLength; &#125; &#125; # 方法一：暴力# 时间复杂度：\\(O(m^2n)\\) 空间复杂度：\\(O(1)\\) class Solution &#123; public int findLength(int[] nums1, int[] nums2) &#123; int res = 0; for (int i = 0; i &lt; nums1.length; ++i) &#123; for (int j = 0; j &lt; nums2.length; ++j) &#123; int count1 = i, count2 = j; int counter = 0; while (count1 &lt; nums1.length &amp;&amp; count2 &lt; nums2.length &amp;&amp; nums1[count1] == nums2[count2]) &#123; ++counter; ++count1; ++count2; &#125; res = Math.max(res, counter); &#125; &#125; return res; &#125; &#125; 方法二：DP# dp[i][j]:以nums1[i - 1]结尾与以nums2[j - 1]结尾时的最长重复子数组 状态转移公式：当nums1[i - 1] == nums2[j - 1]时，dp[i][j] = dp[i - 1][j - 1] + 1 初始化：m为nums1的长度，n为nums2的长度，初始化(m + 1) * (n + 1)的二维数组，第一行第一列初始化为0，因为任一数组为空，就不会有重复子数组 注意事项：输出结果是dp数组中的最大值，因为最长的重复子数组不一定是在两数组的结尾处，可以在循环内比较 时间复杂度：\\(O(mn)\\) 空间复杂度：\\(O(mn)\\) class Solution &#123; public int findLength(int[] nums1, int[] nums2) &#123; int m = nums1.length, n = nums2.length; int[][] dp = new int[m + 1][n + 1]; int result = 0; for (int i = 1; i &lt;= m; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; if (nums1[i - 1] == nums2[j - 1]) &#123; dp[i][j] = dp[i - 1][j - 1] + 1; result = Math.max(result, dp[i][j]); &#125; &#125; &#125; return result; &#125; &#125; 滚动数组缩减空间复杂度 dp数组为第二个数组的长度加一 不相等时要把dp[j]赋0，不然之后会出错 此时遍历第二个数组的时候，就要从后向前遍历，这样避免重复覆盖。 比如nums1 = [1, 2, 3, 1],nums2 = [1,6,8,1,3,1,2,3] i = 1时候，dp数组为[1,0,0,1,0,1,0,0] i = 2时候，dp数组为[0,0,0,0,0,0,1,0] i = 3时候，dp数组为[0,0,0,0,1,0,0,2] i=3时，如果第二层for循环j从前往后遍历，那么dp倒数第二个位置会因为3!=2，被赋0，进而导致dp最后一个位置是1而不是2 class Solution &#123; public int findLength(int[] nums1, int[] nums2) &#123; int[] dp = new int[nums2.length + 1]; int res = 0; for (int i = 1; i &lt;= nums1.length; ++i) &#123; for (int j = nums2.length; j > 0; --j) &#123; if (nums1[i - 1] == nums2[j - 1]) &#123; dp[j] = dp[j - 1] + 1; &#125; else &#123; dp[j] = 0; &#125; res = Math.max(res, dp[j]); &#125; &#125; return res; &#125; &#125; 方法三：滑动窗口# 树形DP# 左神shi'p 树形DP题目# 没有上司的舞会 337. 打家劫舍 III 96. 不同的二叉搜索树 1372. 二叉树中的最长交错路径 Binary Tree# # 方法一：递归# 假设树上一共有n 个节点。 时间复杂度：遍历了整棵树，\\(O(n)\\) 空间复杂度：和递归使用的栈大小相关，递归层数不超过n(一叉树)，\\(O(n)\\) class Solution &#123; public List&lt;Integer> preorderTraversal(TreeNode root) &#123; List&lt;Integer> result = new LinkedList&lt;>(); dfs(root, result); return result; &#125; public void dfs(TreeNode root, List&lt;Integer> result) &#123; if (root == null) return; result.add(root.val); dfs(root.left, result); dfs(root.right, result); &#125; &#125; 方法二：非递归# 假设树上一共有n 个节点。 时间复杂度：遍历了整棵树，\\(O(n)\\) 空间复杂度：和递归使用的栈大小相关，递归层数不超过n(一叉树)，\\(O(n)\\) class Solution &#123; public List&lt;Integer> preorderTraversal(TreeNode root) &#123; List&lt;Integer> result = new LinkedList&lt;>(); Stack&lt;TreeNode> stack = new Stack&lt;>(); TreeNode cur = root; while (cur != null || !stack.isEmpty()) &#123; while (cur != null) &#123; result.add(cur.val); stack.push(cur); cur = cur.left; &#125; cur = stack.pop(); cur = cur.right; &#125; return result; &#125; &#125; 方法三：Morris前序遍历# morris遍历利用树的大量空闲指针，实现空间开销的极限缩减。 时间复杂度：\\(O(n)\\)，其中n是二叉树的节点数。没有左子树的节点只被访问一次，有左子树的节点被访问两次 空间复杂度：\\(O(1)\\)，只操作已存在的指针（树的空闲指针），因此只需要常数的额外空间 class Solution &#123; public List&lt;Integer> preorderTraversal(TreeNode root) &#123; List&lt;Integer> result = new LinkedList&lt;>(); TreeNode cur = root, mostRight = null; while (cur != null) &#123; mostRight = cur.left; if (mostRight != null) &#123; while (mostRight.right != null &amp;&amp; mostRight.right != cur) mostRight = mostRight.right; if (mostRight.right == null) &#123; result.add(cur.val); mostRight.right = cur; cur = cur.left; continue; &#125; else &#123; // mostRight.right == cur mostRight.right = null; &#125; &#125; else &#123; // cur.left == null result.add(cur.val); &#125; cur = cur.right; &#125; return result; &#125; &#125; # 方法一：递归# 时间复杂度：\\(O(n)\\)，其中n为树的节点数 空间复杂度：\\(O(n)\\)，和递归使用的栈大小相关，递归层数不超过n(一叉树) class Solution &#123; public List&lt;Integer> inorderTraversal(TreeNode root) &#123; List&lt;Integer> result = new LinkedList&lt;>(); dfs(root, result); return result; &#125; public void dfs(TreeNode root, List&lt;Integer> result) &#123; if (root != null) &#123; dfs(root.left, result); result.add(root.val); dfs(root.right, result); &#125; &#125; &#125; 方法二：非递归# 时间复杂度：\\(O(n)\\)，其中n为树的节点数 空间复杂度：\\(O(n)\\)，和递归使用的栈大小相关，递归层数不超过n(一叉树) class Solution &#123; public List&lt;Integer> inorderTraversal(TreeNode root) &#123; List&lt;Integer> res = new LinkedList&lt;>(); Stack&lt;TreeNode> stack = new Stack&lt;>(); TreeNode cur = root; while (cur != null || !stack.isEmpty()) &#123; while (cur != null) &#123; stack.push(cur); cur = cur.left; &#125; cur = stack.pop(); res.add(cur.val); cur = cur.right; &#125; return res; &#125; &#125; 方法三：Morris中序遍历# morris遍历利用树的大量空闲指针，实现空间开销的极限缩减。 时间复杂度：\\(O(n)\\)，其中n是二叉树的节点数。没有左子树的节点只被访问一次，有左子树的节点被访问两次 空间复杂度：\\(O(1)\\)，只操作已存在的指针（树的空闲指针），因此只需要常数的额外空间 class Solution &#123; public List&lt;Integer> inorderTraversal(TreeNode root) &#123; List&lt;Integer> res = new LinkedList&lt;>(); TreeNode cur = root, mostRight = null; while (cur != null) &#123; mostRight = cur.left; if (mostRight != null) &#123; while (mostRight.right != null &amp;&amp; mostRight.right != cur) mostRight = mostRight.right; if (mostRight.right == null) &#123; mostRight.right = cur; cur = cur.left; continue; &#125; else &#123; // mostRight == cur mostRight.right = null; &#125; &#125; res.add(cur.val); cur = cur.right; &#125; return res; &#125; &#125; # 方法一：递归# 方法二：非递归# class Solution &#123; public List&lt;Integer> postorderTraversal(TreeNode root) &#123; List&lt;Integer> res = new LinkedList&lt;>(); Stack&lt;TreeNode> stack = new Stack&lt;>(); TreeNode cur = root, pre = null; while (cur != null || !stack.isEmpty()) &#123; while (cur != null) &#123; stack.push(cur); cur = cur.left; &#125; cur = stack.peek(); if (cur.right != null &amp;&amp; cur.right != pre) &#123; cur = cur.right; &#125; else &#123; stack.pop(); res.add(cur.val); pre = cur; cur = null; &#125; &#125; return res; &#125; &#125; 方法三：Morris后序遍历# 时间复杂度：\\(O(n)\\)，其中n为树的节点数 空间复杂度：\\(O(n)\\)，和递归使用的栈大小相关，递归层数不超过n(一叉树) 如果可以到达一个节点两次(有左子树)，第二次逆序打印左子树上的右边界 最后走出循环后，逆序打印根节点的右边界 class Solution &#123; public List&lt;Integer> postorderTraversal(TreeNode root) &#123; List&lt;Integer> res = new LinkedList&lt;>(); TreeNode cur = root, mostRight = null; while (cur != null) &#123; mostRight = cur.left; if (mostRight != null) &#123; while (mostRight.right != null &amp;&amp; mostRight.right != cur) mostRight = mostRight.right; if (mostRight.right == null) &#123; mostRight.right = cur; cur = cur.left; continue; &#125; else &#123; // mostRight.right = cur mostRight.right = null; visit(cur.left, res); &#125; &#125; cur = cur.right; &#125; visit(root, res); return res; &#125; private void visit(TreeNode cur, List&lt;Integer> res) &#123; TreeNode tail = reverse(cur); cur = tail; while (cur != null) &#123; res.add(cur.val); cur = cur.right; &#125; reverse(tail); &#125; private TreeNode reverse(TreeNode cur) &#123; TreeNode pre = null; while (cur != null) &#123; TreeNode next = cur.right; cur.right = pre; pre = cur; cur = next; &#125; return pre; &#125; &#125; # 借助队列实现，关键在于通过queue.size来判断下一层的节点数！ Queue.offer(null)的话，size为1！ # 这道题目背后有一个让程序员心酸的故事，听说 Homebrew的作者Max Howell，就是因为没在白板上写出翻转二叉树，最后被Google拒绝了。（真假不做判断，权当一个乐子哈） 要求：左右子树交换位置 方法一：bfs层级遍历# 时间复杂度：所有节点都需要入队，出队一次，所以是\\(O(n)\\) 空间复杂度：在最坏的情况下，给定的树是满二叉树，所有叶节点(\\(n/2 + 1\\))都要入队，所以是\\(O(n)\\) class Solution &#123; public TreeNode invertTree(TreeNode root) &#123; if (root &#x3D;&#x3D; null) return root; Queue&lt;TreeNode&gt; queue &#x3D; new LinkedList&lt;&gt;(); queue.offer(root); TreeNode cur; while (!queue.isEmpty()) &#123; cur &#x3D; queue.poll(); reverse(cur); if (cur.left !&#x3D; null) queue.offer(cur.left); if (cur.right !&#x3D; null) queue.offer(cur.right); &#125; return root; &#125; private void reverse(TreeNode cur) &#123; TreeNode temp &#x3D; cur.left; cur.left &#x3D; cur.right; cur.right &#x3D; temp; &#125; &#125; 方法二：dfs# class Solution &#123; public TreeNode invertTree(TreeNode root) &#123; // 反转所有左子树和右子树，对这棵树的所有节点 dfs(root); return root; &#125; private void dfs(TreeNode root) &#123; if (root == null) return; dfs(root.left); dfs(root.right); reverse(root); &#125; private void reverse(TreeNode root) &#123; TreeNode temp = root.left; root.left = root.right; root.right = temp; &#125; &#125; # 方法一：拷贝+翻转+判断(高情商：刷一道，解三道！低情商：只会笨方法？还是看看远方的复杂度吧)# 写了80行，一题三解！不分析复杂度了。。 方法二：BFS# 假设树上一共有n 个节点。 时间复杂度：遍历了整棵树，\\(O(n)\\) 空间复杂度：和使用的队列大小相关，在最坏的情况下，给定的树是满二叉树，所有叶节点(\\(n/2 + 1\\))都要入队，所以是\\(O(n)\\) 注意：如果p,q都为空，continue！而不是return truel！！！ class Solution &#123; public boolean isSymmetric(TreeNode root) &#123; Queue&lt;TreeNode> queue = new LinkedList&lt;>(); queue.offer(root.left); queue.offer(root.right); TreeNode p, q; while (!queue.isEmpty()) &#123; p = queue.poll(); q = queue.poll(); if (p == null &amp;&amp; q == null) continue; if (p == null || q == null) return false; if (p.val != q.val) return false; queue.offer(p.left); queue.offer(q.right); queue.offer(p.right); queue.offer(q.left); &#125; return true; &#125; &#125; 方法三：DFS# YYDS 假设树上一共有n 个节点。 时间复杂度：遍历了整棵树，\\(O(n)\\) 空间复杂度：和递归使用的栈大小相关，递归层数不超过n(一叉树)，\\(O(n)\\) class Solution &#123; public boolean isSymmetric(TreeNode root) &#123; return dfs(root.left, root.right); &#125; private boolean dfs(TreeNode left, TreeNode right) &#123; if (left == null &amp;&amp; right == null) return true; if (left == null || right == null) return false; return (left.val == right.val) &amp;&amp; dfs(left.left, right.right) &amp;&amp; dfs(left.right, right.left); &#125; &#125; # 对称二叉树方法一中用到了这个笨方法，顺手做了吧。 方法一：DFS# 假设树上一共有\\(n\\)个节点 时间复杂度：遍历了整棵树，\\(O(n)\\) 空间复杂度：和递归使用的栈大小相关，递归层数不超过n，\\(O(n)\\) 方法二：BFS# 只是和对称二叉树BFS解法中的入队顺序改变一点。 假设树上一共有n 个节点。 时间复杂度：遍历了整棵树，\\(O(n)\\) 空间复杂度：和使用的队列大小相关，在最坏的情况下，给定的树是满二叉树，所有叶节点(\\(n/2 + 1\\))都要入队，所以是\\(O(n)\\) # 方法一：BFS# 时间复杂度：遍历整棵树，\\(O(n)\\) 空间复杂度：和使用的队列大小相关，在最坏情况下，给定的二叉树是满二叉树，\\(n/2 + 1\\)个叶节点要入队，所以是\\(O(n)\\) 方法二：DFS# 假设树上一共有\\(n\\)个节点 时间复杂度：遍历了整棵树，\\(O(n)\\) 空间复杂度：和递归使用的栈大小相关，递归层数不超过n，\\(O(n)\\) # 同上题二叉树的最大深度，只是在遍历子节点的时候不同。 for (int i = 0; i &lt; cur.children.size(); i++) &#123; if (cur.children.get(i) != null) queue.offer(cur.children.get(i)); &#125; # 最小深度是从根节点到最近叶子节点的最短路径上的节点数量 方法一：DFS# 首先递归左子树和右子树 如果左子树为空，那么返回右子树的高度 + 1；如果右子树为空， 那么返回左子树的高度 + 1 如果左右子树都不为空，那么返回他们最小高度 + 1 class Solution &#123; public int minDepth(TreeNode root) &#123; if (root == null) return 0; int leftDepth = minDepth(root.left); int rightDepth = minDepth(root.right); if (root.left == null) return rightDepth + 1; if (root.right == null) return leftDepth + 1; return Math.min(leftDepth, rightDepth) + 1; &#125; &#125; 方法二：BFS# 通过队列的size知道这是第几层，上一层加入队列节点的个数就是队列的size，在得到size的同时，将记录最小深度的变量minDepth加一 遍历到第一个叶子节点的当前层数就是二叉树的最小深度 时间复杂度：遍历整棵树，\\(O(n)\\) 空间复杂度：和使用的队列大小相关，在最坏情况下，给定的二叉树是满二叉树，\\(n/2 + 1\\)个叶节点要入队，所以是\\(O(n)\\) class Solution &#123; public int minDepth(TreeNode root) &#123; if (root == null) return 0; Queue&lt;TreeNode> queue = new LinkedList&lt;>(); queue.offer(root); TreeNode cur; int minDepth = 0; while (!queue.isEmpty()) &#123; int size = queue.size(); ++minDepth; while (size-- > 0) &#123; cur = queue.poll(); if (cur.left == null &amp;&amp; cur.right == null) return minDepth; if (cur.left != null) queue.offer(cur.left); if (cur.right != null) queue.offer(cur.right); &#125; &#125; return minDepth; &#125; &#125; # 方法一：BFS# 在每层开始遍历时，记录节点个数的变量加上队列里元素个数 方法二：DFS# 边界：如果是空节点，返回0 递归左子树和右子树+1(当前节点) class Solution &#123; public int countNodes(TreeNode root) &#123; return dfs(root); &#125; public int dfs(TreeNode root) &#123; if (root == null) return 0; return 1 + dfs(root.left) + dfs(root.right); &#125; &#125; # 方法一：先序DFS# 终止条件：如果root为空，返回true 首先求当前节点左右子树高度是否&lt;=1，再判断递归左子树和右子树 时间复杂度：\\(O(n^2)\\) 空间复杂度：\\(O(n)\\) class Solution &#123; public boolean isBalanced(TreeNode root) &#123; if (root == null) return true; return Math.abs(height(root.left) - height(root.right)) &lt;= 1 &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right); &#125; private int height(TreeNode root) &#123; if (root == null) return 0; return Math.max(height(root.left), height(root.right)) + 1; &#125; &#125; :warning:方法二：后序DFS# 只需遍历所有节点一次 时间复杂度\\(O(n)\\) 空间复杂度\\((n)\\) class Solution &#123; public boolean isBalanced(TreeNode root) &#123; return height(root) >= 0; &#125; public int height(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; int leftHeight = height(root.left); int rightHeight = height(root.right); if (leftHeight == -1 || rightHeight == -1 || Math.abs(leftHeight - rightHeight) > 1) &#123; return -1; &#125; else &#123; return Math.max(leftHeight, rightHeight) + 1; &#125; &#125; &#125; :warning:# 方法一：BFS# class Solution &#123; public List&lt;String> binaryTreePaths(TreeNode root) &#123; List&lt;String> result = new LinkedList&lt;>(); Queue&lt;Object> queue = new LinkedList&lt;>(); queue.offer(root); queue.offer(String.valueOf(root.val)); TreeNode cur; String path = \"\"; while (!queue.isEmpty()) &#123; cur = (TreeNode)queue.poll(); path = (String)queue.poll(); if (cur.left == null &amp;&amp; cur.right == null) &#123; result.add(path); &#125; if (cur.left != null) &#123; queue.offer(cur.left); queue.offer(path + \"->\" + String.valueOf(cur.left.val)); &#125; if (cur.right != null) &#123; queue.offer(cur.right); queue.offer(path + \"->\" + String.valueOf(cur.right.val)); &#125; &#125; return result; &#125; &#125; 方法二：DFS# class Solution &#123; List&lt;String> result = new LinkedList&lt;>(); public List&lt;String> binaryTreePaths(TreeNode root) &#123; dfs(root, \"\"); return result; &#125; public void dfs(TreeNode root, String path) &#123; if (root == null) return; path += String.valueOf(root.val); if (root.left == null &amp;&amp; root.right == null) &#123; result.add(path); &#125; else &#123; path += \"->\"; dfs(root.left, path); dfs(root.right, path); &#125; &#125; &#125; # :warning:方法一：DFS# class Solution &#123; public int sumOfLeftLeaves(TreeNode root) &#123; if (root.left == null &amp;&amp; root.right == null) return 0; return dfs(root); &#125; private int dfs(TreeNode root) &#123; if (root == null) return 0; int sum = 0; if (root.left != null) &#123; sum += isLeaf(root.left) ? root.left.val : dfs(root.left); &#125; if (root.right != null) &#123; sum += dfs(root.right); &#125; return sum; &#125; private boolean isLeaf(TreeNode root) &#123; return root.left == null &amp;&amp; root.right == null; &#125; &#125; # :warning:方法一：DFS# class Solution &#123; int curHeight = 0; int curValue = 0; public int findBottomLeftValue(TreeNode root) &#123; dfs(root, 0); return curValue; &#125; private void dfs(TreeNode root, int height) &#123; if (root == null) return; ++height; dfs(root.left, height); dfs(root.right, height); if (height > curHeight) &#123; curHeight = height; curValue = root.val; &#125; &#125; &#125; 方法二：BFS# 从右往左层次遍历，最后一个访问的节点就是树左下角的值！ class Solution &#123; public int findBottomLeftValue(TreeNode root) &#123; TreeNode cur; int res = 0; Queue&lt;TreeNode> queue = new LinkedList&lt;>(); queue.offer(root); while (!queue.isEmpty()) &#123; cur = queue.poll(); if (cur.right != null) &#123; queue.offer(cur.right); &#125; if (cur.left != null) &#123; queue.offer(cur.left); &#125; res = cur.val; &#125; return res; &#125; &#125; # 方法一：BFS# 初始化一个Object类型队列，用于存放节点与节点的值，首先把根节点和根节点的值offer进队列 开始while循环，循环的执行条件是队列不为空 首先按顺序取出节点和节点的值，注意这里需要强转 判断当前节点是否为根节点且节点的值是否为目标值，如果满足，直接return true 如果左子树不为空，先将左子树节点offer进队列，再将左子树的值加上poll出的当前节点的值offer进队列 如果右子树不为空，先将右子树节点offer进队列，再将右子树的值加上poll出的当前节点的值offer进队列 如果有这么一条路径，那么在while循环中就会return true，不会执行到这；如果没有满足条件的路径，则返回false class Solution &#123; public boolean hasPathSum(TreeNode root, int targetSum) &#123; if (root == null) return false; Queue&lt;Object> queue = new LinkedList&lt;>(); queue.offer(root); queue.offer(root.val); TreeNode cur; while (!queue.isEmpty()) &#123; cur = (TreeNode)queue.poll(); int val = (int)queue.poll(); if (cur.left == null &amp;&amp; cur.right == null &amp;&amp; val == targetSum) &#123; return true; &#125; if (cur.left != null) &#123; queue.offer(cur.left); queue.offer(val + cur.left.val); &#125; if (cur.right != null) &#123; queue.offer(cur.right); queue.offer(val + cur.right.val); &#125; &#125; return false; &#125; &#125; |:warning::warning:方法二：DFS class Solution &#123; public boolean hasPathSum(TreeNode root, int targetSum) &#123; if (root == null) return false; if (root.left == null &amp;&amp; root.right == null) return targetSum == root.val; return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val); &#125; &#125; # 方法一：BFS# 使用队列存放当前节点和累加节点值 使用HashMap记录每个节点的父节点 当节点满足是叶节点且累加值等于targetSum时，通过HashMap，从该叶子节点遍历到根节点记录到list中，最后把list反转 class Solution &#123; public List&lt;List&lt;Integer>> pathSum(TreeNode root, int targetSum) &#123; List&lt;List&lt;Integer>> res = new LinkedList&lt;>(); if (root == null) return res; Queue&lt;Object> queue = new LinkedList&lt;>(); queue.offer(root); queue.offer(root.val); TreeNode cur; Map&lt;TreeNode, TreeNode> sonFather = new HashMap&lt;>(); while (!queue.isEmpty()) &#123; cur = (TreeNode)queue.poll(); int val = (Integer)queue.poll(); if (cur.left == null &amp;&amp; cur.right == null &amp;&amp; val == targetSum) &#123; res.add(getPath(cur, sonFather)); &#125; if (cur.left != null) &#123; queue.offer(cur.left); queue.offer(val + cur.left.val); sonFather.put(cur.left, cur); &#125; if(cur.right != null) &#123; queue.offer(cur.right); queue.offer(val + cur.right.val); sonFather.put(cur.right, cur); &#125; &#125; return res; &#125; private List&lt;Integer> getPath(TreeNode node, Map&lt;TreeNode, TreeNode> sonFather) &#123; List&lt;Integer> path = new LinkedList&lt;>(); path.add(node.val); while (node != null) &#123; node = sonFather.get(node); path.add(node.val); &#125; Collections.reverse(path); return path; &#125; :warning:方法二：DFS# 使用双端队列，每次dfs将当前节点值放入双端队列队尾，并让targetSum减去当前节点元素 如果当前节点是叶子节点且targetSum等于0，那么说明这条路径满足条件，将path加入结果 每次dfs完左右，再将双端队列最后一个元素移除！！！ class Solution &#123; Deque&lt;Integer> path = new LinkedList&lt;>(); List&lt;List&lt;Integer>> res = new LinkedList&lt;>(); public List&lt;List&lt;Integer>> pathSum(TreeNode root, int targetSum) &#123; dfs(root, targetSum); return res; &#125; private void dfs(TreeNode root, int targetSum) &#123; if (root == null) return; path.offerLast(root.val); targetSum -= root.val; if (root.left == null &amp;&amp; root.right == null &amp;&amp; targetSum == 0) &#123; res.add(new LinkedList&lt;>(path)); &#125; dfs(root.left, targetSum); dfs(root.right, targetSum); path.pollLast(); &#125; &#125; :star:方法三：回溯(其实方法二也是回溯)# 递归终止条件是：节点为空 /** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */ class Solution &#123; List&lt;List&lt;Integer>> res = new LinkedList&lt;>(); Deque&lt;Integer> path = new LinkedList&lt;>(); public List&lt;List&lt;Integer>> pathSum(TreeNode root, int targetSum) &#123; if (root == null) return res; dfs(root, targetSum); return res; &#125; private void dfs(TreeNode root, int targetSum) &#123; if (root == null) return; path.add(root.val); if (root.left == null &amp;&amp; root.right == null &amp;&amp; targetSum == root.val) &#123; res.add(new LinkedList(path)); &#125; dfs(root.left, targetSum - root.val); dfs(root.right, targetSum - root.val); path.removeLast(); &#125; &#125; :star:# 草稿构造一棵二叉树，写出中序和后序序列 确定好边界条件：左闭右闭 后序序列最后一个元素是根，通过HashMap找到根节点下标 根节点左边的长度为lenOfLeft，那么先序序列和后序序列的前lenOfLeft为根节点的左子树 class Solution &#123; Map&lt;Integer, Integer> map = new HashMap&lt;>(); public TreeNode buildTree(int[] inorder, int[] postorder) &#123; if (postorder == null) return null; for (int i = 0; i &lt; inorder.length; ++i) &#123; map.put(inorder[i], i); &#125; // [start, end - 1]左闭右闭 return dfs(inorder, 0, inorder.length - 1, postorder, 0, postorder.length - 1); &#125; private TreeNode dfs(int[] inorder, int inStart, int inEnd, int[] postorder, int postStart, int postEnd) &#123; if (inStart > inEnd || postStart > postEnd) return null; // 找到postorder最后一个元素的下标，也就是根节点 int rootValue = postorder[postEnd]; // 找到inorder中根节点的位置 int rootIdx = map.get(rootValue); // 构造树节点 TreeNode root = new TreeNode(rootValue); // 根据inorder切割左子树的大小，那么剩下的就是右子树 int lenOfLeft = rootIdx - inStart; // 按照根节点切割成左子树和右子树 root.left = dfs(inorder, inStart, rootIdx - 1, postorder, postStart, postStart + lenOfLeft - 1); root.right = dfs(inorder, rootIdx + 1, inEnd, postorder, postStart + lenOfLeft, postEnd - 1); return root; &#125; &#125; # 注意：int lenOfLeft = rootIdx - inStart; ！！！！！！！！ class Solution &#123; Map&lt;Integer, Integer> map = new HashMap&lt;>(); public TreeNode buildTree(int[] preorder, int[] inorder) &#123; int length = inorder.length; for (int i = 0; i &lt; length; ++i) map.put(inorder[i], i); // [)左闭右开 return dfs(inorder, 0, length, preorder, 0, length); &#125; private TreeNode dfs(int[] inorder, int inStart, int inEnd, int[] preorder, int preStart, int preEnd) &#123; if (inStart >= inEnd || preStart >= preEnd) return null; // 找到根节点 int rootVal = preorder[preStart]; int rootIdx = map.get(rootVal); // 中序遍历中根节点左边的长度 int lenOfLeft = rootIdx - inStart; TreeNode root = new TreeNode(rootVal); root.left = dfs(inorder, inStart, rootIdx, preorder, preStart + 1, preStart + 1 + lenOfLeft); root.right = dfs(inorder, rootIdx + 1, inEnd, preorder, preStart + 1 + lenOfLeft, preEnd); return root; &#125; &#125; :star:# 方法一：DFS# 思路同106. 从中序与后序遍历序列构造二叉树 class Solution &#123; public TreeNode constructMaximumBinaryTree(int[] nums) &#123; return dfs(0, nums.length, nums); &#125; private TreeNode dfs(int start, int end, int[] nums) &#123; if (start >= end) return null; int index = start; int maxValue = nums[start]; for (int i = start; i &lt; end; ++i) &#123; if (maxValue &lt; nums[i]) &#123; maxValue = nums[i]; index = i; &#125; &#125; TreeNode root = new TreeNode(maxValue); root.left = dfs(start, index, nums); root.right = dfs(index + 1, end, nums); return root; &#125; &#125; # 解题思路：当树1当前节点的左子树或右子树为空，而树2当前节点左子树或右子树不为空时：使用parentQueue存储树1树2的当前节点parent1，parent2，在遍历到下一层时，使用parent1来指向parent2的左子树或者右子树。 Debug：如果cur1左子树为空，cur2左子树不为空，将cur1,cur2加入trashQueue；同理右子树。如果cur1左右子树都为空，cur2左右子树都不为空，将cur1,cur2加入parentQueue两次！！不然之后poll的时候空指针！！ :warning:方法二：DFS# class Solution &#123; public TreeNode mergeTrees(TreeNode root1, TreeNode root2) &#123; if (root1 == null) return root2; if (root2 == null) return root1; root1.val += root2.val; root1.left = mergeTrees(root1.left, root2.left); root1.right = mergeTrees(root1.right, root2.right); return root1; &#125; &#125; # 方法一：DFS# class Solution &#123; public TreeNode searchBST(TreeNode root, int val) &#123; TreeNode cur = root; while (cur != null) &#123; if (cur.val == val) &#123; return cur; &#125; else if (cur.val &lt; val) &#123; cur = cur.right; &#125; else &#123; cur = cur.left; &#125; &#125; return null; &#125; &#125; :star:# 方法一：中序遍历# 中序遍历二叉搜索树应该是升序的，只需要一个记录上一个节点的值的遍历preVal，并与当前节点比较，如果当前节点的值小于等于preVal(cur.val应该严格&gt;preVal不能等于)，则返回false;否则，遍历完所有节点返回true。 假设树有n个节点 时间复杂度：遍历所有节点，\\(O(n)\\) 空间复杂度：和使用的栈相关，在最坏情况(每个节点都只有一个子节点)下，树的高度为n，都需要压栈，所以为\\(O(n)\\) class Solution &#123; public boolean isValidBST(TreeNode root) &#123; if (root == null) return true; long preVal = Long.MIN_VALUE; TreeNode cur = root; Stack&lt;TreeNode> stack = new Stack&lt;>(); while (cur != null || !stack.isEmpty()) &#123; while (cur != null) &#123; stack.push(cur); cur = cur.left; &#125; cur = stack.pop(); if (cur.val &lt;= preVal) return false; preVal = cur.val; cur = cur.right; &#125; return true; &#125; &#125; :war:方法二：递归# class Solution &#123; public boolean isValidBST(TreeNode root) &#123; if (root == null) return true; return dfs(TreeNode root, long.MIN_VALUE, long.MAX_VALUE) &#125; public boolean dfs(TreeNode root, long pre, long post) &#123; if (root == null) return true; if (root.val &lt;= pre || root.val >= post) return false; return dfs(root.left, pre, root.val) &amp;&amp; dfs(root.right, root.val, post); &#125; &#125; 方法三：Morris中序遍历# Morris遍历利用叶子节点的左右空指针，实现空间开销的极限缩减。 morris遍历的实现原则# 记作当前节点为cur。 如果cur无左孩子，cur向右移动（cur=cur.right） 如果cur有左孩子，找到cur左子树上最右的节点，记为mostright 如果mostright的right指针指向空，让其指向cur，cur向左移动（cur=cur.left） 如果mostright的right指针指向cur，让其指向空，cur向右移动（cur=cur.right） 实现以上的原则，即实现了morris遍历。 morris遍历的实质# 建立一种机制，对于没有左子树的节点只到达一次，对于有左子树的节点会到达两次 Morris中序遍历# 如果可以到达一个节点两次(有左子树)，第二次访问 如果可以到达一个节点一次(无左子树)，直接访问 举个例子# 从根节点5开始遍历，令cur = 根节点5，找到mostRight为节点1 节点1的右子树为空，将节点1的右子树指向节点5，并让cur移动到左子树(节点1) 开始遍历节点1，由于节点一无左子树，直接访问，比较节点一与preValue(初始化为最小值)， 1 &lt; Long.MIN_VALUE，将节点1的val赋值给preValue 将cur(1)移动到右子树，此时cur为之前访问过的根节点5，继续找到cur(5)左子树的最右节点1，发现节点1的右子树为当前节点cur(5)，将节点1的右子树还原为空 此时是第二次到达节点5，比较节点5与preValue(1)，并将5赋值给preValue，cur向右子树移动，此时cur到达节点4 找到cur(4)左子树的最右节点3，将节点3的右子树指向cur(4)，cur向左子树移动，此时cur到达节点3 由于节点3无左子树，直接比较节点3与preValue(5)的值，3&lt;5，返回false。 可以发现中序遍历的顺序是：15346 Morris中序遍历到达的节点顺序是：5154346，其中5和4有左子树，在到底5和4的第二次时作比较。 class Solution &#123; public boolean isValidBST(TreeNode root) &#123; TreeNode cur = root, mostRight = null; long preValue = Long.MIN_VALUE; while (cur != null) &#123; mostRight = cur.left; if (mostRight != null) &#123; while (mostRight.right != null &amp;&amp; mostRight.right != cur) mostRight = mostRight.right; if (mostRight.right == null) &#123; mostRight.right = cur; cur = cur.left; continue; &#125; else if (mostRight.right == cur) &#123; mostRight.right = null; &#125; &#125; if (cur.val &lt;= preValue) return false; preValue = cur.val; cur = cur.right; &#125; return true; &#125; &#125; 时间复杂度：遍历所有节点，\\(O(n)\\) 空间复杂度：Morris遍历利用叶子节点的左右空指针，实现空间开销的极限缩减，\\(O(1)\\) # 方法一：中序遍历# 使用中序遍历二叉搜索树得到的结果是升序的。 :star::warning:方法二：双指针# 双指针的思想真的很重要！！！ 初始化全局变量：pre节点初始化为空；diff存储相邻节点差值，初始化为整型最大值 中序遍历过程：第一次遍历，pre是空的，还没遇到第二个节点也就没有相邻节点之间的差值； 把当前节点(root)赋给pre，那么下一个root就是中序遍历顺序pre的下一个节点 class Solution &#123; TreeNode pre; int diff = Integer.MAX_VALUE; public int getMinimumDifference(TreeNode root) &#123; dfs(root); return diff; &#125; private void dfs(TreeNode root) &#123; if (root == null) return; dfs(root.left); if (pre != null) diff = Math.min(diff, root.val - pre.val); pre = root; dfs(root.right); &#125; &#125; # # 老样子，中序遍历 遍历的过程 if (preVal == cur.val) &#123; ++counter; &#125; else &#123; counter = 1; &#125; if (!modes.contains(cur.val) &amp;&amp; counter == maxCounter) &#123; modes.add(cur.val); &#125; if (counter > maxCounter) &#123; maxCounter = counter; modes.removeAll(modes); modes.add(cur.val); &#125; preVal = cur.val; cur = cur.right; # 方法一：用HashMap存储所有父节点，用HashSet标记是否访问过；从p开始向上遍历，并标记访问过的父节点，再从q开始向上遍历，如果当前节点被访问过，那么这个节点就是最近公共祖先。# 注意：对于p，先设置visisted，再向上移；对于q，先判断当前节点是不是已经被visited，再向上移。如果p,q任意一者先向上移再操作，都会导致在，p或q是最近公共节点时，返回的却是p或q的父节点 /** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */ class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; Map&lt;TreeNode, TreeNode> map = new HashMap&lt;>(); Set&lt;TreeNode> visited = new HashSet&lt;>(); dfs(root, map); while (p != null) &#123; visited.add(p); p = map.get(p); &#125; while (q != null) &#123; if (visited.contains(q)) &#123; return q; &#125; q = map.get(q); &#125; return root; &#125; public void dfs(TreeNode root, Map&lt;TreeNode, TreeNode> map) &#123; if (root == null) return; if (root.left != null) &#123; map.put(root.left, root); &#125; if (root.right != null) &#123; map.put(root.right, root); &#125; dfs(root.left, map); dfs(root.right, map); &#125; &#125; :warning:方法二：DFS# 题解 可以不判断非p,q的叶节点 class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; return dfs(root, p, q); &#125; public TreeNode dfs(TreeNode root, TreeNode p, TreeNode q) &#123; if (root == null || root == p || root == q) return root; TreeNode left = dfs(root.left, p, q); TreeNode right = dfs(root.right, p, q); if (left == null) return right; if (right == null) return left; return root; &#125; &#125; # 递归：考虑三种情况# p,q是root：return root p,q在root两侧，(p.val &lt; root.val &amp;&amp; q.val &gt; root.val) || (p.val &gt; root.val &amp;&amp; q.val &lt; root.val)， return root p,q在root同一侧 (p.val &lt; root &amp;&amp; q.val &lt; root.val) || (p.val &gt; root.val &amp;&amp; q.val &gt; root.val) p.val &lt; root &amp;&amp; q.val &lt; root.val: return dfs(left, p, q) p.val &gt; root.val &amp;&amp; q.val &gt; root.val: return dfs(right, p, q) 方法一：DFS# class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if (root == null) return null; if (root.val > p.val &amp;&amp; root.val > q.val) return lowestCommonAncestor(root.left, p, q); if (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) return lowestCommonAncestor(root.right, p, q); return root; &#125; &#125; # 要点是：如何记录要插入节点的父节点 方法一：栈# 从根节点开始遍历，用栈存储每个遍历过的节点，大于向右小于向左；循环结束，判断插入最后一个被遍历的节点(栈中最顶层节点)，判断大于小于，插入，结束。 遍历过程把所有元素放进栈，空节点跳出循环后，栈顶元素就是要插入节点的父节点 class Solution &#123; public TreeNode insertIntoBST(TreeNode root, int val) &#123; if (root == null) return new TreeNode(val); TreeNode cur = root; Stack&lt;TreeNode> stack = new Stack&lt;>(); while (cur != null) &#123; stack.push(cur); if (val &lt; cur.val) &#123; cur = cur.left; &#125; else &#123; cur = cur.right; &#125; &#125; cur = stack.pop(); TreeNode newNode = new TreeNode(val); if (cur.val > val) &#123; cur.left = newNode; &#125; else &#123; cur.right = newNode; &#125; return root; &#125; &#125; 方法二：双指针# 用pre指针指向上一个节点，有两个要注意的地方 初始化pre指针时，不能初始化为null，如果根节点没有左子树，而要插入的节点小于根节点，要插入的节点会成为根节点的左子树，这种情况判断一次就会跳出while循环，此时pre还是null，所以要把pre初始化为根节点 在while循环中，用pre=cur记录cur的上一个节点，但是，最后cur等于空的时候，pre再记录cur就没有意义了，所以加上if (cur != null)判断条件 class Solution &#123; public TreeNode insertIntoBST(TreeNode root, int val) &#123; TreeNode res = new TreeNode(val); if (root == null) return res; TreeNode cur = root, pre = root; while (cur != null) &#123; if (cur.val > val) cur = cur.left; else if (cur.val &lt; val) cur= cur.right; if (cur != null) pre = cur; &#125; if (val > pre.val) pre.right = res; else pre.left = res; return root; &#125; &#125; 方法三：DFS# 当时想出来了，但是卡在怎么插入这个点上，其实这里已经用root.left或者root.right来接收 new TreeNode(val)了。==构造树==！！！ class Solution &#123; public TreeNode insertIntoBST(TreeNode root, int val) &#123; if (root == null) &#123; return new TreeNode(val); &#125; if (val &lt; root.val) &#123; root.left = insertIntoBST(root.left, val); &#125; else &#123; root.right = insertIntoBST(root.right, val); &#125; return root; &#125; &#125; x# 解题思路： 如果目标节点大于当前节点值，则去右子树中删除； 如果目标节点小于当前节点值，则去左子树中删除； 如果目标节点就是当前节点，分为以下三种情况： 其无左子：其右子顶替其位置，删除了该节点； 其无右子：其左子顶替其位置，删除了该节点； 其左右子节点都有：其左子树转移到其右子树的最左节点的左子树上，然后右子树顶替其位置，由此删除了该节点。 写了快100行，重构一下代码。。 方法一：迭代# /** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */ class Solution &#123; public TreeNode deleteNode(TreeNode root, int key) &#123; if (root == null) return root; TreeNode cur = root, pre = root; while (cur != null) &#123; if (cur.val == key) &#123; if (cur.left == null &amp;&amp; cur.right == null) &#123; // 叶子节点 if (pre.val &lt; key) pre.right = null; else pre.left = null; &#125; else &#123; if (cur.left != null &amp;&amp; cur.right != null) &#123; // 找到要删除节点右子树上的最左节点，再把要删除节点左子树挂上去 TreeNode left = cur.left, right = cur.right; cur = cur.right; while (cur.left != null) cur = cur.left; cur.left = left; if (pre.val &lt; key) pre.right = right; else pre.left = right; &#125; else if (cur.left == null &amp;&amp; cur.right != null) &#123; TreeNode right = cur.right; if (pre.val &lt; key) pre.right = right; else pre.left = right; &#125; else if (cur.left != null &amp;&amp; cur.right == null) &#123; TreeNode left = cur.left; if (pre.val &lt; key) pre.right = left; else pre.left = left; &#125; &#125; break; &#125; else if (cur.val &lt; key) &#123; pre = cur; cur = cur.right; &#125; else &#123; pre = cur; cur = cur.left; &#125; &#125; if (root.val == key) &#123; return root.left == null ? root.right : root.left; &#125; return root; &#125; &#125; :star:方法二：DFS# 注意代码注释部分是完全冗余的！ class Solution &#123; public TreeNode deleteNode(TreeNode root, int key) &#123; if (root == null) return root; if (key &lt; root.val) root.left = deleteNode(root.left, key); else if (key > root.val) root.right = deleteNode(root.right, key); else &#123; //(key == root.val) &#123; if (root.left == null &amp;&amp; root.right == null) &#123; return null; &#125; else if (root.left == null &amp;&amp; root.right != null) &#123; return root.right; &#125; else if (root.left != null &amp;&amp; root.right == null) &#123; return root.left; &#125; else &#123; TreeNode cur = root.right; while (cur.left != null) cur = cur.left; cur.left = root.left; return root.right; &#125; &#125; // if (root.val == key) &#123; // if (root.left == null &amp;&amp; root.right == null) // return null; // else &#123; // return root.left == null ? root.right : root.left; // &#125; // &#125; return root; &#125; &#125; :warning:# 借上一题的思路直接速通了 # 方法一：二分DFS[左闭右闭]# 方法二：DFS[左闭右开)]，开区间元素在record的数值要--，闭区间元素在record的位置要++，开区间元素和闭区间元素都为‘a’，所以s的下标1以‘b’开始的子串“ba”也是变位词！# class Solution &#123; public List&lt;Integer> findAnagrams(String s, String p) &#123; List&lt;Integer> index = new LinkedList&lt;>(); if (s.length() &lt; p.length()) return index; int[] record = new int[26]; for (int i = 0; i &lt; p.length(); ++i) &#123; ++record[p.charAt(i) - 'a']; --record[s.charAt(i) - 'a']; &#125; if (areZeros(record)) &#123; index.add(0); &#125; for (int i = p.length(); i &lt; s.length(); ++i) &#123; ++record[s.charAt(i - p.length()) - 'a']; --record[s.charAt(i) - 'a']; if (areZeros(record)) &#123; index.add(i - p.length() + 1); &#125; &#125; return index; &#125; private boolean areZeros(int[] record) &#123; for (int element : record) if (element != 0) return false; return true; &#125; &#125; String补充知识# String与char数组，StringBuilder之间相互转换# 将String转换为char数组： codeString str = \"hello\"; char[] charArray = str.toCharArray(); 将char数组转换为String： codechar[] charArray = &#123;'h', 'e', 'l', 'l', 'o'&#125;; String str = new String(charArray); 将String转换为StringBuilder： //1. codeString str = \"hello\"; StringBuilder sb = new StringBuilder(str); //2. StringBuilder sb = new StringBuilder(); sb.append(str); 将StringBuilder转换为String： codeStringBuilder sb = new StringBuilder(); sb.append(\"hello\"); String str = sb.toString(); 将char数组转换为StringBuilder： codechar[] charArray = &#123;'h', 'e', 'l', 'l', 'o'&#125;; StringBuilder sb = new StringBuilder(); sb.append(charArray); 将StringBuilder转换为char数组： codeStringBuilder sb = new StringBuilder(\"hello\"); char[] charArray = new char[sb.length()]; sb.getChars(0, sb.length(), charArray, 0); 需要注意的是，在将String转换为char数组或char时，如果字符串为空，或者字符串中的字符数量为0，则可能会导致越界异常或其他异常。因此，在进行这些转换操作时，需要进行有效性检查和异常处理。 单个字符char转换为String 在Java中，将单个字符（char）转换为字符串（String）有以下两种方法： 1.使用字符串连接符 您可以使用字符串连接符\"+\"来连接一个空字符串和单个字符，从而将其转换为字符串。例如： arduinoCopy codechar c &#x3D; &#39;a&#39;; String s &#x3D; &quot;&quot; + c; 在上面的代码中，首先创建一个空字符串，然后使用字符串连接符将其与字符\"c\"连接起来，从而将字符\"c\"转换为字符串。现在，字符串s将包含字符\"c\"的字符串。 2.使用String.valueOf()方法 另一种将单个字符转换为字符串的方法是使用String类的valueOf()方法。例如： arduinoCopy codechar c &#x3D; &#39;a&#39;; String s &#x3D; String.valueOf(c); 在上面的代码中，将字符\"c\"传递给valueOf()方法，并将返回的字符串分配给变量s。 无论使用哪种方法，您都可以将单个字符转换为字符串，从而可以对其进行各种字符串操作。 StringBuilder的append可以是char或者String# StringBuilder的append()方法可以接受char类型和String类型的参数。append()方法的作用是在StringBuilder对象的末尾追加指定的字符序列，这可以是char、String、StringBuilder或其他CharSequence实例。 以下是使用StringBuilder的append()方法追加char和String类型参数的示例代码： 追加char类型参数： codeStringBuilder sb = new StringBuilder(); char c = 'a'; sb.append(c); 追加String类型参数： codeStringBuilder sb = new StringBuilder(); String str = \"hello\"; sb.append(str); 需要注意的是，使用append()方法追加char类型参数时，会自动将char类型转换为String类型。因此，如果需要在StringBuilder中追加一个char类型的字符，可以直接使用append()方法，而不需要先将其转换为String类型。 KMP算法# 生成next数组讲得很透彻 Array# # 方法一：左闭右开# 区间：[left, right) 初始化：right = nums.length while循环终止条件应为left &lt; right（右开，right不能等于left） 当nums[mid] &lt; target时，nums[0]~nums[mid]都小于target，此时有效的有边界是mid - 1，又因为右边界是开区间，所以另right = mid 时间复杂度：\\(O(logn)\\)，由于每次查找都会将查找范围缩小一半，因此二分查找的时间复杂度是\\(O(logn)\\)，其中 n 是数组的长度 空间复杂度：\\(O(1)\\) class Solution &#123; public int search(int[] nums, int target) &#123; int left = 0, right = nums.length; // [left, right) while(left &lt; right) &#123; int mid = left + ((right - left) >> 1); if (nums[mid] == target) return mid; else if (nums[mid] &lt; target) left = mid + 1; else right = mid; &#125; return -1; &#125; &#125; 方法二：左闭右闭# 区间：[left, right] 初始化：right = nums.length - 1 while循环终止条件应为left &lt;= right 当nums[mid] &lt; target时，nums[0]~nums[mid]都小于target，另right = mid - 1 时间复杂度：\\(O(logn)\\)，由于每次查找都会将查找范围缩小一半，因此二分查找的时间复杂度是\\(O(logn)\\)，其中 n 是数组的长度 空间复杂度：\\(O(1)\\) class Solution &#123; public int search(int[] nums, int target) &#123; int left = 0, right = nums.length - 1; while (left &lt;= right) &#123; int mid = right - ((right - left) >> 2); if (nums[mid] > target) right = mid - 1; else if (nums[mid] &lt; target) left = mid + 1; else return mid; &#125; return -1; &#125; &#125; # 方法一：暴力# 每当发现一个数相等，那么从当前数组的下一个数开始，全部往前移一位。 注意：因为移位后，下一个要访问的数组元素j会到当前i的位置，然后for循环结束i自增，会错过访j，所以移位后要--i。 时间复杂度：\\(O(n^2)\\) 空间复杂度：\\(O(1)\\) class Solution &#123; public int removeElement(int[] nums, int val) &#123; int newLen = nums.length; if (newLen == 0) return 0; for (int i = 0; i &lt; newLen; i++) &#123; if (nums[i] == val) &#123; for (int j = i + 1; j &lt; newLen; j++) &#123; nums[j - 1] = nums[j]; &#125; --newLen; --i; &#125; &#125; return newLen; &#125; &#125; 方法二：双指针# 初始化慢指针为0 for循环遍历快指针，当nums[fast] != val时，令nums[slow] = nums[fast]，slow指针往后移。也就是说，如果快指针找到了val，那么慢指针停在val位置，之后快指针遍历到非val的位置时，将该非val数据覆盖到慢指针的指向数组位置的数据。 最后返回慢指针(慢指针大小代表新数组的大小) 时间复杂度：\\(O(n)\\) 空间复杂度：\\(O(1)\\) class Solution &#123; public int removeElement(int[] nums, int val) &#123; int slow = 0; for (int fast = 0; fast &lt; nums.length; ++fast) &#123; if (nums[fast] != val) &#123; nums[slow] = nums[fast]; ++slow; &#125; &#125; return slow; &#125; &#125; 方法三：相向双指针# 避免了需要保留的元素的重复赋值操作。 初始化：left=0, right=nums.length-1，左闭右闭区间，所以while语句的执行条件是 left &lt;= right(如果没有等于，left会少后移一次) 循环：当nums[left]不等于val时，left指针后移；当nums[left]等于val时，将nums[right]赋值给nums[left]，right指针前移；如果赋值过来的元素恰好也等于val，可以继续把右指针 right指向的元素的值赋值过来，直到左指针指向的元素的值不等于 val为止。 时间复杂度：\\(O(n)\\) 空间复杂度：\\(O(1)\\) class Solution &#123; public int removeElement(int[] nums, int val) &#123; int left = 0, right = nums.length - 1; // [left, right] while (left &lt;= right) &#123; if (nums[left] == val) &#123; nums[left] = nums[right]; --right; &#125; else &#123; ++left; &#125; &#125; return left; &#125; &#125; # 双指针# left,right指针指向数组两端，将较大的平方数放入result数组里。 时间复杂度：\\(O(n)\\) 空间复杂度：\\(O(n)\\) # nums[++i]先执行自增操作还是数组寻址操作?# 在Java中，表达式nums[++i]中的++i是先自增还是先寻址是有规定的。按照Java的运算符优先级规定，前置自增运算符++i的优先级高于数组下标运算符[]，因此在执行这个表达式时，先进行++i自增运算，然后再进行数组下标运算，即先自增再寻址。 因此，nums[++i]相当于先将变量i自增1，然后使用自增后的i作为数组下标去访问nums数组中的元素。如果i的初始值为0，那么nums[++i]将访问nums[1]位置上的元素，而不是nums[0]。如果数组nums越界，将会抛出ArrayIndexOutOfBoundsException异常。 nums[i++]先执行自增操作还是数组寻址操作?# 在这种情况下，nums[i++]实际上会先执行数组寻址操作，然后再对i进行自增操作。这是因为数组寻址操作的优先级比自增操作的优先级高。 具体来说，这个表达式会先使用i的当前值来计算nums数组中第i个元素的地址，然后将地址作为结果返回，接着才会将i的值加1。 int a = ++i 是先赋值还是先自增# 这行代码会先自增变量 i 的值，然后将自增后的结果赋值给变量 a。所以，变量 a 的值等于自增后的变量 i 的值。这个过程中，变量 i 的值会被修改，而变量 a 的值则是这个修改后的值。 可以将这行代码拆分成两步： i = i + 1； // 自增 i 的值 a = i； // 将自增后的 i 的值赋值给 a 所以，最终变量 a 的值等于自增后的变量 i 的值。 int a = i++ 是先赋值还是先自增# 这行代码会先将变量 i 的值赋值给变量 a，然后再将变量 i 的值自增。所以，变量 a 的值等于变量 i 的值，而变量 i 的值会被自增。 可以将这行代码拆分成两步： a = i； // 将 i 的值赋值给 a i = i + 1； // 自增 i 的值 所以，最终变量 a 的值等于变量 i 的初始值，而变量 i 的值则是初始值加一。 while(--index) 先-- 后比较index&gt;0# int index = 2; while (--index > 0) &#123; System.out.print(index); &#125; stdout 1 while(index--) 先比较 后--# int index = 2; while (index-- > 0) &#123; System.out.print(index); &#125; stdout 10 System.out.print(--index) 先-- 后打印# int index = 2; while (index > 0) &#123; System.out.print(--index); &#125; stdout 10 滑动窗口# 注意：为了确保有些案例，sum一直小于target，最后输出判断：如果 result == Integer.MAX_VALUE，就输出0。 result记录最小的长度 时间复杂度：\\(O(n)\\) 空间复杂度：\\(O(1)\\) class Solution &#123; public int minSubArrayLen(int target, int[] nums) &#123; int counter = 0, result = Integer.MAX_VALUE; int sum = 0; for (int i = 0; i &lt; nums.length; ++i) &#123; ++counter; sum += nums[i]; while (sum >= target) &#123; result = Math.min(result, counter); sum -= nums[i - (--counter)]; &#125; &#125; return result == Integer.MAX_VALUE ? 0 : result; &#125; &#125; # 遍历顺序：从左到右(左闭右开)，从上到下(上闭下开)，从右到左(右闭左开)，从下到上(下闭上开) 思路见代码注释部分 时间复杂度：\\(O(n^2)\\) 空间复杂度：\\(O(1)\\) class Solution &#123; public int[][] generateMatrix(int n) &#123; // 用笔画一个n=5的矩阵作为例子 // 遍历顺序：从左到右(左闭右开)，从上到下(上闭下开)，从右到左(右闭左开)，从下到上(下闭上开) // 建立n行n列的矩阵 int[][] matrix = new int[n][n]; // 遍历次数 int traverseTime = n / 2; int i, j; // 写入数组的数 int data = 1; // cur:当前遍历伦茨 for (int cur = 0; cur &lt; traverseTime; ++cur) &#123; // 从左到右(左闭右开) for (j = cur; j &lt; n - cur - 1; ++j) &#123; matrix[cur][j] = data++; &#125; // 从上到下(上闭下开) for (i = cur; i &lt; n - cur - 1; ++i) &#123; matrix[i][j] = data++; &#125; // 从右到左(右闭左开) for (; j > cur; --j) &#123; matrix[i][j] = data++; &#125; // 从下到上(下闭上开) for (; i > cur; --i) &#123; matrix[i][j] = data++; &#125; // debug // for (int a = 0; a &lt; n; ++a) &#123; // for (int b = 0; b &lt; n; ++b) &#123; // System.out.print(matrix[a][b]); // &#125; // &#125; &#125; if (n % 2 == 1) matrix[traverseTime][traverseTime] = n * n; return matrix; &#125; &#125; LinkedList# # 解题思路：在面对链表、树有关创建、删除操作，使用dummyHead！能省去不少边界判定的功夫。# 初始化：dummyHead指向head，dummyHead赋值给pre，head赋值给cur 当cur的值等于所求val，pre指向cur的下一个节点 当cur的值不等于val，pre移动到cur，cur往后移一位 返回dummyHead的下一个节点。 # 注意事项：DummyHead + size# # 用笔模拟一下指针pre，cur，next的过程 时间复杂度：\\(O(n^2)\\) 空间复杂度：\\(O(1)\\) # 注意要点：用纸和笔模拟一下指针pre，cur，next的过程，记得创建dummyHead# 时间复杂度：\\(O(n)\\) 空间复杂度：\\(O(1)\\) # 使用dummyHead，从dummyHead，找到倒数第N个节点的前一个节点node，需要走链表长度size - N步，即可把node指向下一个节点的下一个节点即可完成删除操作。 但是链表的长度是未知的，可以先遍历一遍链表的长度，求出size，再走size-N步完成删除操作。 也可以使用快慢指针，fast与slow的起始点都为dummyHead，fast先走N步，再让fast与slow一起右移，当fast走到最后一个节点时(fast.next == null时)，slow右移了size - N步，到达倒数第N个节点的上一个节点，即可完成删除操作。 时间复杂度：\\(O(n)\\) 空间复杂度：\\(O(1)\\) # 方法一：HashSet# 用指针A,B分别指向两个链表头 开始循环，循环的终止条件为A,B都为空，每次循环先将A,B指向的节点放入HashSet，再向后移 当遍历到某个已经存入HashSet的节点时，这个节点就是相交节点；否则没有相交节点 时间复杂度：\\(O(m + n)\\)，其中m，n分别为两个链表的长度 空间复杂度：\\(O(m + n)\\) 方法二：双指针# 解题思路：A,B分别指向headA,headB，如果有公共节点，设公共节点长度为c，链表A和B长度分别为a,b。向右遍历，如何为空，则指向另一个链表的头。如果两个链表相交，则A向右移动了a+c+b步，B向右移动了b+c+a时相交，返回A；如果两个链表不相交，则A向右移动了a+b步，B向右移动了b+a步，都为空，退出循环返回null。 用指针A,B分别指向两个链表头headA,headB 开始循环，循环的条件是A和B不都为空，如果A为空，则A指向headB，否则向后移；如果B为空，则B指向headA，否则向后移 开始循环，循环的终止条件为A,B都为空，每次循环先将A,B指向的节点放入HashSet，再向后移 当遍历到某个已经存入HashSet的节点时，这个节点就是相交节点；否则没有相交节点 时间复杂度：\\(O(m + n)\\)，其中m，n分别为两个链表的长度 空间复杂度：\\(O(m + n)\\) 一个错误代码实例 public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; if (headA == null || headB == null) return null; ListNode pA = headA, pB = headB; while (pA != null || pB != null) &#123; pA = pA == null ? headB : pA.next; pB = pB == null ? headA : pB.next; if (pA == pB) return pA; &#125; return null; &#125; &#125; 错误如下，当两个链表只有公共部分节点1时，上述代码没有先判断，先向右移，结果指向A,B都为空，返回空。 所以解决方案是把判断AB相等的语句放在指针移动上面 public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; if (headA == null || headB == null) return null; ListNode pA = headA, pB = headB; while (pA != null || pB != null) &#123; if (pA == pB) return pA; pA = pA == null ? headB : pA.next; pB = pB == null ? headA : pB.next; &#125; return null; &#125; 成功 优化# 当A,B只有公共部分时，直接返回结果 当A,B有自己的部分也相交时 当A,B公共部分前面节点数量相同时，遍历到相交节点直接返回结果 当A,B公共部分前面节点数量不同时，遍历a+b+c步也会相交，返回结果 当A,B不相交时，遍历完a+ 1(null) + b + 1(null) 步后，A和B都为null，返回的A为null，表示不相交 public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; if (headA == null || headB == null) return null; ListNode pA = headA, pB = headB; while (pA != pB) &#123; pA = pA == null ? headB : pA.next; pB = pB == null ? headA : pB.next; &#125; return pA; &#125; &#125; # 解题思路：快慢指针，慢指针走一步，快指针走两步，如果有环，快指针总能在环中追上慢指针。当快指针和慢指针指向同一节点时，把快节点指向头节点，慢节点不动，快慢指针一起走，再次相遇时，指向的节点就是入环的第一个节点。 时间复杂度：\\(O(m + n)\\)，其中m，n分别为两个链表的长度 空间复杂度：\\(O(m + n)\\) public class Solution &#123; public ListNode detectCycle(ListNode head) &#123; if (head == null || head.next == null) return null; ListNode fast = head.next.next, slow = head.next; while (fast != null &amp;&amp; fast.next != null) &#123; fast = fast.next.next; slow = slow.next; if (fast == slow) &#123; fast = head; while (fast != slow) &#123; fast = fast.next; slow = slow.next; &#125; return fast; &#125; &#125; return null; &#125; &#125; Hash Table# # 方法一：双HashMap记录词频# 判断s与t的长度，若不相等，则一定不是字母异位词 建立两个HashMap&lt;Character, Integer&gt; 遍历字符串，将每个字符存入map中，并将值+1 如果map1与map2的size不相等，则一定不是字母异位词 遍历map1(我遍历的是字符串)，get字符串s，t的每一个字符出现了的次数，判断是否相同，如果不同，则一定不是字母异位词。 时间复杂度：\\(O(n)\\)，其中n为第一个字符串的长度 空间复杂度：\\(O(1)\\) class Solution &#123; public boolean isAnagram(String s, String t) &#123; int len = s.length(); if (len != t.length()) return false; Map&lt;Character, Integer> map1 = new HashMap&lt;>(), map2 = new HashMap&lt;>(); for (int i = 0; i &lt; len; ++i) &#123; char sChar = s.charAt(i); char tChar = t.charAt(i); map1.put(sChar, map1.getOrDefault(sChar, 0) + 1); map2.put(tChar, map2.getOrDefault(tChar, 0) + 1); &#125; for (int i = 0; i &lt; len; ++i) &#123; int sSize = map1.get(s.charAt(i)); int tSize = map2.getOrDefault(s.charAt(i), 0); if (sSize != tSize) &#123; return false; &#125; &#125; return true; &#125; &#125; 方法二：数组# 数组其实就是一个简单哈希表，而且这道题目中字符串只有小写字符，那么就可以定义一个数组，来记录字符串s里字符出现的次数。 定一个数组record，大小为26 ，初始化为0，因为字符a到字符z的ASCII也是26个连续的数值。 遍历第一个字符串s时，只需要将s.charAt(i) - ‘a’所在的元素+1，这样统计了字符串s中每个字符出现的次数。 同样，遍历第二个字符串t时，只需要将t.charAt(i) - ‘a’所在的元素-1。 如果record全部元素为0，那么s和t是字母异位词；否则不是。 时间复杂度：\\(O(n)\\)，其中n为第一个字符串的长度 空间复杂度：\\(O(1)\\)，只使用了常数大小的辅助数组。 class Solution &#123; public boolean isAnagram(String s, String t) &#123; if (s.length() != t.length()) return false; int[] record = new int[26]; for (int i = 0; i &lt; s.length(); ++i) &#123; ++record[s.charAt(i) - 'a']; --record[t.charAt(i) - 'a']; &#125; for (int i = 0; i &lt; 26; ++i) if (record[i] != 0) return false; return true; &#125; &#125; # 解题思路：双HashSet# 首先使用一个HashSet命名为set，记录第一个数组中不包含重复的所有元素 再用一个HashSet命名为intersection，遍历第二个数组，如果第二个数组中的元素在set中，则加入intersection中 最后将intersection转换为数组，并返回 class Solution &#123; public int[] intersection(int[] nums1, int[] nums2) &#123; Set&lt;Integer> set = new HashSet&lt;>(); Set&lt;Integer> intersection = new HashSet&lt;>(); for (int i = 0; i &lt; nums1.length; ++i) set.add(nums1[i]); for (int i = 0; i &lt; nums2.length; ++i) if (set.contains(nums2[i])) intersection.add(nums2[i]); int[] result = new int[intersection.size()]; int i = 0; for (int element : intersection) &#123; result[i++] = element; &#125; return result; &#125; &#125; # 求和的过程中，sum会重复出现，用HashSet记录每一次求和，如果有重复，那么必定不是快乐数。 注意：sum += (n % 10) * (n % 10);+=的优先级高于%。 class Solution &#123; public boolean isHappy(int n) &#123; Set&lt;Integer> set = new HashSet&lt;>(); while (n != 1 &amp;&amp; !set.contains(n)) &#123; set.add(n); n = getSum(n); &#125; return n == 1; &#125; private int getSum(int n) &#123; int sum = 0; while (n > 0) &#123; sum += (n % 10) * (n % 10); n /= 10; &#125; return sum; &#125; &#125; # 方法一：暴力# 注意初始化int数组：new int[]{i, j}; 时间复杂度：\\(O(n^2)\\)，其中n为第一个字符串的长度 空间复杂度：\\(O(1)\\)，只使用了常数大小的辅助数组。 class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int[] result = new int[2]; for (int i = 0; i &lt; nums.length - 1; ++i) &#123; for (int j = i + 1; j &lt; nums.length; ++j) &#123; if (nums[i] + nums[j] == target) &#123; return new int[]&#123;i, j&#125;; &#125; &#125; &#125; return result; &#125; &#125; 方法二：HashMap# 解题思路： 建立一个HashMap，key为数组的值，value为数组索引 遍历一遍，每次遍历判断哈希表中是否存在key为target-nums[i]，如果有，则这个key对应的value与i即为所求 时间复杂度：\\(O(n)\\) 空间复杂度：\\(O(n)\\) class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer> map = new HashMap&lt;>(); for (int i = 0; i &lt; nums.length; ++i) &#123; if (map.containsKey(target - nums[i])) return new int[]&#123;map.get(target - nums[i]), i&#125;; map.put(nums[i], i); &#125; return new int[2]; &#125; &#125; # 解题思路：# 用HashMap用两层循环记录前两个数组每个元素之和为key，和出现的次数为value 再两次循环后两个数组，如果map.containsKey(- i - j)，那么- i - j与当前i + j之和为0，即为本题所求，则把result加上和为- i - j的数量 时间复杂度：\\(O(n^2)\\)，两层循环 空间复杂度：\\(O(n^2)\\)，在最坏情况下，前两个数组的元素各不相同，map占n * n class Solution &#123; public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) &#123; Map&lt;Integer, Integer> map = new HashMap&lt;>(); int result = 0; int n = nums1.length; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; map.put(nums1[i] + nums2[j], map.getOrDefault(nums1[i] + nums2[j], 0) + 1); &#125; &#125; for (int i : nums3) &#123; for (int j : nums4) &#123; if (map.containsKey(- i - j)) result += map.get(- i - j); &#125; &#125; return result; &#125; &#125; # 解题思路：字母表# 如果ransomNote的长度大于magazine的长度，直接返回false 新建一个长度为26的字母表，以及一个HashMap，key为字母-‘a’，value为字母出现的次数，将magazine中的每个字符put进map 遍历ransomNote的所有字符i，如果map中key为字符i的value大于0，那么把这个value减一；如果map中key为字符i的value小于等于0，说明magazine不存在字符i或者字符i的个数小于ransomNote中字符i的个数，那么 ransomNote 能不能由 magazine 里面的字符构成，返回false 时间复杂度：\\(O(n)\\)，两层循环 空间复杂度：\\(O(1)\\)，只需要常数大小的辅助空间 class Solution &#123; public boolean canConstruct(String ransomNote, String magazine) &#123; if (ransomNote.length() > magazine.length()) return false; char[] record = new char[26]; Map&lt; Integer, Integer> map = new HashMap&lt;>(); for (int i = 0; i &lt; magazine.length(); ++i) &#123; int index = magazine.charAt(i) - 'a'; map.put(index, map.getOrDefault(index, 0) + 1); &#125; for (int i = 0; i &lt; ransomNote.length(); ++i) &#123; int index = ransomNote.charAt(i) - 'a'; if (map.getOrDefault(index, 0) > 0) &#123; map.put(index, map.get(index) - 1); &#125; else return false; &#125; return true; &#125; &#125; # 题目要求： nums[i],nums[j],nums[k]中i,j,k各不相同 输出的nums[i],nums[j],nums[k]不能重复，如果结果集合中有{1,2,3}了，就不能再加入一个{1,2,3} 不能有重复的三元组，但三元组内的元素是可以重复的！{0,0,0},{-1,-1,2}是允许的 方法一：暴力# 注意：{1，2，3}和{3， 2， 1}是不同的元素！ set.add(Arrays.asList(1, 2, 3)); set.add(Arrays.asList(3, 1, 2)); [1, 2, 3] [3, 1, 2] 找到符合的元素先排序，如何hashset中不存在再加入list中。 class Solution &#123; public List&lt;List&lt;Integer>> threeSum(int[] nums) &#123; Set&lt;List&lt;Integer>> set = new HashSet&lt;>(); List&lt;List&lt;Integer>> list = new LinkedList&lt;>(); for (int i = 0; i &lt; nums.length - 2; ++i) &#123; for (int j = i + 1; j &lt;nums.length - 1; ++j) &#123; for (int k = j + 1; k &lt; nums.length; ++k) &#123; if (nums[i] + nums[j] + nums[k] == 0) &#123; List&lt;Integer> temp = Arrays.asList(nums[i], nums[j], nums[k]); Collections.sort(temp); if (!set.contains(temp)) &#123; set.add(temp); list.add(temp); &#125; &#125; &#125; &#125; &#125; return list; &#125; &#125; 超时 方法二：排序 + 双指针# 去重思路 边界判断 时间复杂度：\\(O(n^2)\\)，两层循环 空间复杂度：\\(O(1)\\) class Solution &#123; public List&lt;List&lt;Integer>> threeSum(int[] nums) &#123; List&lt;List&lt;Integer>> result = new LinkedList&lt;>(); Arrays.sort(nums); // window: [nums[i], left, right] for (int i = 0; i &lt; nums.length - 2; ++i) &#123; if (nums[i] > 0) break; // 去重 // 为什么不是nums[i] = nums[i + 1]? // 比如&#123;-1，-1，2&#125; // 如果是nums[i] = nums[i + 1]，那么&#123;-1，-1，2&#125;这个结果不会被选中 if (i > 0 &amp;&amp; nums[i] == nums[i - 1]) continue; int left = i + 1, right = nums.length - 1; // 只能选取数组中不同下标的三个数，所以left == right时会使用同一个数，不执行 while (left &lt; right) &#123; int sum = nums[i] + nums[left] + nums[right]; if (sum &lt; 0) ++left; else if (sum > 0) --right; else &#123; // sum == 0 result.add(Arrays.asList(nums[i], nums[left], nums[right])); // 去重 // 必须在添加完结果后去重，不然第一次的结果可能无法添加 while (right > left &amp;&amp; nums[right] == nums[right - 1]) --right; while (right > left &amp;&amp; nums[left] == nums[left + 1]) ++left; // 为什么两个指针都移动？去重之后，只移动一个，结果必定不等于0 --right; ++left; &#125; &#125; &#125; return result; &#125; &#125; # 注意事项：nums[i]的范围，如果4个数都等于\\(10^9\\)， 那么将大于\\(2^{31} - 1= 2147483648 &lt; 2.15 * 10^9\\)(int最大的正数)，所以要用long记录四数之和 在三数之和的基础上，再增加一层循环， 区间为[nums[i], nums[left], nums[right], nums[j]] 时间复杂度：\\(O(n^3)\\)，三层循环 空间复杂度：\\(O(n)\\)，排序使用了额外的数组存储数组nums的副本 剪枝# 第一层循环中，如果最小的四数之和大于target，那么后面的数更大，break \\\\ 第一层循环 if ((long) nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 1] > target) break; 第二层循环中，如果最大的四数之和小于target，那么前面的数更小，break \\\\ 第二层循环 if ((long) nums[i] + nums[j] + nums[j - 1] + nums[j - 2] &lt; target) break; 完整代码如下 class Solution &#123; public List&lt;List&lt;Integer>> fourSum(int[] nums, int target) &#123; List&lt;List&lt;Integer>> result = new LinkedList&lt;>(); int length = nums.length; if (length &lt; 4) return result; Arrays.sort(nums); // window: [nums[i], nums[left], nums[right], nums[j]] for (int i = 0; i &lt; length - 3; ++i) &#123; // 去重 if (i > 0 &amp;&amp; nums[i] == nums[i - 1]) continue; if ((long) nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 1] > target) break; // 第4个数从尾开始遍历，举例&#123;-1, -1, 0, 2&#125;来确定j > 2这个边界条件 for (int j = length - 1; j > 2; --j) &#123; // 去重，如果使用nums[j] == nums[j - 1]判断，nums[j - 1]属于right的范围 // 那么&#123;-1，-1，1, 1&#125;这个结果不会被选中 if (j &lt; length - 1 &amp;&amp; nums[j] == nums[j + 1]) continue; if ((long) nums[i] + nums[j] + nums[j - 1] + nums[j - 2] &lt; target) break; int left = i + 1, right = j - 1; // 只能选取数组中不同下标的三个数，所以left == right时会使用同一个数，不执行 while (left &lt; right) &#123; long sum = (long) nums[i] + nums[left] + nums[right] + nums[j]; if (sum &lt; target) ++left; else if (sum > target) --right; else &#123; // sum == target result.add(Arrays.asList(nums[i], nums[left], nums[right], nums[j])); while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) ++left; while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) --right; ++left; --right; &#125; &#125; &#125; &#125; return result; &#125; &#125; Stack and Queue# # 解题思路：使用两个栈，inStack,outStack来实现队列。 push：直接将元素push进inStack pop：如果outStack不为空，则弹出outStack顶部元素；如果outStack为空，则将inStack中的元素全部弹入inStack，再弹出outStack顶部元素 class MyQueue &#123; private Stack&lt;Integer> inStack; private Stack&lt;Integer> outStack; public MyQueue() &#123; inStack = new Stack&lt;>(); outStack = new Stack&lt;>(); &#125; public void push(int x) &#123; inStack.push(x); &#125; public int pop() &#123; if (outStack.isEmpty()) &#123; pushIntoOut(); &#125; return outStack.pop(); &#125; public int peek() &#123; if (outStack.isEmpty()) pushIntoOut(); return outStack.peek(); &#125; public boolean empty() &#123; return inStack.isEmpty() &amp;&amp; outStack.isEmpty(); &#125; public void pushIntoOut() &#123; while (!inStack.isEmpty()) &#123; outStack.push(inStack.pop()); &#125; &#125; &#125; /** * Your MyQueue object will be instantiated and called as such: * MyQueue obj = new MyQueue(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.peek(); * boolean param_4 = obj.empty(); */ # 方法一：单队列# push：直接将元素加入queue pop()：首先将队列元素移除并重新加入queue.size() - 1次，这样底部的元素就在队列首部了，poll出来即可 peek()：首先将队列元素移除并重新加入queue.size() - 1次，这样底部的元素就在队列首部了，先用result接收queue.peek()，再将这个元素移除并重新加入，最后返回result，peek()操作是不能改变内部数据的！！ class MyStack &#123; private Queue&lt;Integer> queue; public MyStack() &#123; queue = new LinkedList&lt;>(); &#125; public void push(int x) &#123; queue.offer(x); &#125; public int pop() &#123; catchBottom(); return queue.poll(); &#125; public int top() &#123; catchBottom(); int result = queue.peek(); queue.offer(queue.poll()); return result; &#125; public boolean empty() &#123; return queue.isEmpty(); &#125; public void catchBottom() &#123; for (int i = 0; i &lt; queue.size() - 1; ++i) &#123; queue.offer(queue.poll()); &#125; &#125; &#125; 优化# 在面对大量需要查看顶部元素业务的时候，每次都要重新出队入队n次，不如在push的时候就排好序， public void push(int x) &#123; queue.offer(x); for (int i = 0; i &lt; queue.size() - 1; ++i) &#123; queue.offer(queue.poll()); &#125; &#125; public int pop() &#123; return queue.poll(); &#125; public int top() &#123; return queue.peek(); &#125; 方法二：双队列# push：先在辅助队列supportQueue中加入目标数据，再将主队列queue中的数据全部弹出并加入到supportQueue中，这个时候supportQueue就是先进后出的排列顺序，最后将queue和support交换 class MyStack &#123; Queue&lt;Integer> queue, supportQueue; public MyStack() &#123; queue = new LinkedList&lt;>(); supportQueue = new LinkedList&lt;>(); &#125; public void push(int x) &#123; supportQueue.offer(x); while (!queue.isEmpty()) &#123; supportQueue.offer(queue.poll()); &#125; Queue&lt;Integer> temp = queue; queue = supportQueue; supportQueue = temp; &#125; public int pop() &#123; return queue.poll(); &#125; public int top() &#123; return queue.peek(); &#125; public boolean empty() &#123; return queue.isEmpty(); &#125; &#125; # 方法一：HashMap + Stack# 注意事项：如果是左括号，直接push进栈 如果是右括号，如果栈为空那么匹配不了；如果右括号和栈顶部的左括号不匹配，也不满足 最后如果栈空，则是有效的括号；否则不是 class Solution &#123; public boolean isValid(String s) &#123; Map&lt;Character, Character> map = new HashMap&lt;>(); map.put('&#123;', '&#125;'); map.put('(', ')'); map.put('[', ']'); Stack&lt;Character> stack = new Stack&lt;>(); for (int i = 0; i &lt; s.length(); ++i) &#123; char c = s.charAt(i); if (map.containsKey(c)) stack.push(c); else &#123; if (stack.isEmpty() || map.get(stack.pop()) != c) &#123; return false; &#125; &#125; &#125; return stack.isEmpty(); &#125; &#125; # 方法一：StringBuilder# 如果当前字符和前一个字符相等，则删除当前字符；否则加入当前字符 class Solution &#123; public String removeDuplicates(String s) &#123; StringBuilder sb = new StringBuilder(); int index = -1; for (int i = 0; i &lt; s.length(); ++i) &#123; char c = s.charAt(i); if (sb.length() == 0 || c != sb.charAt(index)) &#123; sb.append(c); ++index; &#125; else &#123; sb.deleteCharAt(index); --index; &#125; &#125; return sb.toString(); &#125; &#125; # 解题思路： 遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中 class Solution &#123; public int evalRPN(String[] tokens) &#123; Stack&lt;Integer> stack = new Stack&lt;>(); for (int i = 0; i &lt; tokens.length; ++i) &#123; String token = tokens[i]; if (isNumber(token)) stack.push(Integer.parseInt(token)); else &#123; int b = stack.pop(), a = stack.pop(); switch (token) &#123; case \"+\": stack.push(a + b); break; case \"-\": stack.push(a - b); break; case \"*\": stack.push(a * b); break; case \"/\": stack.push(a / b); break; default: &#125; &#125; &#125; return stack.pop(); &#125; public boolean isNumber(String s) &#123; return !(s.equals(\"+\") || s.equals(\"-\") || s.equals(\"*\") || s.equals(\"/\")); &#125; &#125; 注意事项： 在Java中，==和.equals()都是用于比较两个对象是否相等的操作符。但是它们之间存在着不同的用法和含义。 ==用于比较两个对象的引用是否相等，也就是判断这两个对象是否是同一个对象。当比较两个基本数据类型的值时，它们的值相等时返回true；当比较两个引用类型的对象时，如果它们所指向的内存地址相同，也就是它们是同一个对象时，返回true；否则返回false。 .equals()方法用于比较两个对象的内容是否相等。默认情况下，.equals()方法比较的是两个对象的引用是否相等，也就是使用==比较，但是我们可以通过重写.equals()方法来自定义比较规则，比如根据对象的属性值来比较是否相等。 对于字符串类型的变量来说，==和.equals()方法的区别如下： ==比较的是字符串对象的引用是否相等，也就是它们是否指向同一个内存地址。 .equals()方法比较的是字符串对象的内容是否相等，也就是它们包含的字符序列是否相同。 因为Java中字符串是一个特殊的对象类型，为了方便字符串的比较操作，Java中提供了一种特殊的机制，也就是\"字符串常量池\"，它可以缓存字符串对象，使得多个字符串对象可以共享同一个对象，也就是它们的引用相等。在这种情况下，==操作符会返回true。但是在其他情况下，如果不是使用相同的字符串字面量来创建字符串对象，==操作符会返回false，此时需要使用.equals()方法来进行字符串的内容比较。 # 方法一：暴力（超时）# 时间复杂度：\\(O(kn)\\) 空间复杂度：\\(O(n)\\)，存储结果的数组 class Solution &#123; public int[] maxSlidingWindow(int[] nums, int k) &#123; int n = nums.length; int[] result = new int[n - k + 1]; if (k > n) return result; // [i, i + k) for (int i = 0; i &lt; result.length; ++i) &#123; int max = Integer.MIN_VALUE; for (int j = i; j &lt; i + k; ++j) &#123; max = Math.max(max, nums[j]); &#125; result[i] = max; &#125; return result; &#125; &#125; 方法二：单调队列# class Solution &#123; public int[] maxSlidingWindow(int[] nums, int k) &#123; int n = nums.length - k + 1; Deque&lt;Integer> deque = new LinkedList&lt;>(); for (int i = 0; i &lt; k; ++i) &#123; while (!deque.isEmpty() &amp;&amp; nums[i] > nums[deque.peekLast()]) &#123; deque.pollLast(); &#125; deque.offerLast(i); &#125; int[] result = new int[n]; result[0] = nums[deque.peekFirst()]; for (int i = k; i &lt; nums.length; ++i) &#123; while (!deque.isEmpty() &amp;&amp; nums[i] > nums[deque.peekLast()]) &#123; deque.pollLast(); &#125; deque.offerLast(i); // 如果i的左区间在队首元素右边，则要移除队首元素; 用if就可以了(while也行) if (deque.peekFirst() &lt;= i - k) &#123; deque.pollFirst(); &#125; result[i - k + 1] = nums[deque.peekFirst()]; &#125; return result; &#125; &#125; # class Solution &#123; public int[] topKFrequent(int[] nums, int k) &#123; Map&lt;Integer, Integer> map = new HashMap&lt;>(); for (int i = 0; i &lt; nums.length; ++i) &#123; map.put(nums[i], map.getOrDefault(nums[i], 0) + 1); &#125; PriorityQueue&lt;int[]> queue = new PriorityQueue&lt;>(new Comparator&lt;int[]>() &#123; public int compare(int[] m, int[] n) &#123; return m[1] - n[1]; &#125; &#125;); for (Map.Entry&lt;Integer, Integer> entry: map.entrySet()) &#123; int num = entry.getKey(), count = entry.getValue(); if (queue.size() == k) &#123; if (count > queue.peek()[1]) &#123; queue.poll(); queue.offer(new int[]&#123;num, count&#125;); &#125; &#125; else &#123; queue.offer(new int[]&#123;num, count&#125;); &#125; &#125; int[] result = new int[k]; for (int i = 0; i &lt; k; ++i) &#123; result[i] = queue.poll()[0]; &#125; return result; &#125; &#125; 优先级队列（大根堆、小根堆）# Java中可以使用PriorityQueue类来创建优先级队列，它实现了一个基于优先级堆的无界优先级队列。 要创建一个大根堆，需要使用Comparator.reverseOrder()方法来创建一个反转自然顺序的比较器，示例如下： PriorityQueue&lt;Integer> maxHeap = new PriorityQueue&lt;>(Comparator.reverseOrder()); maxHeap.add(5); maxHeap.add(1); maxHeap.add(10); System.out.println(maxHeap.poll()); // 输出10 要创建一个小根堆，只需要使用默认的比较器即可，示例如下： PriorityQueue&lt;Integer> minHeap = new PriorityQueue&lt;>(); minHeap.add(5); minHeap.add(1); minHeap.add(10); System.out.println(minHeap.poll()); // 输出1 在上述示例中，我们首先创建了一个空的优先级队列，然后使用add()方法向其中添加元素，使用poll()方法从队列中取出元素并删除。由于大根堆和小根堆的比较器不同，它们会按照不同的顺序取出元素。 除了示例中用到的add()和poll()方法之外，PriorityQueue类还提供了一些其他常用的方法，下面对一些常用方法进行补充说明： offer(E e): 添加元素到队列中，如果队列已满则抛出异常。 arduinoCopy codePriorityQueue&lt;Integer&gt; queue &#x3D; new PriorityQueue&lt;&gt;(); queue.offer(1); peek(): 获取但不删除队列的头部元素，如果队列为空则返回null。 arduinoCopy codePriorityQueue&lt;Integer&gt; queue &#x3D; new PriorityQueue&lt;&gt;(); queue.offer(1); queue.offer(2); System.out.println(queue.peek()); &#x2F;&#x2F; 输出1 remove(Object o): 从队列中删除指定的元素，如果队列中不存在该元素则返回false。 arduinoCopy codePriorityQueue&lt;Integer&gt; queue &#x3D; new PriorityQueue&lt;&gt;(); queue.offer(1); queue.offer(2); queue.offer(3); System.out.println(queue.remove(2)); &#x2F;&#x2F; 输出true System.out.println(queue.remove(4)); &#x2F;&#x2F; 输出false System.out.println(queue); &#x2F;&#x2F; 输出[3, 1] size(): 返回队列中元素的数量。 arduinoCopy codePriorityQueue&lt;Integer&gt; queue &#x3D; new PriorityQueue&lt;&gt;(); queue.offer(1); queue.offer(2); queue.offer(3); System.out.println(queue.size()); &#x2F;&#x2F; 输出3 clear(): 删除队列中的所有元素。 arduinoCopy codePriorityQueue&lt;Integer&gt; queue &#x3D; new PriorityQueue&lt;&gt;(); queue.offer(1); queue.offer(2); queue.offer(3); queue.clear(); System.out.println(queue); &#x2F;&#x2F; 输出[] 还有一些其他的方法，如toArray()、contains()、addAll()等，可以参考Java官方文档进行学习。 Greedy# # 方法一：从小胃口开始喂小饼干# 先把两个数组都升序排序，从左往右遍历 如果孩子满足度小于等于饼干满足度，那么++res，并让两个指针都往后移动一位 如果孩子满足度大于饼干满足度，使饼干的指针向后移动一位 直到任意一个指针超出数组范围为止 class Solution &#123; public int findContentChildren(int[] children, int[] cookies) &#123; int res = 0; Arrays.sort(children); Arrays.sort(cookies); int i = 0, j = 0; while (i &lt; children.length &amp;&amp; j &lt; cookies.length) &#123; if (children[i] &lt;= cookies[j]) &#123; ++res; ++i; ++j; &#125; else &#123; ++j; &#125; &#125; return res; &#125; &#125; 方法二：从大胃口开始喂大饼干# class Solution &#123; public int findContentChildren(int[] children, int[] cookies) &#123; int res = 0; Arrays.sort(children); Arrays.sort(cookies); int i = children.length - 1, j = cookies.length - 1; while (i >= 0 &amp;&amp; j >= 0) &#123; if (children[i] &lt;= cookies[j]) &#123; ++res; --i; --j; &#125; else &#123; --i; &#125; &#125; return res; &#125; &#125; # 方法一：排序+删除连续重复元素+dp(不推荐)# class Solution &#123; public int wiggleMaxLength(int[] nums) &#123; int n = nums.length; if (n == 1) return 1; // 1.dp[i]:以nums[i]为结尾，最长的摆动序列 List&lt;Integer> list = new LinkedList&lt;>(); list.add(nums[0]); for (int i = 1; i &lt; n; ++i) &#123; if (nums[i] != nums[i - 1]) list.add(nums[i]); &#125; Integer[] dummy = list.toArray(new Integer[0]); if (dummy.length == 1) return 1; if (dummy.length == 2) return 2; int[] dp = new int[dummy.length]; dp[0] = 1; dp[1] = 2; // 2.状态转移方程： // 1)nums[i] - nums[i - 1]与nums[i - 1] - nums[i- 2]异号：dp[i] = dp[i - 1] + 1 // 2)nums[i] - nums[i - 1]与nums[i - 1] - nums[i- 2]同号：dp[i] = dp[i - 1] int res = 1; for (int i = 2; i &lt; dummy.length; ++i) &#123; if ((dummy[i] - dummy[i - 1]) * (dummy[i - 1] - dummy[i - 2]) &lt; 0) &#123; dp[i] = dp[i - 1] + 1; &#125; else if ((dummy[i] - dummy[i - 1]) * (dummy[i - 1] - dummy[i - 2]) > 0) &#123; dp[i] = dp[i - 1]; &#125; res = Math.max(res, dp[i]); &#125; return res; &#125; &#125; # 方法一：DP# dp[i]：以nums[i]结尾的子数组的最数组和 状态转移方程： 当dp[i - 1] &gt;= 0 时候，dp[i] = dp[i - 1] + nums[i] 当dp[i - 1] &lt; 0时候， dp[i] = nums[i] 初始化：dp[0] = nums[0] 时间复杂度：\\(O(n)\\) 空间复杂度：\\(O(n)\\) class Solution &#123; public int maxSubArray(int[] nums) &#123; int n = nums.length; if (n == 1) return nums[0]; // dp[i]：以nums[i]结尾的子数组的最数组和 int[] dp = new int[n]; dp[0] = nums[0]; int res = dp[0]; for (int i = 1; i &lt; n; ++i) &#123; if (dp[i - 1] >= 0) &#123; dp[i] = dp[i - 1] + nums[i]; &#125; else &#123; // dp[i - 1] &lt; 0 dp[i] = nums[i]; &#125; res = Math.max(res, dp[i]); &#125; return res; &#125; &#125; 方法二：优化空间的DP# 由于dp[i]只依赖dp[i - 1]，所以可以用一个长度为2的数组记录dp class Solution &#123; public int maxSubArray(int[] nums) &#123; int n = nums.length; if (n == 1) return nums[0]; // dp[i]：以nums[i]结尾的子数组的最数组和 int[] dp = new int[2]; dp[0] = nums[0]; int res = nums[0]; for (int i = 1; i &lt; n; ++i) &#123; if (dp[(i - 1) % 2] >= 0) &#123; dp[i % 2] = dp[(i - 1) % 2] + nums[i]; &#125; else &#123; // dp[i - 1] &lt; 0 dp[i % 2] = nums[i]; &#125; res = Math.max(res, dp[i % 2]); &#125; return res; &#125; &#125; 贪心# 首先把记录结果的result初始化为最小值，以及count=0 遍历数组，count加上当前元素，如果count大于result，讲count值赋给result 如果count等于负数了，令count等于0，从下一个数开始重新计算 class Solution &#123; public int maxSubArray(int[] nums) &#123; int result = Integer.MIN_VALUE; int count = 0; for (int i = 0; i &lt; nums.length; ++i) &#123; count += nums[i]; if (count > result) result = count; if (count &lt; 0) count = 0; &#125; return result; &#125; &#125; # 只要下一天股票价格高于当天，那么就买入当前股票并在下一天卖出 class Solution &#123; public int maxProfit(int[] prices) &#123; int res = 0; for (int i = 0; i &lt; prices.length - 1; ++i) &#123; int diff = prices[i + 1] - prices[i]; if (diff > 0) &#123; res += diff; &#125; &#125; return res; &#125; &#125; # 方法一：贪心# 初始化一个available数组，available[i]表示是否可以到底数组元素i 如果当前节点是可到达的，令i=0前往后遍历，把available数组从i+1开始，后nums[i]个元素都赋true 初始化：第一个元素是肯定能到达的，初始化为true 时间复杂度：\\(O(n^2)\\)，最坏情况下，所有节点都刚好能到达数组倒数第二个元素，且倒数第二个元素的值为0，如[n - 2, n - 3, ..., 1, 0, 1]，需要遍历\\(\\frac{(n-1)(n-2)}{2}\\)次 空间复杂度：\\(O(n)\\) class Solution &#123; public boolean canJump(int[] nums) &#123; int n = nums.length; boolean[] available = new boolean[n]; available[0] = true; for (int i = 0; i &lt; n - 1; ++i) &#123; if (available[i]) &#123; for (int j = i + 1; j &lt; nums[i] + i + 1; ++j) &#123; if (j == n - 1) return true; available[j] = true; &#125; &#125; &#125; return available[n - 1]; &#125; &#125; 方法二：贪心（优化空间复杂度）# 不必要用一个boolean数组来表示是否可以到达当前数组元素，可以用一个整数rightmost来判断 class Solution &#123; public boolean canJump(int[] nums) &#123; int n = nums.length; int rightmost = 0; for (int i = 0; i &lt; n; ++i) &#123; if (i &lt;= rightmost) &#123; rightmost = Math.max(rightmost, i + nums[i]); if (rightmost >= n - 1) return true; &#125; &#125; return false; &#125; &#125; # 方法一：dp# class Solution &#123; public int jump(int[] nums) &#123; int n &#x3D; nums.length; &#x2F;&#x2F; 1.dp[i]：到达i的最小跳数 int[] dp &#x3D; new int[n]; Arrays.fill(dp, Integer.MAX_VALUE); dp[0] &#x3D; 0; for (int i &#x3D; 0; i &lt; n - 1; ++i) &#123; for (int j &#x3D; i + 1; j &lt; i + 1 + nums[i]; ++j) &#123; dp[j] &#x3D; Math.min(dp[j], dp[i] + 1); if (j &#x3D;&#x3D; n - 1) break; &#125; &#125; return dp[n - 1]; &#125; &#125; 方法二：贪心# class Solution &#123; public int jump(int[] nums) &#123; int result = 0; int n = nums.length; int maxDistance = 0, end = 0; for (int i = 0; i &lt; n - 1; ++i) &#123; maxDistance = Math.max(maxDistance, i + nums[i]); if (i == end) &#123; end = maxDistance; ++result; &#125; &#125; return result; &#125; &#125; # 先创建一个小根堆，把数组所有元素都放进去 取反小根堆堆顶元素再放回小根堆，循环k次 时间复杂度：\\(O(n)\\) 空间复杂度：\\(O(n)\\) 如果小根堆堆顶是负数\\(x\\)，那么一定是最小的负数，取反后会是比较大的正数\\(-x\\)； 如果小根堆堆顶是正数\\(x\\)，那么是最小的正数，取反后是负数\\(-x\\)，由于此时只有这一个负数，所以\\(-x\\)是最小值，再放入堆顶，再取反又是最小的正数，循环到k为0为止。 class Solution &#123; public int largestSumAfterKNegations(int[] nums, int k) &#123; // 先创建一个小根堆，把数组所有元素都放进去 // 取反小根堆堆顶元素再放回小根堆，循环k次 PriorityQueue&lt;Integer> queue = new PriorityQueue&lt;>(); for (int n : nums) queue.offer(n); while (!queue.isEmpty() &amp;&amp; k > 0) &#123; int cur = queue.poll(); queue.offer(-1 * cur); --k; &#125; int sum = 0; while (!queue.isEmpty()) &#123; sum += queue.poll(); &#125; return sum; &#125; &#125; 方法二：优化方法一# 先创建一个小根堆，把数组所有元素都放进去 首先小根堆弹出的元素\\(x\\)如果是负数，就取反(最小的负数取反是比较大的正数),再放回小根堆 小根堆弹出的元素\\(x\\)如果是是正数：此时\\(k\\)值如果能被2整除，那么重复取反堆顶元素\\(x\\)，最终\\(x\\)不变，直接将\\(x\\)加入堆中；如果\\(k\\)值如果不能被2整除，那么将-x加入堆中 class Solution &#123; public int largestSumAfterKNegations(int[] nums, int k) &#123; // 先创建一个小根堆，把数组所有元素都放进去 // 要取反k次，首先小根堆弹出的元素x如果是负数，就取反(最小的负数取反是比较大的正数),再放回小根堆 // 小根堆弹出的元素x如果是是正数：此时k值如果能被2整除，那么重复取反堆顶元素x，最终x不变，直接将x加入堆中；如果k值如果不能被2整除，那么将-x加入堆中 PriorityQueue&lt;Integer> queue = new PriorityQueue&lt;>(); for (int n : nums) queue.offer(n); while (!queue.isEmpty() &amp;&amp; k > 0) &#123; int cur = queue.poll(); if (cur &lt; 0) &#123; queue.offer(-1 * cur); --k; &#125; else &#123; // cur >= 0 int negPart = k % 2 == 0 ? 1 : -1; queue.offer(cur * negPart); break; &#125; &#125; int sum = 0; while (!queue.isEmpty()) &#123; sum += queue.poll(); &#125; return sum; &#125; &#125; # 首先如果总油量减去总消耗大于等于零那么一定可以跑完一圈 class Solution &#123; public int canCompleteCircuit(int[] gas, int[] cost) &#123; int curSum = 0; int totalSum = 0; int index = 0; for (int i = 0; i &lt; gas.length; i++) &#123; curSum += gas[i] - cost[i]; totalSum += gas[i] - cost[i]; if (curSum &lt; 0) &#123; index = (i + 1) % gas.length ; curSum = 0; &#125; &#125; return (totalSum &lt; 0) ? -1 : index; &#125; &#125; # 先从左往右，再从右往左 class Solution &#123; public int candy(int[] ratings) &#123; int n = ratings.length; int[] candy = new int[n]; Arrays.fill(candy, 1); for (int i = 0; i &lt; n; ++i) &#123; if (i > 0 &amp;&amp; ratings[i] > ratings[i - 1]) &#123; candy[i] = candy[i - 1] + 1; &#125; &#125; for (int i = n - 1; i >= 0; --i) &#123; if (i &lt; n - 1 &amp;&amp; ratings[i] > ratings[i + 1]) &#123; candy[i] = Math.max(candy[i], candy[i + 1] + 1); &#125; &#125; return IntStream.of(candy).sum(); &#125; &#125; # class Solution &#123; public boolean lemonadeChange(int[] bills) &#123; if (bills[0] != 5) return false; int five = 0, ten = 0; for (int i = 0; i &lt; bills.length; ++i) &#123; if (bills[i] == 5) &#123; ++five; &#125; else if (bills[i] == 10) &#123; if (five > 0) &#123; --five; ++ten; &#125; else &#123; return false; &#125; &#125; else &#123; if (five > 0 &amp;&amp; ten > 0) &#123; --five; --ten; &#125; else if (five >= 3) &#123; five -= 3; &#125; else &#123; return false; &#125; &#125; &#125; return true; &#125; &#125; # class Solution &#123; public int[][] reconstructQueue(int[][] people) &#123; // 先按照身高进行降序排序，再按照k进行升序排序 Arrays.sort(people, new Comparator&lt;int[]>() &#123; public int compare(int[] person1, int[] person2) &#123; if (person1[0] != person2[0]) &#123; return person2[0] - person1[0]; &#125; else &#123; return person1[1] - person2[1]; &#125; &#125; &#125;); List&lt;int[]> list = new LinkedList&lt;>(); for (int[] person : people) &#123; list.add(person[1], person); &#125; return list.toArray(new int[list.size()][]); &#125; &#125; # 注意事项： compare方法用return p1[0] - p2[0]会越界！ 从左往右遍历，如果左边气球的右边界大于等于右边气球的左边界，那么可以一箭双球，此时有可能有第三个气球和前面两个气球有重合，但是把第一个气球的右边界设置为重合气球右边界的最小值 class Solution &#123; public int findMinArrowShots(int[][] points) &#123; Arrays.sort(points, new Comparator&lt;int[]>() &#123; public int compare(int[] p1, int[] p2) &#123; return p1[0] &lt; p2[0] ? -1 : 1; &#125; &#125;); int arrow = 1; for (int i = 0, j = 1; j &lt; points.length &amp;&amp; j &lt; points.length ; ++j) &#123; if (points[i][1] >= points[j][0]) &#123; points[i][1] = Math.min(points[i][1], points[j][1]); &#125; else &#123; ++arrow; i = j; &#125; &#125; return arrow; &#125; &#125; # 比较器按以下方法来，不然容易出错！！ Arrays.sort(intervals, new Comparator&lt;int[]>() &#123; public int compare(int[] p1, int[] p2) &#123; if (p1[0] == p2[0]) &#123; return Integer.compare(p1[1], p2[1]); &#125; else &#123; return Integer.compare(p1[0], p2[0]); &#125; &#125; &#125;); 先定义比较器，如果p1, p2第一个元素不相等，则按照第一个元素升序排序；如果第一个元素相等，则按照第二个元素升序排序 双指针从前往后遍历，初始i=0，j=1 当intervals[i]与intervals[j]的第一个元素相等，那么必定要移除其中一个，由于比较器的排序，intervals[j]的区间更大，那么选择移除intervals[j]，答案只需要返回最少移除了多少个数，所以将表示删除元素个数的变量erase加一，让j后移即可 当intervals[i]与intervals[j]的第一个元素不相等时候，分两种情况讨论 如果intervals[i]的第二个元素 &gt; intervals[j]的第一个元素，此时区间重合，将表示删除元素个数的变量erase加一；如果此时intervals[i]的第二个元素 &gt; intervals[j]的第二个元素，说明intervals[i]包含 intervals[j]，那么此时必定删除 intervals[i]，将i指向j表示删除 intervals[i]这个元素 如果intervals[i]的第二个元素 &lt;= intervals[j]的第一个元素，那么i与j之间的元素都不重复，将i移动到j的位置 class Solution &#123; public int eraseOverlapIntervals(int[][] intervals) &#123; Arrays.sort(intervals, new Comparator&lt;int[]>() &#123; public int compare(int[] p1, int[] p2) &#123; if (p1[0] == p2[0]) &#123; return Integer.compare(p1[1], p2[1]); &#125; else &#123; return Integer.compare(p1[0], p2[0]); &#125; &#125; &#125;); int erase = 0, n = intervals.length; for (int i = 0, j = 1; j &lt; n; ++j) &#123; if (intervals[i][0] == intervals[j][0]) &#123; ++erase; &#125; else &#123; if (intervals[i][1] > intervals[j][0]) &#123; ++erase; if (intervals[i][1] >= intervals[j][1]) &#123; i = j; &#125; &#125; else &#123; // intervals[i][1] &lt;= intervals[j][0] i = j; &#125; &#125; &#125; return erase; &#125; &#125; 方法二：右边界取最小的# class Solution &#123; public int eraseOverlapIntervals(int[][] intervals) &#123; Arrays.sort(intervals, (a,b)-> &#123; return Integer.compare(a[0],b[0]); &#125;); int count = 0; for(int i = 1;i &lt; intervals.length;i++)&#123; if(intervals[i][0] &lt; intervals[i-1][1])&#123; ++count; intervals[i][1] = Math.min(intervals[i - 1][1], intervals[i][1]); &#125; &#125; for (int[] is : intervals) &#123; for (int i : is) &#123; System.out.print(i + \",\"); &#125; System.out.println(); &#125; return count; &#125; &#125; # 方法一：贪心# 首先创建一个长度为26的整型数组，统计每次字符出现的最远位置 遍历字符串，不断更新右边界的值 当当前下标i与右边界相等时，那么就将right-i+1记录 class Solution &#123; public List&lt;Integer> partitionLabels(String s) &#123; int[] ch = new int[26]; for (int i = 0; i &lt; s.length(); ++i) &#123; ch[s.charAt(i) - 'a'] = i; &#125; List&lt;Integer> res = new LinkedList&lt;>(); int left = 0, right = -1; for (int i = 0; i &lt; s.length(); ++i) &#123; right = Math.max(right, ch[s.charAt(i) - 'a']); if (i == right) &#123; res.add(right - left + 1); left = i + 1; &#125; &#125; return res; &#125; &#125; # 遍历数组，如果后一个元素的左边界大于等于前一个元素的右边界，那么修改后一个元素的左边界为两元素左边界最小的值，修改后一个元素的右边界为两元素右边界最大的值 如果后一个元素左边界大于前一个元素的右边界，直接把前一个元素加入结果list中 最后再把最后一个元素(修改过)加入结果list中 class Solution &#123; public int[][] merge(int[][] intervals) &#123; int n = intervals.length; Arrays.sort(intervals, new Comparator&lt;int[]>() &#123; public int compare(int[] p1, int[] p2) &#123; return Integer.compare(p1[0], p2[0]); &#125; &#125;); List&lt;int[]> res = new LinkedList&lt;>(); for (int i = 0; i &lt; n - 1; ++i) &#123; if (intervals[i + 1][0] &lt;= intervals[i][1]) &#123; intervals[i + 1][0] = Math.min(intervals[i + 1][0], intervals[i][0]); intervals[i + 1][1] = Math.max(intervals[i + 1][1], intervals[i][1]); &#125; else &#123; res.add(new int[]&#123;intervals[i][0], intervals[i][1]&#125;); &#125; &#125; res.add(new int[]&#123;intervals[n - 1][0], intervals[n - 1][1]&#125;); return res.toArray(new int[res.size()][]); &#125; &#125; # 从后往前遍历 注意边界！！！ class Solution &#123; public int monotoneIncreasingDigits(int n) &#123; String s = String.valueOf(n); char[] ch = s.toCharArray(); int length = ch.length; int start = length; for (int i = length - 2; i >= 0; --i) &#123; if (ch[i + 1] &lt; ch[i]) &#123; start = i + 1; --ch[i]; &#125; &#125; for (int i = start; i &lt; length; ++i) &#123; ch[i] = '9'; &#125; return Integer.parseInt(String.valueOf(ch)); &#125; &#125; # 方法一：贪心# class Solution &#123; int result = 0; public int minCameraCover(TreeNode root) &#123; // dfs后检查根节点是否被覆盖 if (dfs(root) == 404) ++result; return result; &#125; private int dfs(TreeNode root) &#123; // state 404:未覆盖 // state 200:覆盖 // state 201:有监控 //叶节点的左右空孩子需要返回被覆盖，这样才不会在叶子节点上装监控 if (root == null) return 200; // post traversal int leftState = dfs(root.left); int rightState = dfs(root.right); // 1.如果左右子树都被覆盖 if (leftState == 200 &amp;&amp; rightState == 200) return 404; // 2.如果左右子树至少有一个没被覆盖 if (leftState == 404 || rightState == 404) &#123; ++result; return 201; &#125; // 3.如果左右子树至少有一个监控 if (leftState == 201 || rightState == 201) return 200; return 666; &#125; &#125; BackTracing# 开始回溯前要知道的# 详细讲解 image.png 注意# 如果递归终止条件是这个，那么结果回事全空 if (depth == len) &#123; res.add(path); return; &#125; 执行 main 方法以后输出如下： [[], [], [], [], [], []] 变量 path 所指向的列表 在深度优先遍历的过程中只有一份 ，深度优先遍历完成以后，回到了根结点，成为空列表。 在 Java 中，参数传递是 值传递，对象类型变量在传参的过程中，复制的是变量的地址。这些地址被添加到 res 变量，但实际上指向的是同一块内存地址，因此我们会看到 6 个空的列表对象。解决的方法很简单，在 res.add(path); 这里做一次拷贝即可。 修改的部分： if (depth == len) &#123; res.add(new ArrayList&lt;>(path)); return; &#125; 算法模板# void backtracking(参数) &#123; if (终止条件) &#123; 存放结果; return; &#125; for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123; 处理节点; backtracking(路径，选择列表); &#x2F;&#x2F; 递归 回溯，撤销处理结果 &#125; &#125; # 方法一：回溯# 由于已知结果要存放的数组大小为k，所以res使用ArrayList List没有removeLast方法，但是LinkedList中有！ class Solution &#123; List&lt;List&lt;Integer>> res = new ArrayList&lt;>(); LinkedList&lt;Integer> path = new LinkedList&lt;>(); public List&lt;List&lt;Integer>> combine(int n, int k) &#123; backtracing(n, k, 1); return res; &#125; private void backtracing (int n, int k, int start) &#123; if (path.size() == k) &#123; res.add(new LinkedList&lt;>(path)); return; &#125; for (int i = start; i &lt;= n; ++i) &#123; path.add(i); backtracing(n, k, i + 1); // path.removeLast(); path.removeLast(); &#125; &#125; &#125; 方法二：方法一+剪枝# for循环横向遍历时候，i的执行条件为i &lt;= n - (k - path.size()) + 1 例如，当i = 2，path里已经有1，需要组合k=3个元素，n为4，那么 4 - (3 - 1) + 1 = 3，说明i最多等于3，组成path[1, 3, 4]，如果此时i = 4，那么就不能组成3个元素，只能组成[1,4] class Solution &#123; List&lt;List&lt;Integer>> res = new ArrayList&lt;>(); LinkedList&lt;Integer> path = new LinkedList&lt;>(); public List&lt;List&lt;Integer>> combine(int n, int k) &#123; backtracing(n, k, 1); return res; &#125; private void backtracing (int n, int k, int start) &#123; if (path.size() == k) &#123; res.add(new LinkedList&lt;>(path)); return; &#125; for (int i = start; i &lt;= n - (k - path.size()) + 1; ++i) &#123; path.add(i); backtracing(n, k, i + 1); // path.removeLast(); path.removeLast(); &#125; &#125; &#125; 方法二：选或不选# 防止底层扩容 Deque&lt;Integer> path = new ArrayDeque&lt;>(k); 若n=3，k=2,即从[1,2,3]中选两个数，如果当前什么都没选(k=2)，n - k + 1= 2，说明至少要从2开始，才能满足选两个数这个要求 int bound = n - k + 1; if (start > bound) return; 代码如下 class Solution &#123; List&lt;List&lt;Integer>> res = new LinkedList&lt;>(); public List&lt;List&lt;Integer>> combine(int n, int k) &#123; // 防止底层扩容 Deque&lt;Integer> path = new ArrayDeque&lt;>(k); backtracking(path, n, k, 1); return res; &#125; private void backtracking(Deque&lt;Integer> path, int n, int k, int start) &#123; if (k == 0) &#123; res.add(new LinkedList&lt;>(path)); return; &#125; // 若n=3，k=2,即从[1,2,3]中选两个数，如果当前什么都没选(k=2)，n - k + 1= 2， // 说明至少要从2开始，才能满足选两个数这个要求 int bound = n - k + 1; if (start > bound) return; backtracking(path, n, k, start + 1); path.addLast(start); backtracking(path, n, k - 1, start + 1); path.removeLast(); &#125; &#125; # 方法一：回溯+剪枝# i那里的剪枝可以这么理解，假设从i开始取，则从i到n一共有n-i+1个元素，而当前还需要k-path.size()个元素，所以必须满足n-i+1&gt;=k-path.size()，移项就可以得到i&lt;=n+1-(k-path.size()) class Solution &#123; List&lt;List&lt;Integer>> res = new LinkedList&lt;>(); public List&lt;List&lt;Integer>> combinationSum3(int k, int n) &#123; backtracking(k, n, 1, new ArrayDeque&lt;>(k)); return res; &#125; private void backtracking(int k, int n, int start, Deque&lt;Integer> path) &#123; if (path.size() == k) &#123; if (n == 0) res.add(new LinkedList&lt;>(path)); return; &#125; for (int i = start; i &lt;= 9 - (k - path.size()) + 1; ++i) &#123; path.add(i); backtracking(k, n - i, i + 1, path); path.removeLast(); &#125; &#125; &#125; 方法二：选或不选# 注意：int bound = 9 - k + 1;而不是9 - (k - path.size()) + 1，因为这里的递归终止条件是k==0，==k的语义是还剩多少元素没选！！！== class Solution &#123; List&lt;List&lt;Integer>> res = new LinkedList&lt;>(); public List&lt;List&lt;Integer>> combinationSum3(int k, int n) &#123; backtracking(k, n, 1, new ArrayDeque&lt;>(k)); return res; &#125; private void backtracking(int k, int n, int start, Deque&lt;Integer> path) &#123; if (k == 0) &#123; if (n == 0) res.add(new LinkedList&lt;>(path)); return; &#125; int bound = 9 - k + 1; if (start > bound) return; backtracking(k, n, start + 1, path); path.add(start); backtracking(k - 1, n - start, start + 1, path); path.removeLast(); &#125; &#125; # 注意边界条件！ class Solution &#123; List&lt;String> res = new LinkedList&lt;>(); StringBuilder path = new StringBuilder(); String[] alphabet = &#123;\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"&#125;; public List&lt;String> letterCombinations(String digits) &#123; if (digits == null || digits.length() == 0) return res; backtracing(digits, 0); return res; &#125; private void backtracing(String digits, int start) &#123; if (path.length() == digits.length()) &#123; res.add(new String(path)); return; &#125; char num = digits.charAt(start); String str = alphabet[num - '0']; for (int i = 0; i &lt; str.length(); ++i) &#123; path.append(str.charAt(i)); backtracing(digits, start + 1); path.deleteCharAt(path.length() - 1); &#125; &#125; &#125; # 与前面两题不同的是，可以选取相同元素；以及组合不能重复，如[3，5]与[5，3]是同一个组合 同一个 数字可以 无限制重复被选取 解析 方法一：回溯# 去重：遇到这一类相同元素不计算顺序的问题，我们在搜索的时候就需要 按某种顺序搜索。具体的做法是：每一次搜索的时候设置 下一轮搜索的起点 begin，请看下图。 img class Solution &#123; List&lt;List&lt;Integer>> res = new LinkedList&lt;>(); LinkedList&lt;Integer> path = new LinkedList&lt;>(); public List&lt;List&lt;Integer>> combinationSum(int[] candidates, int target) &#123; backtracing(candidates, target, 0); return res; &#125; private void backtracing(int[] candidates, int target, int start) &#123; if (target &lt; 0) return; if (target == 0) &#123; res.add(new LinkedList&lt;>(path)); return; &#125; for (int i = start; i &lt; candidates.length; ++i) &#123; path.add(candidates[i]); backtracing(candidates, target - candidates[i], i); path.removeLast(); &#125; &#125; &#125; 方法二：回溯+剪枝# 注意： 是i不是start！！！ 回溯前要排序！！！ class Solution &#123; List&lt;List&lt;Integer>> res = new LinkedList&lt;>(); LinkedList&lt;Integer> path = new LinkedList&lt;>(); public List&lt;List&lt;Integer>> combinationSum(int[] candidates, int target) &#123; // 排序是剪枝的前提 Arrays.sort(candidates); backtracing(candidates, target, 0); return res; &#125; private void backtracing(int[] candidates, int target, int start) &#123; if (target == 0) &#123; res.add(new LinkedList&lt;>(path)); return; &#125; for (int i = start; i &lt; candidates.length; ++i) &#123; // 由于进入更深层的时候，小于 0 的部分被剪枝，因此递归终止条件值只判断等于 0 的情况 if (target - candidates[i] &lt; 0) break; path.add(candidates[i]); backtracing(candidates, target - candidates[i], i); path.removeLast(); &#125; &#125; &#125; # 去重和39题(上一题)以及三数之和差不多 这个避免重复当思想是在是太重要了。 这个方法最重要的作用是，可以让同一层级，不出现相同的元素。即 1 &#x2F; \\ 2 2 这种情况不会发生 但是却允许了不同层级之间的重复即： &#x2F; \\ 5 5 例2 1 &#x2F; 2 这种情况确是允许的 &#x2F; 2 为何会有这种神奇的效果呢？ 首先 cur-1 &#x3D;&#x3D; cur 是用于判定当前元素是否和之前元素相同的语句。这个语句就能砍掉例1。 可是问题来了，如果把所有当前与之前一个元素相同的都砍掉，那么例二的情况也会消失。 因为当第二个2出现的时候，他就和前一个2相同了。 那么如何保留例2呢？ 那么就用cur &gt; begin 来避免这种情况，你发现例1中的两个2是处在同一个层级上的， 例2的两个2是处在不同层级上的。 在一个for循环中，所有被遍历到的数都是属于一个层级的。我们要让一个层级中， 必须出现且只出现一个2，那么就放过第一个出现重复的2，但不放过后面出现的2。 第一个出现的2的特点就是 cur &#x3D;&#x3D; begin. 第二个出现的2 特点是cur &gt; begin. class Solution &#123; List&lt;List&lt;Integer>> res = new LinkedList&lt;>(); LinkedList&lt;Integer> path = new LinkedList&lt;>(); public List&lt;List&lt;Integer>> combinationSum2(int[] candidates, int target) &#123; Arrays.sort(candidates); backtracing(candidates, target, 0); return res; &#125; private void backtracing(int[] candidates, int target, int start) &#123; if (target == 0) &#123; res.add(new LinkedList&lt;>(path)); return; &#125; for (int i = start; i &lt; candidates.length; ++i) &#123; // 剪枝 if (candidates[i] > target) break; // 去重 if (i > start &amp;&amp; candidates[i] == candidates[i - 1]) continue; path.add(candidates[i]); backtracing(candidates, target - candidates[i], i + 1); path.removeLast(); &#125; &#125; &#125; :warning:# class Solution &#123; List&lt;List&lt;String>> res = new LinkedList&lt;>(); Deque&lt;String> path = new LinkedList&lt;>(); public List&lt;List&lt;String>> partition(String s) &#123; backtracking(s.toCharArray(), 0); return res; &#125; public void backtracking(char[] ch, int start) &#123; if (start == ch.length) &#123; res.add(new LinkedList(path)); return; &#125; for (int i = start; i &lt; ch.length; ++i) &#123; if (isPalindrome(ch, start, i)) &#123; path.add(new String(ch, start, i - start + 1)); backtracking(ch, i + 1); path.removeLast(); &#125; &#125; &#125; public boolean isPalindrome(char[] ch, int start, int end) &#123; while (start &lt; end) &#123; if (ch[start++] != ch[end--]) return false; &#125; return true; &#125; &#125; :star:# 重做 方法一：回溯# # 以下两种方法的区别： 方法二有横向for循环，使用i进入递归方法 方法一有两个递归方法，分别表示选与不选，用start进入递归犯法 方法一：选或不选# class Solution &#123; List&lt;List&lt;Integer>> res = new LinkedList&lt;>(); Deque&lt;Integer> path = new LinkedList&lt;>(); public List&lt;List&lt;Integer>> subsets(int[] nums) &#123; backtracking(nums, 0); return res; &#125; private void backtracking(int[] nums, int start) &#123; if (start == nums.length) &#123; res.add(new LinkedList(path)); return; &#125; backtracking(nums, start + 1); path.add(nums[start]); backtracking(nums, start + 1); path.removeLast(); &#125; &#125; 方法二：for循环横向顺序遍历# class Solution &#123; List&lt;List&lt;Integer>> res = new LinkedList&lt;>(); Deque&lt;Integer> path = new LinkedList&lt;>(); public List&lt;List&lt;Integer>> subsets(int[] nums) &#123; backtracking(nums, 0); return res; &#125; private void backtracking(int[] nums, int start) &#123; res.add(new LinkedList(path)); for (int i = start; i &lt; nums.length; i++) &#123; path.add(nums[i]); backtracking(nums, i + 1); path.removeLast(); &#125; &#125; &#125; # tips# 新建数组时赋值# int[] array = new int[]{3, 4}；","categories":[],"tags":[]}],"categories":[],"tags":[]}