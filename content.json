{"meta":{"title":"Leopold's Blog","subtitle":"Algorithms","description":"For offers","author":"Leopold","url":"https://leopol1d.github.io","root":"/"},"pages":[{"title":"","date":"2023-05-23T10:05:13.718Z","updated":"2023-05-23T10:05:13.718Z","comments":false,"path":"css/fluid-extension.css","permalink":"https://leopol1d.github.io/css/fluid-extension.css","excerpt":"","text":"::-webkit-scrollbar { width: 8px; height: 8px; } ::-webkit-scrollbar-track { border-radius: 4px; background-color: rgba(255, 255, 255, .1); } ::-webkit-scrollbar-thumb { border-radius: 4px; background-color: rgba(0, 120, 231, .5); } ::-webkit-scrollbar-thumb:window-inactive { background-color: rgba(0, 120, 231, .3) } ::-webkit-scrollbar-thumb:hover { background-color: rgba(0, 120, 231, .7) } ::-webkit-scrollbar-thumb:active { background-color: rgba(0, 120, 231, .9) } figure.highlight { background: #FFFFFF; border-radius: 5px; box-shadow: 0 4px 7px 0 rgba(0, 0, 0, .4); padding-top: 30px } figure.highlight::before { background: #fc625d; border-radius: 50%; box-shadow: 20px 0 #fdbc40, 40px 0 #35cd4b; content: ' '; height: 12px; left: 12px; margin-top: -20px; position: absolute; width: 12px; } .table-container { overflow: auto; margin-bottom: 16px; } /* Avoid affecting the style of codeblock */ .markdown-body .table-container table { display: table !important; margin-bottom: 0 !important; } #navbar { -webkit-backdrop-filter: blur(3px); backdrop-filter: blur(3px); } div.dropdown-menu { min-width: inherit !important; text-align: center !important; background-color: var(--navbar-bg-color) !important; right: 0; left: initial !important; box-shadow: 0 4px 7px 0 rgba(0, 0, 0, .5); -webkit-animation: sub_menus .3s .1s ease both; -moz-animation: sub_menus .3s .1s ease both; -o-animation: sub_menus .3s .1s ease both; -ms-animation: sub_menus .3s .1s ease both; animation: sub_menus .3s .1s ease both; } @-moz-keyframes sub_menus { 0% { opacity: 0; -webkit-transform: translateY(10px); -moz-transform: translateY(10px); -o-transform: translateY(10px); -ms-transform: translateY(10px); transform: translateY(10px); } 100% { opacity: 1; -webkit-transform: translateY(0); -moz-transform: translateY(0); -o-transform: translateY(0); -ms-transform: translateY(0); transform: translateY(0); } } @-webkit-keyframes sub_menus { 0% { opacity: 0; -webkit-transform: translateY(10px); -moz-transform: translateY(10px); -o-transform: translateY(10px); -ms-transform: translateY(10px); transform: translateY(10px); } 100% { opacity: 1; -webkit-transform: translateY(0); -moz-transform: translateY(0); -o-transform: translateY(0); -ms-transform: translateY(0); transform: translateY(0); } } @-o-keyframes sub_menus { 0% { opacity: 0; -webkit-transform: translateY(10px); -moz-transform: translateY(10px); -o-transform: translateY(10px); -ms-transform: translateY(10px); transform: translateY(10px); } 100% { opacity: 1; -webkit-transform: translateY(0); -moz-transform: translateY(0); -o-transform: translateY(0); -ms-transform: translateY(0); transform: translateY(0); } } @keyframes sub_menus { 0% { opacity: 0; -webkit-transform: translateY(10px); -moz-transform: translateY(10px); -o-transform: translateY(10px); -ms-transform: translateY(10px); transform: translateY(10px); } 100% { opacity: 1; -webkit-transform: translateY(0); -moz-transform: translateY(0); -o-transform: translateY(0); -ms-transform: translateY(0); transform: translateY(0); } } /* 代码和表格设置最大高度，高度或宽度超出都不会显示在页面中，可以通过滚动条查看 */ table { padding: 0; word-break: initial; overflow-x: auto; max-height: 44em; overflow-y: auto !important; }"},{"title":"tags~","date":"2023-05-20T07:00:53.000Z","updated":"2023-05-20T07:05:43.906Z","comments":false,"path":"tags/index.html","permalink":"https://leopol1d.github.io/tags/index.html","excerpt":"","text":""},{"title":"标题","date":"2023-05-21T03:11:41.458Z","updated":"2023-05-21T03:11:41.458Z","comments":false,"path":"about/index.html","permalink":"https://leopol1d.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"Dynamic Programming","slug":"dynamic-programming","date":"2023-05-24T02:32:30.724Z","updated":"2023-05-24T11:07:09.318Z","comments":true,"path":"2023/05/24/dynamic-programming/","link":"","permalink":"https://leopol1d.github.io/2023/05/24/dynamic-programming/","excerpt":"","text":"自顶向下的动态规划——记忆化搜索 记忆化搜索好解决不常见状态转移方程的dp问题 198. 打家劫舍 方法一：DP 1234567891011121314151617class Solution &#123; public int rob(int[] nums) &#123; // 1.dp[j]: 到达标号为j的房屋可获得的最大价值 // 2.状态转移：dp[j] = max(dp[j - 1], dp[j - 2] + nums[j]) // 3.初始化：dp[0] = nums[0], dp[1] = max(nums[0], nums[1]) // 4.遍历顺序：从前往后 int[] dp = new int[nums.length]; dp[0] = nums[0]; if (nums.length == 1) return nums[0]; dp[1] = Math.max(nums[0], nums[1]); for (int i = 2; i &lt; nums.length; ++i) &#123; dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]); &#125; return dp[nums.length - 1]; &#125;&#125; 方法二：DP + 滚动数组 由状态转移方程可以看出，dp[i]由前面两个状态得出，所以dp数组的长度只需要为3 1234567891011121314151617class Solution &#123; public int rob(int[] nums) &#123; // 1.dp[j]: 到达标号为j的房屋可获得的最大价值 // 2.状态转移：dp[j] = max(dp[j - 1], dp[j - 2] + nums[j]) // 3.初始化：dp[0] = nums[0], dp[1] = max(nums[0], nums[1]) // 4.遍历顺序：从前往后 if (nums.length == 1) return nums[0]; int[] dp = new int[3]; dp[0] = nums[0]; dp[1] = Math.max(nums[0], nums[1]); for (int i = 2; i &lt; nums.length; ++i) &#123; dp[i % 3] = Math.max(dp[(i - 1) % 3], dp[(i - 2) % 3] + nums[i]); &#125; return dp[(nums.length - 1) % 3]; &#125;&#125; 方法三：记忆化搜索 自顶向下，举个例子nums=[1,2,3,1] 返回的答案为dfs(3, nums) 要求，需要知道dfs(3-1,nums)与dfs(3-2,nums)+nums[3]，然后取最大值 求dfs(2,nums)，需要知道dfs(2-1,nums)与dfs(2-2,nums)+nums[2]，然后取最大值 ....... 1234567891011121314151617181920public class Solution &#123; int[] dp; public int rob(int[] nums) &#123; dp = new int[nums.length]; Arrays.fill(dp, -1); return dfs(nums.length - 1, nums); &#125; private int dfs(int index, int[] nums) &#123; if (index &lt; 0) return 0; if (dp[index] != -1) return dp[index];// int dont = dfs(index - 1, nums);// int steal = dfs(index - 2, nums) + nums[index];// return dp[index] = Math.max(dont, steal); return dp[index] = Math.max(dfs(index - 1, nums), dfs(index - 2, nums) + nums[index]); &#125;&#125; 213. 打家劫舍 II 方法一：DP 12345678910111213141516171819class Solution &#123; public int rob(int[] nums) &#123; if (nums.length == 1) return nums[0]; if (nums.length == 2) return Math.max(nums[0], nums[1]); return Math.max(process(nums, 0, nums.length - 1), process(nums, 1, nums.length)); &#125; private int process(int[] nums, int start, int end) &#123; int[] dp = new int[end - start]; dp[0] = nums[start]; dp[1] = Math.max(nums[start], nums[start + 1]); for (int i = 2; i &lt; end - start; ++i) &#123; dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i + start]); &#125; return dp[end - start - 1]; &#125;&#125; 方法二：DP + 滚动数组 12345678910111213141516171819class Solution &#123; public int rob(int[] nums) &#123; if (nums.length == 1) return nums[0]; if (nums.length == 2) return Math.max(nums[0], nums[1]); return Math.max(process(nums, 0, nums.length - 1), process(nums, 1, nums.length)); &#125; private int process(int[] nums, int start, int end) &#123; int[] dp = new int[3]; dp[0] = nums[start]; dp[1] = Math.max(nums[start], nums[start + 1]); for (int i = 2; i &lt; end - start; ++i) &#123; dp[i % 3] = Math.max(dp[(i - 1) % 3], dp[(i - 2) % 3] + nums[i + start]); &#125; return dp[(end - start - 1) % 3]; &#125;&#125; 方法三：记忆化搜索 1234567891011121314151617181920212223class Solution &#123; int[] dp; public int rob(int[] nums) &#123; if (nums.length == 1) return nums[0]; if (nums.length == 2) return Math.max(nums[0], nums[1]); dp = new int[nums.length]; Arrays.fill(dp, -1); int res1 = dfs(nums, 0, nums.length - 2); Arrays.fill(dp, -1); int res2 = dfs(nums, 1, nums.length - 1); return Math.max(res1, res2); &#125; private int dfs(int[] nums, int start, int index) &#123; if (index &lt; start) return 0; if (dp[index] != -1) return dp[index]; return dp[index] = Math.max(dfs(nums, start, index - 1), dfs(nums, start, index - 2) + nums[index]); &#125;&#125; 337. 打家劫舍 III 方法一：DP 1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; // steal: 偷当前节点能获得的最大金额 // pass: 不偷当前节点能获得的最大金额 // steal(cur) = cur.val + pass(cur.left) + pass(cur.right) // pass(cur) = max(steal(cur.left), pass(steal.right)) + max(steal(cur.right), pass(steal.right)) Map&lt;TreeNode, Integer&gt; steal = new HashMap&lt;&gt;(); Map&lt;TreeNode, Integer&gt; pass = new HashMap&lt;&gt;(); public int rob(TreeNode root) &#123; dfs(root); return Math.max(steal.getOrDefault(root, 0), pass.getOrDefault(root, 0)); &#125; public void dfs(TreeNode root) &#123; if (root == null) return; dfs(root.left); dfs(root.right); steal.put(root, root.val + pass.getOrDefault(root.left, 0) + pass.getOrDefault(root.right, 0)); pass.put(root, Math.max(steal.getOrDefault(root.left, 0), pass.getOrDefault(root.left, 0)) + Math.max(steal.getOrDefault(root.right, 0), pass.getOrDefault(root.right, 0))); &#125;&#125; 方法二：记忆化搜索 1234567891011121314151617181920212223242526272829class Solution &#123; // steal: 偷当前节点能获得的最大金额 // pass: 不偷当前节点能获得的最大金额 // steal(cur) = cur.val + pass(cur.left) + pass(cur.right) // pass(cur) = max(steal(cur.left), pass(steal.right)) + max(steal(cur.right), pass(steal.right)) Map&lt;TreeNode, Integer&gt; steal = new HashMap&lt;&gt;(); Map&lt;TreeNode, Integer&gt; pass = new HashMap&lt;&gt;(); public int rob(TreeNode root) &#123; int steal = dfs(root, 0); int pass = dfs(root, 1); return Math.max(steal, pass); &#125; public int dfs(TreeNode root, int flag) &#123; if (root == null) return 0; if (flag == 1 &amp;&amp; pass.get(root) != null) &#123; return pass.get(root); &#125; else if (flag == 0 &amp;&amp; steal.get(root) != null) &#123; return steal.get(root); &#125; steal.put(root, root.val + pass.getOrDefault(root.left, dfs(root.left, 1)) + pass.getOrDefault(root.right, dfs(root.right, 1))); pass.put(root, Math.max(steal.getOrDefault(root.left, dfs(root.left, 0)), pass.getOrDefault(root.left, dfs(root.left, 1))) + Math.max(steal.getOrDefault(root.right, dfs(root.right, 0)), pass.getOrDefault(root.right, dfs(root.right, 1)))); if (flag == 0) return steal.getOrDefault(root, 0); else return pass.getOrDefault(root, 0); &#125;&#125; 494. 目标和 方法一：01背包 12345678910111213141516171819class Solution &#123; public int findTargetSumWays(int[] nums, int target) &#123; int sum = Arrays.stream(nums).sum(); int diff = sum - target; if (diff % 2 == 1 || diff &lt; 0) return 0; target = diff / 2; // dp[j]:装满容量为j的方法数 // dp[0] = 1,装满容量为0的背包有一种 int[] dp = new int[target + 1]; dp[0] = 1; for (int i = 0; i &lt; nums.length; ++i) &#123; for (int j = target; j &gt;= nums[i]; --j) &#123; dp[j] += dp[j - nums[i]]; &#125; &#125; return dp[target]; &#125;&#125; 方法二：回溯 使用sum，对sum作加操作，相当于对target作减操作 1234567891011121314151617class Solution &#123; int res = 0; public int findTargetSumWays(int[] nums, int target) &#123; backtracking(nums, target, 0); return res; &#125; private void backtracking(int[] nums, int target, int start) &#123; if (start == nums.length) &#123; if (target == 0) ++res; return; &#125; backtracking(nums, target + nums[start], start + 1); backtracking(nums, target - nums[start], start + 1); &#125;&#125; 方法三：回溯的另一种写法 123456789101112class Solution &#123; public int findTargetSumWays(int[] nums, int target) &#123; return dfs(nums, target, 0, 0); &#125; private int dfs(int[] nums, int target, int start, int sum) &#123; if (start == nums.length) &#123; return target == sum ? 1 : 0; &#125; return dfs(nums, target, start + 1, sum - nums[start]) + dfs(nums, target, start + 1, sum + nums[start]); &#125;&#125; 方法四：记忆化搜索 相比回溯，使用数组记录已经计算过的结果，return前先赋值给数组memo 每次遍历时，首先检查memo中是否已经有结果(已经计算过了)，有结果直接返回结果 123456789101112131415161718class Solution &#123; int[][] memo; public int findTargetSumWays(int[] nums, int target) &#123; memo = new int[nums.length][2001]; for (int[] m : memo) Arrays.fill(m, -1); return dfs(nums, target, nums.length - 1, 0); &#125; private int dfs(int[] nums, int target, int start, int sum) &#123; if (start &lt; 0) &#123; return target == sum ? 1 : 0; &#125; if (memo[start][sum + 1000] != -1) return memo[start][sum + 1000]; return memo[start][sum + 1000] = dfs(nums, target, start - 1, sum - nums[start]) + dfs(nums, target, start - 1, sum + nums[start]); &#125;&#125; 64. 最小路径和 方法一：回溯超时 12345678910111213141516171819202122232425class Solution &#123; int[][] dirs = new int[][]&#123; &#123;1, 0&#125;, &#123;0, 1&#125;&#125;; int res = Integer.MAX_VALUE; public int minPathSum(int[][] grid) &#123; int m = grid.length, n = grid[0].length; dfs(grid, m, n, 0, 0, grid[m - 1][n - 1]); // 最后一次答案没有计算，所以在遍历前加上 return res; &#125; private void dfs(int[][] grid, int m, int n, int i, int j, int sum) &#123; if(i == m - 1 &amp;&amp; j == n - 1) &#123; res = Math.min(res, sum); return; &#125; sum += grid[i][j]; if (isValid(i + 1, j, m, n)) dfs(grid, m, n, i + 1, j, sum); if (isValid(i, j + 1, m, n)) dfs(grid, m, n, i, j + 1, sum); &#125; private boolean isValid(int row, int col, int m, int n) &#123; return row &gt;= 0 &amp;&amp; col &gt;= 0 &amp;&amp; row &lt; m &amp;&amp; col &lt; n; &#125;&#125; 方法二：记忆化搜索 1234567891011121314151617181920212223242526class Solution &#123; int res = Integer.MAX_VALUE; int dp[][]; public int minPathSum(int[][] grid) &#123; int m = grid.length, n = grid[0].length; // dp[i][j]:grid[i][j]到右下角的最小距离 dp = new int[m][n]; for (int[] arr : dp) Arrays.fill(arr, -1); return dfs(grid, m - 1, n - 1); &#125; private int dfs(int[][] grid, int i, int j) &#123; if (i == 0 &amp;&amp; j == 0) return grid[0][0]; if (i &lt; 0 || j &lt; 0) return 8000000; if (dp[i][j] != -1) return dp[i][j]; return dp[i][j] = grid[i][j] + Math.min(dfs(grid, i - 1, j), dfs(grid, i, j - 1)); &#125; private boolean isValid(int row, int col) &#123; return row &gt;= 0 &amp;&amp; col &gt;= 0; &#125;&#125; 62. 不同路径 方法一：记忆化搜索 12345678910111213141516171819class Solution &#123; int[][] dp; public int uniquePaths(int m, int n) &#123; dp = new int[m + 1][n + 1]; for (int[] arr : dp) Arrays.fill(arr, -1); return dfs(m, n); &#125; private int dfs(int i, int j) &#123; if (i == 1 &amp;&amp; j == 1) return 1; if (i &lt; 1 || j &lt; 1) return 0; if (dp[i][j] != -1) return dp[i][j]; return dp[i][j] = dfs(i - 1, j) + dfs(i, j - 1); &#125;&#125; 63. 不同路径 II 方法一：记忆化搜索 obstacleGrid[i][j] == 1的判断要在if (i == 0 &amp;&amp; j == 0)上面，不然会报如下错 1234567891011121314151617181920class Solution &#123; int[][] dp; public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123; int m = obstacleGrid.length, n = obstacleGrid[0].length; dp = new int[m][n]; for (int[] arr : dp) Arrays.fill(arr, -1); return dfs(obstacleGrid, m - 1, n - 1); &#125; private int dfs(int[][] obstacleGrid, int i, int j) &#123; if (i &lt; 0 || j &lt; 0 || obstacleGrid[i][j] == 1) return 0; if (i == 0 &amp;&amp; j == 0) return 1; if (dp[i][j] != -1) return dp[i][j]; return dp[i][j] = dfs(obstacleGrid,i - 1, j) + dfs(obstacleGrid, i, j - 1); &#125;&#125; 自底向上的动态规划","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://leopol1d.github.io/categories/Algorithms/"},{"name":"dynamic programming","slug":"Algorithms/dynamic-programming","permalink":"https://leopol1d.github.io/categories/Algorithms/dynamic-programming/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://leopol1d.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"Backtracking","slug":"backtracking","date":"2023-05-20T05:46:51.857Z","updated":"2023-05-24T02:25:39.259Z","comments":true,"path":"2023/05/20/backtracking/","link":"","permalink":"https://leopol1d.github.io/2023/05/20/backtracking/","excerpt":"","text":"Backtracking 93. 复原 IP 地址 解题思路：加“.”分割字符串 注意：isValid()中，如果得到的子串str为空，说明字符串s已经有三个“.”分割，并且最后一个点在最后一个位置，比如101.0.23.， s = s.substring(0, i + 1) + \".\" + s.substring(i + 1);得到字符串s = 101.0.23. ++pointNum; 进入下一轮backtracking(s, i + 2, pointNum); i + 2为.后面一位9 此时pointNum == 3，判断ip是否合法if (isValid(s, start, s.length() - 1)) String str = s.substring(start, end + 1); 此时start为9，end + 1为9，String.subString左闭右开，所以得到的str为空 这种情况返回false 123456789101112131415161718192021222324252627282930313233343536class Solution &#123; List&lt;String&gt; res = new LinkedList&lt;&gt;(); public List&lt;String&gt; restoreIpAddresses(String s) &#123; if (s.length() &gt; 12) return res; backtracking(s, 0, 0); return res; &#125; private void backtracking(String s, int start, int pointNum) &#123; if (pointNum == 3) &#123; if (isValid(s, start, s.length() - 1)) res.add(s); return; &#125; for (int i = start; i &lt; s.length(); ++i) &#123; if (isValid(s, start, i)) &#123; s = s.substring(0, i + 1) + &quot;.&quot; + s.substring(i + 1); ++pointNum; backtracking(s, i + 2, pointNum); --pointNum; s = s.substring(0, i + 1) + s.substring(i + 2); // 删除&quot;.&quot; &#125; else break; &#125; &#125; private boolean isValid(String s, int start, int end) &#123; String str = s.substring(start, end + 1); if (str.isEmpty()) return false; return Integer.valueOf(str) &lt;= 255 &amp;&amp; (str.equals(&quot;0&quot;) ||str.charAt(0) != &#x27;0&#x27;); &#125;&#125; 131. 分割回文串 二刷 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; List&lt;List&lt;String&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;String&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;String&gt;&gt; partition(String s) &#123; backtracking(s, 0); return res; &#125; private void backtracking(String s, int start) &#123; if (start == s.length()) &#123; res.add(new LinkedList&lt;&gt;(path)); return; &#125; for (int i = start; i &lt; s.length(); ++i) &#123; String split = s.substring(start, i + 1); if (isValid(split)) &#123; path.add(s.substring(start, i + 1)); backtracking(s, i + 1); path.pollLast(); &#125; &#125; &#125; private boolean isValid(String split) &#123; int start = 0, end = split.length() - 1; while (start &lt; end) &#123; if (split.charAt(start++) != split.charAt(end--)) return false; &#125; return true; &#125;&#125; 剑指 Offer II 085. 生成匹配的括号 1234567891011121314151617181920class Solution &#123; List&lt;String&gt; res = new LinkedList&lt;&gt;(); public List&lt;String&gt; generateParenthesis(int n) &#123; backtracking(n, n, &quot;&quot;); return res; &#125; private void backtracking(int leftNum, int rightNum, String parenthesis) &#123; if (leftNum == 0 &amp;&amp; rightNum == 0) &#123; res.add(parenthesis); return; &#125; if (leftNum &gt; 0) &#123; backtracking(leftNum - 1, rightNum, parenthesis + &quot;(&quot;); &#125; if (leftNum &lt; rightNum) &#123; backtracking(leftNum, rightNum - 1, parenthesis + &quot;)&quot;); &#125; &#125;&#125; 77. 组合 方法一： 剪枝： 当前最多用n - i + 1 当前还需要加入k - path.size()个数组 n - i + 1 &gt;= k - path.size 1234567891011121314151617181920class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; backtracking(n, k, 1); return res; &#125; private void backtracking(int n, int k, int start) &#123; if (path.size() == k) &#123; res.add(new LinkedList&lt;&gt;(path)); return; &#125; for (int i = start; i &lt;= n - (k - path.size()) + 1; ++i) &#123; path.add(i); backtracking(n, k, i + 1); path.pollLast(); &#125; &#125;&#125; 方法二： 123456789101112131415161718192021222324class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; // 防止底层扩容 Deque&lt;Integer&gt; path = new ArrayDeque&lt;&gt;(k); backtracking(path, n, k, 1); return res; &#125; private void backtracking(Deque&lt;Integer&gt; path, int n, int k, int start) &#123; if (k == 0) &#123; res.add(new LinkedList&lt;&gt;(path)); return; &#125; // 若n=3，k=2,即从[1,2,3]中选两个数，如果当前什么都没选(k=2)，n - k + 1= 2， // 说明至少要从2开始，才能满足选两个数这个要求 int bound = n - k + 1; if (start &gt; bound) return; backtracking(path, n, k, start + 1); path.addLast(start); backtracking(path, n, k - 1, start + 1); path.removeLast(); &#125;&#125; 两种方法的树形结构（求子集为例子） 216. 组合总和 III 方法一： 注意：backtracking(k - 1, n - i, i + 1);k - 1，别写成--k!!! 1234567891011121314151617181920public class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) &#123; backtracking(k, n, 1); return res; &#125; private void backtracking(int k, int n, int start) &#123; if (k == 0) &#123; if (n == 0) res.add(new LinkedList&lt;&gt;(path)); return; &#125; for (int i = start; i &lt;= 9 - (k - path.size()) + 1; ++i) &#123; path.offerLast(i); backtracking(k - 1, n - i, i + 1); path.pollLast(); &#125; &#125; 方法二： 1234567891011121314151617181920212223public class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) &#123; backtracking(k, n, 1); return res; &#125; private void backtracking(int k, int n, int start) &#123; if (k == 0) &#123; if (n == 0) res.add(new LinkedList&lt;&gt;(path)); return; &#125; int bound = 9 - k + 1; if (start &gt; bound) return; backtracking(k, n, start + 1); path.offerLast(start); backtracking(k - 1, n - start, start + 1); path.pollLast(); &#125;&#125; 39. 组合总和 无重复元素，每个元素可以无限次选取 方法一： 剪枝： 12if (target &lt; candidates[i]) break; 可重复选取，所以backtracking传入的是当前下标i 1backtracking(candidates, target - candidates[i], i); 剪枝的条件是把数组排序 1Arrays.sort(candidates); 123456789101112131415161718192021222324List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;();Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;();public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; Arrays.sort(candidates); backtracking(candidates, target, 0); return res;&#125;private void backtracking(int[] candidates, int target, int start) &#123; if (target &lt; 0) return; if (target == 0) &#123; res.add(new LinkedList&lt;&gt;(path)); return; &#125; for (int i = start; i &lt; candidates.length; ++i) &#123; if (target &lt; candidates[i]) break; path.offerLast(candidates[i]); backtracking(candidates, target - candidates[i], i); path.pollLast(); &#125;&#125; 方法二： 1234567891011121314151617181920212223class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; Arrays.sort(candidates); backtracking(candidates, target, 0); return res; &#125; private void backtracking(int[] candidates, int target, int start) &#123; if (target &lt; 0 || start == candidates.length) return; if (target == 0) &#123; res.add(new LinkedList&lt;&gt;(path)); return; &#125; backtracking(candidates, target, start + 1); path.offerLast(candidates[start]); backtracking(candidates, target - candidates[start], start); path.pollLast(); &#125;&#125; 40. 组合总和 II 数组内有重复元素，每个元素只能使用一次，解集不能包含重复组合 方法一： 剪枝 12if (candidates[i] &gt; target) break; 去重 12if (i &gt; start &amp;&amp; candidates[i] == candidates[i - 1]) continue; 1234567891011121314151617181920212223242526class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; Arrays.sort(candidates); backtracking(candidates, target, 0); return res; &#125; private void backtracking(int[] candidates, int target, int start) &#123; if (target == 0) &#123; res.add(new LinkedList&lt;&gt;(path)); return; &#125; for (int i = start; i &lt; candidates.length; ++i) &#123; if (candidates[i] &gt; target) break; if (i &gt; start &amp;&amp; candidates[i] == candidates[i - 1]) continue; path.offerLast(candidates[i]); backtracking(candidates, target - candidates[i], i + 1); path.pollLast(); &#125; &#125;&#125; 78. 子集 1234567891011121314151617181920class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; backtracking(nums, 0); return res; &#125; private void backtracking(int[] nums, int start) &#123; if (start == nums.length) &#123; res.add(new LinkedList&lt;&gt;(path)); return; &#125; backtracking(nums, start + 1); path.offerLast(nums[start]); backtracking(nums, start + 1); path.pollLast(); &#125;&#125; 491. 递增子序列 方法一：顺序DFS 注意： HashSet的位置！！！每进入一层递归，就会在for循环前创建一个HashSet，这样可以保证树层去重，并且树枝不会去重 peekLast()! 不是peek() 1234567891011121314151617181920212223class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; findSubsequences(int[] nums) &#123; backtracking(nums, 0); return res; &#125; public void backtracking(int[] nums, int start) &#123; if (path.size() &gt;= 2) res.add(new LinkedList(path)); Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int i = start; i &lt; nums.length; ++i) &#123; if ((!path.isEmpty() &amp;&amp; nums[i] &lt; path.peekLast())) continue; if (set.contains(nums[i])) continue; set.add(nums[i]); path.add(nums[i]); backtracking(nums, i + 1); path.pollLast(); &#125; &#125;&#125; 46. 全排列 把树形结构画出来就懂了 12345678910111213141516171819202122232425262728class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path; boolean[] used; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; // 防止底层扩容 path = new ArrayDeque&lt;&gt;(nums.length); used = new boolean[nums.length]; backtracking(nums, 0); return res; &#125; private void backtracking(int[] nums, int start) &#123; if (path.size() == nums.length) &#123; res.add(new ArrayList&lt;&gt;(path)); return; &#125; for (int i = 0; i &lt; nums.length; ++i) &#123; if (used[i]) continue; path.offerLast(nums[i]); used[i] = true; backtracking(nums, i + 1); used[i] = false; path.pollLast(); &#125; &#125;&#125; 47. 全排列 II 为了去重，需要先将数组排序 树层去重，树枝不需要去重 上一个相同的数如果used[i - 1] == false，那么说明已经被遍历过，并且将used数组赋值回false，这个时候就不需要遍历当前nums[i]了；如果used[i - 1] == true，那么说明是在同一路径上 12if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !used[i - 1]) continue; 12345678910111213141516171819202122232425262728293031class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path; boolean[] used; public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; // 防止底层扩容 path = new ArrayDeque&lt;&gt;(nums.length); used = new boolean[nums.length]; Arrays.sort(nums); backtracking(nums, 0); return res; &#125; private void backtracking(int[] nums, int start) &#123; if (path.size() == nums.length) &#123; res.add(new ArrayList&lt;&gt;(path)); return; &#125; for (int i = 0; i &lt; nums.length; ++i) &#123; if (used[i]) continue; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !used[i - 1]) continue; path.offerLast(nums[i]); used[i] = true; backtracking(nums, i + 1); used[i] = false; path.pollLast(); &#125; &#125;&#125; 698. 划分为k个相等的子集 优质题解 123456789101112131415161718192021222324252627class Solution &#123; public boolean canPartitionKSubsets(int[] nums, int k) &#123; int sum = Arrays.stream(nums).sum(); if (sum % k != 0) return false; int target = sum / k; int[] bucket = new int[k]; return backtracking(nums, k, bucket, 0, target); &#125; private boolean backtracking(int[] nums, int k, int[] bucket, int index, int target) &#123; if (index == nums.length) &#123; return true; &#125; for (int i = 0; i &lt; k; ++i) &#123; if (i &gt; 0 &amp;&amp; bucket[i] == bucket[i - 1]) continue; if (nums[index] + bucket[i] &gt; target) continue; bucket[i] += nums[index]; if (backtracking(nums, k, bucket, index + 1, target)) return true; bucket[i] -= nums[index]; &#125; return false; &#125;&#125; 51. N 皇后 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution &#123; List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; char[][] board = generateBoard(n); backtracking(board, n, 0); return res; &#125; private void backtracking(char[][] board, int n, int row) &#123; if (row == n) &#123; res.add(toList(board)); &#125; for (int col = 0; col &lt; n; ++col) &#123; if (isValid(board, row, col, n)) &#123; board[row][col] = &#x27;Q&#x27;; backtracking(board, n, row + 1); board[row][col] = &#x27;.&#x27;; &#125; &#125; &#125; private List&lt;String&gt; toList(char[][] board) &#123; List&lt;String&gt; path = new LinkedList&lt;&gt;(); for (char[] ch : board) &#123; path.add(new String(ch)); &#125; return path; &#125; private boolean isValid(char[][] board, int row, int col, int n) &#123; // 1.列 for (int i = 0; i &lt; row; ++i) &#123; if (board[i][col] == &#x27;Q&#x27;) return false; &#125; // 2. 45度 for (int i = row - 1, j = col - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; --i, --j) &#123; if (board[i][j] == &#x27;Q&#x27;) &#123; return false; &#125; &#125; // 3.135度 for (int i = row - 1, j = col + 1; i &gt;= 0 &amp;&amp; j &lt; n; --i, ++j) &#123; if (board[i][j] == &#x27;Q&#x27;) &#123; return false; &#125; &#125; return true; &#125; private char[][] generateBoard(int n) &#123; char[][] board = new char[n][n]; for (char[] row : board) Arrays.fill(row, &#x27;.&#x27;); return board; &#125;&#125;","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://leopol1d.github.io/categories/Algorithms/"},{"name":"backtracking","slug":"Algorithms/backtracking","permalink":"https://leopol1d.github.io/categories/Algorithms/backtracking/"}],"tags":[{"name":"回溯","slug":"回溯","permalink":"https://leopol1d.github.io/tags/%E5%9B%9E%E6%BA%AF/"}]},{"title":"quiz1","slug":"2023_5_19","date":"2023-05-19T03:06:35.352Z","updated":"2023-05-24T02:40:14.202Z","comments":true,"path":"2023/05/19/2023_5_19/","link":"","permalink":"https://leopol1d.github.io/2023/05/19/2023_5_19/","excerpt":"","text":"222. 完全二叉树的节点个数 BFS 1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public int countNodes(TreeNode root) &#123; if (root == null) return 0; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); int count = 0; while (!queue.isEmpty()) &#123; TreeNode cur = queue.poll(); ++count; if (cur.left != null) &#123; queue.offer(cur.left); &#125; if (cur.right != null) &#123; queue.offer(cur.right); &#125; &#125; return count; &#125;&#125; 93. 复原 IP 地址 回溯，没想出来 123. 买卖股票的最佳时机 III DP 416. 分割等和子集 0-1背包 1234567891011121314151617181920class Solution &#123; public boolean canPartition(int[] nums) &#123; // 是否可以在数组中凑出sum / 2 -&gt; 0-1背包 // dp[j]: 是否能恰好装满j // 状态转移：dp[j] = dp[j] || dp[j - nums[i]] // dp[0] = true, 什么都不选，即可装满容量为0的背包 int sum = Arrays.stream(nums).sum(); if (sum % 2 == 1) return false; int target = sum / 2; boolean[] dp = new boolean[target + 1]; dp[0] = true; for (int i = 0; i &lt; nums.length; ++i) &#123; for (int j = target; j &gt;= nums[i]; --j) &#123; dp[j] |= dp[j - nums[i]]; &#125; &#125; return dp[target]; &#125;&#125; 329. 矩阵中的最长递增路径 BFS 12345678910111213141516171819202122232425262728293031323334class Solution &#123; private int[][] dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; int[][] path; public int longestIncreasingPath(int[][] matrix) &#123; int m = matrix.length, n = matrix[0].length; path = new int[m][n]; int res = 0; for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; res = Math.max(res, dfs(i, j, m, n, matrix)); &#125; &#125; return res; &#125; private int dfs(int i, int j, int m, int n, int[][] matrix) &#123; if (path[i][j] != 0) return path[i][j]; int maxPath = 1; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; int path = 1; if (isValid(row, col, m, n) &amp;&amp; matrix[row][col] &gt; matrix[i][j]) &#123; path += dfs(row, col, m, n, matrix); &#125; maxPath = Math.max(maxPath, path); &#125; path[i][j] = maxPath; return maxPath; &#125; private boolean isValid(int row, int col, int m, int n) &#123; return row &gt;= 0 &amp;&amp; col &gt;= 0 &amp;&amp; row &lt; m &amp;&amp; col &lt; n; &#125;&#125; 1208. 尽可能使字符串相等 滑动窗口 123456789101112131415161718class Solution &#123; public int equalSubstring(String s, String t, int maxCost) &#123; int n = s.length(); int[] diff = new int[n]; for (int i = 0; i &lt; n; ++i) &#123; diff[i] = Math.abs(s.charAt(i) - t.charAt(i)); &#125; int res = 0, start = 0, sum = 0; for (int end = 0; end &lt; n; ++end) &#123; sum += diff[end]; while (maxCost &lt; sum) &#123; sum -= diff[start++]; &#125; res = Math.max(res, end - start + 1); &#125; return res; &#125;&#125; 410. 分割数组的最大值 感觉要用二分 503. 下一个更大元素 II 还没刷单调栈","categories":[],"tags":[]},{"title":"Algorithms","slug":"Algorithms","date":"2023-04-07T08:06:11.000Z","updated":"2023-05-21T09:02:00.833Z","comments":true,"path":"2023/04/07/Algorithms/","link":"","permalink":"https://leopol1d.github.io/2023/04/07/Algorithms/","excerpt":"","text":"LeetCode Solutions Dynamic Programming debug 1234567private static void printDp(int[] dp, int i) &#123; System.out.print(i + &quot;: &quot;); for (int maxValue : dp)&#123; System.out.print(maxValue + &quot; &quot;); &#125; System.out.println();&#125; 509. 斐波那契数 方法一：DP 123456789101112class Solution &#123; public int fib(int n) &#123; if (n == 0) return 0; int[] dp = new int[n + 1]; dp[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; dp[i] = dp[i - 2] + dp[i - 1]; &#125; return dp[n]; &#125;&#125; 方法二：DP + 滚动数组 123456789101112class Solution &#123; public int fib(int n) &#123; if (n == 0) return 0; int[] dp = new int[3]; dp[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; dp[i % 3] = dp[(i - 2) % 3] + dp[(i - 1) % 3]; &#125; return dp[n % 3]; &#125;&#125; 70. 爬楼梯 方法一：DP + 滚动数组 123456789101112131415class Solution &#123; public int climbStairs(int n) &#123; // 1.dp[i]:爬上第i层楼梯的方法数 // 2.状态转移方程：dp[i] = dp[i - 1] + dp[i - 2] // 3.初始化：爬上第0层楼梯的方法数是1，dp[0] = 1,如果是0，那么dp[2] = 1！ // 爬上第一层楼梯的方法数是1,dp[1] = 1 int[] dp = new int[3]; dp[0] = 1; dp[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; dp[i % 3] = dp[(i - 1) % 3] + dp[(i - 2) % 3]; &#125; return dp[n % 3]; &#125;&#125; 746. 使用最小花费爬楼梯 注意：最后一个阶梯之后才是楼顶 image-20230512125550663 方法一：DP + 滚动数组 123456789101112131415class Solution &#123; public int minCostClimbingStairs(int[] cost) &#123; // dp[i]:爬到第i层的最小花费 // 状态转移方程：dp[i] = min(dp[i - 2] + cost[i - 2], dp[i - 1] + cost[i - 1]) // 初始化：dp[0] = 0, dp[1] = 0 int n = cost.length; int[] dp = new int[3]; dp[0] = 0; dp[1] = 0; for (int i = 2; i &lt;= n; ++i) &#123; dp[i % 3] = Math.min(dp[(i - 2) % 3] + cost[i - 2], dp[(i - 1) % 3] + cost[i - 1]); &#125; return dp[n % 3]; &#125;&#125; 剑指Offer 95 最优子结构：求最长公共子序列，求问题最优解，适合使用dp解决。 重叠子问题：求第一个字符串中位置0~\\(i\\)构成的子序列与第二个字符串中0~\\(j\\)构成的子序列的最大公共子序列\\(f(i,j)\\)，需要多次使用\\(f(i-1, j-1), f(i-1,j),f(i,j-1)\\)，拥有重叠子问题 状态转移方程： \\[ f(i,j) = \\begin{cases} f(i-1,j-1)+1, &amp; ch[i]==ch[j] \\\\ max(f(i-1,j),f(i,j-1)), &amp; else \\\\ \\end{cases} \\] 边界条件：dp[0][:] == 0, dp[:][] == 0 令两个字符串长度分别为\\(m,n\\)， 时间复杂度：双重for循环，\\(O(mn)\\) 空间复杂度：需要建立大小为(m+1)(n+1)的数组，因此空间复杂度为\\(O(mn)\\) 1234567891011121314151617class Solution &#123; public int longestCommonSubsequence(String text1, String text2) &#123; int m = text1.length(), n = text2.length(); int[][] dp = new int[m + 1][n + 1]; for (int i = 1; i &lt;= m; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; if (text1.charAt(i - 1) == text2.charAt(j - 1)) &#123; dp[i][j] = dp[i - 1][j - 1] + 1; &#125; else &#123; dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]); &#125; &#125; &#125; return dp[m][n]; &#125;&#125; 如何优化空间复杂度？ 剑指Offer 101 分割等和子集 分析：只要在数组中找到任意数等于数组累加和的一半，该数组就是等和子集，可抽象为经典0-1背包问题。 dp[i][j]:从编号0-i的物品中任选物品(可以都不选)，容量为j的背包能否正好装满 递归公式:dp[i][j] = dp[i-1][j] || j &gt;= num[i] : dp[i-1][j-nums[i]] : false 初始化: 当j==0时，即背包容量为0，不管有多少物品，只要什么都不选就能使背包总重量为0，所以f(i,0)=true 当i==0 &amp;&amp; j!= 0时，即物品数量为0，怎样都不能放满容量大于0的背包，所以f(0,i)=false 遍历顺序：先遍历物品再嵌套从头到尾遍历容量 打印dp数组验证与手写稿是否一致 空间复杂度优化：由于求第i行dp数组只需要用到第i-1行dp数组的信息，所以可以使用一维滑动dp数组代替二维dp数组。 剑指Offer 1049 最后一块石头的重量 II 从 stones数组中选择，凑成总和不超过 \\(sum/2\\) 的最大价值 1234567891011121314class Solution &#123; public int lastStoneWeightII(int[] stones) &#123; int sum = Arrays.stream(stones).sum(); int target = sum / 2; // dp[j]:容量为j的背包能装下不超过target的最大价值 int[] dp = new int[target + 1]; for (int i = 0; i &lt; stones.length; ++i) &#123; for (int j = target; j &gt;= stones[i]; --j) &#123; dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]); &#125; &#125; return sum - dp[target] * 2; &#125;&#125; 一和零 背包问题中，weight里的数据不一定要升序！比如weights=[4,1,3] 方法一：DP 12345678910111213141516171819202122232425class Solution &#123; public int findMaxForm(String[] strs, int m, int n) &#123; // dp[i][j]:最多有i个0，j个1，最多能选的字符数量 int[][][] dp = new int[strs.length + 1][m + 1][n + 1]; for (int k = 1; k &lt;= strs.length; ++k) &#123; String str = strs[k - 1]; int num0 = 0, num1 = 0; for (int x = 0; x &lt; str.length(); ++x) &#123; if (str.charAt(x) == &#x27;0&#x27;) ++num0; else ++num1; &#125; for (int i = 0; i &lt;= m; ++i) &#123; for (int j = 0; j &lt;= n; ++j) &#123; if (i &lt; num0 || j &lt; num1) dp[k][i][j] = dp[k - 1][i][j]; else dp[k][i][j] = Math.max(dp[k - 1][i][j], dp[k - 1][i - num0][j - num1] + 1); &#125; &#125; &#125; return dp[strs.length][m][n]; &#125;&#125; 方法二：DP+滚动数组 12345678910111213141516171819202122class Solution &#123; public int findMaxForm(String[] strs, int m, int n) &#123; // dp[i][j]:最多有i个0，j个1，最多能选的字符数量 int[][] dp = new int[m + 1][n + 1]; for (int k = 1; k &lt;= strs.length; ++k) &#123; String str = strs[k - 1]; int num0 = 0, num1 = 0; for (int x = 0; x &lt; str.length(); ++x) &#123; if (str.charAt(x) == &#x27;0&#x27;) ++num0; else ++num1; &#125; for (int i = m; i &gt;= num0; --i) &#123; for (int j = n; j &gt;= num1; --j) &#123; dp[i][j] = Math.max(dp[i][j], dp[i - num0][j - num1] + 1); &#125; &#125; &#125; return dp[m][n]; &#125;&#125; 518. 零钱兑换 II ​ 经典完全背包问题，解题步骤如下： dp[j]：背包容量为j时，放满背包的组合方法数 状态转移公式：dp[j] = dp[j] + dp[j - coins[i]] 初始化dp[0]：背包容量为0时，有一种方法放满背包（什么都不放） 遍历顺序：求组合数，先便利物品，再遍历容量 遍历dp数组 关于组合和排列的理解：先遍历物品后遍历背包是这样，比如，外层循环固定coins[1]，在内层循环遍历背包时，随着背包不断增加，coins[1]可以重复被添加进来，而由于外层循环固定了，因此coins[2]只能在下一次外层循环添加进不同大小的背包中，这么看的话，coins[i + 1]只能在coins[i]之后了；如果先遍历背包后遍历物品，那么外层循环先固定背包大小j，然后在大小为j的背包中循环遍历添加物品，然后在下次外层循环背包大小变为j+1，此时仍要执行内层循环遍历添加物品，也就会出现在上一轮外层循环中添加coins[2]的基础上还能再添加coins[1]的情况，那么就有了coins[1]在coins[2]之后的情况了(逆序)。 如果求组合数就是外层for循环遍历物品，内层for遍历背包。 如果求排列数就是外层for遍历背包，内层for循环遍历物品。 377. 组合总和 Ⅳ 先举个例子，nums = [1, 2, 3]，target = 35. 假设用1，2，3拼凑出35的总组合个数为y。我们可以考虑三种情况： （1）有效组合的末尾数字为1，这类组合的个数为 x1。我们把所有该类组合的末尾1去掉，那么不难发现，我们找到了一个子问题，x1即为在[1，2，3]中凑出35 - 1 = 34的总组合个数。因为我如果得到了和为34的所有组合，我只要在所有组合的最后面，拼接一个1，就得到了和为35且最后一个数字为1的组合个数了。 （2）有效组合的末尾数字为2，这类组合的个数为 x2。我们把所有该类组合的末尾2去掉，那么不难发现，我们找到了一个子问题，x2即为在[1，2，3]中凑出35 - 2 = 33的总组合个数。因为我如果得到了和为33的所有组合，我只要在所有组合的最后面，拼接一个2，就得到了和为35且最后一个数字为2的组合个数了。 （3）有效组合的末尾数字为3，这类组合的个数为 x3。我们把所有该类组合的末尾3去掉，那么不难发现，我们找到了一个子问题，x3即为在[1，2，3]中凑出35 - 3 = 32的总组合个数。因为我如果得到了和为32的所有组合，我只要在所有组合的最后面，拼接一个3，就得到了和为35且最后一个数字为3的组合个数了。 这样就简单了，y = x1 + x2 + x3。而x1，x2，x3又可以用同样的办法从子问题得到。状态转移方程get！ 全排列问题，转化为完全背包问题 dp[j]：在背包容量为j时，放满背包的排列数 状态转移公式：dp[j] = dp[j] + dp[j - nums[i]] 初始化dp[0]：在背包容量为0时，放满背包的排列数量为1（什么都不放） 遍历顺序，排列问题，先遍历背包容量(物品可以逆序放入dp[j - nums[i]])，再遍历物品 打印dp数组 70. 爬楼梯 完全背包 + 全排列问题，可以重复选择放入物品1与物品2，求放满容量为n的背包的排列数 dp[j]：在背包容量为j时，放满背包的排列数 状态转移公式：dp[j] = dp[j] + dp[j - nums[i]] 初始化dp[0]：在背包容量为0时，放满背包的排列数量为1（什么都不放） 遍历顺序，排列问题，先遍历背包容量(物品可以逆序放入dp[j - nums[i]])，再遍历物品 打印dp数组 322. 零钱兑换 完全背包问题 dp[j]：背包容量为j时，凑满背包容量所需的最少硬币数 状态转移公式：dp[j] = min(dp[j], dp[j - coins[i]] + 1) 初始化dp[0]：背包容量为0时，凑满背包容量所需的最少硬币数时0,其他初始化为Integer.MAX_VALUE 遍历顺序，无所谓 打印dp数组 1234567891011121314151617class Solution &#123; public int coinChange(int[] coins, int amount) &#123; // dp[j]: 凑成整数j所需的最少的硬币书 // 状态转移方程：dp[j] = min(dp[j], dp[j - nums[i] + 1]) // 初始化：dp[0] = 0,其他初始化为1 int[] dp = new int[amount + 1]; Arrays.fill(dp, Integer.MAX_VALUE); dp[0] = 0; for (int i = 0; i &lt; coins.length; ++i) &#123; for (int j = coins[i]; j &lt;= amount; ++j) &#123; if (dp[j - coins[i]] != Integer.MAX_VALUE) dp[j] = Math.min(dp[j], dp[j - coins[i]] + 1); &#125; &#125; return dp[amount] == Integer.MAX_VALUE ? -1 : dp[amount]; &#125;&#125; 279. 完全平方数 dp[j]：装满容量为j的背包，至少要放多少个物品 状态转移公式：dp[j] = min(dp[j], dp[j - weights[i]] + 1) 初始化dp[0]:装满容量为0的背包，至少放0个物品；其他设为Integet.MAX_VALUE 遍历顺序：无所谓 打印dp数组 123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public int numSquares(int n) &#123; // 完全背包问题 // 定义物品的weights数组，先找到小于等于n的最大完全平方数 int max_weight = (int)(Math.sqrt(n)); int[] weights = new int[max_weight]; for(int i = 1; i &lt;= max_weight; i++) weights[i-1] = i*i; // 1.dp[j]：装满容量为j的背包，至少要放多少个物品 int[] dp = new int[n + 1]; // 2.状态转移公式：dp[j] = min(dp[j], dp[j - weights[i]] + 1) // 3.初始化dp[0]:装满容量为0的背包，至少放0个物品；其他设为Integet.MAX_VALUE for(int i = 1; i &lt;= n; i++) &#123; dp[i] = Integer.MAX_VALUE; &#125; // 4.遍历顺序：无所谓 for(int i = 0; i &lt; weights.length; i++) &#123; for(int j = weights[i]; j &lt;= n; j++) &#123; if(dp[j - weights[i]] != Integer.MAX_VALUE) dp[j] = Math.min(dp[j], dp[j - weights[i]] + 1); &#125; // printDp(dp, i); &#125; return dp[n]; // 5.打印dp数组 &#125; private static void printDp(int[] dp, int i) &#123; System.out.print(i + &quot;: &quot;); for (int maxValue : dp)&#123; System.out.print(maxValue + &quot; &quot;); &#125; System.out.println(); &#125;&#125; 139. 单词拆分 背包问题 + 排列(“leetcode”由“leet”与“code”组成但不能反过来由“code”与“leet”组成 )的变种，建议不要完全抽象成背包问题，便于理解 dp[j]：长度为j的字符串，可以被字典中的单词拆分。 状态转移公式：if([j, i] 这个区间的子串出现在字典里 &amp;&amp; dp[j]是true) 那么 dp[i] = true， 其中j&lt;i。 初始化dp[0]:dp[i]依赖于前面的dp[j]，所以dp[0]要初始化为true，不然全为false 遍历顺序：先遍历背包容量，再嵌套遍历物品 打印dp数组 198. 打家劫舍 dp[j]：偷窃从标号为0到j的房屋所能获得的最大价值 状态转移公式：dp[j] = max(dp[j - 1], dp[j - 2] + nums[j]) 初始化：dp[0] = nums[0], dp[1] = max(nums[0], nums[1]) 遍历顺序：单序列问题,dp[i] 是根据dp[i - 2] 和 dp[i - 1] 推导出来的，那么一定是从前到后遍历！ 遍历dp数组 优化空间复杂度 根据状态转移公式dp[j] = max(dp[j - 1], dp[j - 2] + nums[j])，dp[j]只需要dp[j-1]以及dp[j-2]两个变量即可，可以把数组大小压缩到2。 213. 打家劫舍 II 416. 分割等和子集 dp[j]：背包容量为j时，是否能用物品装满 状态转移方程：dp[j] = dp[j] || dp[j - nums[i]] 初始化：背包容量为0时，不把物品装进去即可装满，dp[0] = true 遍历顺序：一维滑动数组，零一背包，先遍历物品后遍历背包容量 337. 打家劫舍 III 方法一：HashMap f：偷当前房屋能获得的最大价值；g：不偷当前房屋能获得的最大价值 偷当前房屋f(cur) = cur.val + g(cur.left) + g(cur.right) 不偷当前房屋g(cur) = max(f(cur.left), g(cur.left)) + max(f(cur.right), g(cur.right)) 方法二：Morris + HashMap 当作是练习题了！！ 注意事项：在访问的时候，此时需要cur.right，而这个时候已经是逆序过的，cur.right实际上指向的是自己的父节点，所以再用一个hashmap存储cur真正的右节点（或者再逆序一遍）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Solution &#123; Map&lt;TreeNode, Integer&gt; f = new HashMap&lt;&gt;(); Map&lt;TreeNode, Integer&gt; g = new HashMap&lt;&gt;(); Map&lt;TreeNode, TreeNode&gt; right = new HashMap&lt;&gt;(); public int rob(TreeNode root) &#123; // f:偷当前节点能获得的最大价值 // g:不偷当前节点能获得的最大价值 // f(cur) = cur.val + g(cur.left) + g(cur.right) // g(cur) = max(f(cur.left), g(cur.left)) + max(f(cur.right), g(cur.right)) TreeNode cur = root, mostRight = null; while (cur != null) &#123; mostRight = cur.left; if (mostRight != null) &#123; while (mostRight.right != null &amp;&amp; mostRight.right != cur) mostRight = mostRight.right; if (mostRight.right == null) &#123; mostRight.right = cur; cur = cur.left; continue; &#125; else &#123; // mostRight.right = cur mostRight.right = null; visit(cur.left); &#125; &#125; cur = cur.right; &#125; visit(root); return Math.max(f.getOrDefault(root, 0), g.getOrDefault(root, 0)); &#125; private void visit(TreeNode cur) &#123; TreeNode tail = reverse(cur); cur = tail; while (cur != null) &#123; f.put(cur, cur.val + g.getOrDefault(cur.left, 0) + g.getOrDefault(right.get(cur), 0)); int maxLeft = Math.max(f.getOrDefault(cur.left, 0), g.getOrDefault(cur.left, 0)); int maxRight = Math.max(f.getOrDefault(right.get(cur), 0), g.getOrDefault(right.get(cur), 0)); g.put(cur, maxLeft + maxRight); if (cur.right != null) right.put(cur.right, cur); cur = cur.right; &#125; reverse(tail); &#125; private TreeNode reverse(TreeNode cur) &#123; TreeNode pre = null; while (cur != null) &#123; TreeNode next = cur.right; cur.right = pre; pre = cur; cur = next; &#125; return pre; &#125;&#125; 121. 买卖股票的最佳时机 你根本没在dp！ 方法一：暴力迭代 超时咯 image-20230330094627247 方法二：贪心 从前往后遍历，使用minPrice记录最小值，使用maxProfit记录最大收益 方法三：DP DP数组的定义十分重要！ 12345678910111213141516171819class Solution &#123; public int maxProfit(int[] prices) &#123; int len = prices.length; if (len == 0 || prices == null) return 0; // 1.dp[0][j]:第j天持有股票(之前买入或者当前买入)所拥有的最大价值，dp[1][j]：第j天不持有股票(之前卖出或者当前卖出)所拥有的最大价值 int[][] dp = new int[2][len]; // 2.状态转移方程：dp[0][j] = max(dp[0][j-1], -price[j]); dp[1][j] = max(dp[1][j-1], price[j] + dp[0][j - 1]) // 3.初始化：dp[0][0]必须买入，初始化为-price[0]；dp[1][0]不能卖出任何股票，初始化为0 dp[0][0] = -prices[0]; // 4.遍历顺序：dp[j]由dp[j-1]决定，所以从前往后遍历 for (int j = 1; j &lt; len; ++j) &#123; dp[0][j] = Math.max(dp[0][j - 1], -prices[j]); dp[1][j] = Math.max(dp[1][j - 1], prices[j] + dp[0][j - 1]); // 不能当天买入当天卖出所以是dp[0][j - 1] &#125; return dp[1][len - 1]; // 5.打印dp数组 &#125;&#125; 122. 买卖股票的最佳时机 II 1234567891011121314151617class Solution &#123; public int maxProfit(int[] prices) &#123; // 1.dp[0][j]:在第j天持有(之前买入，当前买入)股票时拥有的最大现金;dp[1][j]在第j天不持有(之前卖出，当前卖出)股票拥有的最大现金 int len = prices.length; int[][] dp = new int[2][len]; // 2.状态转移方程：dp[0][j] = max(dp[0][j - 1], dp[1][j - 1] - price[j]); dp[1][j] = max(dp[1][j - 1], dp[0][j - 1] + price[j]) // 3.初始化：dp[0][0] = -price[0];dp[1][0] = 0;可以当天出售 dp[0][0] = -prices[0]; // 4.遍历顺序 for (int j = 1; j &lt; len; ++j) &#123; dp[0][j] = Math.max(dp[0][j - 1], dp[1][j - 1] - prices[j]); dp[1][j] = Math.max(dp[1][j - 1], dp[0][j - 1] + prices[j]); &#125; return dp[1][len - 1]; // 5.打印dp数组 &#125;&#125; 96. 不同的二叉搜索树 12345678910111213class Solution &#123; public int numTrees(int n) &#123; int[] dp = new int[n + 1]; dp[0] = 1; dp[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= i; ++j) &#123; dp[i] += dp[j - 1] * dp[i - j]; &#125; &#125; return dp[n]; &#125;&#125; 优化空间.. 123. 买卖股票的最佳时机 III 1372. 二叉树中的最长交错路径 1234567891011121314151617181920212223242526272829303132class Solution &#123; // f(cur)：以cur结尾，且cur是左子树的最大长度 // g(cur)：以cur结尾，且cur是右子树的最大长度 Map&lt;TreeNode, Integer&gt; f = new HashMap&lt;&gt;(); Map&lt;TreeNode, Integer&gt; g = new HashMap&lt;&gt;(); Queue&lt;TreeNode[]&gt; queue = new LinkedList&lt;&gt;(); public int longestZigZag(TreeNode root) &#123; // f.put(root, 0); // g.put(root, 0); queue.offer(new TreeNode[]&#123;root, null&#125;); while (!queue.isEmpty()) &#123; TreeNode[] sonFather = queue.poll(); f.put(sonFather[0], 0); g.put(sonFather[0], 0); if(sonFather[1] != null) &#123; if (sonFather[1].left == sonFather[0]) f.put(sonFather[0], g.get(sonFather[1]) + 1); if (sonFather[1].right == sonFather[0]) g.put(sonFather[0], f.get(sonFather[1]) + 1); &#125; if (sonFather[0].left != null) queue.offer(new TreeNode[]&#123;sonFather[0].left, sonFather[0]&#125;); if (sonFather[0].right != null) queue.offer(new TreeNode[]&#123;sonFather[0].right, sonFather[0]&#125;); &#125; int max = Integer.MIN_VALUE; for (TreeNode node : f.keySet()) &#123; max = Math.max(max, Math.max(f.get(node), g.get(node))); &#125; return max; &#125;&#125; 300. 最长递增子序列 dp[i]：以nums[i]结尾的最长递增子序列的长度 从前往后，在i的左开区间进行比较所有的j(j &lt; i)，如果nums[j]&lt;nums[i]，那么dp[i] = max(dp[i], dp[j] + 1) 初始化：令dp数组所有元素为1，最短序列是本身 遍历顺序：第二层从前往后，从后往前都可以，只要把i之前的元素全部遍历了就行 要注意的是，要输出的答案不是dp[dp.length-1]，而是dp数组中的最大值，比如序列为01234512，输出的是结果是dp[5]；所以可以用一个全局变量记录dp数组中的最大值 时间复杂度：\\(O(n^2)\\) 空间复杂度：\\(O(n)\\) 12345678910111213141516171819class Solution &#123; public int lengthOfLIS(int[] nums) &#123; int n = nums.length; if (n == 1) return 1; int[] dp = new int[n]; Arrays.fill(dp, 1); int maxLenOfSubsequence = 0; for (int i = 1; i &lt; n; ++i) &#123; for (int j = 0; j &lt; i; ++j) &#123; if (nums[i] &gt; nums[j]) &#123; dp[i] = Math.max(dp[i], dp[j] + 1); &#125; &#125; maxLenOfSubsequence = Math.max(maxLenOfSubsequence, dp[i]); &#125; return maxLenOfSubsequence; &#125;&#125; 674. 最长连续递增序列 方法一：DP dp[i]：以nums[i]结尾的最长连续递增子序列的长度 当当前数字nums[i]大于nums[i-1]，令dp[i] = dp[i - 1] + 1 初始化：令dp数组所有元素为1，最短序列是本身 时间复杂度：\\(O(n)\\) 空间复杂度：\\(O(n)\\) 1234567891011121314151617181920class Solution &#123; public int findLengthOfLCIS(int[] nums) &#123; int n = nums.length; if (n == 1) return 1; int[] dp = new int[n]; Arrays.fill(dp, 1); int maxLength = 0; for (int i = 1; i &lt; n; ++i) &#123; if (nums[i] &gt; nums[i - 1]) &#123; dp[i] = dp[i - 1] + 1; &#125; maxLength = Math.max(maxLength, dp[i]); &#125; // for (int i = 0; i &lt; dp.length; ++i) &#123; // System.out.print(dp[i] + &quot; &quot;); // &#125; return maxLength; &#125;&#125; 方法二：DP + 滑动数组 注意：当nums[i] &lt;= nums[i - 1]时，需要把dp[i%2]重置为1 1234567891011121314151617181920class Solution &#123; public int findLengthOfLCIS(int[] nums) &#123; int n = nums.length; if (n == 1) return 1; int[] dp = new int[2]; Arrays.fill(dp, 1); int maxLength = 0; for (int i = 1; i &lt; n; ++i) &#123; if (nums[i] &gt; nums[i - 1]) &#123; dp[i % 2] = dp[(i - 1) % 2] + 1; &#125; else &#123; dp[i % 2] = 1; &#125; maxLength = Math.max(maxLength, dp[i % 2]); &#125; return maxLength; &#125;&#125; 718. 最长重复子数组:warning: 方法一：暴力 时间复杂度：\\(O(m^2n)\\) 空间复杂度：\\(O(1)\\) 123456789101112131415161718class Solution &#123; public int findLength(int[] nums1, int[] nums2) &#123; int res = 0; for (int i = 0; i &lt; nums1.length; ++i) &#123; for (int j = 0; j &lt; nums2.length; ++j) &#123; int count1 = i, count2 = j; int counter = 0; while (count1 &lt; nums1.length &amp;&amp; count2 &lt; nums2.length &amp;&amp; nums1[count1] == nums2[count2]) &#123; ++counter; ++count1; ++count2; &#125; res = Math.max(res, counter); &#125; &#125; return res; &#125;&#125; 方法二：DP dp[i][j]:以nums1[i - 1]结尾与以nums2[j - 1]结尾时的最长重复子数组 状态转移公式：当nums1[i - 1] == nums2[j - 1]时，dp[i][j] = dp[i - 1][j - 1] + 1 初始化：m为nums1的长度，n为nums2的长度，初始化(m + 1) * (n + 1)的二维数组，第一行第一列初始化为0，因为任一数组为空，就不会有重复子数组 注意事项：输出结果是dp数组中的最大值，因为最长的重复子数组不一定是在两数组的结尾处，可以在循环内比较 时间复杂度：\\(O(mn)\\) 空间复杂度：\\(O(mn)\\) 12345678910111213141516class Solution &#123; public int findLength(int[] nums1, int[] nums2) &#123; int m = nums1.length, n = nums2.length; int[][] dp = new int[m + 1][n + 1]; int result = 0; for (int i = 1; i &lt;= m; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; if (nums1[i - 1] == nums2[j - 1]) &#123; dp[i][j] = dp[i - 1][j - 1] + 1; result = Math.max(result, dp[i][j]); &#125; &#125; &#125; return result; &#125;&#125; 滚动数组缩减空间复杂度 dp数组为第二个数组的长度加一 不相等时要把dp[j]赋0，不然之后会出错 此时遍历第二个数组的时候，就要从后向前遍历，这样避免重复覆盖。 比如nums1 = [1, 2, 3, 1],nums2 = [1,6,8,1,3,1,2,3] i = 1时候，dp数组为[1,0,0,1,0,1,0,0] i = 2时候，dp数组为[0,0,0,0,0,0,1,0] i = 3时候，dp数组为[0,0,0,0,1,0,0,2] i=3时，如果第二层for循环j从前往后遍历，那么dp倒数第二个位置会因为3!=2，被赋0，进而导致dp最后一个位置是1而不是2 123456789101112131415161718class Solution &#123; public int findLength(int[] nums1, int[] nums2) &#123; int[] dp = new int[nums2.length + 1]; int res = 0; for (int i = 1; i &lt;= nums1.length; ++i) &#123; for (int j = nums2.length; j &gt; 0; --j) &#123; if (nums1[i - 1] == nums2[j - 1]) &#123; dp[j] = dp[j - 1] + 1; &#125; else &#123; dp[j] = 0; &#125; res = Math.max(res, dp[j]); &#125; &#125; return res; &#125;&#125; 方法三：滑动窗口 62. 不同路径 方法一：DP O(mn) 12345678910111213141516171819class Solution &#123; public int uniquePaths(int m, int n) &#123; // dp[i][j]:走到i,j位置的路径数 // 状态转移方程：dp[i][j] = dp[i - 1][j] + dp[i][j - 1] int[][] dp = new int[m][n]; for (int i = 0; i &lt; m; ++i) &#123; dp[i][0] = 1; &#125; for (int j = 0; j &lt; n; ++j) &#123; dp[0][j] = 1; &#125; for (int i = 1; i &lt; m; ++i) &#123; for (int j = 1; j &lt; n; ++j) &#123; dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; &#125; &#125; return dp[m - 1][n - 1]; &#125;&#125; 方法二：DP+滚动数组 O(n) 2行 12345678910111213141516171819class Solution &#123; public int uniquePaths(int m, int n) &#123; // dp[i][j]:走到i,j位置的路径数 // 状态转移方程：dp[i][j] = dp[i - 1][j] + dp[i][j - 1] int[][] dp = new int[2][n]; for (int i = 0; i &lt; 2; ++i) &#123; dp[i][0] = 1; &#125; for (int j = 0; j &lt; n; ++j) &#123; dp[0][j] = 1; &#125; for (int i = 1; i &lt; m; ++i) &#123; for (int j = 1; j &lt; n; ++j) &#123; dp[i % 2][j] = dp[(i - 1) % 2][j] + dp[i % 2][j - 1]; &#125; &#125; return dp[(m - 1) % 2][n - 1]; &#125;&#125; 方法三：DP+滚动数组 O(n) 1行 12345678910111213141516class Solution &#123; public int uniquePaths(int m, int n) &#123; // dp[i][j]:走到i,j位置的路径数 // 状态转移方程：dp[j] = dp[j] + dp[j - 1] // 初始化：全部初始化为1 // 遍历顺序：dp[j]依赖dp[j - 1]，所以从左往右遍历 int[] dp = new int[n]; Arrays.fill(dp, 1); for (int i = 1; i &lt; m; ++i) &#123; for (int j = 1; j &lt; n; ++j) &#123; dp[j] += dp[j - 1]; &#125; &#125; return dp[n - 1]; &#125;&#125; 63. 不同路径 II 方法一：DP 12345678910111213141516171819202122232425class Solution &#123; public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123; int m = obstacleGrid.length, n = obstacleGrid[0].length; int[][] dp = new int[m][n]; for (int i = 0; i &lt; m; ++i) &#123; if (obstacleGrid[i][0] == 1) &#123; break; &#125; dp[i][0] = 1; &#125; for (int j = 0; j &lt; n; ++j) &#123; if (obstacleGrid[0][j] == 1) break; dp[0][j] = 1; &#125; for (int i = 1; i &lt; m; ++i) &#123; for (int j = 1; j &lt; n; ++j) &#123; if (obstacleGrid[i][j] == 1) continue; dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; &#125; &#125; return dp[m - 1][n - 1]; &#125;&#125; 343. 整数拆分:warning: 方法一：DP image-20230515170354808 123456789101112131415class Solution &#123; public int integerBreak(int n) &#123; // dp[j]:j拆分为多个数的最大乘积 int[] dp = new int[n + 1]; dp[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; for (int j = 1; j &lt; i; ++j) &#123; int k = i - j; dp[i] = Math.max(dp[i], Math.max(k * j, dp[k] * j)); &#125; &#125; return dp[n]; &#125;&#125; 96. 不同的二叉搜索树:warning: 剑指 Offer II 102. 加减的目标值 方法一：DP 12345678910111213141516171819class Solution &#123; public int findTargetSumWays(int[] nums, int target) &#123; int sum = Arrays.stream(nums).sum(); int diff = sum - target; if (diff % 2 == 1 || diff &lt; 0) return 0; target = diff / 2; // dp[j]:装满容量为j的方法数 // dp[0] = 1,装满容量为0的背包有一种 int[] dp = new int[target + 1]; dp[0] = 1; for (int i = 0; i &lt; nums.length; ++i) &#123; for (int j = target; j &gt;= nums[i]; --j) &#123; dp[j] += dp[j - nums[i]]; &#125; &#125; return dp[target]; &#125;&#125; 树形DP 左神shi'p 树形DP题目 没有上司的舞会 337. 打家劫舍 III 96. 不同的二叉搜索树 1372. 二叉树中的最长交错路径 Binary Tree 144. 二叉树的前序遍历 方法一：递归 假设树上一共有n 个节点。 时间复杂度：遍历了整棵树，\\(O(n)\\) 空间复杂度：和递归使用的栈大小相关，递归层数不超过n(一叉树)，\\(O(n)\\) 1234567891011121314class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); dfs(root, result); return result; &#125; public void dfs(TreeNode root, List&lt;Integer&gt; result) &#123; if (root == null) return; result.add(root.val); dfs(root.left, result); dfs(root.right, result); &#125;&#125; 方法二：非递归 假设树上一共有n 个节点。 时间复杂度：遍历了整棵树，\\(O(n)\\) 空间复杂度：和递归使用的栈大小相关，递归层数不超过n(一叉树)，\\(O(n)\\) 1234567891011121314151617class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode cur = root; while (cur != null || !stack.isEmpty()) &#123; while (cur != null) &#123; result.add(cur.val); stack.push(cur); cur = cur.left; &#125; cur = stack.pop(); cur = cur.right; &#125; return result; &#125;&#125; 方法三：Morris前序遍历 morris遍历利用树的大量空闲指针，实现空间开销的极限缩减。 时间复杂度：\\(O(n)\\)，其中n是二叉树的节点数。没有左子树的节点只被访问一次，有左子树的节点被访问两次 空间复杂度：\\(O(1)\\)，只操作已存在的指针（树的空闲指针），因此只需要常数的额外空间 123456789101112131415161718192021222324252627class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); TreeNode cur = root, mostRight = null; while (cur != null) &#123; mostRight = cur.left; if (mostRight != null) &#123; while (mostRight.right != null &amp;&amp; mostRight.right != cur) mostRight = mostRight.right; if (mostRight.right == null) &#123; result.add(cur.val); mostRight.right = cur; cur = cur.left; continue; &#125; else &#123; // mostRight.right == cur mostRight.right = null; &#125; &#125; else &#123; // cur.left == null result.add(cur.val); &#125; cur = cur.right; &#125; return result; &#125;&#125; 94. 二叉树的中序遍历 方法一：递归 时间复杂度：\\(O(n)\\)，其中n为树的节点数 空间复杂度：\\(O(n)\\)，和递归使用的栈大小相关，递归层数不超过n(一叉树) 123456789101112131415class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); dfs(root, result); return result; &#125; public void dfs(TreeNode root, List&lt;Integer&gt; result) &#123; if (root != null) &#123; dfs(root.left, result); result.add(root.val); dfs(root.right, result); &#125; &#125;&#125; 方法二：非递归 时间复杂度：\\(O(n)\\)，其中n为树的节点数 空间复杂度：\\(O(n)\\)，和递归使用的栈大小相关，递归层数不超过n(一叉树) 1234567891011121314151617class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new LinkedList&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode cur = root; while (cur != null || !stack.isEmpty()) &#123; while (cur != null) &#123; stack.push(cur); cur = cur.left; &#125; cur = stack.pop(); res.add(cur.val); cur = cur.right; &#125; return res; &#125;&#125; 方法三：Morris中序遍历 morris遍历利用树的大量空闲指针，实现空间开销的极限缩减。 时间复杂度：\\(O(n)\\)，其中n是二叉树的节点数。没有左子树的节点只被访问一次，有左子树的节点被访问两次 空间复杂度：\\(O(1)\\)，只操作已存在的指针（树的空闲指针），因此只需要常数的额外空间 123456789101112131415161718192021222324class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new LinkedList&lt;&gt;(); TreeNode cur = root, mostRight = null; while (cur != null) &#123; mostRight = cur.left; if (mostRight != null) &#123; while (mostRight.right != null &amp;&amp; mostRight.right != cur) mostRight = mostRight.right; if (mostRight.right == null) &#123; mostRight.right = cur; cur = cur.left; continue; &#125; else &#123; // mostRight == cur mostRight.right = null; &#125; &#125; res.add(cur.val); cur = cur.right; &#125; return res; &#125;&#125; 145. 二叉树的后序遍历 方法一：递归 方法二：非递归 123456789101112131415161718192021222324class Solution &#123; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new LinkedList&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode cur = root, pre = null; while (cur != null || !stack.isEmpty()) &#123; while (cur != null) &#123; stack.push(cur); cur = cur.left; &#125; cur = stack.peek(); if (cur.right != null &amp;&amp; cur.right != pre) &#123; cur = cur.right; &#125; else &#123; stack.pop(); res.add(cur.val); pre = cur; cur = null; &#125; &#125; return res; &#125;&#125; 方法三：Morris后序遍历 时间复杂度：\\(O(n)\\)，其中n为树的节点数 空间复杂度：\\(O(n)\\)，和递归使用的栈大小相关，递归层数不超过n(一叉树) 如果可以到达一个节点两次(有左子树)，第二次逆序打印左子树上的右边界 最后走出循环后，逆序打印根节点的右边界 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new LinkedList&lt;&gt;(); TreeNode cur = root, mostRight = null; while (cur != null) &#123; mostRight = cur.left; if (mostRight != null) &#123; while (mostRight.right != null &amp;&amp; mostRight.right != cur) mostRight = mostRight.right; if (mostRight.right == null) &#123; mostRight.right = cur; cur = cur.left; continue; &#125; else &#123; // mostRight.right = cur mostRight.right = null; visit(cur.left, res); &#125; &#125; cur = cur.right; &#125; visit(root, res); return res; &#125; private void visit(TreeNode cur, List&lt;Integer&gt; res) &#123; TreeNode tail = reverse(cur); cur = tail; while (cur != null) &#123; res.add(cur.val); cur = cur.right; &#125; reverse(tail); &#125; private TreeNode reverse(TreeNode cur) &#123; TreeNode pre = null; while (cur != null) &#123; TreeNode next = cur.right; cur.right = pre; pre = cur; cur = next; &#125; return pre; &#125;&#125; 102. 二叉树的层序遍历 借助队列实现，关键在于通过queue.size来判断下一层的节点数！ Queue.offer(null)的话，size为1！ 226. 翻转二叉树 这道题目背后有一个让程序员心酸的故事，听说 Homebrew的作者Max Howell，就是因为没在白板上写出翻转二叉树，最后被Google拒绝了。（真假不做判断，权当一个乐子哈） 要求：左右子树交换位置 方法一：bfs层级遍历 时间复杂度：所有节点都需要入队，出队一次，所以是\\(O(n)\\) 空间复杂度：在最坏的情况下，给定的树是满二叉树，所有叶节点(\\(n/2 + 1\\))都要入队，所以是\\(O(n)\\) 1234567891011121314151617181920212223class Solution &#123; public TreeNode invertTree(TreeNode root) &#123; if (root == null) return root; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); TreeNode cur; while (!queue.isEmpty()) &#123; cur = queue.poll(); reverse(cur); if (cur.left != null) queue.offer(cur.left); if (cur.right != null) queue.offer(cur.right); &#125; return root; &#125; private void reverse(TreeNode cur) &#123; TreeNode temp = cur.left; cur.left = cur.right; cur.right = temp; &#125;&#125; 方法二：dfs 12345678910111213141516171819class Solution &#123; public TreeNode invertTree(TreeNode root) &#123; // 反转所有左子树和右子树，对这棵树的所有节点 dfs(root); return root; &#125; private void dfs(TreeNode root) &#123; if (root == null) return; dfs(root.left); dfs(root.right); reverse(root); &#125; private void reverse(TreeNode root) &#123; TreeNode temp = root.left; root.left = root.right; root.right = temp; &#125;&#125; 101. 对称二叉树 方法一：拷贝+翻转+判断(高情商：刷一道，解三道！低情商：只会笨方法？还是看看远方的复杂度吧) 写了80行，一题三解！不分析复杂度了。。 方法二：BFS 假设树上一共有n 个节点。 时间复杂度：遍历了整棵树，\\(O(n)\\) 空间复杂度：和使用的队列大小相关，在最坏的情况下，给定的树是满二叉树，所有叶节点(\\(n/2 + 1\\))都要入队，所以是\\(O(n)\\) 注意：如果p,q都为空，continue！而不是return truel！！！ 1234567891011121314151617181920212223class Solution &#123; public boolean isSymmetric(TreeNode root) &#123; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root.left); queue.offer(root.right); TreeNode p, q; while (!queue.isEmpty()) &#123; p = queue.poll(); q = queue.poll(); if (p == null &amp;&amp; q == null) continue; if (p == null || q == null) return false; if (p.val != q.val) return false; queue.offer(p.left); queue.offer(q.right); queue.offer(p.right); queue.offer(q.left); &#125; return true; &#125;&#125; 方法三：DFS YYDS 假设树上一共有n 个节点。 时间复杂度：遍历了整棵树，\\(O(n)\\) 空间复杂度：和递归使用的栈大小相关，递归层数不超过n(一叉树)，\\(O(n)\\) 123456789101112class Solution &#123; public boolean isSymmetric(TreeNode root) &#123; return dfs(root.left, root.right); &#125; private boolean dfs(TreeNode left, TreeNode right) &#123; if (left == null &amp;&amp; right == null) return true; if (left == null || right == null) return false; return (left.val == right.val) &amp;&amp; dfs(left.left, right.right) &amp;&amp; dfs(left.right, right.left); &#125;&#125; 100. 相同的树 对称二叉树方法一中用到了这个笨方法，顺手做了吧。 方法一：DFS 假设树上一共有\\(n\\)个节点 时间复杂度：遍历了整棵树，\\(O(n)\\) 空间复杂度：和递归使用的栈大小相关，递归层数不超过n，\\(O(n)\\) 方法二：BFS 只是和对称二叉树BFS解法中的入队顺序改变一点。 假设树上一共有n 个节点。 时间复杂度：遍历了整棵树，\\(O(n)\\) 空间复杂度：和使用的队列大小相关，在最坏的情况下，给定的树是满二叉树，所有叶节点(\\(n/2 + 1\\))都要入队，所以是\\(O(n)\\) 104. 二叉树的最大深度 方法一：BFS 时间复杂度：遍历整棵树，\\(O(n)\\) 空间复杂度：和使用的队列大小相关，在最坏情况下，给定的二叉树是满二叉树，\\(n/2 + 1\\)个叶节点要入队，所以是\\(O(n)\\) 方法二：DFS 假设树上一共有\\(n\\)个节点 时间复杂度：遍历了整棵树，\\(O(n)\\) 空间复杂度：和递归使用的栈大小相关，递归层数不超过n，\\(O(n)\\) 559. N 叉树的最大深度 同上题二叉树的最大深度，只是在遍历子节点的时候不同。 1234for (int i = 0; i &lt; cur.children.size(); i++) &#123; if (cur.children.get(i) != null) queue.offer(cur.children.get(i));&#125; 111. 二叉树的最小深度 最小深度是从根节点到最近叶子节点的最短路径上的节点数量 方法一：DFS 首先递归左子树和右子树 如果左子树为空，那么返回右子树的高度 + 1；如果右子树为空， 那么返回左子树的高度 + 1 如果左右子树都不为空，那么返回他们最小高度 + 1 12345678910111213class Solution &#123; public int minDepth(TreeNode root) &#123; if (root == null) return 0; int leftDepth = minDepth(root.left); int rightDepth = minDepth(root.right); if (root.left == null) return rightDepth + 1; if (root.right == null) return leftDepth + 1; return Math.min(leftDepth, rightDepth) + 1; &#125;&#125; 方法二：BFS 通过队列的size知道这是第几层，上一层加入队列节点的个数就是队列的size，在得到size的同时，将记录最小深度的变量minDepth加一 遍历到第一个叶子节点的当前层数就是二叉树的最小深度 时间复杂度：遍历整棵树，\\(O(n)\\) 空间复杂度：和使用的队列大小相关，在最坏情况下，给定的二叉树是满二叉树，\\(n/2 + 1\\)个叶节点要入队，所以是\\(O(n)\\) 123456789101112131415161718192021222324class Solution &#123; public int minDepth(TreeNode root) &#123; if (root == null) return 0; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); TreeNode cur; int minDepth = 0; while (!queue.isEmpty()) &#123; int size = queue.size(); ++minDepth; while (size-- &gt; 0) &#123; cur = queue.poll(); if (cur.left == null &amp;&amp; cur.right == null) return minDepth; if (cur.left != null) queue.offer(cur.left); if (cur.right != null) queue.offer(cur.right); &#125; &#125; return minDepth; &#125;&#125; 222. 完全二叉树的节点个数 方法一：BFS 在每层开始遍历时，记录节点个数的变量加上队列里元素个数 方法二：DFS 边界：如果是空节点，返回0 递归左子树和右子树+1(当前节点) 12345678910class Solution &#123; public int countNodes(TreeNode root) &#123; return dfs(root); &#125; public int dfs(TreeNode root) &#123; if (root == null) return 0; return 1 + dfs(root.left) + dfs(root.right); &#125;&#125; 110. 平衡二叉树 方法一：先序DFS 终止条件：如果root为空，返回true 首先求当前节点左右子树高度是否&lt;=1，再判断递归左子树和右子树 时间复杂度：\\(O(n^2)\\) 空间复杂度：\\(O(n)\\) 123456789101112class Solution &#123; public boolean isBalanced(TreeNode root) &#123; if (root == null) return true; return Math.abs(height(root.left) - height(root.right)) &lt;= 1 &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right); &#125; private int height(TreeNode root) &#123; if (root == null) return 0; return Math.max(height(root.left), height(root.right)) + 1; &#125;&#125; 方法二：后序DFS:warning: 只需遍历所有节点一次 时间复杂度\\(O(n)\\) 空间复杂度\\((n)\\) 1234567891011121314151617class Solution &#123; public boolean isBalanced(TreeNode root) &#123; return height(root) &gt;= 0; &#125; public int height(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; int leftHeight = height(root.left); int rightHeight = height(root.right); if (leftHeight == -1 || rightHeight == -1 || Math.abs(leftHeight - rightHeight) &gt; 1) &#123; return -1; &#125; else &#123; return Math.max(leftHeight, rightHeight) + 1; &#125; &#125;&#125; 257. 二叉树的所有路径:warning: 方法一：BFS 1234567891011121314151617181920212223242526class Solution &#123; public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123; List&lt;String&gt; result = new LinkedList&lt;&gt;(); Queue&lt;Object&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); queue.offer(String.valueOf(root.val)); TreeNode cur; String path = &quot;&quot;; while (!queue.isEmpty()) &#123; cur = (TreeNode)queue.poll(); path = (String)queue.poll(); if (cur.left == null &amp;&amp; cur.right == null) &#123; result.add(path); &#125; if (cur.left != null) &#123; queue.offer(cur.left); queue.offer(path + &quot;-&gt;&quot; + String.valueOf(cur.left.val)); &#125; if (cur.right != null) &#123; queue.offer(cur.right); queue.offer(path + &quot;-&gt;&quot; + String.valueOf(cur.right.val)); &#125; &#125; return result; &#125;&#125; 方法二：DFS 1234567891011121314151617181920class Solution &#123; List&lt;String&gt; result = new LinkedList&lt;&gt;(); public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123; dfs(root, &quot;&quot;); return result; &#125; public void dfs(TreeNode root, String path) &#123; if (root == null) return; path += String.valueOf(root.val); if (root.left == null &amp;&amp; root.right == null) &#123; result.add(path); &#125; else &#123; path += &quot;-&gt;&quot;; dfs(root.left, path); dfs(root.right, path); &#125; &#125; &#125; 404. 左叶子之和 :warning:方法一：DFS 12345678910111213141516171819202122class Solution &#123; public int sumOfLeftLeaves(TreeNode root) &#123; if (root.left == null &amp;&amp; root.right == null) return 0; return dfs(root); &#125; private int dfs(TreeNode root) &#123; if (root == null) return 0; int sum = 0; if (root.left != null) &#123; sum += isLeaf(root.left) ? root.left.val : dfs(root.left); &#125; if (root.right != null) &#123; sum += dfs(root.right); &#125; return sum; &#125; private boolean isLeaf(TreeNode root) &#123; return root.left == null &amp;&amp; root.right == null; &#125;&#125; 513. 找树左下角的值 :warning:方法一：DFS 12345678910111213141516171819class Solution &#123; int curHeight = 0; int curValue = 0; public int findBottomLeftValue(TreeNode root) &#123; dfs(root, 0); return curValue; &#125; private void dfs(TreeNode root, int height) &#123; if (root == null) return; ++height; dfs(root.left, height); dfs(root.right, height); if (height &gt; curHeight) &#123; curHeight = height; curValue = root.val; &#125; &#125;&#125; 方法二：BFS 从右往左层次遍历，最后一个访问的节点就是树左下角的值！ 12345678910111213141516171819class Solution &#123; public int findBottomLeftValue(TreeNode root) &#123; TreeNode cur; int res = 0; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while (!queue.isEmpty()) &#123; cur = queue.poll(); if (cur.right != null) &#123; queue.offer(cur.right); &#125; if (cur.left != null) &#123; queue.offer(cur.left); &#125; res = cur.val; &#125; return res; &#125;&#125; 112. 路径总和 方法一：BFS 初始化一个Object类型队列，用于存放节点与节点的值，首先把根节点和根节点的值offer进队列 开始while循环，循环的执行条件是队列不为空 首先按顺序取出节点和节点的值，注意这里需要强转 判断当前节点是否为根节点且节点的值是否为目标值，如果满足，直接return true 如果左子树不为空，先将左子树节点offer进队列，再将左子树的值加上poll出的当前节点的值offer进队列 如果右子树不为空，先将右子树节点offer进队列，再将右子树的值加上poll出的当前节点的值offer进队列 如果有这么一条路径，那么在while循环中就会return true，不会执行到这；如果没有满足条件的路径，则返回false 1234567891011121314151617181920212223242526class Solution &#123; public boolean hasPathSum(TreeNode root, int targetSum) &#123; if (root == null) return false; Queue&lt;Object&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); queue.offer(root.val); TreeNode cur; while (!queue.isEmpty()) &#123; cur = (TreeNode)queue.poll(); int val = (int)queue.poll(); if (cur.left == null &amp;&amp; cur.right == null &amp;&amp; val == targetSum) &#123; return true; &#125; if (cur.left != null) &#123; queue.offer(cur.left); queue.offer(val + cur.left.val); &#125; if (cur.right != null) &#123; queue.offer(cur.right); queue.offer(val + cur.right.val); &#125; &#125; return false; &#125;&#125; |:warning::warning:方法二：DFS 123456789class Solution &#123; public boolean hasPathSum(TreeNode root, int targetSum) &#123; if (root == null) return false; if (root.left == null &amp;&amp; root.right == null) return targetSum == root.val; return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val); &#125;&#125; 113. 路径总和 II 方法一：BFS 使用队列存放当前节点和累加节点值 使用HashMap记录每个节点的父节点 当节点满足是叶节点且累加值等于targetSum时，通过HashMap，从该叶子节点遍历到根节点记录到list中，最后把list反转 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int targetSum) &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); if (root == null) return res; Queue&lt;Object&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); queue.offer(root.val); TreeNode cur; Map&lt;TreeNode, TreeNode&gt; sonFather = new HashMap&lt;&gt;(); while (!queue.isEmpty()) &#123; cur = (TreeNode)queue.poll(); int val = (Integer)queue.poll(); if (cur.left == null &amp;&amp; cur.right == null &amp;&amp; val == targetSum) &#123; res.add(getPath(cur, sonFather)); &#125; if (cur.left != null) &#123; queue.offer(cur.left); queue.offer(val + cur.left.val); sonFather.put(cur.left, cur); &#125; if(cur.right != null) &#123; queue.offer(cur.right); queue.offer(val + cur.right.val); sonFather.put(cur.right, cur); &#125; &#125; return res; &#125; private List&lt;Integer&gt; getPath(TreeNode node, Map&lt;TreeNode, TreeNode&gt; sonFather) &#123; List&lt;Integer&gt; path = new LinkedList&lt;&gt;(); path.add(node.val); while (node != null) &#123; node = sonFather.get(node); path.add(node.val); &#125; Collections.reverse(path); return path; &#125; :warning:方法二：DFS 使用双端队列，每次dfs将当前节点值放入双端队列队尾，并让targetSum减去当前节点元素 如果当前节点是叶子节点且targetSum等于0，那么说明这条路径满足条件，将path加入结果 每次dfs完左右，再将双端队列最后一个元素移除！！！ 1234567891011121314151617181920class Solution &#123; Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int targetSum) &#123; dfs(root, targetSum); return res; &#125; private void dfs(TreeNode root, int targetSum) &#123; if (root == null) return; path.offerLast(root.val); targetSum -= root.val; if (root.left == null &amp;&amp; root.right == null &amp;&amp; targetSum == 0) &#123; res.add(new LinkedList&lt;&gt;(path)); &#125; dfs(root.left, targetSum); dfs(root.right, targetSum); path.pollLast(); &#125;&#125; :star:方法三：回溯(其实方法二也是回溯) 递归终止条件是：节点为空 123456789101112131415161718192021222324252627282930313233343536/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int targetSum) &#123; if (root == null) return res; dfs(root, targetSum); return res; &#125; private void dfs(TreeNode root, int targetSum) &#123; if (root == null) return; path.add(root.val); if (root.left == null &amp;&amp; root.right == null &amp;&amp; targetSum == root.val) &#123; res.add(new LinkedList(path)); &#125; dfs(root.left, targetSum - root.val); dfs(root.right, targetSum - root.val); path.removeLast(); &#125;&#125; :star:106. 从中序与后序遍历序列构造二叉树 草稿构造一棵二叉树，写出中序和后序序列 确定好边界条件：左闭右闭 后序序列最后一个元素是根，通过HashMap找到根节点下标 根节点左边的长度为lenOfLeft，那么先序序列和后序序列的前lenOfLeft为根节点的左子树 12345678910111213141516171819202122232425262728class Solution &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); public TreeNode buildTree(int[] inorder, int[] postorder) &#123; if (postorder == null) return null; for (int i = 0; i &lt; inorder.length; ++i) &#123; map.put(inorder[i], i); &#125; // [start, end - 1]左闭右闭 return dfs(inorder, 0, inorder.length - 1, postorder, 0, postorder.length - 1); &#125; private TreeNode dfs(int[] inorder, int inStart, int inEnd, int[] postorder, int postStart, int postEnd) &#123; if (inStart &gt; inEnd || postStart &gt; postEnd) return null; // 找到postorder最后一个元素的下标，也就是根节点 int rootValue = postorder[postEnd]; // 找到inorder中根节点的位置 int rootIdx = map.get(rootValue); // 构造树节点 TreeNode root = new TreeNode(rootValue); // 根据inorder切割左子树的大小，那么剩下的就是右子树 int lenOfLeft = rootIdx - inStart; // 按照根节点切割成左子树和右子树 root.left = dfs(inorder, inStart, rootIdx - 1, postorder, postStart, postStart + lenOfLeft - 1); root.right = dfs(inorder, rootIdx + 1, inEnd, postorder, postStart + lenOfLeft, postEnd - 1); return root; &#125;&#125; 105. 从前序与中序遍历序列构造二叉树 注意：int lenOfLeft = rootIdx - inStart; ！！！！！！！！ 1234567891011121314151617181920212223class Solution &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); public TreeNode buildTree(int[] preorder, int[] inorder) &#123; int length = inorder.length; for (int i = 0; i &lt; length; ++i) map.put(inorder[i], i); // [)左闭右开 return dfs(inorder, 0, length, preorder, 0, length); &#125; private TreeNode dfs(int[] inorder, int inStart, int inEnd, int[] preorder, int preStart, int preEnd) &#123; if (inStart &gt;= inEnd || preStart &gt;= preEnd) return null; // 找到根节点 int rootVal = preorder[preStart]; int rootIdx = map.get(rootVal); // 中序遍历中根节点左边的长度 int lenOfLeft = rootIdx - inStart; TreeNode root = new TreeNode(rootVal); root.left = dfs(inorder, inStart, rootIdx, preorder, preStart + 1, preStart + 1 + lenOfLeft); root.right = dfs(inorder, rootIdx + 1, inEnd, preorder, preStart + 1 + lenOfLeft, preEnd); return root; &#125;&#125; :star:654. 最大二叉树 方法一：DFS 思路同106. 从中序与后序遍历序列构造二叉树 123456789101112131415161718192021class Solution &#123; public TreeNode constructMaximumBinaryTree(int[] nums) &#123; return dfs(0, nums.length, nums); &#125; private TreeNode dfs(int start, int end, int[] nums) &#123; if (start &gt;= end) return null; int index = start; int maxValue = nums[start]; for (int i = start; i &lt; end; ++i) &#123; if (maxValue &lt; nums[i]) &#123; maxValue = nums[i]; index = i; &#125; &#125; TreeNode root = new TreeNode(maxValue); root.left = dfs(start, index, nums); root.right = dfs(index + 1, end, nums); return root; &#125;&#125; 617. 合并二叉树 解题思路：当树1当前节点的左子树或右子树为空，而树2当前节点左子树或右子树不为空时：使用parentQueue存储树1树2的当前节点parent1，parent2，在遍历到下一层时，使用parent1来指向parent2的左子树或者右子树。 Debug：如果cur1左子树为空，cur2左子树不为空，将cur1,cur2加入trashQueue；同理右子树。如果cur1左右子树都为空，cur2左右子树都不为空，将cur1,cur2加入parentQueue两次！！不然之后poll的时候空指针！！ :warning:方法二：DFS 123456789101112class Solution &#123; public TreeNode mergeTrees(TreeNode root1, TreeNode root2) &#123; if (root1 == null) return root2; if (root2 == null) return root1; root1.val += root2.val; root1.left = mergeTrees(root1.left, root2.left); root1.right = mergeTrees(root1.right, root2.right); return root1; &#125;&#125; 700. 二叉搜索树中的搜索 方法一：DFS 1234567891011121314151617class Solution &#123; public TreeNode searchBST(TreeNode root, int val) &#123; TreeNode cur = root; while (cur != null) &#123; if (cur.val == val) &#123; return cur; &#125; else if (cur.val &lt; val) &#123; cur = cur.right; &#125; else &#123; cur = cur.left; &#125; &#125; return null; &#125;&#125; :star:98. 验证二叉搜索树 方法一：中序遍历 中序遍历二叉搜索树应该是升序的，只需要一个记录上一个节点的值的遍历preVal，并与当前节点比较，如果当前节点的值小于等于preVal(cur.val应该严格&gt;preVal不能等于)，则返回false;否则，遍历完所有节点返回true。 假设树有n个节点 时间复杂度：遍历所有节点，\\(O(n)\\) 空间复杂度：和使用的栈相关，在最坏情况(每个节点都只有一个子节点)下，树的高度为n，都需要压栈，所以为\\(O(n)\\) 123456789101112131415161718192021class Solution &#123; public boolean isValidBST(TreeNode root) &#123; if (root == null) return true; long preVal = Long.MIN_VALUE; TreeNode cur = root; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); while (cur != null || !stack.isEmpty()) &#123; while (cur != null) &#123; stack.push(cur); cur = cur.left; &#125; cur = stack.pop(); if (cur.val &lt;= preVal) return false; preVal = cur.val; cur = cur.right; &#125; return true; &#125;&#125; :war:方法二：递归 1234567891011121314151617class Solution &#123; public boolean isValidBST(TreeNode root) &#123; if (root == null) return true; return dfs(TreeNode root, long.MIN_VALUE, long.MAX_VALUE) &#125; public boolean dfs(TreeNode root, long pre, long post) &#123; if (root == null) return true; if (root.val &lt;= pre || root.val &gt;= post) return false; return dfs(root.left, pre, root.val) &amp;&amp; dfs(root.right, root.val, post); &#125;&#125; 方法三：Morris中序遍历 Morris遍历利用叶子节点的左右空指针，实现空间开销的极限缩减。 morris遍历的实现原则 记作当前节点为cur。 如果cur无左孩子，cur向右移动（cur=cur.right） 如果cur有左孩子，找到cur左子树上最右的节点，记为mostright 如果mostright的right指针指向空，让其指向cur，cur向左移动（cur=cur.left） 如果mostright的right指针指向cur，让其指向空，cur向右移动（cur=cur.right） 实现以上的原则，即实现了morris遍历。 morris遍历的实质 建立一种机制，对于没有左子树的节点只到达一次，对于有左子树的节点会到达两次 Morris中序遍历 如果可以到达一个节点两次(有左子树)，第二次访问 如果可以到达一个节点一次(无左子树)，直接访问 举个例子 从根节点5开始遍历，令cur = 根节点5，找到mostRight为节点1 节点1的右子树为空，将节点1的右子树指向节点5，并让cur移动到左子树(节点1) 开始遍历节点1，由于节点一无左子树，直接访问，比较节点一与preValue(初始化为最小值)， 1 &lt; Long.MIN_VALUE，将节点1的val赋值给preValue 将cur(1)移动到右子树，此时cur为之前访问过的根节点5，继续找到cur(5)左子树的最右节点1，发现节点1的右子树为当前节点cur(5)，将节点1的右子树还原为空 此时是第二次到达节点5，比较节点5与preValue(1)，并将5赋值给preValue，cur向右子树移动，此时cur到达节点4 找到cur(4)左子树的最右节点3，将节点3的右子树指向cur(4)，cur向左子树移动，此时cur到达节点3 由于节点3无左子树，直接比较节点3与preValue(5)的值，3&lt;5，返回false。 可以发现中序遍历的顺序是：15346 Morris中序遍历到达的节点顺序是：5154346，其中5和4有左子树，在到底5和4的第二次时作比较。 1234567891011121314151617181920212223242526class Solution &#123; public boolean isValidBST(TreeNode root) &#123; TreeNode cur = root, mostRight = null; long preValue = Long.MIN_VALUE; while (cur != null) &#123; mostRight = cur.left; if (mostRight != null) &#123; while (mostRight.right != null &amp;&amp; mostRight.right != cur) mostRight = mostRight.right; if (mostRight.right == null) &#123; mostRight.right = cur; cur = cur.left; continue; &#125; else if (mostRight.right == cur) &#123; mostRight.right = null; &#125; &#125; if (cur.val &lt;= preValue) return false; preValue = cur.val; cur = cur.right; &#125; return true; &#125;&#125; 时间复杂度：遍历所有节点，\\(O(n)\\) 空间复杂度：Morris遍历利用叶子节点的左右空指针，实现空间开销的极限缩减，\\(O(1)\\) 530. 二叉搜索树的最小绝对差 方法一：中序遍历 使用中序遍历二叉搜索树得到的结果是升序的。 :star::warning:方法二：双指针 双指针的思想真的很重要！！！ 初始化全局变量：pre节点初始化为空；diff存储相邻节点差值，初始化为整型最大值 中序遍历过程：第一次遍历，pre是空的，还没遇到第二个节点也就没有相邻节点之间的差值； 把当前节点(root)赋给pre，那么下一个root就是中序遍历顺序pre的下一个节点 1234567891011121314151617class Solution &#123; TreeNode pre; int diff = Integer.MAX_VALUE; public int getMinimumDifference(TreeNode root) &#123; dfs(root); return diff; &#125; private void dfs(TreeNode root) &#123; if (root == null) return; dfs(root.left); if (pre != null) diff = Math.min(diff, root.val - pre.val); pre = root; dfs(root.right); &#125;&#125; 501. 二叉搜索树中的众数 老样子，中序遍历 遍历的过程 1234567891011121314151617if (preVal == cur.val) &#123; ++counter;&#125;else &#123; counter = 1;&#125;if (!modes.contains(cur.val) &amp;&amp; counter == maxCounter) &#123; modes.add(cur.val);&#125;if (counter &gt; maxCounter) &#123; maxCounter = counter; modes.removeAll(modes); modes.add(cur.val);&#125;preVal = cur.val;cur = cur.right; 236. 二叉树的最近公共祖先 方法一：用HashMap存储所有父节点，用HashSet标记是否访问过；从p开始向上遍历，并标记访问过的父节点，再从q开始向上遍历，如果当前节点被访问过，那么这个节点就是最近公共祖先。 注意：对于p，先设置visisted，再向上移；对于q，先判断当前节点是不是已经被visited，再向上移。如果p,q任意一者先向上移再操作，都会导致在，p或q是最近公共节点时，返回的却是p或q的父节点 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; Map&lt;TreeNode, TreeNode&gt; map = new HashMap&lt;&gt;(); Set&lt;TreeNode&gt; visited = new HashSet&lt;&gt;(); dfs(root, map); while (p != null) &#123; visited.add(p); p = map.get(p); &#125; while (q != null) &#123; if (visited.contains(q)) &#123; return q; &#125; q = map.get(q); &#125; return root; &#125; public void dfs(TreeNode root, Map&lt;TreeNode, TreeNode&gt; map) &#123; if (root == null) return; if (root.left != null) &#123; map.put(root.left, root); &#125; if (root.right != null) &#123; map.put(root.right, root); &#125; dfs(root.left, map); dfs(root.right, map); &#125;&#125; :warning:方法二：DFS 题解 可以不判断非p,q的叶节点 12345678910111213141516class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; return dfs(root, p, q); &#125; public TreeNode dfs(TreeNode root, TreeNode p, TreeNode q) &#123; if (root == null || root == p || root == q) return root; TreeNode left = dfs(root.left, p, q); TreeNode right = dfs(root.right, p, q); if (left == null) return right; if (right == null) return left; return root; &#125;&#125; 235. 二叉搜索树的最近公共祖先 递归：考虑三种情况 p,q是root：return root p,q在root两侧，(p.val &lt; root.val &amp;&amp; q.val &gt; root.val) || (p.val &gt; root.val &amp;&amp; q.val &lt; root.val)， return root p,q在root同一侧 (p.val &lt; root &amp;&amp; q.val &lt; root.val) || (p.val &gt; root.val &amp;&amp; q.val &gt; root.val) p.val &lt; root &amp;&amp; q.val &lt; root.val: return dfs(left, p, q) p.val &gt; root.val &amp;&amp; q.val &gt; root.val: return dfs(right, p, q) 方法一：DFS 1234567891011class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if (root == null) return null; if (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) return lowestCommonAncestor(root.left, p, q); if (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) return lowestCommonAncestor(root.right, p, q); return root; &#125;&#125; 701. 二叉搜索树中的插入操作 要点是：如何记录要插入节点的父节点 方法一：栈 从根节点开始遍历，用栈存储每个遍历过的节点，大于向右小于向左；循环结束，判断插入最后一个被遍历的节点(栈中最顶层节点)，判断大于小于，插入，结束。 遍历过程把所有元素放进栈，空节点跳出循环后，栈顶元素就是要插入节点的父节点 1234567891011121314151617181920212223242526class Solution &#123; public TreeNode insertIntoBST(TreeNode root, int val) &#123; if (root == null) return new TreeNode(val); TreeNode cur = root; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); while (cur != null) &#123; stack.push(cur); if (val &lt; cur.val) &#123; cur = cur.left; &#125; else &#123; cur = cur.right; &#125; &#125; cur = stack.pop(); TreeNode newNode = new TreeNode(val); if (cur.val &gt; val) &#123; cur.left = newNode; &#125; else &#123; cur.right = newNode; &#125; return root; &#125;&#125; 方法二：双指针 用pre指针指向上一个节点，有两个要注意的地方 初始化pre指针时，不能初始化为null，如果根节点没有左子树，而要插入的节点小于根节点，要插入的节点会成为根节点的左子树，这种情况判断一次就会跳出while循环，此时pre还是null，所以要把pre初始化为根节点 在while循环中，用pre=cur记录cur的上一个节点，但是，最后cur等于空的时候，pre再记录cur就没有意义了，所以加上if (cur != null)判断条件 123456789101112131415161718192021class Solution &#123; public TreeNode insertIntoBST(TreeNode root, int val) &#123; TreeNode res = new TreeNode(val); if (root == null) return res; TreeNode cur = root, pre = root; while (cur != null) &#123; if (cur.val &gt; val) cur = cur.left; else if (cur.val &lt; val) cur= cur.right; if (cur != null) pre = cur; &#125; if (val &gt; pre.val) pre.right = res; else pre.left = res; return root; &#125;&#125; 方法三：DFS 当时想出来了，但是卡在怎么插入这个点上，其实这里已经用root.left或者root.right来接收 new TreeNode(val)了。==构造树==！！！ 12345678910111213class Solution &#123; public TreeNode insertIntoBST(TreeNode root, int val) &#123; if (root == null) &#123; return new TreeNode(val); &#125; if (val &lt; root.val) &#123; root.left = insertIntoBST(root.left, val); &#125; else &#123; root.right = insertIntoBST(root.right, val); &#125; return root; &#125;&#125; x450. 删除二叉搜索树中的节点 解题思路： 如果目标节点大于当前节点值，则去右子树中删除； 如果目标节点小于当前节点值，则去左子树中删除； 如果目标节点就是当前节点，分为以下三种情况： 其无左子：其右子顶替其位置，删除了该节点； 其无右子：其左子顶替其位置，删除了该节点； 其左右子节点都有：其左子树转移到其右子树的最左节点的左子树上，然后右子树顶替其位置，由此删除了该节点。 写了快100行，重构一下代码。。 方法一：迭代 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public TreeNode deleteNode(TreeNode root, int key) &#123; if (root == null) return root; TreeNode cur = root, pre = root; while (cur != null) &#123; if (cur.val == key) &#123; if (cur.left == null &amp;&amp; cur.right == null) &#123; // 叶子节点 if (pre.val &lt; key) pre.right = null; else pre.left = null; &#125; else &#123; if (cur.left != null &amp;&amp; cur.right != null) &#123; // 找到要删除节点右子树上的最左节点，再把要删除节点左子树挂上去 TreeNode left = cur.left, right = cur.right; cur = cur.right; while (cur.left != null) cur = cur.left; cur.left = left; if (pre.val &lt; key) pre.right = right; else pre.left = right; &#125; else if (cur.left == null &amp;&amp; cur.right != null) &#123; TreeNode right = cur.right; if (pre.val &lt; key) pre.right = right; else pre.left = right; &#125; else if (cur.left != null &amp;&amp; cur.right == null) &#123; TreeNode left = cur.left; if (pre.val &lt; key) pre.right = left; else pre.left = left; &#125; &#125; break; &#125; else if (cur.val &lt; key) &#123; pre = cur; cur = cur.right; &#125; else &#123; pre = cur; cur = cur.left; &#125; &#125; if (root.val == key) &#123; return root.left == null ? root.right : root.left; &#125; return root; &#125;&#125; :star:方法二：DFS 注意代码注释部分是完全冗余的！ 123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public TreeNode deleteNode(TreeNode root, int key) &#123; if (root == null) return root; if (key &lt; root.val) root.left = deleteNode(root.left, key); else if (key &gt; root.val) root.right = deleteNode(root.right, key); else &#123; //(key == root.val) &#123; if (root.left == null &amp;&amp; root.right == null) &#123; return null; &#125; else if (root.left == null &amp;&amp; root.right != null) &#123; return root.right; &#125; else if (root.left != null &amp;&amp; root.right == null) &#123; return root.left; &#125; else &#123; TreeNode cur = root.right; while (cur.left != null) cur = cur.left; cur.left = root.left; return root.right; &#125; &#125; // if (root.val == key) &#123; // if (root.left == null &amp;&amp; root.right == null) // return null; // else &#123; // return root.left == null ? root.right : root.left; // &#125; // &#125; return root; &#125;&#125; :warning:669. 修剪二叉搜索树 借上一题的思路直接速通了 108. 将有序数组转换为二叉搜索树 方法一：二分DFS[左闭右闭] 方法二：DFS[左闭右开)]，开区间元素在record的数值要--，闭区间元素在record的位置要++，开区间元素和闭区间元素都为‘a’，所以s的下标1以‘b’开始的子串“ba”也是变位词！ 1234567891011121314151617181920212223242526272829class Solution &#123; public List&lt;Integer&gt; findAnagrams(String s, String p) &#123; List&lt;Integer&gt; index = new LinkedList&lt;&gt;(); if (s.length() &lt; p.length()) return index; int[] record = new int[26]; for (int i = 0; i &lt; p.length(); ++i) &#123; ++record[p.charAt(i) - &#x27;a&#x27;]; --record[s.charAt(i) - &#x27;a&#x27;]; &#125; if (areZeros(record)) &#123; index.add(0); &#125; for (int i = p.length(); i &lt; s.length(); ++i) &#123; ++record[s.charAt(i - p.length()) - &#x27;a&#x27;]; --record[s.charAt(i) - &#x27;a&#x27;]; if (areZeros(record)) &#123; index.add(i - p.length() + 1); &#125; &#125; return index; &#125; private boolean areZeros(int[] record) &#123; for (int element : record) if (element != 0) return false; return true; &#125;&#125; 1208. 尽可能使字符串相等:warning: 方法一：滑动窗口 123456789101112131415161718class Solution &#123; public int equalSubstring(String s, String t, int maxCost) &#123; int n = s.length(); int[] diff = new int[n]; for (int i = 0; i &lt; n; ++i) &#123; diff[i] = Math.abs(s.charAt(i) - t.charAt(i)); &#125; int res = 0, start = 0, sum = 0; for (int end = 0; end &lt; n; ++end) &#123; sum += diff[end]; while (maxCost &lt; sum) &#123; sum -= diff[start++]; &#125; res = Math.max(res, end - start + 1); &#125; return res; &#125;&#125; String补充知识 String与char数组，StringBuilder之间相互转换 将String转换为char数组： 12codeString str = &quot;hello&quot;;char[] charArray = str.toCharArray(); 将char数组转换为String： 12codechar[] charArray = &#123;&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;&#125;;String str = new String(charArray); 将String转换为StringBuilder： 123456//1.codeString str = &quot;hello&quot;;StringBuilder sb = new StringBuilder(str);//2.StringBuilder sb = new StringBuilder();sb.append(str); 将StringBuilder转换为String： 123codeStringBuilder sb = new StringBuilder();sb.append(&quot;hello&quot;);String str = sb.toString(); 将char数组转换为StringBuilder： 123codechar[] charArray = &#123;&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;&#125;;StringBuilder sb = new StringBuilder();sb.append(charArray); 将StringBuilder转换为char数组： 123codeStringBuilder sb = new StringBuilder(&quot;hello&quot;);char[] charArray = new char[sb.length()];sb.getChars(0, sb.length(), charArray, 0); 需要注意的是，在将String转换为char数组或char时，如果字符串为空，或者字符串中的字符数量为0，则可能会导致越界异常或其他异常。因此，在进行这些转换操作时，需要进行有效性检查和异常处理。 单个字符char转换为String 在Java中，将单个字符（char）转换为字符串（String）有以下两种方法： 1.使用字符串连接符 您可以使用字符串连接符\"+\"来连接一个空字符串和单个字符，从而将其转换为字符串。例如： 12arduinoCopy codechar c = &#x27;a&#x27;;String s = &quot;&quot; + c; 在上面的代码中，首先创建一个空字符串，然后使用字符串连接符将其与字符\"c\"连接起来，从而将字符\"c\"转换为字符串。现在，字符串s将包含字符\"c\"的字符串。 2.使用String.valueOf()方法 另一种将单个字符转换为字符串的方法是使用String类的valueOf()方法。例如： 12arduinoCopy codechar c = &#x27;a&#x27;;String s = String.valueOf(c); 在上面的代码中，将字符\"c\"传递给valueOf()方法，并将返回的字符串分配给变量s。 无论使用哪种方法，您都可以将单个字符转换为字符串，从而可以对其进行各种字符串操作。 StringBuilder的append可以是char或者String StringBuilder的append()方法可以接受char类型和String类型的参数。append()方法的作用是在StringBuilder对象的末尾追加指定的字符序列，这可以是char、String、StringBuilder或其他CharSequence实例。 以下是使用StringBuilder的append()方法追加char和String类型参数的示例代码： 追加char类型参数： 123codeStringBuilder sb = new StringBuilder();char c = &#x27;a&#x27;;sb.append(c); 追加String类型参数： 123codeStringBuilder sb = new StringBuilder();String str = &quot;hello&quot;;sb.append(str); 需要注意的是，使用append()方法追加char类型参数时，会自动将char类型转换为String类型。因此，如果需要在StringBuilder中追加一个char类型的字符，可以直接使用append()方法，而不需要先将其转换为String类型。 KMP算法 生成next数组讲得很透彻 Array 704. 二分查找 方法一：左闭右开 区间：[left, right) 初始化：right = nums.length while循环终止条件应为left &lt; right（右开，right不能等于left） 当nums[mid] &lt; target时，nums[0]~nums[mid]都小于target，此时有效的有边界是mid - 1，又因为右边界是开区间，所以另right = mid 时间复杂度：\\(O(logn)\\)，由于每次查找都会将查找范围缩小一半，因此二分查找的时间复杂度是\\(O(logn)\\)，其中 n 是数组的长度 空间复杂度：\\(O(1)\\) 12345678910111213141516class Solution &#123; public int search(int[] nums, int target) &#123; int left = 0, right = nums.length; // [left, right) while(left &lt; right) &#123; int mid = left + ((right - left) &gt;&gt; 1); if (nums[mid] == target) return mid; else if (nums[mid] &lt; target) left = mid + 1; else right = mid; &#125; return -1; &#125;&#125; 方法二：左闭右闭 区间：[left, right] 初始化：right = nums.length - 1 while循环终止条件应为left &lt;= right 当nums[mid] &lt; target时，nums[0]~nums[mid]都小于target，另right = mid - 1 时间复杂度：\\(O(logn)\\)，由于每次查找都会将查找范围缩小一半，因此二分查找的时间复杂度是\\(O(logn)\\)，其中 n 是数组的长度 空间复杂度：\\(O(1)\\) 123456789101112131415class Solution &#123; public int search(int[] nums, int target) &#123; int left = 0, right = nums.length - 1; while (left &lt;= right) &#123; int mid = right - ((right - left) &gt;&gt; 1); if (nums[mid] &gt; target) right = mid - 1; else if (nums[mid] &lt; target) left = mid + 1; else return mid; &#125; return -1; &#125;&#125; 27. 移除元素 方法一：暴力 每当发现一个数相等，那么从当前数组的下一个数开始，全部往前移一位。 注意：因为移位后，下一个要访问的数组元素j会到当前i的位置，然后for循环结束i自增，会错过访j，所以移位后要--i。 时间复杂度：\\(O(n^2)\\) 空间复杂度：\\(O(1)\\) 12345678910111213141516171819class Solution &#123; public int removeElement(int[] nums, int val) &#123; int newLen = nums.length; if (newLen == 0) return 0; for (int i = 0; i &lt; newLen; i++) &#123; if (nums[i] == val) &#123; for (int j = i + 1; j &lt; newLen; j++) &#123; nums[j - 1] = nums[j]; &#125; --newLen; --i; &#125; &#125; return newLen; &#125;&#125; 方法二：双指针 初始化慢指针为0 for循环遍历快指针，当nums[fast] != val时，令nums[slow] = nums[fast]，slow指针往后移。也就是说，如果快指针找到了val，那么慢指针停在val位置，之后快指针遍历到非val的位置时，将该非val数据覆盖到慢指针的指向数组位置的数据。 最后返回慢指针(慢指针大小代表新数组的大小) 时间复杂度：\\(O(n)\\) 空间复杂度：\\(O(1)\\) 123456789101112class Solution &#123; public int removeElement(int[] nums, int val) &#123; int slow = 0; for (int fast = 0; fast &lt; nums.length; ++fast) &#123; if (nums[fast] != val) &#123; nums[slow] = nums[fast]; ++slow; &#125; &#125; return slow; &#125;&#125; 方法三：相向双指针 避免了需要保留的元素的重复赋值操作。 初始化：left=0, right=nums.length-1，左闭右闭区间，所以while语句的执行条件是 left &lt;= right(如果没有等于，left会少后移一次) 循环：当nums[left]不等于val时，left指针后移；当nums[left]等于val时，将nums[right]赋值给nums[left]，right指针前移；如果赋值过来的元素恰好也等于val，可以继续把右指针 right指向的元素的值赋值过来，直到左指针指向的元素的值不等于 val为止。 时间复杂度：\\(O(n)\\) 空间复杂度：\\(O(1)\\) 12345678910111213141516class Solution &#123; public int removeElement(int[] nums, int val) &#123; int left = 0, right = nums.length - 1; // [left, right] while (left &lt;= right) &#123; if (nums[left] == val) &#123; nums[left] = nums[right]; --right; &#125; else &#123; ++left; &#125; &#125; return left; &#125;&#125; 977. 有序数组的平方 双指针 left,right指针指向数组两端，将较大的平方数放入result数组里。 时间复杂度：\\(O(n)\\) 空间复杂度：\\(O(n)\\) 209. 长度最小的子数组 nums[++i]先执行自增操作还是数组寻址操作? 在Java中，表达式nums[++i]中的++i是先自增还是先寻址是有规定的。按照Java的运算符优先级规定，前置自增运算符++i的优先级高于数组下标运算符[]，因此在执行这个表达式时，先进行++i自增运算，然后再进行数组下标运算，即先自增再寻址。 因此，nums[++i]相当于先将变量i自增1，然后使用自增后的i作为数组下标去访问nums数组中的元素。如果i的初始值为0，那么nums[++i]将访问nums[1]位置上的元素，而不是nums[0]。如果数组nums越界，将会抛出ArrayIndexOutOfBoundsException异常。 nums[i++]先执行自增操作还是数组寻址操作? 在这种情况下，nums[i++]实际上会先执行数组寻址操作，然后再对i进行自增操作。这是因为数组寻址操作的优先级比自增操作的优先级高。 具体来说，这个表达式会先使用i的当前值来计算nums数组中第i个元素的地址，然后将地址作为结果返回，接着才会将i的值加1。 int a = ++i 是先赋值还是先自增 这行代码会先自增变量 i 的值，然后将自增后的结果赋值给变量 a。所以，变量 a 的值等于自增后的变量 i 的值。这个过程中，变量 i 的值会被修改，而变量 a 的值则是这个修改后的值。 可以将这行代码拆分成两步： i = i + 1； // 自增 i 的值 a = i； // 将自增后的 i 的值赋值给 a 所以，最终变量 a 的值等于自增后的变量 i 的值。 int a = i++ 是先赋值还是先自增 这行代码会先将变量 i 的值赋值给变量 a，然后再将变量 i 的值自增。所以，变量 a 的值等于变量 i 的值，而变量 i 的值会被自增。 可以将这行代码拆分成两步： a = i； // 将 i 的值赋值给 a i = i + 1； // 自增 i 的值 所以，最终变量 a 的值等于变量 i 的初始值，而变量 i 的值则是初始值加一。 while(--index) 先-- 后比较index&gt;0 1234int index = 2;while (--index &gt; 0) &#123; System.out.print(index);&#125; stdout 1 while(index--) 先比较 后-- 1234int index = 2;while (index-- &gt; 0) &#123; System.out.print(index);&#125; stdout 10 System.out.print(--index) 先-- 后打印 1234int index = 2;while (index &gt; 0) &#123; System.out.print(--index);&#125; stdout 10 滑动窗口 注意：为了确保有些案例，sum一直小于target，最后输出判断：如果 result == Integer.MAX_VALUE，就输出0。 result记录最小的长度 时间复杂度：\\(O(n)\\) 空间复杂度：\\(O(1)\\) 123456789101112131415class Solution &#123; public int minSubArrayLen(int target, int[] nums) &#123; int counter = 0, result = Integer.MAX_VALUE; int sum = 0; for (int i = 0; i &lt; nums.length; ++i) &#123; ++counter; sum += nums[i]; while (sum &gt;= target) &#123; result = Math.min(result, counter); sum -= nums[i - (--counter)]; &#125; &#125; return result == Integer.MAX_VALUE ? 0 : result; &#125;&#125; 59. 螺旋矩阵 II 遍历顺序：从左到右(左闭右开)，从上到下(上闭下开)，从右到左(右闭左开)，从下到上(下闭上开) 思路见代码注释部分 时间复杂度：\\(O(n^2)\\) 空间复杂度：\\(O(1)\\) 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public int[][] generateMatrix(int n) &#123; // 用笔画一个n=5的矩阵作为例子 // 遍历顺序：从左到右(左闭右开)，从上到下(上闭下开)，从右到左(右闭左开)，从下到上(下闭上开) // 建立n行n列的矩阵 int[][] matrix = new int[n][n]; // 遍历次数 int traverseTime = n / 2; int i, j; // 写入数组的数 int data = 1; // cur:当前遍历伦茨 for (int cur = 0; cur &lt; traverseTime; ++cur) &#123; // 从左到右(左闭右开) for (j = cur; j &lt; n - cur - 1; ++j) &#123; matrix[cur][j] = data++; &#125; // 从上到下(上闭下开) for (i = cur; i &lt; n - cur - 1; ++i) &#123; matrix[i][j] = data++; &#125; // 从右到左(右闭左开) for (; j &gt; cur; --j) &#123; matrix[i][j] = data++; &#125; // 从下到上(下闭上开) for (; i &gt; cur; --i) &#123; matrix[i][j] = data++; &#125; // debug // for (int a = 0; a &lt; n; ++a) &#123; // for (int b = 0; b &lt; n; ++b) &#123; // System.out.print(matrix[a][b]); // &#125; // &#125; &#125; if (n % 2 == 1) matrix[traverseTime][traverseTime] = n * n; return matrix; &#125;&#125; 303. 区域和检索 - 数组不可变 方法一：暴力 1234567891011121314151617181920class NumArray &#123; private int[] nums; public NumArray(int[] nums) &#123; this.nums = nums; &#125; public int sumRange(int left, int right) &#123; int sum = 0; for (int i = left; i &lt;= right; ++i) &#123; sum += nums[i]; &#125; return sum; &#125;&#125;/** * Your NumArray object will be instantiated and called as such: * NumArray obj = new NumArray(nums); * int param_1 = obj.sumRange(left,right); */ 方法二：前缀和 建立一个长度为n+1的数组preSum 初始化preSum[0] = 0; preSum[i]表示数组nums从下标0到下标i-1的和 image-20230511111212882 区间[left,right]的和为preSum[right + 1] - preSum[left]; preSum[right + 1]表示数组从下标0到right的和，preSum[left]表示数组从下标0到left-1的和 将前缀和数组preSum的长度设为n+1的目标是为了方便计算sumRange(left, right)时，不需要对left=0的情况做特殊处理 12345678910111213141516171819class NumArray &#123; private int[] preSum; public NumArray(int[] nums) &#123; preSum = new int[nums.length + 1]; for (int i = 1; i &lt; preSum.length; ++i) &#123; preSum[i] = preSum[i - 1] + nums[i - 1]; &#125; &#125; public int sumRange(int left, int right) &#123; return preSum[right + 1] - preSum[left]; &#125;&#125;/** * Your NumArray object will be instantiated and called as such: * NumArray obj = new NumArray(nums); * int param_1 = obj.sumRange(left,right); */ 前缀和：前缀和数组为n，需要对left=0时做特殊处理 1234567891011121314151617181920212223class NumArray &#123; private int[] preSum; public NumArray(int[] nums) &#123; preSum = new int[nums.length]; preSum[0] = nums[0]; for (int i = 1; i &lt; preSum.length; ++i) &#123; preSum[i] = preSum[i - 1] + nums[i]; &#125; &#125; public int sumRange(int left, int right) &#123; if (left == 0) &#123; return preSum[right]; &#125; return preSum[right] - preSum[left - 1]; &#125;&#125;/** * Your NumArray object will be instantiated and called as such: * NumArray obj = new NumArray(nums); * int param_1 = obj.sumRange(left,right); */ 304. 二维区域和检索 - 矩阵不可变 方法一：前缀和:warning: 需要重刷！ 题解 image-20230511124326460 123456789101112131415161718192021class NumMatrix &#123; int[][] preSum; public NumMatrix(int[][] matrix) &#123; preSum = new int[matrix.length + 1][matrix[0].length + 1]; for (int i = 1; i &lt;= matrix.length; ++i) &#123; for (int j = 1; j &lt;= matrix[0].length; ++j) &#123; preSum[i][j] = matrix[i - 1][j - 1] + preSum[i - 1][j] + preSum[i][j - 1] - preSum[i - 1][j - 1]; &#125; &#125; &#125; public int sumRegion(int row1, int col1, int row2, int col2) &#123; return preSum[row2 + 1][col2 + 1] - preSum[row2 + 1][col1] - preSum[row1][col2 + 1] + preSum[row1][col1]; &#125;&#125;/** * Your NumMatrix object will be instantiated and called as such: * NumMatrix obj = new NumMatrix(matrix); * int param_1 = obj.sumRegion(row1,col1,row2,col2); */ 1109. 航班预订统计 LinkedList 203. 移除链表元素 解题思路：在面对链表、树有关创建、删除操作，使用dummyHead！能省去不少边界判定的功夫。 初始化：dummyHead指向head，dummyHead赋值给pre，head赋值给cur 当cur的值等于所求val，pre指向cur的下一个节点 当cur的值不等于val，pre移动到cur，cur往后移一位 返回dummyHead的下一个节点。 707. 设计链表 注意事项：DummyHead + size 206. 反转链表 用笔模拟一下指针pre，cur，next的过程 时间复杂度：\\(O(n^2)\\) 空间复杂度：\\(O(1)\\) 24. 两两交换链表中的节点 注意要点：用纸和笔模拟一下指针pre，cur，next的过程，记得创建dummyHead 时间复杂度：\\(O(n)\\) 空间复杂度：\\(O(1)\\) 19. 删除链表的倒数第 N 个结点 使用dummyHead，从dummyHead，找到倒数第N个节点的前一个节点node，需要走链表长度size - N步，即可把node指向下一个节点的下一个节点即可完成删除操作。 但是链表的长度是未知的，可以先遍历一遍链表的长度，求出size，再走size-N步完成删除操作。 也可以使用快慢指针，fast与slow的起始点都为dummyHead，fast先走N步，再让fast与slow一起右移，当fast走到最后一个节点时(fast.next == null时)，slow右移了size - N步，到达倒数第N个节点的上一个节点，即可完成删除操作。 时间复杂度：\\(O(n)\\) 空间复杂度：\\(O(1)\\) 面试题 02.07. 链表相交 方法一：HashSet 用指针A,B分别指向两个链表头 开始循环，循环的终止条件为A,B都为空，每次循环先将A,B指向的节点放入HashSet，再向后移 当遍历到某个已经存入HashSet的节点时，这个节点就是相交节点；否则没有相交节点 时间复杂度：\\(O(m + n)\\)，其中m，n分别为两个链表的长度 空间复杂度：\\(O(m + n)\\) 方法二：双指针 解题思路：A,B分别指向headA,headB，如果有公共节点，设公共节点长度为c，链表A和B长度分别为a,b。向右遍历，如何为空，则指向另一个链表的头。如果两个链表相交，则A向右移动了a+c+b步，B向右移动了b+c+a时相交，返回A；如果两个链表不相交，则A向右移动了a+b步，B向右移动了b+a步，都为空，退出循环返回null。 用指针A,B分别指向两个链表头headA,headB 开始循环，循环的条件是A和B不都为空，如果A为空，则A指向headB，否则向后移；如果B为空，则B指向headA，否则向后移 开始循环，循环的终止条件为A,B都为空，每次循环先将A,B指向的节点放入HashSet，再向后移 当遍历到某个已经存入HashSet的节点时，这个节点就是相交节点；否则没有相交节点 时间复杂度：\\(O(m + n)\\)，其中m，n分别为两个链表的长度 空间复杂度：\\(O(m + n)\\) 一个错误代码实例 1234567891011121314public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; if (headA == null || headB == null) return null; ListNode pA = headA, pB = headB; while (pA != null || pB != null) &#123; pA = pA == null ? headB : pA.next; pB = pB == null ? headA : pB.next; if (pA == pB) return pA; &#125; return null; &#125;&#125; 错误如下，当两个链表只有公共部分节点1时，上述代码没有先判断，先向右移，结果指向A,B都为空，返回空。 所以解决方案是把判断AB相等的语句放在指针移动上面 12345678910111213public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; if (headA == null || headB == null) return null; ListNode pA = headA, pB = headB; while (pA != null || pB != null) &#123; if (pA == pB) return pA; pA = pA == null ? headB : pA.next; pB = pB == null ? headA : pB.next; &#125; return null; &#125; 成功 优化 当A,B只有公共部分时，直接返回结果 当A,B有自己的部分也相交时 当A,B公共部分前面节点数量相同时，遍历到相交节点直接返回结果 当A,B公共部分前面节点数量不同时，遍历a+b+c步也会相交，返回结果 当A,B不相交时，遍历完a+ 1(null) + b + 1(null) 步后，A和B都为null，返回的A为null，表示不相交 123456789101112public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; if (headA == null || headB == null) return null; ListNode pA = headA, pB = headB; while (pA != pB) &#123; pA = pA == null ? headB : pA.next; pB = pB == null ? headA : pB.next; &#125; return pA; &#125;&#125; 142. 环形链表 II 解题思路：快慢指针，慢指针走一步，快指针走两步，如果有环，快指针总能在环中追上慢指针。当快指针和慢指针指向同一节点时，把快节点指向头节点，慢节点不动，快慢指针一起走，再次相遇时，指向的节点就是入环的第一个节点。 时间复杂度：\\(O(m + n)\\)，其中m，n分别为两个链表的长度 空间复杂度：\\(O(m + n)\\) 1234567891011121314151617181920public class Solution &#123; public ListNode detectCycle(ListNode head) &#123; if (head == null || head.next == null) return null; ListNode fast = head.next.next, slow = head.next; while (fast != null &amp;&amp; fast.next != null) &#123; fast = fast.next.next; slow = slow.next; if (fast == slow) &#123; fast = head; while (fast != slow) &#123; fast = fast.next; slow = slow.next; &#125; return fast; &#125; &#125; return null; &#125;&#125; 剑指 Offer II 026. 重排链表 方法一：翻转合并 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public void reorderList(ListNode head) &#123; ListNode cur = head, fast = head.next; while(fast != null &amp;&amp; fast.next != null) &#123; fast = fast.next.next; cur = cur.next; &#125; ListNode mid = cur; fast = mid.next; mid.next = null; fast = reverse(fast); cur = head; while (fast != null) &#123; ListNode next1 = cur.next, next2 = fast.next; cur.next = fast; fast.next = next1; cur = next1; fast = next2; &#125; &#125; private ListNode reverse(ListNode cur) &#123; ListNode pre = null, next = null; while (cur != null) &#123; next = cur.next; cur.next = pre; pre = cur; cur = next; &#125; return pre; &#125;&#125; 剑指 Offer II 025. 链表中的两数相加 方法一：翻转三次 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; l1 = reverse(l1); l2 = reverse(l2); ListNode res = addReversedList(l1, l2); return reverse(res); &#125; private ListNode addReversedList(ListNode l1, ListNode l2) &#123; ListNode dummy = new ListNode(-1); ListNode cur = dummy; int carry = 0, sum = 0; while (l1 != null || l2 != null) &#123; l1 = l1 == null ? null : l1; l2 = l2 == null ? null : l2; sum = (l1 == null ? 0 : l1.val) + (l2 == null ? 0 : l2.val) + carry; carry = sum &gt;= 10 ? 1 : 0; sum = sum &gt;= 10 ? sum - 10 : sum; ListNode newNode = new ListNode(sum); cur.next = newNode; cur = cur.next; l1 = l1 == null ? null : l1.next; l2 = l2 == null ? null : l2.next; &#125; if (carry == 1) &#123; ListNode newNode = new ListNode(1); cur.next = newNode; &#125; return dummy.next; &#125; private ListNode reverse(ListNode cur) &#123; ListNode pre = null, next = null; while (cur != null) &#123; next = cur.next; cur.next = pre; pre = cur; cur = next; &#125; return pre; &#125;&#125; 方法二：翻转两次(最后一次不需要翻转) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; l1 = reverse(l1); l2 = reverse(l2); ListNode res = addReversedList(l1, l2); return res; &#125; private ListNode addReversedList(ListNode l1, ListNode l2) &#123; ListNode dummy = new ListNode(-1); ListNode cur = dummy; int carry = 0, sum = 0; while (l1 != null || l2 != null) &#123; l1 = l1 == null ? null : l1; l2 = l2 == null ? null : l2; sum = (l1 == null ? 0 : l1.val) + (l2 == null ? 0 : l2.val) + carry; carry = sum &gt;= 10 ? 1 : 0; sum = sum &gt;= 10 ? sum - 10 : sum; ListNode newNode = new ListNode(sum); cur = dummy.next; dummy.next = newNode; newNode.next = cur; l1 = l1 == null ? null : l1.next; l2 = l2 == null ? null : l2.next; &#125; if (carry == 1) &#123; cur = dummy.next; ListNode newNode = new ListNode(1); dummy.next = newNode; newNode.next = cur; &#125; return dummy.next; &#125; private ListNode reverse(ListNode cur) &#123; ListNode pre = null, next = null; while (cur != null) &#123; next = cur.next; cur.next = pre; pre = cur; cur = next; &#125; return pre; &#125;&#125; Hash Table 242. 有效的字母异位词 方法一：双HashMap记录词频 判断s与t的长度，若不相等，则一定不是字母异位词 建立两个HashMap&lt;Character, Integer&gt; 遍历字符串，将每个字符存入map中，并将值+1 如果map1与map2的size不相等，则一定不是字母异位词 遍历map1(我遍历的是字符串)，get字符串s，t的每一个字符出现了的次数，判断是否相同，如果不同，则一定不是字母异位词。 时间复杂度：\\(O(n)\\)，其中n为第一个字符串的长度 空间复杂度：\\(O(1)\\) 1234567891011121314151617181920212223class Solution &#123; public boolean isAnagram(String s, String t) &#123; int len = s.length(); if (len != t.length()) return false; Map&lt;Character, Integer&gt; map1 = new HashMap&lt;&gt;(), map2 = new HashMap&lt;&gt;(); for (int i = 0; i &lt; len; ++i) &#123; char sChar = s.charAt(i); char tChar = t.charAt(i); map1.put(sChar, map1.getOrDefault(sChar, 0) + 1); map2.put(tChar, map2.getOrDefault(tChar, 0) + 1); &#125; for (int i = 0; i &lt; len; ++i) &#123; int sSize = map1.get(s.charAt(i)); int tSize = map2.getOrDefault(s.charAt(i), 0); if (sSize != tSize) &#123; return false; &#125; &#125; return true; &#125;&#125; 方法二：数组 数组其实就是一个简单哈希表，而且这道题目中字符串只有小写字符，那么就可以定义一个数组，来记录字符串s里字符出现的次数。 定一个数组record，大小为26 ，初始化为0，因为字符a到字符z的ASCII也是26个连续的数值。 遍历第一个字符串s时，只需要将s.charAt(i) - ‘a’所在的元素+1，这样统计了字符串s中每个字符出现的次数。 同样，遍历第二个字符串t时，只需要将t.charAt(i) - ‘a’所在的元素-1。 如果record全部元素为0，那么s和t是字母异位词；否则不是。 时间复杂度：\\(O(n)\\)，其中n为第一个字符串的长度 空间复杂度：\\(O(1)\\)，只使用了常数大小的辅助数组。 123456789101112131415class Solution &#123; public boolean isAnagram(String s, String t) &#123; if (s.length() != t.length()) return false; int[] record = new int[26]; for (int i = 0; i &lt; s.length(); ++i) &#123; ++record[s.charAt(i) - &#x27;a&#x27;]; --record[t.charAt(i) - &#x27;a&#x27;]; &#125; for (int i = 0; i &lt; 26; ++i) if (record[i] != 0) return false; return true; &#125;&#125; 349. 两个数组的交集 解题思路：双HashSet 首先使用一个HashSet命名为set，记录第一个数组中不包含重复的所有元素 再用一个HashSet命名为intersection，遍历第二个数组，如果第二个数组中的元素在set中，则加入intersection中 最后将intersection转换为数组，并返回 1234567891011121314151617class Solution &#123; public int[] intersection(int[] nums1, int[] nums2) &#123; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); Set&lt;Integer&gt; intersection = new HashSet&lt;&gt;(); for (int i = 0; i &lt; nums1.length; ++i) set.add(nums1[i]); for (int i = 0; i &lt; nums2.length; ++i) if (set.contains(nums2[i])) intersection.add(nums2[i]); int[] result = new int[intersection.size()]; int i = 0; for (int element : intersection) &#123; result[i++] = element; &#125; return result; &#125;&#125; 202. 快乐数 求和的过程中，sum会重复出现，用HashSet记录每一次求和，如果有重复，那么必定不是快乐数。 注意：sum += (n % 10) * (n % 10);+=的优先级高于%。 12345678910111213141516171819class Solution &#123; public boolean isHappy(int n) &#123; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); while (n != 1 &amp;&amp; !set.contains(n)) &#123; set.add(n); n = getSum(n); &#125; return n == 1; &#125; private int getSum(int n) &#123; int sum = 0; while (n &gt; 0) &#123; sum += (n % 10) * (n % 10); n /= 10; &#125; return sum; &#125;&#125; 1. 两数之和 方法一：暴力 注意初始化int数组：new int[]{i, j}; 时间复杂度：\\(O(n^2)\\)，其中n为第一个字符串的长度 空间复杂度：\\(O(1)\\)，只使用了常数大小的辅助数组。 12345678910111213class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int[] result = new int[2]; for (int i = 0; i &lt; nums.length - 1; ++i) &#123; for (int j = i + 1; j &lt; nums.length; ++j) &#123; if (nums[i] + nums[j] == target) &#123; return new int[]&#123;i, j&#125;; &#125; &#125; &#125; return result; &#125;&#125; 方法二：HashMap 解题思路： 建立一个HashMap，key为数组的值，value为数组索引 遍历一遍，每次遍历判断哈希表中是否存在key为target-nums[i]，如果有，则这个key对应的value与i即为所求 时间复杂度：\\(O(n)\\) 空间复杂度：\\(O(n)\\) 1234567891011class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; ++i) &#123; if (map.containsKey(target - nums[i])) return new int[]&#123;map.get(target - nums[i]), i&#125;; map.put(nums[i], i); &#125; return new int[2]; &#125;&#125; 454. 四数相加 II 解题思路： 用HashMap用两层循环记录前两个数组每个元素之和为key，和出现的次数为value 再两次循环后两个数组，如果map.containsKey(- i - j)，那么- i - j与当前i + j之和为0，即为本题所求，则把result加上和为- i - j的数量 时间复杂度：\\(O(n^2)\\)，两层循环 空间复杂度：\\(O(n^2)\\)，在最坏情况下，前两个数组的元素各不相同，map占n * n 12345678910111213141516171819class Solution &#123; public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); int result = 0; int n = nums1.length; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; map.put(nums1[i] + nums2[j], map.getOrDefault(nums1[i] + nums2[j], 0) + 1); &#125; &#125; for (int i : nums3) &#123; for (int j : nums4) &#123; if (map.containsKey(- i - j)) result += map.get(- i - j); &#125; &#125; return result; &#125;&#125; 383. 赎金信 解题思路：字母表 如果ransomNote的长度大于magazine的长度，直接返回false 新建一个长度为26的字母表，以及一个HashMap，key为字母-‘a’，value为字母出现的次数，将magazine中的每个字符put进map 遍历ransomNote的所有字符i，如果map中key为字符i的value大于0，那么把这个value减一；如果map中key为字符i的value小于等于0，说明magazine不存在字符i或者字符i的个数小于ransomNote中字符i的个数，那么 ransomNote 能不能由 magazine 里面的字符构成，返回false 时间复杂度：\\(O(n)\\)，两层循环 空间复杂度：\\(O(1)\\)，只需要常数大小的辅助空间 12345678910111213141516171819202122class Solution &#123; public boolean canConstruct(String ransomNote, String magazine) &#123; if (ransomNote.length() &gt; magazine.length()) return false; char[] record = new char[26]; Map&lt; Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; magazine.length(); ++i) &#123; int index = magazine.charAt(i) - &#x27;a&#x27;; map.put(index, map.getOrDefault(index, 0) + 1); &#125; for (int i = 0; i &lt; ransomNote.length(); ++i) &#123; int index = ransomNote.charAt(i) - &#x27;a&#x27;; if (map.getOrDefault(index, 0) &gt; 0) &#123; map.put(index, map.get(index) - 1); &#125; else return false; &#125; return true; &#125;&#125; x15. 三数之和 题目要求： nums[i],nums[j],nums[k]中i,j,k各不相同 输出的nums[i],nums[j],nums[k]不能重复，如果结果集合中有{1,2,3}了，就不能再加入一个{1,2,3} 不能有重复的三元组，但三元组内的元素是可以重复的！{0,0,0},{-1,-1,2}是允许的 方法一：暴力 注意：{1，2，3}和{3， 2， 1}是不同的元素！ 1234set.add(Arrays.asList(1, 2, 3));set.add(Arrays.asList(3, 1, 2));[1, 2, 3][3, 1, 2] 找到符合的元素先排序，如何hashset中不存在再加入list中。 123456789101112131415161718192021class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; Set&lt;List&lt;Integer&gt;&gt; set = new HashSet&lt;&gt;(); List&lt;List&lt;Integer&gt;&gt; list = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; nums.length - 2; ++i) &#123; for (int j = i + 1; j &lt;nums.length - 1; ++j) &#123; for (int k = j + 1; k &lt; nums.length; ++k) &#123; if (nums[i] + nums[j] + nums[k] == 0) &#123; List&lt;Integer&gt; temp = Arrays.asList(nums[i], nums[j], nums[k]); Collections.sort(temp); if (!set.contains(temp)) &#123; set.add(temp); list.add(temp); &#125; &#125; &#125; &#125; &#125; return list; &#125;&#125; 超时 方法二：排序 + 双指针 去重思路 边界判断 时间复杂度：\\(O(n^2)\\)，两层循环 空间复杂度：\\(O(1)\\) 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;(); Arrays.sort(nums); // window: [nums[i], left, right] for (int i = 0; i &lt; nums.length - 2; ++i) &#123; if (nums[i] &gt; 0) break; // 去重 // 为什么不是nums[i] = nums[i + 1]? // 比如&#123;-1，-1，2&#125; // 如果是nums[i] = nums[i + 1]，那么&#123;-1，-1，2&#125;这个结果不会被选中 if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue; int left = i + 1, right = nums.length - 1; // 只能选取数组中不同下标的三个数，所以left == right时会使用同一个数，不执行 while (left &lt; right) &#123; int sum = nums[i] + nums[left] + nums[right]; if (sum &lt; 0) ++left; else if (sum &gt; 0) --right; else &#123; // sum == 0 result.add(Arrays.asList(nums[i], nums[left], nums[right])); // 去重 // 必须在添加完结果后去重，不然第一次的结果可能无法添加 while (right &gt; left &amp;&amp; nums[right] == nums[right - 1]) --right; while (right &gt; left &amp;&amp; nums[left] == nums[left + 1]) ++left; // 为什么两个指针都移动？去重之后，只移动一个，结果必定不等于0 --right; ++left; &#125; &#125; &#125; return result; &#125;&#125; 18. 四数之和 注意事项：nums[i]的范围，如果4个数都等于\\(10^9\\)， 那么将大于\\(2^{31} - 1= 2147483648 &lt; 2.15 * 10^9\\)(int最大的正数)，所以要用long记录四数之和 在三数之和的基础上，再增加一层循环， 区间为[nums[i], nums[left], nums[right], nums[j]] 时间复杂度：\\(O(n^3)\\)，三层循环 空间复杂度：\\(O(n)\\)，排序使用了额外的数组存储数组nums的副本 剪枝 第一层循环中，如果最小的四数之和大于target，那么后面的数更大，break 123\\\\ 第一层循环if ((long) nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 1] &gt; target) break; 第二层循环中，如果最大的四数之和小于target，那么前面的数更小，break 123\\\\ 第二层循环if ((long) nums[i] + nums[j] + nums[j - 1] + nums[j - 2] &lt; target) break; 完整代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;(); int length = nums.length; if (length &lt; 4) return result; Arrays.sort(nums); // window: [nums[i], nums[left], nums[right], nums[j]] for (int i = 0; i &lt; length - 3; ++i) &#123; // 去重 if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue; if ((long) nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 1] &gt; target) break; // 第4个数从尾开始遍历，举例&#123;-1, -1, 0, 2&#125;来确定j &gt; 2这个边界条件 for (int j = length - 1; j &gt; 2; --j) &#123; // 去重，如果使用nums[j] == nums[j - 1]判断，nums[j - 1]属于right的范围 // 那么&#123;-1，-1，1, 1&#125;这个结果不会被选中 if (j &lt; length - 1 &amp;&amp; nums[j] == nums[j + 1]) continue; if ((long) nums[i] + nums[j] + nums[j - 1] + nums[j - 2] &lt; target) break; int left = i + 1, right = j - 1; // 只能选取数组中不同下标的三个数，所以left == right时会使用同一个数，不执行 while (left &lt; right) &#123; long sum = (long) nums[i] + nums[left] + nums[right] + nums[j]; if (sum &lt; target) ++left; else if (sum &gt; target) --right; else &#123; // sum == target result.add(Arrays.asList(nums[i], nums[left], nums[right], nums[j])); while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) ++left; while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) --right; ++left; --right; &#125; &#125; &#125; &#125; return result; &#125;&#125; 剑指 Offer II 030. 插入、删除和随机访问都是 O(1) 的容器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class RandomizedSet &#123; List&lt;Integer&gt; list; Map&lt;Integer, Integer&gt; map; /** Initialize your data structure here. */ public RandomizedSet() &#123; list = new LinkedList&lt;&gt;(); map = new HashMap&lt;&gt;(); &#125; /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */ public boolean insert(int val) &#123; if (map.containsKey(val)) return false; list.add(val); map.put(val, list.size() - 1); return true; &#125; /** Removes a value from the set. Returns true if the set contained the specified element. */ public boolean remove(int val) &#123; if (!map.containsKey(val)) return false; int index = map.get(val); int lastVal = list.get(list.size() - 1); list.set(index, lastVal); list.remove(list.size() - 1); map.put(lastVal ,index); map.remove(val); return true; &#125; /** Get a random element from the set. */ public int getRandom() &#123; Random random = new Random(); return list.get(random.nextInt(list.size())); &#125;&#125;/** * Your RandomizedSet object will be instantiated and called as such: * RandomizedSet obj = new RandomizedSet(); * boolean param_1 = obj.insert(val); * boolean param_2 = obj.remove(val); * int param_3 = obj.getRandom(); */ 剑指 Offer II 031. 最近最少使用缓存 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class LRUCache &#123; class ListNode &#123; int key; int val; ListNode pre; ListNode next; public ListNode(int key, int val) &#123; this.val = val; this.key = key; &#125; &#125; ListNode head, tail; private int capacity; Map&lt;Integer, ListNode&gt; map; public LRUCache(int capacity) &#123; this.capacity = capacity; head = new ListNode(-1, -1); tail = new ListNode(-1, -1); head.next = tail; tail.pre = head; map = new HashMap&lt;&gt;(); &#125; public int get(int key) &#123; if (!map.containsKey(key)) return -1; moveToTail(key); return map.get(key).val; &#125; public void put(int key, int value) &#123; if (map.containsKey(key)) &#123; ListNode node = map.get(key); node.val = value; map.put(key, node); moveToTail(key); &#125; else &#123; // do not exist ListNode node = new ListNode(key, value); if (this.capacity != map.size()) &#123; // not full insertAtTail(node); map.put(key, node); &#125; else &#123; // full ListNode toDelete = head.next; delete(toDelete); map.remove(toDelete.key); insertAtTail(node); map.put(key, node); &#125; &#125; &#125; public void moveToTail(int key) &#123; ListNode node = map.get(key); if (node.next == tail) return; delete(node); insertAtTail(node); &#125; public void delete(ListNode node) &#123; node.pre.next = node.next; node.next.pre = node.pre; &#125; public void insertAtTail(ListNode node) &#123; node.pre = tail.pre; node.next = tail; node.pre.next = node; tail.pre = node; &#125;&#125;/** * Your LRUCache object will be instantiated and called as such: * LRUCache obj = new LRUCache(capacity); * int param_1 = obj.get(key); * obj.put(key,value); */ Stack and Queue 232. 用栈实现队列 解题思路：使用两个栈，inStack,outStack来实现队列。 push：直接将元素push进inStack pop：如果outStack不为空，则弹出outStack顶部元素；如果outStack为空，则将inStack中的元素全部弹入inStack，再弹出outStack顶部元素 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class MyQueue &#123; private Stack&lt;Integer&gt; inStack; private Stack&lt;Integer&gt; outStack; public MyQueue() &#123; inStack = new Stack&lt;&gt;(); outStack = new Stack&lt;&gt;(); &#125; public void push(int x) &#123; inStack.push(x); &#125; public int pop() &#123; if (outStack.isEmpty()) &#123; pushIntoOut(); &#125; return outStack.pop(); &#125; public int peek() &#123; if (outStack.isEmpty()) pushIntoOut(); return outStack.peek(); &#125; public boolean empty() &#123; return inStack.isEmpty() &amp;&amp; outStack.isEmpty(); &#125; public void pushIntoOut() &#123; while (!inStack.isEmpty()) &#123; outStack.push(inStack.pop()); &#125; &#125;&#125;/** * Your MyQueue object will be instantiated and called as such: * MyQueue obj = new MyQueue(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.peek(); * boolean param_4 = obj.empty(); */ 225. 用队列实现栈 方法一：单队列 push：直接将元素加入queue pop()：首先将队列元素移除并重新加入queue.size() - 1次，这样底部的元素就在队列首部了，poll出来即可 peek()：首先将队列元素移除并重新加入queue.size() - 1次，这样底部的元素就在队列首部了，先用result接收queue.peek()，再将这个元素移除并重新加入，最后返回result，peek()操作是不能改变内部数据的！！ 12345678910111213141516171819202122232425262728293031323334class MyStack &#123; private Queue&lt;Integer&gt; queue; public MyStack() &#123; queue = new LinkedList&lt;&gt;(); &#125; public void push(int x) &#123; queue.offer(x); &#125; public int pop() &#123; catchBottom(); return queue.poll(); &#125; public int top() &#123; catchBottom(); int result = queue.peek(); queue.offer(queue.poll()); return result; &#125; public boolean empty() &#123; return queue.isEmpty(); &#125; public void catchBottom() &#123; for (int i = 0; i &lt; queue.size() - 1; ++i) &#123; queue.offer(queue.poll()); &#125; &#125;&#125; 优化 在面对大量需要查看顶部元素业务的时候，每次都要重新出队入队n次，不如在push的时候就排好序， 123456789101112public void push(int x) &#123; queue.offer(x); for (int i = 0; i &lt; queue.size() - 1; ++i) &#123; queue.offer(queue.poll()); &#125;&#125;public int pop() &#123; return queue.poll();&#125;public int top() &#123; return queue.peek();&#125; 方法二：双队列 push：先在辅助队列supportQueue中加入目标数据，再将主队列queue中的数据全部弹出并加入到supportQueue中，这个时候supportQueue就是先进后出的排列顺序，最后将queue和support交换 12345678910111213141516171819202122232425262728293031class MyStack &#123; Queue&lt;Integer&gt; queue, supportQueue; public MyStack() &#123; queue = new LinkedList&lt;&gt;(); supportQueue = new LinkedList&lt;&gt;(); &#125; public void push(int x) &#123; supportQueue.offer(x); while (!queue.isEmpty()) &#123; supportQueue.offer(queue.poll()); &#125; Queue&lt;Integer&gt; temp = queue; queue = supportQueue; supportQueue = temp; &#125; public int pop() &#123; return queue.poll(); &#125; public int top() &#123; return queue.peek(); &#125; public boolean empty() &#123; return queue.isEmpty(); &#125;&#125; 20. 有效的括号 方法一：HashMap + Stack 注意事项：如果是左括号，直接push进栈 如果是右括号，如果栈为空那么匹配不了；如果右括号和栈顶部的左括号不匹配，也不满足 最后如果栈空，则是有效的括号；否则不是 1234567891011121314151617181920class Solution &#123; public boolean isValid(String s) &#123; Map&lt;Character, Character&gt; map = new HashMap&lt;&gt;(); map.put(&#x27;&#123;&#x27;, &#x27;&#125;&#x27;); map.put(&#x27;(&#x27;, &#x27;)&#x27;); map.put(&#x27;[&#x27;, &#x27;]&#x27;); Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); for (int i = 0; i &lt; s.length(); ++i) &#123; char c = s.charAt(i); if (map.containsKey(c)) stack.push(c); else &#123; if (stack.isEmpty() || map.get(stack.pop()) != c) &#123; return false; &#125; &#125; &#125; return stack.isEmpty(); &#125;&#125; 1047. 删除字符串中的所有相邻重复项 方法一：StringBuilder 如果当前字符和前一个字符相等，则删除当前字符；否则加入当前字符 123456789101112131415161718class Solution &#123; public String removeDuplicates(String s) &#123; StringBuilder sb = new StringBuilder(); int index = -1; for (int i = 0; i &lt; s.length(); ++i) &#123; char c = s.charAt(i); if (sb.length() == 0 || c != sb.charAt(index)) &#123; sb.append(c); ++index; &#125; else &#123; sb.deleteCharAt(index); --index; &#125; &#125; return sb.toString(); &#125;&#125; 150. 逆波兰表达式求值 解题思路： 遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中 1234567891011121314151617181920212223242526272829303132class Solution &#123; public int evalRPN(String[] tokens) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for (int i = 0; i &lt; tokens.length; ++i) &#123; String token = tokens[i]; if (isNumber(token)) stack.push(Integer.parseInt(token)); else &#123; int b = stack.pop(), a = stack.pop(); switch (token) &#123; case &quot;+&quot;: stack.push(a + b); break; case &quot;-&quot;: stack.push(a - b); break; case &quot;*&quot;: stack.push(a * b); break; case &quot;/&quot;: stack.push(a / b); break; default: &#125; &#125; &#125; return stack.pop(); &#125; public boolean isNumber(String s) &#123; return !(s.equals(&quot;+&quot;) || s.equals(&quot;-&quot;) || s.equals(&quot;*&quot;) || s.equals(&quot;/&quot;)); &#125;&#125; 注意事项： 在Java中，==和.equals()都是用于比较两个对象是否相等的操作符。但是它们之间存在着不同的用法和含义。 ==用于比较两个对象的引用是否相等，也就是判断这两个对象是否是同一个对象。当比较两个基本数据类型的值时，它们的值相等时返回true；当比较两个引用类型的对象时，如果它们所指向的内存地址相同，也就是它们是同一个对象时，返回true；否则返回false。 .equals()方法用于比较两个对象的内容是否相等。默认情况下，.equals()方法比较的是两个对象的引用是否相等，也就是使用==比较，但是我们可以通过重写.equals()方法来自定义比较规则，比如根据对象的属性值来比较是否相等。 对于字符串类型的变量来说，==和.equals()方法的区别如下： ==比较的是字符串对象的引用是否相等，也就是它们是否指向同一个内存地址。 .equals()方法比较的是字符串对象的内容是否相等，也就是它们包含的字符序列是否相同。 因为Java中字符串是一个特殊的对象类型，为了方便字符串的比较操作，Java中提供了一种特殊的机制，也就是\"字符串常量池\"，它可以缓存字符串对象，使得多个字符串对象可以共享同一个对象，也就是它们的引用相等。在这种情况下，==操作符会返回true。但是在其他情况下，如果不是使用相同的字符串字面量来创建字符串对象，==操作符会返回false，此时需要使用.equals()方法来进行字符串的内容比较。 239. 滑动窗口最大值 方法一：暴力（超时） 时间复杂度：\\(O(kn)\\) 空间复杂度：\\(O(n)\\)，存储结果的数组 1234567891011121314151617class Solution &#123; public int[] maxSlidingWindow(int[] nums, int k) &#123; int n = nums.length; int[] result = new int[n - k + 1]; if (k &gt; n) return result; // [i, i + k) for (int i = 0; i &lt; result.length; ++i) &#123; int max = Integer.MIN_VALUE; for (int j = i; j &lt; i + k; ++j) &#123; max = Math.max(max, nums[j]); &#125; result[i] = max; &#125; return result; &#125;&#125; 方法二：单调队列 1234567891011121314151617181920212223242526class Solution &#123; public int[] maxSlidingWindow(int[] nums, int k) &#123; int n = nums.length - k + 1; Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; k; ++i) &#123; while (!deque.isEmpty() &amp;&amp; nums[i] &gt; nums[deque.peekLast()]) &#123; deque.pollLast(); &#125; deque.offerLast(i); &#125; int[] result = new int[n]; result[0] = nums[deque.peekFirst()]; for (int i = k; i &lt; nums.length; ++i) &#123; while (!deque.isEmpty() &amp;&amp; nums[i] &gt; nums[deque.peekLast()]) &#123; deque.pollLast(); &#125; deque.offerLast(i); // 如果i的左区间在队首元素右边，则要移除队首元素; 用if就可以了(while也行) if (deque.peekFirst() &lt;= i - k) &#123; deque.pollFirst(); &#125; result[i - k + 1] = nums[deque.peekFirst()]; &#125; return result; &#125;&#125; 347. 前 K 个高频元素 123456789101112131415161718192021222324252627282930class Solution &#123; public int[] topKFrequent(int[] nums, int k) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; ++i) &#123; map.put(nums[i], map.getOrDefault(nums[i], 0) + 1); &#125; PriorityQueue&lt;int[]&gt; queue = new PriorityQueue&lt;&gt;(new Comparator&lt;int[]&gt;() &#123; public int compare(int[] m, int[] n) &#123; return m[1] - n[1]; &#125; &#125;); for (Map.Entry&lt;Integer, Integer&gt; entry: map.entrySet()) &#123; int num = entry.getKey(), count = entry.getValue(); if (queue.size() == k) &#123; if (count &gt; queue.peek()[1]) &#123; queue.poll(); queue.offer(new int[]&#123;num, count&#125;); &#125; &#125; else &#123; queue.offer(new int[]&#123;num, count&#125;); &#125; &#125; int[] result = new int[k]; for (int i = 0; i &lt; k; ++i) &#123; result[i] = queue.poll()[0]; &#125; return result; &#125;&#125; 优先级队列（大根堆、小根堆） Java中可以使用PriorityQueue类来创建优先级队列，它实现了一个基于优先级堆的无界优先级队列。 要创建一个大根堆，需要使用Comparator.reverseOrder()方法来创建一个反转自然顺序的比较器，示例如下： 12345PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;(Comparator.reverseOrder());maxHeap.add(5);maxHeap.add(1);maxHeap.add(10);System.out.println(maxHeap.poll()); // 输出10 要创建一个小根堆，只需要使用默认的比较器即可，示例如下： 12345PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;();minHeap.add(5);minHeap.add(1);minHeap.add(10);System.out.println(minHeap.poll()); // 输出1 在上述示例中，我们首先创建了一个空的优先级队列，然后使用add()方法向其中添加元素，使用poll()方法从队列中取出元素并删除。由于大根堆和小根堆的比较器不同，它们会按照不同的顺序取出元素。 除了示例中用到的add()和poll()方法之外，PriorityQueue类还提供了一些其他常用的方法，下面对一些常用方法进行补充说明： offer(E e): 添加元素到队列中，如果队列已满则抛出异常。 12arduinoCopy codePriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;();queue.offer(1); peek(): 获取但不删除队列的头部元素，如果队列为空则返回null。 1234arduinoCopy codePriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;();queue.offer(1);queue.offer(2);System.out.println(queue.peek()); // 输出1 remove(Object o): 从队列中删除指定的元素，如果队列中不存在该元素则返回false。 1234567arduinoCopy codePriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;();queue.offer(1);queue.offer(2);queue.offer(3);System.out.println(queue.remove(2)); // 输出trueSystem.out.println(queue.remove(4)); // 输出falseSystem.out.println(queue); // 输出[3, 1] size(): 返回队列中元素的数量。 12345arduinoCopy codePriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;();queue.offer(1);queue.offer(2);queue.offer(3);System.out.println(queue.size()); // 输出3 clear(): 删除队列中的所有元素。 123456arduinoCopy codePriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;();queue.offer(1);queue.offer(2);queue.offer(3);queue.clear();System.out.println(queue); // 输出[] 还有一些其他的方法，如toArray()、contains()、addAll()等，可以参考Java官方文档进行学习。 Greedy 455. 分发饼干 方法一：从小胃口开始喂小饼干 先把两个数组都升序排序，从左往右遍历 如果孩子满足度小于等于饼干满足度，那么++res，并让两个指针都往后移动一位 如果孩子满足度大于饼干满足度，使饼干的指针向后移动一位 直到任意一个指针超出数组范围为止 12345678910111213141516171819class Solution &#123; public int findContentChildren(int[] children, int[] cookies) &#123; int res = 0; Arrays.sort(children); Arrays.sort(cookies); int i = 0, j = 0; while (i &lt; children.length &amp;&amp; j &lt; cookies.length) &#123; if (children[i] &lt;= cookies[j]) &#123; ++res; ++i; ++j; &#125; else &#123; ++j; &#125; &#125; return res; &#125;&#125; 方法二：从大胃口开始喂大饼干 12345678910111213141516171819class Solution &#123; public int findContentChildren(int[] children, int[] cookies) &#123; int res = 0; Arrays.sort(children); Arrays.sort(cookies); int i = children.length - 1, j = cookies.length - 1; while (i &gt;= 0 &amp;&amp; j &gt;= 0) &#123; if (children[i] &lt;= cookies[j]) &#123; ++res; --i; --j; &#125; else &#123; --i; &#125; &#125; return res; &#125;&#125; 376. 摆动序列 方法一：排序+删除连续重复元素+dp(不推荐) 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; public int wiggleMaxLength(int[] nums) &#123; int n = nums.length; if (n == 1) return 1; // 1.dp[i]:以nums[i]为结尾，最长的摆动序列 List&lt;Integer&gt; list = new LinkedList&lt;&gt;(); list.add(nums[0]); for (int i = 1; i &lt; n; ++i) &#123; if (nums[i] != nums[i - 1]) list.add(nums[i]); &#125; Integer[] dummy = list.toArray(new Integer[0]); if (dummy.length == 1) return 1; if (dummy.length == 2) return 2; int[] dp = new int[dummy.length]; dp[0] = 1; dp[1] = 2; // 2.状态转移方程： // 1)nums[i] - nums[i - 1]与nums[i - 1] - nums[i- 2]异号：dp[i] = dp[i - 1] + 1 // 2)nums[i] - nums[i - 1]与nums[i - 1] - nums[i- 2]同号：dp[i] = dp[i - 1] int res = 1; for (int i = 2; i &lt; dummy.length; ++i) &#123; if ((dummy[i] - dummy[i - 1]) * (dummy[i - 1] - dummy[i - 2]) &lt; 0) &#123; dp[i] = dp[i - 1] + 1; &#125; else if ((dummy[i] - dummy[i - 1]) * (dummy[i - 1] - dummy[i - 2]) &gt; 0) &#123; dp[i] = dp[i - 1]; &#125; res = Math.max(res, dp[i]); &#125; return res; &#125;&#125; 方法二：贪心 1234567891011121314class Solution &#123; public int wiggleMaxLength(int[] nums) &#123; int preDiff = 0, postDiff = 0; int result = 1; for (int i = 0; i &lt; nums.length - 1; ++i) &#123; postDiff = nums[i + 1] - nums[i]; if ((preDiff &lt;= 0 &amp;&amp; postDiff &gt; 0) || (preDiff &gt;= 0 &amp;&amp; postDiff &lt; 0)) &#123; ++result; preDiff = postDiff; &#125; &#125; return result; &#125;&#125; 方法三：DP 12345678910111213141516171819202122232425class Solution &#123; public int wiggleMaxLength(int[] nums) &#123; int n = nums.length; if (n &lt; 2) return n; int[] up = new int[n], down = new int[n]; up[0] = 1; down[0] = 1; for (int i = 1; i &lt; n; ++i) &#123; if (nums[i] &gt; nums[i - 1]) &#123; up[i] = Math.max(up[i - 1], down[i - 1] + 1); down[i] = down[i - 1]; &#125; else if (nums[i] &lt; nums[i - 1]) &#123; up[i] = up[i - 1]; down[i] = Math.max(down[i - 1], up[i - 1] + 1); &#125; else &#123; up[i] = up[i - 1]; down[i] = down[i - 1]; &#125; &#125; return Math.max(up[n - 1], down[n - 1]); &#125;&#125; 53. 最大子数组和 方法一：DP dp[i]：以nums[i]结尾的子数组的最大数组和 状态转移方程： 当dp[i - 1] &gt;= 0 时候，dp[i] = dp[i - 1] + nums[i] 当dp[i - 1] &lt; 0时候， dp[i] = nums[i] 初始化：dp[0] = nums[0] 时间复杂度：\\(O(n)\\) 空间复杂度：\\(O(n)\\) 12345678910111213141516171819202122class Solution &#123; public int maxSubArray(int[] nums) &#123; int n = nums.length; if (n == 1) return nums[0]; // dp[i]：以nums[i]结尾的子数组的最数组和 int[] dp = new int[n]; dp[0] = nums[0]; int res = dp[0]; for (int i = 1; i &lt; n; ++i) &#123; if (dp[i - 1] &gt;= 0) &#123; dp[i] = dp[i - 1] + nums[i]; &#125; else &#123; // dp[i - 1] &lt; 0 dp[i] = nums[i]; &#125; res = Math.max(res, dp[i]); &#125; return res; &#125;&#125; 方法二：优化空间的DP 由于dp[i]只依赖dp[i - 1]，所以可以用一个长度为2的数组记录dp 123456789101112131415161718192021class Solution &#123; public int maxSubArray(int[] nums) &#123; int n = nums.length; if (n == 1) return nums[0]; // dp[i]：以nums[i]结尾的子数组的最数组和 int[] dp = new int[2]; dp[0] = nums[0]; int res = nums[0]; for (int i = 1; i &lt; n; ++i) &#123; if (dp[(i - 1) % 2] &gt;= 0) &#123; dp[i % 2] = dp[(i - 1) % 2] + nums[i]; &#125; else &#123; // dp[i - 1] &lt; 0 dp[i % 2] = nums[i]; &#125; res = Math.max(res, dp[i % 2]); &#125; return res; &#125;&#125; 贪心 首先把记录结果的result初始化为最小值，以及count=0 遍历数组，count加上当前元素，如果count大于result，讲count值赋给result 如果count等于负数了，令count等于0，从下一个数开始重新计算 1234567891011121314class Solution &#123; public int maxSubArray(int[] nums) &#123; int result = Integer.MIN_VALUE; int count = 0; for (int i = 0; i &lt; nums.length; ++i) &#123; count += nums[i]; if (count &gt; result) result = count; if (count &lt; 0) count = 0; &#125; return result; &#125;&#125; 122. 买卖股票的最佳时机 II 只要下一天股票价格高于当天，那么就买入当前股票并在下一天卖出 123456789101112class Solution &#123; public int maxProfit(int[] prices) &#123; int res = 0; for (int i = 0; i &lt; prices.length - 1; ++i) &#123; int diff = prices[i + 1] - prices[i]; if (diff &gt; 0) &#123; res += diff; &#125; &#125; return res; &#125;&#125; 55. 跳跃游戏 方法一：贪心 初始化一个available数组，available[i]表示是否可以到底数组元素i 如果当前节点是可到达的，令i=0前往后遍历，把available数组从i+1开始，后nums[i]个元素都赋true 初始化：第一个元素是肯定能到达的，初始化为true 时间复杂度：\\(O(n^2)\\)，最坏情况下，所有节点都刚好能到达数组倒数第二个元素，且倒数第二个元素的值为0，如[n - 2, n - 3, ..., 1, 0, 1]，需要遍历\\(\\frac{(n-1)(n-2)}{2}\\)次 空间复杂度：\\(O(n)\\) 1234567891011121314151617class Solution &#123; public boolean canJump(int[] nums) &#123; int n = nums.length; boolean[] available = new boolean[n]; available[0] = true; for (int i = 0; i &lt; n - 1; ++i) &#123; if (available[i]) &#123; for (int j = i + 1; j &lt; nums[i] + i + 1; ++j) &#123; if (j == n - 1) return true; available[j] = true; &#125; &#125; &#125; return available[n - 1]; &#125;&#125; 方法二：贪心（优化空间复杂度） 不必要用一个boolean数组来表示是否可以到达当前数组元素，可以用一个整数rightmost来判断 1234567891011121314class Solution &#123; public boolean canJump(int[] nums) &#123; int n = nums.length; int rightmost = 0; for (int i = 0; i &lt; n; ++i) &#123; if (i &lt;= rightmost) &#123; rightmost = Math.max(rightmost, i + nums[i]); if (rightmost &gt;= n - 1) return true; &#125; &#125; return false; &#125;&#125; 45. 跳跃游戏 II 方法一：dp 1234567891011121314151617class Solution &#123; public int jump(int[] nums) &#123; int n = nums.length; // 1.dp[i]：到达i的最小跳数 int[] dp = new int[n]; Arrays.fill(dp, Integer.MAX_VALUE); dp[0] = 0; for (int i = 0; i &lt; n - 1; ++i) &#123; for (int j = i + 1; j &lt; i + 1 + nums[i]; ++j) &#123; dp[j] = Math.min(dp[j], dp[i] + 1); if (j == n - 1) break; &#125; &#125; return dp[n - 1]; &#125;&#125; 方法二：贪心 123456789101112131415class Solution &#123; public int jump(int[] nums) &#123; int result = 0; int n = nums.length; int maxDistance = 0, end = 0; for (int i = 0; i &lt; n - 1; ++i) &#123; maxDistance = Math.max(maxDistance, i + nums[i]); if (i == end) &#123; end = maxDistance; ++result; &#125; &#125; return result; &#125;&#125; 1005. K 次取反后最大化的数组和 先创建一个小根堆，把数组所有元素都放进去 取反小根堆堆顶元素再放回小根堆，循环k次 时间复杂度：\\(O(n)\\) 空间复杂度：\\(O(n)\\) 如果小根堆堆顶是负数\\(x\\)，那么一定是最小的负数，取反后会是比较大的正数\\(-x\\)； 如果小根堆堆顶是正数\\(x\\)，那么是最小的正数，取反后是负数\\(-x\\)，由于此时只有这一个负数，所以\\(-x\\)是最小值，再放入堆顶，再取反又是最小的正数，循环到k为0为止。 12345678910111213141516171819class Solution &#123; public int largestSumAfterKNegations(int[] nums, int k) &#123; // 先创建一个小根堆，把数组所有元素都放进去 // 取反小根堆堆顶元素再放回小根堆，循环k次 PriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;(); for (int n : nums) queue.offer(n); while (!queue.isEmpty() &amp;&amp; k &gt; 0) &#123; int cur = queue.poll(); queue.offer(-1 * cur); --k; &#125; int sum = 0; while (!queue.isEmpty()) &#123; sum += queue.poll(); &#125; return sum; &#125;&#125; 方法二：优化方法一 先创建一个小根堆，把数组所有元素都放进去 首先小根堆弹出的元素\\(x\\)如果是负数，就取反(最小的负数取反是比较大的正数),再放回小根堆 小根堆弹出的元素\\(x\\)如果是是正数：此时\\(k\\)值如果能被2整除，那么重复取反堆顶元素\\(x\\)，最终\\(x\\)不变，直接将\\(x\\)加入堆中；如果\\(k\\)值如果不能被2整除，那么将-x加入堆中 123456789101112131415161718192021222324252627class Solution &#123; public int largestSumAfterKNegations(int[] nums, int k) &#123; // 先创建一个小根堆，把数组所有元素都放进去 // 要取反k次，首先小根堆弹出的元素x如果是负数，就取反(最小的负数取反是比较大的正数),再放回小根堆 // 小根堆弹出的元素x如果是是正数：此时k值如果能被2整除，那么重复取反堆顶元素x，最终x不变，直接将x加入堆中；如果k值如果不能被2整除，那么将-x加入堆中 PriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;(); for (int n : nums) queue.offer(n); while (!queue.isEmpty() &amp;&amp; k &gt; 0) &#123; int cur = queue.poll(); if (cur &lt; 0) &#123; queue.offer(-1 * cur); --k; &#125; else &#123; // cur &gt;= 0 int negPart = k % 2 == 0 ? 1 : -1; queue.offer(cur * negPart); break; &#125; &#125; int sum = 0; while (!queue.isEmpty()) &#123; sum += queue.poll(); &#125; return sum; &#125;&#125; 方法三：贪心(二刷) 首先将数组升序排序 进入for循环，注意循环的条件有两个，i &lt; nums.length || k &gt; 0 当k==0时，说明已经翻转了k次，不需要继续执行程序了，break即可 if (i == nums.length)留到最后讲解 如果，nums[i] &lt;= 0，直接翻转即可；如果nums[i] &gt; 0，那么说明此时数组里已经没有负数了，那么需要找到最小的正数，并且将剩余需要翻转的次数都对这个数使用：最小的正数只可能是当前的数或者前一个位置的数，比如数组[-5, -4, -3, 2, 3, 5]，需要翻转四次，翻转四次后数组为[5, 4, 3, 2, 3, 5]，即负数部分翻转后是降序。如果k能被2整除，那么翻转k次后这个数还是保持不变；如果不能被2整除，翻转一次即可。最后break退出for循环 如果i == nums.length，但是k的次数还没用完，这种情况只可能是数组元素全为负的情况，如果有一个正数，k都会在 if (nums[i] &gt;= 0 &amp;&amp; i &gt; 0) 语句下被消化。这种情况下，一定是最后一个数最小，如果k不能被2整除，就nums[i - 1]翻转即可。比如数组为[-4, -3, -2]，需要翻转4次，翻转3次后数组为 [4, 3, 2]，此时i == nums.length，翻转2即可 123456789101112131415161718192021class Solution &#123; public int largestSumAfterKNegations(int[] nums, int k) &#123; Arrays.sort(nums); for (int i = 0; i &lt; nums.length || k &gt; 0; ++i) &#123; if (k == 0) break; if (i == nums.length) i--; if (nums[i] &gt;= 0 &amp;&amp; i &gt; 0) &#123; i = nums[i] &gt; nums[i - 1] ? i - 1 : i; if (k % 2 == 1) &#123; nums[i] *= -1; &#125; break; &#125; nums[i] *= -1; --k; &#125; return Arrays.stream(nums).sum(); &#125;&#125; 134. 加油站:warning: 方法一：贪心 首先如果总油量减去总消耗大于等于零那么一定可以跑完一圈 12345678910111213141516class Solution &#123; public int canCompleteCircuit(int[] gas, int[] cost) &#123; int curSum = 0; int totalSum = 0; int index = 0; for (int i = 0; i &lt; gas.length; i++) &#123; curSum += gas[i] - cost[i]; totalSum += gas[i] - cost[i]; if (curSum &lt; 0) &#123; index = (i + 1) % gas.length ; curSum = 0; &#125; &#125; return (totalSum &lt; 0) ? -1 : index; &#125;&#125; 方法二：最小累计值的下一站 123456789101112131415class Solution &#123; public int canCompleteCircuit(int[] gas, int[] cost) &#123; int rest = 0; int minDiff = Integer.MAX_VALUE; int minIndex = 0; for (int i = 0; i &lt; gas.length; ++i) &#123; rest += gas[i] - cost[i]; if (rest &lt; minDiff) &#123; minDiff = rest; minIndex = i; &#125; &#125; return rest &lt; 0 ? -1 : (minIndex + 1) % gas.length; &#125;&#125; 135. 分发糖果 先从左往右，再从右往左 12345678910111213141516class Solution &#123; public int candy(int[] ratings) &#123; int[] candy = new int[ratings.length]; Arrays.fill(candy, 1); for (int i = 1; i &lt; candy.length; ++i) &#123; if (ratings[i] &gt; ratings[i - 1]) candy[i] += candy[i - 1]; &#125; for (int i = candy.length - 1; i &gt; 0; --i) &#123; if (ratings[i - 1] &gt; ratings[i]) &#123; candy[i - 1] = Math.max(candy[i - 1], candy[i] + 1); &#125; &#125; return Arrays.stream(candy).sum(); &#125;&#125; 860. 柠檬水找零 12345678910111213141516171819202122232425262728293031323334class Solution &#123; public boolean lemonadeChange(int[] bills) &#123; if (bills[0] != 5) return false; int five = 0, ten = 0; for (int i = 0; i &lt; bills.length; ++i) &#123; if (bills[i] == 5) &#123; ++five; &#125; else if (bills[i] == 10) &#123; if (five &gt; 0) &#123; --five; ++ten; &#125; else &#123; return false; &#125; &#125; else &#123; if (five &gt; 0 &amp;&amp; ten &gt; 0) &#123; --five; --ten; &#125; else if (five &gt;= 3) &#123; five -= 3; &#125; else &#123; return false; &#125; &#125; &#125; return true; &#125;&#125; 406. 根据身高重建队列 :warning: 1234567891011121314151617181920class Solution &#123; public int[][] reconstructQueue(int[][] people) &#123; // 先按照身高进行降序排序，再按照k进行升序排序 Arrays.sort(people, new Comparator&lt;int[]&gt;() &#123; public int compare(int[] person1, int[] person2) &#123; if (person1[0] != person2[0]) &#123; return person2[0] - person1[0]; &#125; else &#123; return person1[1] - person2[1]; &#125; &#125; &#125;); List&lt;int[]&gt; list = new LinkedList&lt;&gt;(); for (int[] person : people) &#123; list.add(person[1], person); &#125; return list.toArray(new int[list.size()][]); &#125;&#125; 452. 用最少数量的箭引爆气球 注意事项： compare方法用return p1[0] - p2[0]会越界！ 从左往右遍历，如果左边气球的右边界大于等于右边气球的左边界，那么可以一箭双球，此时有可能有第三个气球和前面两个气球有重合，但是把第一个气球的右边界设置为重合气球右边界的最小值 1234567891011121314151617181920class Solution &#123; public int findMinArrowShots(int[][] points) &#123; Arrays.sort(points, new Comparator&lt;int[]&gt;() &#123; public int compare(int[] point1, int[] point2) &#123; return Integer.compare(point1[0], point2[0]); &#125; &#125;); int arrow = 1; for (int i = 0, j = 1; j &lt; points.length; ++j) &#123; if (points[i][1] &gt;= points[j][0]) &#123; points[i][1] = Math.min(points[i][1], points[j][1]); &#125; else &#123; ++arrow; i = j; &#125; &#125; return arrow; &#125;&#125; 435. 无重叠区间 方法一： 比较器按以下方法来，不然容易出错！！ 12345678910Arrays.sort(intervals, new Comparator&lt;int[]&gt;() &#123; public int compare(int[] p1, int[] p2) &#123; if (p1[0] == p2[0]) &#123; return Integer.compare(p1[1], p2[1]); &#125; else &#123; return Integer.compare(p1[0], p2[0]); &#125; &#125;&#125;); 先定义比较器，如果p1, p2第一个元素不相等，则按照第一个元素升序排序；如果第一个元素相等，则按照第二个元素升序排序 双指针从前往后遍历，初始i=0，j=1 当intervals[i]与intervals[j]的第一个元素相等，那么必定要移除其中一个，由于比较器的排序，intervals[j]的区间更大，那么选择移除intervals[j]，答案只需要返回最少移除了多少个数，所以将表示删除元素个数的变量erase加一，让j后移即可 当intervals[i]与intervals[j]的第一个元素不相等时候，分两种情况讨论 如果intervals[i]的第二个元素 &gt; intervals[j]的第一个元素，此时区间重合，删除第二个元素即可，将表示删除元素个数的变量erase加一；如果此时intervals[i]的第二个元素 &gt; intervals[j]的第二个元素，说明intervals[i]包含 intervals[j]，那么此时必定删除 intervals[i]，将i指向j表示删除 intervals[i]这个元素 如果intervals[i]的第二个元素 &lt;= intervals[j]的第一个元素，那么i与j之间的元素都不重复，将i移动到j的位置 1234567891011121314151617181920212223242526272829303132class Solution &#123; public int eraseOverlapIntervals(int[][] intervals) &#123; Arrays.sort(intervals, new Comparator&lt;int[]&gt;() &#123; public int compare(int[] p1, int[] p2) &#123; if (p1[0] == p2[0]) &#123; return Integer.compare(p1[1], p2[1]); &#125; else &#123; return Integer.compare(p1[0], p2[0]); &#125; &#125; &#125;); int erase = 0, n = intervals.length; for (int i = 0, j = 1; j &lt; n; ++j) &#123; if (intervals[i][0] == intervals[j][0]) &#123; ++erase; &#125; else &#123; if (intervals[i][1] &gt; intervals[j][0]) &#123; ++erase; if (intervals[i][1] &gt;= intervals[j][1]) &#123; i = j; &#125; &#125; else &#123; // intervals[i][1] &lt;= intervals[j][0] i = j; &#125; &#125; &#125; return erase; &#125;&#125; 方法二：右边界取最小的 123456789101112131415161718192021class Solution &#123; public int eraseOverlapIntervals(int[][] intervals) &#123; Arrays.sort(intervals, (a,b)-&gt; &#123; return Integer.compare(a[0],b[0]); &#125;); int count = 0; for(int i = 1;i &lt; intervals.length;i++)&#123; if(intervals[i][0] &lt; intervals[i-1][1])&#123; ++count; intervals[i][1] = Math.min(intervals[i - 1][1], intervals[i][1]); &#125; &#125; for (int[] is : intervals) &#123; for (int i : is) &#123; System.out.print(i + &quot;,&quot;); &#125; System.out.println(); &#125; return count; &#125;&#125; 二刷：左边界升序排序 1234567891011121314151617181920212223class Solution &#123; public int eraseOverlapIntervals(int[][] intervals) &#123; Arrays.sort(intervals, new Comparator&lt;int[]&gt;() &#123; public int compare(int[] a, int[] b) &#123; if (a[0] == b[0]) return Integer.compare(a[1], b[1]); else return Integer.compare(a[0], b[0]); &#125; &#125;); int res = 0; for (int i = 0, j = 1; j &lt; intervals.length; ++j) &#123; if (intervals[i][1] &gt; intervals[j][0]) &#123; intervals[i][1] = Math.min(intervals[i][1], intervals[j][1]); ++res; &#125; else &#123; i = j; &#125; &#125; return res; &#125;&#125; 763. 划分字母区间 :warning: 方法一：贪心 首先创建一个长度为26的整型数组，统计每次字符出现的最远位置 遍历字符串，不断更新右边界的值 当当前下标i与右边界相等时，那么就将right-i+1记录 123456789101112131415161718class Solution &#123; public List&lt;Integer&gt; partitionLabels(String s) &#123; int[] ch = new int[26]; for (int i = 0; i &lt; s.length(); ++i) &#123; ch[s.charAt(i) - &#x27;a&#x27;] = i; &#125; List&lt;Integer&gt; res = new LinkedList&lt;&gt;(); int left = 0, right = -1; for (int i = 0; i &lt; s.length(); ++i) &#123; right = Math.max(right, ch[s.charAt(i) - &#x27;a&#x27;]); if (i == right) &#123; res.add(right - left + 1); left = i + 1; &#125; &#125; return res; &#125; &#125; 56. 合并区间 方法一： 遍历数组，如果后一个元素的左边界大于等于前一个元素的右边界，那么修改后一个元素的左边界为两元素左边界最小的值，修改后一个元素的右边界为两元素右边界最大的值 如果后一个元素左边界大于前一个元素的右边界，直接把前一个元素加入结果list中 最后再把最后一个元素(修改过)加入结果list中 12345678910111213141516171819202122class Solution &#123; public int[][] merge(int[][] intervals) &#123; int n = intervals.length; Arrays.sort(intervals, new Comparator&lt;int[]&gt;() &#123; public int compare(int[] p1, int[] p2) &#123; return Integer.compare(p1[0], p2[0]); &#125; &#125;); List&lt;int[]&gt; res = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; n - 1; ++i) &#123; if (intervals[i + 1][0] &lt;= intervals[i][1]) &#123; intervals[i + 1][0] = Math.min(intervals[i + 1][0], intervals[i][0]); intervals[i + 1][1] = Math.max(intervals[i + 1][1], intervals[i][1]); &#125; else &#123; res.add(new int[]&#123;intervals[i][0], intervals[i][1]&#125;); &#125; &#125; res.add(new int[]&#123;intervals[n - 1][0], intervals[n - 1][1]&#125;); return res.toArray(new int[res.size()][]); &#125;&#125; 方法二：射气球的思路 首先将数组按照左边界升序排序 当intervals[i][1] &gt;= intervals[j][0]，那么这两个元素一定是要合并的，因为是intervals数组是按照左边界升序排序的，那么合并区间[a, b]的a一定是intervals[i][0]，将intervals[i][1]赋值为intervals[i][1]与intervals[j][1]的最大值 当intervals[i][1] &lt; intervals[j][0]，那么这个两个区间是不重合的，先把上一个重合区间加入结果集，再把j赋值给i，进行下一轮循环 当j == intervals.length - 1时候， 如果intervals[i][1] &gt;= intervals[j][0]，那么会将intervals[i][1]取intervals[i][1]与intervals[j][1]的最大值 如果intervals[i][1] &lt; intervals[j][0]，那么会将之前的重合区间存入结果集，并将j赋值给i 所以出循环，只需要把intervals[i]加入结果集就好！ 12345678910111213141516171819202122232425class Solution &#123; public int[][] merge(int[][] intervals) &#123; Arrays.sort(intervals, new Comparator&lt;int[]&gt;() &#123; public int compare(int[] a, int[] b) &#123; if (a[0] == b[0]) return Integer.compare(a[1], b[1]); else return Integer.compare(a[0], b[0]); &#125; &#125;); List&lt;int[]&gt; res = new LinkedList&lt;&gt;(); int i = 0; for (int j = 1; j &lt; intervals.length; ++j) &#123; if (intervals[i][1] &gt;= intervals[j][0]) &#123; intervals[i][1] = Math.max(intervals[i][1], intervals[j][1]); &#125; else &#123; // (intervals[i][1] &lt; intervals[j][0]) res.add(new int[]&#123;intervals[i][0], intervals[i][1]&#125;); i = j; &#125; &#125; res.add(new int[]&#123;intervals[i][0], intervals[i][1]&#125;); return res.toArray(new int[res.size()][]); &#125;&#125; 738. 单调递增的数字 从后往前遍历，如果有后一个数大于前一个数，那么就用flag记录后一个数的位置，循环结束后，从flag开始，把后面的数全部赋值‘9’ 注意边界！！！ 1234567891011121314151617class Solution &#123; public int monotoneIncreasingDigits(int n) &#123; String str = String.valueOf(n); char[] ch = str.toCharArray(); int flag = ch.length; for (int i = ch.length - 1; i &gt; 0; --i) &#123; if (ch[i - 1] &gt; ch[i]) &#123; --ch[i - 1]; flag = i; &#125; &#125; for (int i = flag; i &lt; ch.length; ++i) &#123; ch[i] = &#x27;9&#x27;; &#125; return Integer.parseInt(String.valueOf(ch)); &#125; &#125; 968. 监控二叉树:star: 方法一：贪心 1234567891011121314151617181920212223242526272829303132class Solution &#123; int result = 0; public int minCameraCover(TreeNode root) &#123; // dfs后检查根节点是否被覆盖 if (dfs(root) == 404) ++result; return result; &#125; private int dfs(TreeNode root) &#123; // state 404:未覆盖 // state 200:覆盖 // state 201:有监控 //叶节点的左右空孩子需要返回被覆盖，这样才不会在叶子节点上装监控 if (root == null) return 200; // post traversal int leftState = dfs(root.left); int rightState = dfs(root.right); // 1.如果左右子树都被覆盖 if (leftState == 200 &amp;&amp; rightState == 200) return 404; // 2.如果左右子树至少有一个没被覆盖 if (leftState == 404 || rightState == 404) &#123; ++result; return 201; &#125; // 3.如果左右子树至少有一个监控 if (leftState == 201 || rightState == 201) return 200; return 666; &#125;&#125; BackTracing 开始回溯前要知道的 详细讲解 image.png 注意 如果递归终止条件是这个，那么结果回事全空 1234if (depth == len) &#123; res.add(path); return;&#125; 执行 main 方法以后输出如下： 1[[], [], [], [], [], []] 变量 path 所指向的列表 在深度优先遍历的过程中只有一份 ，深度优先遍历完成以后，回到了根结点，成为空列表。 在 Java 中，参数传递是 值传递，对象类型变量在传参的过程中，复制的是变量的地址。这些地址被添加到 res 变量，但实际上指向的是同一块内存地址，因此我们会看到 6 个空的列表对象。解决的方法很简单，在 res.add(path); 这里做一次拷贝即可。 修改的部分： 1234if (depth == len) &#123; res.add(new ArrayList&lt;&gt;(path)); return;&#125; 算法模板 123456789101112void backtracking(参数) &#123; if (终止条件) &#123; 存放结果; return; &#125; for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123; 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果 &#125;&#125; 77. 组合 方法一：回溯 由于已知结果要存放的数组大小为k，所以res使用ArrayList List没有removeLast方法，但是LinkedList中有！ 1234567891011121314151617181920class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; backtracing(n, k, 1); return res; &#125; private void backtracing (int n, int k, int start) &#123; if (path.size() == k) &#123; res.add(new LinkedList&lt;&gt;(path)); return; &#125; for (int i = start; i &lt;= n; ++i) &#123; path.add(i); backtracing(n, k, i + 1); // path.removeLast(); path.removeLast(); &#125; &#125;&#125; 方法二：方法一+剪枝 for循环横向遍历时候，i的执行条件为i &lt;= n - (k - path.size()) + 1 例如，当i = 2，path里已经有1，需要组合k=3个元素，n为4，那么 4 - (3 - 1) + 1 = 3，说明i最多等于3，组成path[1, 3, 4]，如果此时i = 4，那么就不能组成3个元素，只能组成[1,4] 1234567891011121314151617181920class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; backtracing(n, k, 1); return res; &#125; private void backtracing (int n, int k, int start) &#123; if (path.size() == k) &#123; res.add(new LinkedList&lt;&gt;(path)); return; &#125; for (int i = start; i &lt;= n - (k - path.size()) + 1; ++i) &#123; path.add(i); backtracing(n, k, i + 1); // path.removeLast(); path.removeLast(); &#125; &#125;&#125; 方法二：选或不选 防止底层扩容 1Deque&lt;Integer&gt; path = new ArrayDeque&lt;&gt;(k); 若n=3，k=2,即从[1,2,3]中选两个数，如果当前什么都没选(k=2)，n - k + 1= 2，说明至少要从2开始，才能满足选两个数这个要求 123int bound = n - k + 1;if (start &gt; bound) return; 代码如下 123456789101112131415161718192021222324class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; // 防止底层扩容 Deque&lt;Integer&gt; path = new ArrayDeque&lt;&gt;(k); backtracking(path, n, k, 1); return res; &#125; private void backtracking(Deque&lt;Integer&gt; path, int n, int k, int start) &#123; if (k == 0) &#123; res.add(new LinkedList&lt;&gt;(path)); return; &#125; // 若n=3，k=2,即从[1,2,3]中选两个数，如果当前什么都没选(k=2)，n - k + 1= 2， // 说明至少要从2开始，才能满足选两个数这个要求 int bound = n - k + 1; if (start &gt; bound) return; backtracking(path, n, k, start + 1); path.addLast(start); backtracking(path, n, k - 1, start + 1); path.removeLast(); &#125;&#125; 216. 组合总和 III 方法一：回溯+剪枝 i那里的剪枝可以这么理解，假设从i开始取，则从i到n一共有n-i+1个元素，而当前还需要k-path.size()个元素，所以必须满足n-i+1&gt;=k-path.size()，移项就可以得到i&lt;=n+1-(k-path.size()) 12345678910111213141516171819class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) &#123; backtracking(k, n, 1, new ArrayDeque&lt;&gt;(k)); return res; &#125; private void backtracking(int k, int n, int start, Deque&lt;Integer&gt; path) &#123; if (path.size() == k) &#123; if (n == 0) res.add(new LinkedList&lt;&gt;(path)); return; &#125; for (int i = start; i &lt;= 9 - (k - path.size()) + 1; ++i) &#123; path.add(i); backtracking(k, n - i, i + 1, path); path.removeLast(); &#125; &#125;&#125; 方法二：选或不选 注意：int bound = 9 - k + 1;而不是9 - (k - path.size()) + 1，因为这里的递归终止条件是k==0，==k的语义是还剩多少元素没选！！！== 123456789101112131415161718192021class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) &#123; backtracking(k, n, 1, new ArrayDeque&lt;&gt;(k)); return res; &#125; private void backtracking(int k, int n, int start, Deque&lt;Integer&gt; path) &#123; if (k == 0) &#123; if (n == 0) res.add(new LinkedList&lt;&gt;(path)); return; &#125; int bound = 9 - k + 1; if (start &gt; bound) return; backtracking(k, n, start + 1, path); path.add(start); backtracking(k - 1, n - start, start + 1, path); path.removeLast(); &#125;&#125; 17. 电话号码的字母组合 注意边界条件！ 123456789101112131415161718192021222324class Solution &#123; List&lt;String&gt; res = new LinkedList&lt;&gt;(); StringBuilder path = new StringBuilder(); String[] alphabet = &#123;&quot;&quot;, &quot;&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;&#125;; public List&lt;String&gt; letterCombinations(String digits) &#123; if (digits == null || digits.length() == 0) return res; backtracing(digits, 0); return res; &#125; private void backtracing(String digits, int start) &#123; if (path.length() == digits.length()) &#123; res.add(new String(path)); return; &#125; char num = digits.charAt(start); String str = alphabet[num - &#x27;0&#x27;]; for (int i = 0; i &lt; str.length(); ++i) &#123; path.append(str.charAt(i)); backtracing(digits, start + 1); path.deleteCharAt(path.length() - 1); &#125; &#125;&#125; 39. 组合总和 与前面两题不同的是，可以选取相同元素；以及组合不能重复，如[3，5]与[5，3]是同一个组合 同一个 数字可以 无限制重复被选取 解析 方法一：回溯 去重：遇到这一类相同元素不计算顺序的问题，我们在搜索的时候就需要 按某种顺序搜索。具体的做法是：每一次搜索的时候设置 下一轮搜索的起点 begin，请看下图。 img 123456789101112131415161718192021class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; backtracing(candidates, target, 0); return res; &#125; private void backtracing(int[] candidates, int target, int start) &#123; if (target &lt; 0) return; if (target == 0) &#123; res.add(new LinkedList&lt;&gt;(path)); return; &#125; for (int i = start; i &lt; candidates.length; ++i) &#123; path.add(candidates[i]); backtracing(candidates, target - candidates[i], i); path.removeLast(); &#125; &#125;&#125; 方法二：回溯+剪枝 注意： 是i不是start！！！ 回溯前要排序！！！ 123456789101112131415161718192021222324class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; // 排序是剪枝的前提 Arrays.sort(candidates); backtracing(candidates, target, 0); return res; &#125; private void backtracing(int[] candidates, int target, int start) &#123; if (target == 0) &#123; res.add(new LinkedList&lt;&gt;(path)); return; &#125; for (int i = start; i &lt; candidates.length; ++i) &#123; // 由于进入更深层的时候，小于 0 的部分被剪枝，因此递归终止条件值只判断等于 0 的情况 if (target - candidates[i] &lt; 0) break; path.add(candidates[i]); backtracing(candidates, target - candidates[i], i); path.removeLast(); &#125; &#125;&#125; 40. 组合总和 II 树层去重，树枝不需要去重 去重和39题(上一题)以及三数之和差不多 方法一： 注意：if判断条件是i &gt; start， 不是i &gt; 0 12345678910111213141516171819202122232425这个避免重复当思想是在是太重要了。这个方法最重要的作用是，可以让同一层级，不出现相同的元素。即 1 / \\ 2 2 这种情况不会发生 但是却允许了不同层级之间的重复即： / \\ 5 5 例2 1 / 2 这种情况确是允许的 / 2 为何会有这种神奇的效果呢？首先 cur-1 == cur 是用于判定当前元素是否和之前元素相同的语句。这个语句就能砍掉例1。可是问题来了，如果把所有当前与之前一个元素相同的都砍掉，那么例二的情况也会消失。 因为当第二个2出现的时候，他就和前一个2相同了。 那么如何保留例2呢？那么就用cur &gt; begin 来避免这种情况，你发现例1中的两个2是处在同一个层级上的，例2的两个2是处在不同层级上的。在一个for循环中，所有被遍历到的数都是属于一个层级的。我们要让一个层级中，必须出现且只出现一个2，那么就放过第一个出现重复的2，但不放过后面出现的2。第一个出现的2的特点就是 cur == begin. 第二个出现的2 特点是cur &gt; begin. 1234567891011121314151617181920212223242526class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; Arrays.sort(candidates); backtracing(candidates, target, 0); return res; &#125; private void backtracing(int[] candidates, int target, int start) &#123; if (target == 0) &#123; res.add(new LinkedList&lt;&gt;(path)); return; &#125; for (int i = start; i &lt; candidates.length; ++i) &#123; // 剪枝 if (candidates[i] &gt; target) break; // 去重 if (i &gt; start &amp;&amp; candidates[i] == candidates[i - 1]) continue; path.add(candidates[i]); backtracing(candidates, target - candidates[i], i + 1); path.removeLast(); &#125; &#125;&#125; 方法二：used数组 多debug 123456789101112131415161718192021222324252627class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; Arrays.sort(candidates); boolean[] used = new boolean[candidates.length]; backtracking(candidates, used, target, 0); return res; &#125; public void backtracking(int[] candidates, boolean[] used, int target, int start) &#123; if (target == 0) &#123; res.add(new LinkedList(path)); return; &#125; for (int i = start; i &lt; candidates.length; ++i) &#123; if (target &lt; candidates[i]) break; if (i &gt; 0 &amp;&amp; candidates[i] == candidates[i - 1] &amp;&amp; !used[i - 1]) continue; path.add(candidates[i]); used[i] = true; backtracking(candidates, used, target - candidates[i], i + 1); used[i] = false; path.removeLast(); &#125; &#125;&#125; 方法三：选或不选 1234567891011121314151617181920212223class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; Arrays.sort(candidates); backtracking(candidates, false, target, 0); return res; &#125; public void backtracking(int[] candidates, boolean choosePre, int target, int start) &#123; if (target == 0) &#123; res.add(new LinkedList(path)); return; &#125; if (target &lt; 0 || start == candidates.length) return; backtracking(candidates, false, target, start + 1); if (start &gt; 0 &amp;&amp; !choosePre &amp;&amp; candidates[start] == candidates[start - 1]) return; path.add(candidates[start]); backtracking(candidates, true, target - candidates[start], start + 1); path.removeLast(); &#125;&#125; 131. 分割回文串:warning: 12345678910111213141516171819202122232425262728class Solution &#123; List&lt;List&lt;String&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;String&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;String&gt;&gt; partition(String s) &#123; backtracking(s.toCharArray(), 0); return res; &#125; public void backtracking(char[] ch, int start) &#123; if (start == ch.length) &#123; res.add(new LinkedList(path)); return; &#125; for (int i = start; i &lt; ch.length; ++i) &#123; if (isPalindrome(ch, start, i)) &#123; path.add(new String(ch, start, i - start + 1)); backtracking(ch, i + 1); path.removeLast(); &#125; &#125; &#125; public boolean isPalindrome(char[] ch, int start, int end) &#123; while (start &lt; end) &#123; if (ch[start++] != ch[end--]) return false; &#125; return true; &#125;&#125; :star:93. 复原 IP 地址 重做 方法一：回溯 1 78. 子集 以下两种方法的区别： 方法二有横向for循环，使用i进入递归方法 方法一有两个递归方法，分别表示选与不选，用start进入递归犯法 方法一：选或不选 123456789101112131415161718class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; backtracking(nums, 0); return res; &#125; private void backtracking(int[] nums, int start) &#123; if (start == nums.length) &#123; res.add(new LinkedList(path)); return; &#125; backtracking(nums, start + 1); path.add(nums[start]); backtracking(nums, start + 1); path.removeLast(); &#125;&#125; 方法二：for循环横向顺序遍历 12345678910111213141516class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; backtracking(nums, 0); return res; &#125; private void backtracking(int[] nums, int start) &#123; res.add(new LinkedList(path)); for (int i = start; i &lt; nums.length; i++) &#123; path.add(nums[i]); backtracking(nums, i + 1); path.removeLast(); &#125; &#125;&#125; 90. 子集 II 方法一：选或不选 如果前后两个数相等，如[1,2,2]，那么只有在第一个2被选择了，才能选择第二个2，不然会重复 123456789101112131415161718192021class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; Arrays.sort(nums); backtracking(nums, false, 0); return res; &#125; public void backtracking(int[] nums, boolean choosePre, int start) &#123; if (start == nums.length) &#123; res.add(new LinkedList(path)); return; &#125; backtracking(nums, false, start + 1); if (start &gt; 0 &amp;&amp; !choosePre &amp;&amp; nums[start - 1] == nums[start]) return; path.add(nums[start]); backtracking(nums, true, start + 1); path.removeLast(); &#125;&#125; 方法二：顺序递归 注意：if判断条件是i &gt; start， 不是i &gt; 0 12345678910111213141516171819class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; Arrays.sort(nums); backtracking(nums, 0); return res; &#125; public void backtracking(int[] nums, int start) &#123; res.add(new LinkedList(path)); for (int i = start; i &lt; nums.length; ++i) &#123; if (i &gt; start &amp;&amp; nums[i - 1] == nums[i]) continue; path.add(nums[i]); backtracking(nums, i + 1); path.removeLast(); &#125; &#125;&#125; 491. 递增子序列:warning: 方法一：顺序DFS 注意：HashSet的位置！！！每进入一层递归，就会在for循环前创建一个HashSet，这样可以保证树层去重，并且树枝不会qu'chong 1234567891011121314151617181920212223class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; findSubsequences(int[] nums) &#123; backtracking(nums, 0); return res; &#125; public void backtracking(int[] nums, int start) &#123; if (path.size() &gt;= 2) res.add(new LinkedList(path)); Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int i = start; i &lt; nums.length; ++i) &#123; if ((!path.isEmpty() &amp;&amp; nums[i] &lt; path.peekLast())) continue; if (set.contains(nums[i])) continue; set.add(nums[i]); path.add(nums[i]); backtracking(nums, i + 1); path.pollLast(); &#125; &#125;&#125; 46. 全排列 12345678910111213141516171819202122232425class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); boolean[] used; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; used = new boolean[nums.length]; backtracking(nums); return res; &#125; private void backtracking(int[] nums) &#123; if (path.size() == nums.length) &#123; res.add(new LinkedList&lt;&gt;(path)); return; &#125; for (int i = 0; i &lt; nums.length; ++i) &#123; if (!used[i]) &#123; path.add(nums[i]); used[i] = true; backtracking(nums); used[i] = false; path.pollLast(); &#125; &#125; &#125;&#125; 47. 全排列 II 12345678910111213141516171819202122232425262728class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); boolean[] used; public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; Arrays.sort(nums); used = new boolean[nums.length]; backtracking(nums); return res; &#125; public void backtracking(int[] nums) &#123; if (path.size() == nums.length) &#123; res.add(new LinkedList(path)); return; &#125; for (int i = 0; i &lt; nums.length; ++i) &#123; if (i &gt; 0 &amp;&amp; !used[i - 1] &amp;&amp; nums[i - 1] == nums[i]) continue; if (!used[i]) &#123; path.add(nums[i]); used[i] = true; backtracking(nums); used[i] = false; path.pollLast(); &#125; &#125; &#125;&#125; 51. N 皇后 方法一：二维数组存表盘 时间复杂度\\(O(n^n)\\) 空间复杂度\\(O(n^2)\\) 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123; List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; char[][] chessboard = new char[n][n]; for (char[] row : chessboard) Arrays.fill(row, &#x27;.&#x27;); backtracking(0, chessboard, n); return res; &#125; private void backtracking(int row, char[][] chessboard, int n) &#123; if (row == n) &#123; res.add(toList(chessboard)); return; &#125; for (int col = 0; col &lt; n; ++col) &#123; if (isValid(row, col, chessboard, n)) &#123; chessboard[row][col] = &#x27;Q&#x27;; backtracking(row + 1, chessboard, n); chessboard[row][col] = &#x27;.&#x27;; &#125; &#125; &#125; private boolean isValid(int row, int col, char[][] chessboard, int n) &#123; for (int i = 0; i &lt; row; ++i) if (chessboard[i][col] == &#x27;Q&#x27;) return false; for (int i = row - 1, j = col - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; --i, --j) &#123; if (chessboard[i][j] == &#x27;Q&#x27;) return false; &#125; for (int i = row - 1, j = col + 1; i &gt;= 0 &amp;&amp; j &lt; n; --i, ++j) if (chessboard[i][j] == &#x27;Q&#x27;) return false; return true; &#125; private List&lt;String&gt; toList(char[][] chessboard) &#123; List&lt;String&gt; path = new ArrayList&lt;&gt;(); for (char[] ch : chessboard) &#123; path.add(String.copyValueOf(ch)); &#125; return path; &#125;&#125; 方法二：一维数组存储每行皇后的列信息 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123; List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); int[] chessboard; public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; chessboard = new int[n]; backtracking(0, n); return res; &#125; private void backtracking(int row, int n) &#123; if (row == n) &#123; res.add(generatePath(n)); return; &#125; for (int col = 0; col &lt; n; ++col) &#123; if (isValid(row, col, n)) &#123; chessboard[row] = col; backtracking(row + 1, n); chessboard[row] = 0; &#125; &#125; &#125; private boolean isValid(int row, int col, int n) &#123; for (int i = 0; i &lt; row; ++i) &#123; if (chessboard[i] == col || Math.abs(col - chessboard[i]) == Math.abs(row - i)) return false; &#125; return true; &#125; private List&lt;String&gt; generatePath(int n) &#123; List&lt;String&gt; path = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n; ++i) &#123; StringBuilder sb = new StringBuilder(); for (int j = 0; j &lt; n; ++j) &#123; if (j == chessboard[i]) sb.append(&#x27;Q&#x27;); else sb.append(&#x27;.&#x27;); &#125; path.add(sb.toString()); &#125; return path; &#125;&#125; 方法三：位运算加速 113. 路径总和 II Graph 797. 所有可能的路径 优质题解 1234567891011121314151617181920class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; allPathsSourceTarget(int[][] graph) &#123; path.offerLast(0); backtracking(0, graph); return res; &#125; private void backtracking(int start, int[][] graph) &#123; if (start == graph.length - 1) &#123; res.add(new LinkedList(path)); return; &#125; for (int x : graph[start]) &#123; path.offerLast(x); backtracking(x, graph); path.removeLast(); &#125; &#125;&#125; 200. 岛屿数量 方法一：DFS 1234567891011121314151617181920212223class Solution &#123; public int numIslands(char[][] grid) &#123; int res = 0; for (int row = 0; row &lt; grid.length; ++row) &#123; for (int col = 0; col &lt; grid[0].length; ++col) &#123; if (grid[row][col] == &#x27;1&#x27;) &#123; ++res; dfs(row, col, grid); &#125; &#125; &#125; return res; &#125; private void dfs(int row, int col, char[][] grid) &#123; if (row &lt; 0 || row &gt; grid.length - 1 || col &lt; 0 || col &gt; grid[0].length - 1 || grid[row][col] != &#x27;1&#x27;) return; grid[row][col] = &#x27;2&#x27;; dfs(row - 1, col, grid); dfs(row + 1, col, grid); dfs(row, col - 1, grid); dfs(row, col + 1, grid); &#125;&#125; 方法二：BFS 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public int numIslands(char[][] grid) &#123; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); int m = grid.length; int n = grid[0].length; int res = 0; for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (grid[i][j] == &#x27;1&#x27;) &#123; ++res; grid[i][j] = &#x27;2&#x27;; queue.offer(new int[]&#123;i, j&#125;); while (!queue.isEmpty()) &#123; int[] coor = queue.poll(); int row = coor[0], col = coor[1]; if (row - 1 &gt;= 0 &amp;&amp; grid[row - 1][col] == &#x27;1&#x27;) &#123; queue.offer(new int[]&#123;row -1, col&#125;); grid[row - 1][col] = &#x27;2&#x27;; &#125; if (row + 1 &lt; m &amp;&amp; grid[row + 1][col] == &#x27;1&#x27;) &#123; queue.offer(new int[]&#123;row + 1, col&#125;); grid[row + 1][col] = &#x27;2&#x27;; &#125; if (col - 1 &gt;= 0 &amp;&amp; grid[row][col - 1] == &#x27;1&#x27;) &#123; queue.offer(new int[]&#123;row, col - 1&#125;); grid[row][col - 1] = &#x27;2&#x27;; &#125; if (col + 1 &lt; n &amp;&amp; grid[row][col + 1] == &#x27;1&#x27;) &#123; queue.offer(new int[]&#123;row, col + 1&#125;); grid[row][col + 1] = &#x27;2&#x27;; &#125; &#125; &#125; &#125; &#125; return res; &#125;&#125; 方法三：不修改输入数据的DFSF 123456789101112131415161718192021222324class Solution &#123; public int numIslands(char[][] grid) &#123; int res = 0; boolean[][] visited = new boolean[grid.length][grid[0].length]; for (int row = 0; row &lt; grid.length; ++row) &#123; for (int col = 0; col &lt; grid[0].length; ++col) &#123; if (!visited[row][col] &amp;&amp; grid[row][col] == &#x27;1&#x27;) &#123; ++res; dfs(row, col, grid, visited); &#125; &#125; &#125; return res; &#125; private void dfs(int row, int col, char[][] grid, boolean[][] visited) &#123; if (row &gt;= 0 &amp;&amp; col &gt;= 0 &amp;&amp; row &lt; grid.length &amp;&amp; col &lt; grid[0].length &amp;&amp; !visited[row][col] &amp;&amp; grid[row][col] == &#x27;1&#x27;) &#123; visited[row][col] = true; int[][] dirs = new int[][]&#123;&#123;0, -1&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;, &#123;1, 0&#125;&#125;; for (int[] dir : dirs) &#123; dfs(row + dir[0], col + dir[1], grid, visited); &#125; &#125; &#125;&#125; 695. 岛屿的最大面积 方法一：DFS 1234567891011121314151617181920212223242526class Solution &#123; int res = 0; int size = 0; public int maxAreaOfIsland(int[][] grid) &#123; for (int i = 0; i &lt; grid.length; ++i) &#123; for (int j = 0; j &lt; grid[0].length; ++j) &#123; if (grid[i][j] == 1) &#123; size = 0; dfs(i, j, grid); System.out.println(res); &#125; &#125; &#125; return res; &#125; private void dfs(int i, int j, int[][] grid) &#123; if (i &lt; 0 || j &lt; 0 || i == grid.length || j == grid[0].length || grid[i][j] != 1) return; grid[i][j] = 2; res = Math.max(res, ++size); dfs(i - 1, j, grid); dfs(i + 1, j, grid); dfs(i, j - 1, grid); dfs(i, j + 1, grid); &#125;&#125; 不修改输入的DFS 12345678910111213141516171819202122232425class Solution &#123; public int maxAreaOfIsland(int[][] grid) &#123; int res = 0; boolean[][] visited = new boolean[grid.length][grid[0].length]; for (int i = 0; i &lt; grid.length; ++i) &#123; for (int j = 0; j &lt; grid[0].length; ++j) &#123; if (!visited[i][j] &amp;&amp; grid[i][j] == 1) &#123; res = Math.max(res, dfs(i, j, grid, visited)); &#125; &#125; &#125; return res; &#125; private int dfs(int i, int j, int[][] grid, boolean[][] visited) &#123; if (i &lt; 0 || j &lt; 0 || i == grid.length || j == grid[0].length || grid[i][j] != 1 || visited[i][j]) return 0; int res = 1; visited[i][j] = true; int[][] dirs = new int[][]&#123;&#123;0, -1&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;, &#123;1, 0&#125;&#125;; for (int[] dir : dirs) &#123; res += dfs(i + dir[0], j + dir[1], grid, visited); &#125; return res; &#125;&#125; 方法三：DFS标准写法 123456789101112131415161718192021222324252627282930class Solution &#123; public int maxAreaOfIsland(int[][] grid) &#123; int res = 0; int m = grid.length, n = grid[0].length; for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (grid[i][j] == 1) &#123; res = Math.max(res, dfs(i, j, grid)); &#125; &#125; &#125; return res; &#125; public int dfs(int i, int j, int[][] grid) &#123; int res = 1; grid[i][j] = 2; int[][] dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col, grid.length, grid[0].length) &amp;&amp; grid[row][col] == 1) &#123; grid[row][col] = 2; res += dfs(row, col, grid); &#125; &#125; return res; &#125; public boolean isValid(int i, int j, int m, int n) &#123; return (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n); &#125;&#125; 827. 最大人工岛:warning::star: 优质题解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution &#123; public int largestIsland(int[][] grid) &#123; Map&lt;Integer, Integer&gt; idToArea = new HashMap&lt;&gt;(); int id = 2; int m = grid.length, n = grid[0].length; int res = 0; for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (grid[i][j] == 1) &#123; idToArea.put(id, getSingleArea(i, j, grid, id)); ++id; &#125; &#125; &#125; for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; res = Math.max(res, dfs(i, j, grid, idToArea)); &#125; &#125; return res; &#125; private int dfs(int i, int j, int[][] grid, Map&lt;Integer,Integer&gt; idToArea) &#123; // if (i &lt; 0 || j &lt; 0 || i == grid.length || j == grid[0].length) // return 0; if (grid[i][j] &gt; 0) &#123; return idToArea.get(grid[i][j]); &#125; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); int res = 1; int[][] dirs = new int[][]&#123;&#123;0, -1&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;, &#123;1, 0&#125;&#125;; for (int[] dir : dirs) &#123; if (i + dir[0] &lt; 0 || j + dir[1] &lt; 0 || i + dir[0] == grid.length || j + dir[1] == grid[0].length) continue; set.add(grid[i + dir[0]][j + dir[1]]); &#125; for (int element : set) &#123; res += idToArea.getOrDefault(element, 0); &#125; return res; &#125; private int getSingleArea(int i, int j, int[][] grid, int id) &#123; if (i &lt; 0 || j &lt; 0 || i == grid.length || j == grid.length || grid[i][j] != 1) return 0; int res = 1; grid[i][j] = id; int[][] dirs = new int[][]&#123;&#123;0, -1&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;, &#123;1, 0&#125;&#125;; for (int[] dir : dirs) &#123; res += getSingleArea(i + dir[0], j + dir[1], grid, id); &#125; return res; &#125;&#125; 二刷 注意hashmap与hashset的使用细节 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution &#123; public int largestIsland(int[][] grid) &#123; int res = 0; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); int id = 2; for (int i = 0; i &lt; grid.length; ++i) &#123; for (int j = 0; j &lt; grid[0].length; ++j) &#123; if (grid[i][j] == 1) &#123; map.put(id, getArea(i, j, grid, id)); ++id; &#125; &#125; &#125; for (int i = 0; i &lt; grid.length; ++i) &#123; for (int j = 0; j &lt; grid[0].length; ++j) &#123; res = Math.max(res, dfs(i, j, grid, map)); &#125; &#125; return res; &#125; public int dfs(int i, int j, int[][] grid, Map&lt;Integer, Integer&gt; map) &#123; if (grid[i][j] &gt; 0) return map.get(grid[i][j]); Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); int res = 1; int[][] dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col, grid)) &#123; int id = grid[row][col]; set.add(id); &#125; &#125; for (int id : set) &#123; res += map.getOrDefault(id, 0); &#125; return res; &#125; public int getArea(int i, int j, int[][] grid, int id) &#123; grid[i][j] = id; int res = 1; int[][] dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col, grid) &amp;&amp; grid[row][col] == 1) &#123; grid[row][col] = id; res += getArea(row, col, grid, id); &#125; &#125; return res; &#125; public boolean isValid(int i, int j, int[][] grid) &#123; return (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; grid.length &amp;&amp; j &lt; grid[0].length); &#125;&#125; 463. 岛屿的周长 方法一：DFS 岛屿的上下左右如果是水域或者超出边界，那么周长加一 1234567891011121314151617181920212223242526272829303132class Solution &#123; public int islandPerimeter(int[][] grid) &#123; for (int i = 0; i &lt; grid.length; ++i) &#123; for (int j = 0; j &lt; grid[0].length; ++j) &#123; if (grid[i][j] == 1) &#123; grid[i][j] = 2; return dfs(i, j, grid); &#125; &#125; &#125; return -1; &#125; private int dfs(int i, int j, int[][] grid) &#123; int res = 0; int[][] dirs = new int[][]&#123;&#123;0, -1&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;, &#123;1, 0&#125;&#125;; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col, grid) &amp;&amp; grid[row][col] == 1) &#123; grid[row][col] = 2; res += dfs(row, col, grid); &#125; else &#123; if (!isValid(row, col, grid) || grid[row][col] == 0) ++res; &#125; &#125; return res; &#125; private boolean isValid(int i, int j, int[][] grid) &#123; return !(i &lt; 0 || j &lt; 0 || i == grid.length || j == grid[0].length); &#125;&#125; 1020. 飞地的数量:warning: 遇到一个陆地，只会返回numEnclaves进入dfs返回的值，因为相连的陆地在grid中会被修改，numEnclaves循环中不会再次fang'wen 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public int numEnclaves(int[][] grid) &#123; int res = 0; for (int i = 0; i &lt; grid.length; ++i) &#123; for (int j = 0; j &lt; grid[0].length; ++j) &#123; if (grid[i][j] == 1) &#123; grid[i][j] = 2; res += dfs(i, j, grid); &#125; &#125; &#125; return res; &#125; private int dfs(int i, int j, int[][] grid) &#123; int res = 1; int[][] dirs = new int[][]&#123;&#123;0, -1&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;, &#123;1, 0&#125;&#125;; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (!isValid(row, col, grid)) &#123; grid[i][j] = 3; &#125; else if (grid[row][col] == 1) &#123; grid[row][col] = 2; int ans = dfs(row, col, grid); if (ans == 0) &#123; grid[i][j] = 3; &#125; else res += ans; &#125; &#125; return grid[i][j] == 3 ? 0 : res; &#125; private boolean isValid(int i, int j, int[][] grid) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; grid.length &amp;&amp; j &lt; grid[0].length; &#125;&#125; 130. 被围绕的区域 从边界(第一行，最后一行以及第一列和最后一列)找到O，这些O肯定不会被围绕，把这些O都标记为# 把其他位置的O全部赋值为X，将#还原为O 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; public void solve(char[][] board) &#123; int m = board.length, n = board[0].length; if (m &lt;= 2 || n &lt;= 2) return; for (int i = 0; i &lt; m; i += m - 1) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (board[i][j] == &#x27;O&#x27;) &#123; board[i][j] = &#x27;#&#x27;; dfs(i, j, board); &#125; &#125; &#125; for (int j = 0; j &lt; n; j += n - 1) &#123; for (int i = 0; i &lt; m; ++i) &#123; if (board[i][j] == &#x27;O&#x27;) &#123; board[i][j] = &#x27;#&#x27;; dfs(i, j, board); &#125; &#125; &#125; for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (board[i][j] == &#x27;O&#x27;) board[i][j] = &#x27;X&#x27;; else if (board[i][j] == &#x27;#&#x27;) board[i][j] = &#x27;O&#x27;; &#125; &#125; &#125; private void dfs(int i, int j, char[][] board) &#123; int[][] dirs = new int[][] &#123;&#123;0, -1&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;, &#123;1, 0&#125;&#125;; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col, board) &amp;&amp; board[row][col] == &#x27;O&#x27;) &#123; board[row][col] = &#x27;#&#x27;; dfs(row, col, board); &#125; &#125; &#125; private boolean isValid(int i, int j, char[][] board) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; board[0].length &amp;&amp; i &lt; board.length; &#125;&#125; 417. 太平洋大西洋水流问题:star: 方法一：DFS 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; pacificAtlantic(int[][] heights) &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); int m = heights.length, n = heights[0].length; boolean[][] pacific = new boolean[m][n], atlantic = new boolean[m][n]; for (int j = 0; j &lt; n; ++j) dfs(0, j, heights, pacific); for (int i = 1; i &lt; m; ++i) dfs(i, 0, heights, pacific); for (int j = 0; j &lt; n; ++j) dfs(m - 1, j, heights, atlantic); for (int i = 0; i &lt; m - 1; ++i) dfs(i, n - 1, heights, atlantic); for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (pacific[i][j] &amp;&amp; atlantic[i][j]) &#123; List&lt;Integer&gt; temp = new ArrayList&lt;&gt;(2); temp.add(i); temp.add(j); res.add(temp); &#125; &#125; &#125; return res; &#125; public void dfs(int i, int j, int[][] heights, boolean[][] ocean) &#123; if (ocean[i][j]) return; ocean[i][j] = true; int[][] dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col, heights) &amp;&amp; heights[row][col] &gt;= heights[i][j]) dfs(row, col, heights, ocean); &#125; &#125; public boolean isValid(int i, int j, int[][] heights) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; heights.length &amp;&amp; j &lt; heights[0].length; &#125;&#125; 127. 单词接龙 方法一：单向广度优先搜索 需要两个队列存储邻居，第一个队列存储的邻居neighbor1距离beginWord的距离是d，将neighbor1的邻居neighbor2存储在queue2中，neighbor2距离beginWord的距离是d + 1 每当把访问完所有queue1中的neighbor1，并且将neighbor2加入到queue2中，那么需要访问新一轮邻居，于是把queue1指向queue2(queue2赋值给queue1)，queue2再新开辟一段空间，此时length(距离)需要加一 开始时需要使用一个HashSet，并将单词表直接放进去，Set&lt;String&gt; set = new HashSet&lt;&gt;(wordList)。函数getNeibours用于找到当前单词所有可能的邻居单词(只有一个字母不同)，对比set中的单词表，如果set中有对应的邻居单词x，则把x加入queue1，并且从set中移除x(如果不移除x，则会重复计算，比如hot的邻居有lot,如果不移除lot，那么下次，如下图 image-20230509162229556 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123; public int ladderLength(String beginWord, String endWord, List&lt;String&gt; wordList) &#123; Queue&lt;String&gt; queue1 = new LinkedList&lt;&gt;(); Queue&lt;String&gt; queue2 = new LinkedList&lt;&gt;(); Set&lt;String&gt; set = new HashSet&lt;&gt;(wordList); int length = 1; queue1.offer(beginWord); while (!queue1.isEmpty()) &#123; String word = queue1.poll(); if (word.equals(endWord)) return length; List&lt;String&gt; neibours = getNeibours(word); for (String str : neibours) &#123; if (set.contains(str)) &#123; queue2.offer(str); set.remove(str); &#125; &#125; if (queue1.isEmpty()) &#123; ++length; queue1 = queue2; queue2 = new LinkedList&lt;&gt;(); &#125; &#125; return 0; &#125; public List&lt;String&gt; getNeibours(String word) &#123; List&lt;String&gt; neibours = new ArrayList&lt;&gt;(); char[] ch = word.toCharArray(); for (int i = 0; i &lt; ch.length; ++i) &#123; char original = ch[i]; for (char j = &#x27;a&#x27;; j &lt;= &#x27;z&#x27;; ++j) &#123; if (j != original) &#123; ch[i] = j; neibours.add(new String(ch)); &#125; &#125; // backtracking ch[i] = original; &#125; return neibours; &#125;&#125; 剑指 Offer II 109. 开密码锁 注意visited的位置！！！同上一题，在入队时就在visited加入该邻居，避免之后的重复访问 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123; public int openLock(String[] deadends, String target) &#123; Set&lt;String&gt; deadSet = new HashSet&lt;&gt;(Arrays.asList(deadends)), visited = new HashSet&lt;&gt;(); String init = &quot;0000&quot;; if (deadSet.contains(init) || deadSet.contains(target)) return -1; visited.add(init); Queue&lt;String&gt; queue1 = new LinkedList&lt;&gt;(), queue2 = new LinkedList&lt;&gt;(); queue1.offer(init); int res = 0; while (!queue1.isEmpty()) &#123; String code = queue1.poll(); if (code.equals(target)) return res; List&lt;String&gt; neibors = getNeibors(code); for (String neibor : neibors) &#123; if (!deadSet.contains(neibor) &amp;&amp; !visited.contains(neibor)) &#123; queue2.offer(neibor); visited.add(neibor); &#125; &#125; if (queue1.isEmpty()) &#123; ++res; queue1 = queue2; queue2 = new LinkedList&lt;&gt;(); &#125; &#125; return -1; &#125; public List&lt;String&gt; getNeibors(String code) &#123; List&lt;String&gt; neibors = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; code.length(); ++i) &#123; char cur = code.charAt(i); StringBuilder sb = new StringBuilder(code); // down char changed = cur == &#x27;0&#x27; ? &#x27;9&#x27; : (char) (cur - 1); sb.setCharAt(i, changed); neibors.add(sb.toString()); // up changed = cur == &#x27;9&#x27; ? &#x27;0&#x27; : (char) (cur + 1); sb.setCharAt(i, changed); neibors.add(sb.toString()); &#125; return neibors; &#125;&#125; 剑指 Offer II 106. 二分图:warning: 方法一：DFS 染色法需要二刷 12345678910111213141516171819202122232425262728293031323334class Solution &#123; private static final int UNCOLORED = 0; private static final int RED = 1; private static final int BLUE = 2; private int[] colorArray; private boolean res = true; public boolean isBipartite(int[][] graph) &#123; colorArray = new int[graph.length]; for (int i = 0; i &lt; graph.length &amp;&amp; res; ++i) &#123; if (colorArray[i] == UNCOLORED) &#123; dfs(i, graph, RED); &#125; &#125; return res; &#125; private void dfs(int i, int[][] graph, int color) &#123; colorArray[i] = color; int neighborColor = color == RED ? BLUE : RED; for (int neibor : graph[i]) &#123; if (colorArray[neibor] == UNCOLORED) &#123; dfs(neibor, graph, neighborColor); if (!res) return; &#125; else if (colorArray[neibor] == neighborColor) &#123; continue; &#125; else &#123; res = false; return; &#125; &#125; &#125;&#125; 方法二：BFS 123456789101112131415161718192021222324252627282930class Solution &#123; private static final int UNCOLORED = 0; private static final int RED = 1; private static final int BLUE = 2; private int[] colorArray; public boolean isBipartite(int[][] graph) &#123; int n = graph.length; colorArray = new int[graph.length]; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; n; ++i) &#123; if (colorArray[i] == UNCOLORED) &#123; queue.offer(i); colorArray[i] = RED; while (!queue.isEmpty()) &#123; int cur = queue.poll(); int neiborColor = colorArray[cur] == RED ? BLUE : RED; for (int neibor : graph[cur]) &#123; if (colorArray[neibor] == UNCOLORED) &#123; queue.offer(neibor); colorArray[neibor] = neiborColor; &#125; else if (colorArray[neibor] != neiborColor) return false; &#125; &#125; &#125; &#125; return true; &#125;&#125; 剑指 Offer II 107. 矩阵中的距离 方法一：BFS 12345678910111213141516171819202122232425262728293031323334class Solution &#123; public int[][] updateMatrix(int[][] mat) &#123; int m = mat.length, n = mat[0].length; int[][] dist = new int[m][n]; boolean[][] visited = new boolean[m][n]; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; mat.length; ++i) &#123; for (int j = 0; j &lt; mat[i].length; ++j) &#123; if (mat[i][j] == 0) &#123; visited[i][j] = true; // dist[i][j] = 0; queue.offer(new int[]&#123;i, j&#125;); &#125; &#125; &#125; int[][] dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; while (!queue.isEmpty()) &#123; int[] pos = queue.poll(); int distance = dist[pos[0]][pos[1]]; for (int[] dir : dirs) &#123; int row = pos[0] + dir[0], col = pos[1] + dir[1]; if (isValid(row, col, m, n) &amp;&amp; !visited[row][col]) &#123; visited[row][col] = true; queue.offer(new int[]&#123;row, col&#125;); dist[row][col] = distance + 1; &#125; &#125; &#125; return dist; &#125; private boolean isValid(int i, int j, int m, int n) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125;&#125; 剑指 Offer II 111. 计算除法:warning: 方法一：BFS 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123; public double[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, double[] values, List&lt;List&lt;String&gt;&gt; queries) &#123; double[] res = new double[queries.size()]; Map&lt;String, Map&lt;String, Double&gt;&gt; graph = buildGraph(equations, values); for (int i = 0; i &lt; queries.size(); ++i) &#123; String from = queries.get(i).get(0); String to = queries.get(i).get(1); if (!graph.containsKey(from) || !graph.containsKey(to)) res[i] = -1; else &#123; Set&lt;String&gt; visited = new HashSet&lt;&gt;(); res[i] = dfs(graph, visited, from, to); &#125; &#125; return res; &#125; private double dfs(Map&lt;String, Map&lt;String, Double&gt;&gt; graph, Set&lt;String&gt; visited, String from, String to) &#123; if (from.equals(to)) return 1.0; visited.add(from); for (Map.Entry&lt;String, Double&gt; entry: graph.get(from).entrySet()) &#123; String key = entry.getKey(); double val = entry.getValue(); if (!visited.contains(key)) &#123; double res = dfs(graph, visited, key, to); if (res != -1) &#123; return res * val; &#125; &#125; &#125; visited.remove(from); return -1.0; &#125; private Map&lt;String, Map&lt;String, Double&gt;&gt; buildGraph(List&lt;List&lt;String&gt;&gt; equations, double[] values) &#123; Map&lt;String, Map&lt;String, Double&gt;&gt; graph = new HashMap&lt;&gt;(); for (int i = 0; i &lt; equations.size(); ++i) &#123; String var1 = equations.get(i).get(0); String var2 = equations.get(i).get(1); graph.putIfAbsent(var1, new HashMap&lt;&gt;()); graph.get(var1).put(var2, values[i]); graph.putIfAbsent(var2, new HashMap&lt;&gt;()); graph.get(var2).putIfAbsent(var1, 1.0 / values[i]); &#125; return graph; &#125;&#125; 剑指 Offer II 112. 最长递增路径:star: 方法一：DFS 1234567891011121314151617181920212223242526272829303132class Solution &#123; int[][] dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; int[][] path; public int longestIncreasingPath(int[][] matrix) &#123; int res = 0, m = matrix.length, n = matrix[0].length; path = new int[m][n]; for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; int dist = dfs(i, j, m, n, matrix); res = Math.max(res, dist); &#125; &#125; return res; &#125; public int dfs(int i, int j, int m, int n, int[][] matrix) &#123; if (path[i][j] != 0) return path[i][j]; int max = 1; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col, m, n) &amp;&amp; matrix[row][col] &gt; matrix[i][j]) &#123; int dist = dfs(row, col, m, n, matrix); max = Math.max(max, dist + 1); &#125; &#125; path[i][j] = max; return max; &#125; public boolean isValid(int i, int j, int m, int n) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125;&#125; 剑指 Offer II 113. 课程顺序 方法一：拓扑排序 123456789101112131415161718192021222324252627class Solution &#123; public int[] findOrder(int numCourses, int[][] prerequisites) &#123; Map&lt;Integer, List&lt;Integer&gt;&gt; graph = new HashMap&lt;&gt;(); for (int i = 0; i &lt; numCourses; ++i) graph.put(i, new LinkedList&lt;&gt;()); int[] inDegrees = new int[numCourses]; for (int i = 0; i &lt; prerequisites.length; ++i) &#123; ++inDegrees[prerequisites[i][0]]; graph.get(prerequisites[i][1]).add(prerequisites[i][0]); &#125; List&lt;Integer&gt; order = new LinkedList&lt;&gt;(); Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; numCourses; ++i) if (inDegrees[i] == 0) queue.offer(i); while (!queue.isEmpty()) &#123; int node = queue.poll(); order.add(node); for (int next : graph.get(node)) &#123; if (--inDegrees[next] == 0) &#123; queue.offer(next); &#125; &#125; &#125; return order.size() == numCourses ? order.stream().mapToInt(Integer::intValue).toArray() : new int[0]; &#125;&#125; 剑指 Offer II 114. 外星文字典 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123; public String alienOrder(String[] words) &#123; Map&lt;Character, Set&lt;Character&gt;&gt; graph = new HashMap&lt;&gt;(); Map&lt;Character, Integer&gt; inDegrees = new HashMap&lt;&gt;(); for (String word : words) &#123; for (char ch : word.toCharArray()) &#123; graph.putIfAbsent(ch, new HashSet&lt;&gt;()); inDegrees.putIfAbsent(ch, 0); &#125; &#125; for (int i = 1; i &lt; words.length; ++i) &#123; String word1 = words[i - 1]; String word2 = words[i]; if (word1.startsWith(word2) &amp;&amp; !word1.equals(word2)) return &quot;&quot;; for (int j = 0; j &lt; word1.length() &amp;&amp; j &lt; word2.length(); ++j) &#123; char ch1 = word1.charAt(j); char ch2 = word2.charAt(j); if (ch1 != ch2) &#123; if (!graph.get(ch1).contains(ch2)) &#123; graph.get(ch1).add(ch2); inDegrees.put(ch2, inDegrees.get(ch2) + 1); &#125; break; &#125; &#125; &#125; Queue&lt;Character&gt; queue = new LinkedList&lt;&gt;(); for (Map.Entry&lt;Character, Integer&gt; entry : inDegrees.entrySet()) &#123; if (entry.getValue() == 0) &#123; queue.offer(entry.getKey()); &#125; &#125; StringBuilder res = new StringBuilder(); while (!queue.isEmpty()) &#123; char ch = queue.poll(); res.append(ch); Set&lt;Character&gt; nexts = graph.get(ch); for (char next : nexts) &#123; inDegrees.put(next, inDegrees.get(next) - 1); if (inDegrees.get(next) == 0) queue.offer(next); &#125; &#125; return res.length() == graph.size() ? res.toString() : &quot;&quot;; &#125;&#125; 剑指 Offer II 115. 重建序列 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123; public boolean sequenceReconstruction(int[] nums, int[][] sequences) &#123; Map&lt;Integer, Set&lt;Integer&gt;&gt; graph = new HashMap&lt;&gt;(); Map&lt;Integer, Integer&gt; inDegrees = new HashMap&lt;&gt;(); for (int[] sequence : sequences) &#123; for (int num : sequence) &#123; graph.putIfAbsent(num, new HashSet&lt;&gt;()); inDegrees.put(num, 0); &#125; &#125; for (int i = 0; i &lt; sequences.length; ++i) &#123; for (int j = 1; j &lt; sequences[i].length; ++j) &#123; int num1 = sequences[i][j - 1], num2 = sequences[i][j]; if (!graph.get(num1).contains(num2)) &#123; graph.get(num1).add(num2); inDegrees.put(num2, inDegrees.get(num2) + 1); &#125; &#125; &#125; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); for (Map.Entry&lt;Integer, Integer&gt; entry : inDegrees.entrySet()) &#123; if (entry.getValue() == 0) &#123; queue.offer(entry.getKey()); &#125; &#125; List&lt;Integer&gt; res = new LinkedList&lt;&gt;(); while (queue.size() == 1) &#123; int num = queue.poll(); res.add(num); Set&lt;Integer&gt; nexts = graph.get(num); for (int next : nexts) &#123; inDegrees.put(next, inDegrees.get(next) - 1); if (inDegrees.get(next) == 0) queue.offer(next); &#125; &#125; int[] resToArr = res.stream().mapToInt(Integer::intValue).toArray(); return Arrays.equals(resToArr, nums); &#125;&#125; 剑指 Offer II 116. 省份数量 方法一：DFS 1234567891011121314151617181920212223class Solution &#123; public int findCircleNum(int[][] isConnected) &#123; int n = isConnected.length; int res = 0; boolean[] visited = new boolean[n]; for (int i = 0; i &lt; n; ++i) &#123; if (!visited[i]) &#123; visited[i] = true; dfs(i, n, visited, isConnected); ++res; &#125; &#125; return res; &#125; private void dfs(int i, int n, boolean[] visited, int[][] isConnected) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (isConnected[i][j] == 1 &amp;&amp; !visited[j]) &#123; visited[j] = true; dfs(j, n, visited, isConnected); &#125; &#125; &#125;&#125; 方法二：BFS 12345678910111213141516171819202122232425class Solution &#123; public int findCircleNum(int[][] isConnected) &#123; int n = isConnected.length; int res = 0; boolean[] visited = new boolean[n]; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; n; ++i) &#123; if (!visited[i]) &#123; ++res; queue.offer(i); while (!queue.isEmpty()) &#123; int province = queue.poll(); visited[province] = true; for (int j = 0; j &lt; n; ++j) &#123; if (isConnected[province][j] == 1 &amp;&amp; !visited[j]) &#123; visited[j] = true; queue.offer(j); &#125; &#125; &#125; &#125; &#125; return res; &#125;&#125; 方法三：并查集 并查集的讲解 findFather一定要return fathers[i]，而不是return i，因为当0的father是1的时候，return 1 而不是return 0！ 两层for循环第二层j = i + 1，因为首先j = i的话，是遍历两个相同的节点没意义；其次，i之前的节点在之前就已经合并过了，所以不需要再遍历了 123456789101112131415161718192021222324252627282930313233class Solution &#123; public int findCircleNum(int[][] isConnected) &#123; int n = isConnected.length; int res = n; int[] fathers = new int[n]; for (int i = 0; i &lt; n; ++i) fathers[i] = i; for (int i = 0; i &lt; n; ++i) &#123; for (int j = i + 1; j &lt; n; ++j) &#123; if (isConnected[i][j] == 1 &amp;&amp; union(i, j, fathers)) &#123; --res; &#125; &#125; &#125; return res; &#125; private boolean union(int i, int j, int[] fathers) &#123; int fatherOfI = findFather(i, fathers); int fatherOfJ = findFather(j, fathers); if (fatherOfI != fatherOfJ) &#123; fathers[fatherOfI] = fatherOfJ; return true; &#125; return false; &#125; private int findFather(int i, int[] fathers) &#123; if (i != fathers[i]) fathers[i] = findFather(fathers[i], fathers); return fathers[i]; &#125;&#125; 剑指 Offer II 117. 相似的字符串 方法一：并查集 判断是否是相似字符串的函数isAnalogical之前用的蠢方法，还要拷贝再交换，直接判断不同字符num的个数就行 如果num==0，那么相似 由于题目给出的字符串数组中，所有字符串互为 字母异位词(字母顺序不同)，所以num == 2时，是交换了两个字符，如果num &gt; 2，就不符合题意了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123; public int numSimilarGroups(String[] strs) &#123; int n = strs.length; int res = n; int[] fathers = new int[n]; for (int i = 0; i &lt; n; ++i) fathers[i] = i; for (int i = 0; i &lt; n; ++i) &#123; for (int j = i + 1; j &lt; n; ++j) &#123; String str1 = strs[i], str2 = strs[j]; if (isAnalogical(str1, str2) &amp;&amp; union(i, j, fathers)) &#123; --res; &#125; &#125; &#125; return res; &#125; private boolean union(int i, int j, int[] fathers) &#123; int fatherOfI = findFather(i, fathers); int fatherOfJ = findFather(j, fathers); if (fatherOfI != fatherOfJ) &#123; fathers[fatherOfI] = fatherOfJ; return true; &#125; return false; &#125; private int findFather(int i, int[] fathers) &#123; if (i != fathers[i]) fathers[i] = findFather(fathers[i], fathers); return fathers[i]; &#125; private boolean isAnalogical(String a, String b) &#123; int num = 0; for (int i = 0; i &lt; a.length(); i++) &#123; if (a.charAt(i) != b.charAt(i)) &#123; num++; if (num &gt; 2) &#123; return false; &#125; &#125; &#125; return true; &#125;&#125; 剑指 Offer II 118. 多余的边 方法一：并查集 image-20230515135402396 123456789101112131415161718192021222324252627282930class Solution &#123; public int[] findRedundantConnection(int[][] edges) &#123; int n = edges.length; int[] fathers = new int[n + 1]; for (int i = 0; i &lt; n; ++i) fathers[i] = i; for (int[] edge : edges) &#123; int node1 = edge[0], node2 = edge[1]; if (!union(node1, node2, fathers)) return new int[]&#123;node1, node2&#125;; &#125; return new int[2]; &#125; private boolean union(int i, int j, int[] fathers) &#123; int fatherOfI = findFather(i, fathers); int fatherOfJ = findFather(j, fathers); if (fatherOfI != fatherOfJ) &#123; fathers[fatherOfI] = fatherOfJ; return true; &#125; return false; &#125; private int findFather(int i, int[] fathers) &#123; if (i != fathers[i]) fathers[i] = findFather(fathers[i], fathers); return fathers[i]; &#125;&#125; 剑指 Offer II 119. 最长连续序列 方法一：暴力 12345678910111213141516171819202122class Solution &#123; public int longestConsecutive(int[] nums) &#123; if (nums.length == 0) return 0; Arrays.sort(nums); for (int i : nums) System.out.print(i + &quot; &quot;); int res = 1, cur = 1; for (int i = 1; i &lt; nums.length; ++i) &#123; if (nums[i] == nums[i - 1]) continue; if (nums[i] - nums[i - 1] == 1) &#123; ++cur; res = Math.max(res, cur); &#125; else &#123; cur = 1; &#125; &#125; return res; &#125;&#125; 方法二：并查集 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public int longestConsecutive(int[] nums) &#123; Map&lt;Integer, Integer&gt; fathers = new HashMap&lt;&gt;(), count = new HashMap&lt;&gt;(); Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int num : nums) &#123; fathers.put(num, num); count.put(num, 1); set.add(num); &#125; for (int num : nums) &#123; if (set.contains(num + 1)) &#123; union(num, num + 1, fathers, count); &#125; if (set.contains(num - 1)) &#123; union(num, num - 1, fathers, count); &#125; &#125; int res = 0; for (int val : count.values()) &#123; res = Math.max(res, val); &#125; return res; &#125; private void union(int i, int j, Map&lt;Integer, Integer&gt; fathers, Map&lt;Integer, Integer&gt; count) &#123; int fatherOfI = findFather(i, fathers); int fatherOfJ = findFather(j, fathers); if (fatherOfI != fatherOfJ) &#123; fathers.put(fatherOfI, fatherOfJ); count.put(fatherOfJ, count.get(fatherOfI) + count.get(fatherOfJ)); &#125; &#125; private int findFather(int i, Map&lt;Integer, Integer&gt; fathers) &#123; int fatherOfI = fathers.get(i); if (i != fatherOfI) &#123; fathers.put(i, findFather(fatherOfI, fathers)); &#125; return fathers.get(i); &#125;&#125; Binary Search 剑指 Offer II 068. 查找插入位置 方法一： 如果nums中有target，那么会被找到并被返回 如果nums中没有target，那么有三种情况，这个数应该被插入道 第一个位置 最后一个位置 中间 这三种情况的索引都是退出循环后的left！！！ 12345678910111213141516class Solution &#123; public int searchInsert(int[] nums, int target) &#123; int left = 0, right = nums.length - 1; while (left &lt;= right) &#123; int mid = right - ((right - left) &gt;&gt; 1); if (nums[mid] == target) return mid; else if (nums[mid] &gt; target) right = mid - 1; else &#123; left = mid + 1; &#125; &#125; return left; &#125;&#125; 方法二： 1234567891011121314151617class Solution &#123; public int searchInsert(int[] nums, int target) &#123; int left = 0, right = nums.length - 1; while (left &lt;= right) &#123; int mid = right - ((right - left) &gt;&gt; 1); if (nums[mid] &gt;= target) &#123; if (mid == 0 || nums[mid - 1] &lt; target) return mid; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; return nums.length; &#125;&#125; Heap 剑指 Offer II 059. 数据流的第 K 大数值 方法一：小根堆 1234567891011121314151617181920212223242526class KthLargest &#123; private PriorityQueue&lt;Integer&gt; queue; private int size; public KthLargest(int k, int[] nums) &#123; queue = new PriorityQueue&lt;&gt;(); size = k; for (int num : nums) &#123; add(num); &#125; &#125; public int add(int val) &#123; queue.offer(val); if (queue.size() &gt; size) &#123; queue.poll(); &#125; return queue.peek(); &#125;&#125;/** * Your KthLargest object will be instantiated and called as such: * KthLargest obj = new KthLargest(k, nums); * int param_1 = obj.add(val); */ 方法二：小根堆另一种写法 1234567891011121314151617181920212223242526272829class KthLargest &#123; private PriorityQueue&lt;Integer&gt; queue; private int k; public KthLargest(int k, int[] nums) &#123; queue = new PriorityQueue&lt;&gt;(); this.k = k; for (int num : nums) &#123; add(num); &#125; &#125; public int add(int val) &#123; if (queue.size() &lt; k) &#123; queue.offer(val); &#125; else if (queue.size() == k &amp;&amp; queue.peek() &lt; val) &#123; queue.poll(); queue.offer(val); &#125; return queue.peek(); &#125;&#125;/** * Your KthLargest object will be instantiated and called as such: * KthLargest obj = new KthLargest(k, nums); * int param_1 = obj.add(val); */ 剑指 Offer II 060. 出现频率最高的 k 个数字 方法一：小根堆 小根堆的比较方式 小根堆的类型是Map.Entry 123456789101112131415161718192021222324class Solution &#123; public int[] topKFrequent(int[] nums, int k) &#123; Map&lt;Integer, Integer&gt; count = new HashMap&lt;&gt;(); for (int num : nums) &#123; count.put(num, count.getOrDefault(num, 0) + 1); &#125; PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; minHeap = new PriorityQueue&lt;&gt;( (e1, e2) -&gt; e1.getValue() - e2.getValue()); for (Map.Entry&lt;Integer, Integer&gt; entry : count.entrySet()) &#123; if (minHeap.size() &lt; k) &#123; minHeap.offer(entry); &#125; else if (entry.getValue() &gt; minHeap.peek().getValue()) &#123; minHeap.poll(); minHeap.offer(entry); &#125; &#125; int[] res = new int[k]; int i = 0; while (!minHeap.isEmpty()) res[i++] = minHeap.poll().getKey(); return res; &#125;&#125; 剑指 Offer II 061. 和最小的 k 个数对 方法一：大根堆 12345678910111213141516171819202122class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; kSmallestPairs(int[] nums1, int[] nums2, int k) &#123; PriorityQueue&lt;int[]&gt; maxHeap = new PriorityQueue&lt;&gt;( (o1, o2) -&gt; o2[0] + o2[1] - o1[0] - o1[1]); for (int i = 0; i &lt; Math.min(k, nums1.length); ++i) &#123; for (int j = 0; j &lt; Math.min(k, nums2.length); ++j) &#123; if (maxHeap.size() &lt; k) maxHeap.offer(new int[]&#123;nums1[i], nums2[j]&#125;); else if (maxHeap.peek()[0] + maxHeap.peek()[1] &gt; nums1[i] + nums2[j]) &#123; maxHeap.poll(); maxHeap.offer(new int[]&#123;nums1[i], nums2[j]&#125;); &#125; &#125; &#125; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); while (!maxHeap.isEmpty()) &#123; int[] temp = maxHeap.poll(); res.add(Arrays.asList(temp[0], temp[1])); &#125; return res; &#125;&#125; 排序 快速排序 边界问题：end &gt; start。当start == end的时候，已经是排序好的一个数，不需要在进行partition 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public int[] sortArray(int[] nums) &#123; quickSort(nums, 0, nums.length - 1); return nums; &#125; private void quickSort(int[] nums, int start, int end) &#123; if (end &gt; start) &#123; int pivot = partition(nums, start, end); quickSort(nums, start, pivot - 1); quickSort(nums, pivot + 1, end); &#125; &#125; private int partition(int[] nums, int start, int end) &#123; int random = new Random().nextInt(end - start + 1) + start; swap(nums, random, end); int small = start - 1; for (int i = start; i &lt; end; ++i) &#123; if (nums[i] &lt; nums[end]) &#123; ++small; swap(nums, small, i); &#125; &#125; // 没有小于pivot的数了 ++small; swap(nums, small, end); return small; &#125; private void swap(int[] nums, int random, int end) &#123; if (random != end) &#123; int temp = nums[end]; nums[end] = nums[random]; nums[random] = temp; &#125; &#125; public static void main(String[] args) &#123; int[] nums = new int[]&#123;5, 2, 3, 1, 4&#125;; int[] clone = nums.clone(); QuickSort quickSort = new QuickSort(); quickSort.sortArray(nums); for (int num : nums) System.out.print(num + &quot; &quot;); System.out.println(); Arrays.sort(clone); for (int cl : clone) System.out.print(cl + &quot; &quot;); &#125; 剑指 Offer II 076. 数组中的第 k 大的数字 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public int findKthLargest(int[] nums, int k) &#123; int target = nums.length - k; int start = 0, end = nums.length - 1; int pivot = partition(nums, start, end); while (pivot != target) &#123; if (pivot &gt; target) &#123; end = pivot - 1; &#125; else &#123; start = pivot + 1; &#125; pivot = partition(nums, start, end); &#125; return nums[pivot]; &#125; public int partition(int[] nums, int start , int end) &#123; int random = new Random().nextInt(end - start + 1) + start; swap(nums, random, end); int small = start - 1; for (int i = start; i &lt; end; ++i) &#123; if (nums[i] &lt; nums[end]) &#123; ++small; swap(nums, small, i); &#125; &#125; ++small; swap(nums, small, end); return small; &#125; public void swap(int[] nums, int index1, int index2) &#123; if (index1 != index2) &#123; int temp = nums[index1]; nums[index1] = nums[index2]; nums[index2] = temp; &#125; &#125;&#125; 前缀树 剑指 Offer II 062. 实现前缀树 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Trie &#123; static class TrieNode &#123; TrieNode[] children; boolean isWord; public TrieNode() &#123; children = new TrieNode[26]; &#125; &#125; private TrieNode root; public Trie() &#123; root = new TrieNode(); &#125; /** Inserts a word into the trie. */ public void insert(String word) &#123; TrieNode cur = root; for (char ch : word.toCharArray()) &#123; if (cur.children[ch - &#x27;a&#x27;] == null) &#123; cur.children[ch - &#x27;a&#x27;] = new TrieNode(); &#125; cur = cur.children[ch - &#x27;a&#x27;]; &#125; cur.isWord = true; &#125; /** Returns if the word is in the trie. */ public boolean search(String word) &#123; TrieNode cur = root; for (char ch : word.toCharArray()) &#123; if (cur.children[ch - &#x27;a&#x27;] == null) return false; cur = cur.children[ch - &#x27;a&#x27;]; &#125; return cur.isWord; &#125; /** Returns if there is any word in the trie that starts with the given prefix. */ public boolean startsWith(String prefix) &#123; TrieNode cur = root; for (char ch : prefix.toCharArray()) &#123; if (cur.children[ch - &#x27;a&#x27;] == null) return false; cur = cur.children[ch - &#x27;a&#x27;]; &#125; return true; &#125;&#125; 剑指 Offer II 063. 替换单词 方法一：前缀树 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123; static class TrieNode &#123; private TrieNode[] children; private boolean isWord; public TrieNode() &#123; children = new TrieNode[26]; &#125; &#125; public String replaceWords(List&lt;String&gt; dictionary, String sentence) &#123; TrieNode root = buildTrie(dictionary); String[] words = sentence.split(&quot; &quot;); StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; words.length; ++i) &#123; String prefix = findPrefix(root, words[i]); if (!prefix.isEmpty()) &#123; words[i] = prefix; &#125; &#125; return String.join(&quot; &quot;, words); &#125; private String findPrefix(TrieNode root, String word) &#123; TrieNode cur = root; StringBuilder sb = new StringBuilder(); for (char ch : word.toCharArray()) &#123; if (cur.children[ch - &#x27;a&#x27;] == null || cur.isWord) break; sb.append(ch); cur = cur.children[ch - &#x27;a&#x27;]; &#125; return cur.isWord == true ? sb.toString() : &quot;&quot;; &#125; private TrieNode buildTrie(List&lt;String&gt; dictionary) &#123; TrieNode root = new TrieNode(); for (String str : dictionary) &#123; TrieNode cur = root; for (char ch : str.toCharArray()) &#123; if (cur.children[ch - &#x27;a&#x27;] == null) cur.children[ch - &#x27;a&#x27;] = new TrieNode(); cur = cur.children[ch - &#x27;a&#x27;]; &#125; cur.isWord = true; &#125; return root; &#125;&#125; 剑指 Offer II 064. 神奇的字典:warning: 方法一：前缀树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class MagicDictionary &#123; static class TrieNode &#123; private TrieNode[] children; private boolean isWord; public TrieNode() &#123; children = new TrieNode[26]; &#125; &#125; /** Initialize your data structure here. */ private TrieNode root; public MagicDictionary() &#123; root = new TrieNode(); &#125; public void buildDict(String[] dictionary) &#123; for (String str : dictionary) &#123; TrieNode cur = root; for (char ch : str.toCharArray()) &#123; if (cur.children[ch - &#x27;a&#x27;] == null) cur.children[ch - &#x27;a&#x27;] = new TrieNode(); cur = cur.children[ch - &#x27;a&#x27;]; &#125; cur.isWord = true; &#125; &#125; public boolean search(String searchWord) &#123; return dfs(root, searchWord, 0, 0); &#125; public boolean dfs(TrieNode root, String searchWord, int index, int modifiedNum) &#123; if (root == null) return false; if (root.isWord &amp;&amp; index == searchWord.length() &amp;&amp; modifiedNum == 1) return true; if (modifiedNum &lt;= 1 &amp;&amp; index &lt; searchWord.length()) &#123; boolean found = false; for (int j = 0; j &lt; 26 &amp;&amp; !found; ++j) &#123; int next = j == searchWord.charAt(index) - &#x27;a&#x27; ? modifiedNum : modifiedNum + 1; found = dfs(root.children[j], searchWord, index + 1, next); &#125; return found; &#125; return false; &#125;&#125;/** * Your MagicDictionary object will be instantiated and called as such: * MagicDictionary obj = new MagicDictionary(); * obj.buildDict(dictionary); * boolean param_2 = obj.search(searchWord); *///leetcode submit region end(Prohibit modification and deletion) 剑指 Offer II 065. 最短的单词编码:warning::star: 方法一：前缀树 这种DFS技巧非常重要！！！ 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123; static class TrieNode &#123; private TrieNode[] children; private boolean isEnd; public TrieNode() &#123; children = new TrieNode[26]; &#125; &#125; private int res = 0; public int minimumLengthEncoding(String[] words) &#123; TrieNode root = buildTree(words); dfs(root, 1); return res; &#125; private void dfs(TrieNode root, int length) &#123; boolean isLeaf = true; for (TrieNode child : root.children) &#123; if (child != null) &#123; isLeaf = false; dfs(child, length + 1); &#125; &#125; if (isLeaf) res += length; &#125; private TrieNode buildTree(String[] words) &#123; TrieNode root = new TrieNode(); for (int i = 0; i &lt; words.length; ++i) &#123; String word = words[i]; TrieNode cur = root; for (int j = word.length() - 1; j &gt;= 0; --j) &#123; char ch = word.charAt(j); if (cur.children[ch - &#x27;a&#x27;] == null) cur.children[ch - &#x27;a&#x27;] = new TrieNode(); cur = cur.children[ch - &#x27;a&#x27;]; &#125; cur.isEnd = true; &#125; return root; &#125;&#125; 剑指 Offer II 066. 单词之和 方法一：前缀树 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class MapSum &#123; static class TrieNode &#123; private TrieNode[] children; private int val; public TrieNode() &#123; children = new TrieNode[26]; &#125; &#125; private TrieNode root; /** Initialize your data structure here. */ public MapSum() &#123; root = new TrieNode(); &#125; public void insert(String key, int val) &#123; TrieNode cur = root; for (char ch : key.toCharArray()) &#123; if (cur.children[ch - &#x27;a&#x27;] == null) cur.children[ch - &#x27;a&#x27;] = new TrieNode(); cur = cur.children[ch - &#x27;a&#x27;]; &#125; cur.val = val; &#125; public int sum(String prefix) &#123; TrieNode cur = root; for (char ch : prefix.toCharArray()) &#123; if (cur.children[ch - &#x27;a&#x27;] == null) return 0; cur = cur.children[ch - &#x27;a&#x27;]; &#125; return dfs(cur); &#125; private int dfs(TrieNode cur) &#123; int sum = cur.val; for (TrieNode child : cur.children) &#123; if (child != null) sum += dfs(child); &#125; return sum; &#125; public static void main(String[] args) &#123; MapSum mapSum = new MapSum(); mapSum.insert(&quot;apple&quot;, 3); mapSum.sum(&quot;ap&quot;); mapSum.insert(&quot;app&quot;, 2); mapSum.sum(&quot;ap&quot;); &#125;&#125;/** * Your MapSum object will be instantiated and called as such: * MapSum obj = new MapSum(); * obj.insert(key,val); * int param_2 = obj.sum(prefix); */ 剑指 Offer II 067. 最大的异或 方法一：前缀树 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123; static class TrieNode &#123; private TrieNode[] children; public TrieNode() &#123; children = new TrieNode[2]; &#125; &#125; public int findMaximumXOR(int[] nums) &#123; TrieNode root = buildTrie(nums); int max = 0; for (int num : nums) &#123; TrieNode cur = root; int xor = 0; for (int i = 31; i &gt;= 0; --i) &#123; int bit = (num &gt;&gt; i) &amp; 1; if (cur.children[1 - bit] != null) &#123; cur = cur.children[1 - bit]; xor = (xor &lt;&lt; 1) + 1; &#125; else &#123; cur = cur.children[bit]; xor = xor &lt;&lt; 1; &#125; &#125; max = Math.max(max, xor); &#125; return max; &#125; private TrieNode buildTrie(int[] nums) &#123; TrieNode root = new TrieNode(); for (int num : nums) &#123; TrieNode cur = root; for (int i = 31; i &gt;= 0; --i) &#123; int bit = (num &gt;&gt; i) &amp; 1; if (cur.children[bit] == null) &#123; cur.children[bit] = new TrieNode(); &#125; cur = cur.children[bit]; &#125; &#125; return root; &#125;&#125; tips 新建数组时赋值 int[] array = new int[]{3, 4}； 链表转数组 方法一： 1int[] intArray = linkedList.stream().mapToInt(Integer::intValue).toArray(); 这行代码可以分解为以下几个部分： linkedList.stream(): 将LinkedList转换为Stream。 mapToInt(Integer::intValue): 将Stream中的每一个元素转换为int类型。 Integer::intValue是一个方法引用，表示调用Integer对象的intValue()方法，将其转换为对应的int值。 toArray(): 将转换后的元素放到一个int数组中。 toArray()的作用是将Stream中的所有元素转换为一个数组，返回值是一个int[]类型的数组。 综上所述，int[] intArray = linkedList.stream().mapToInt(Integer::intValue).toArray();的语义是将LinkedList中的所有元素转换为int类型，并将其放入一个int数组中。在这个过程中，我们使用了Java 8引入的Stream API，它提供了许多方便的操作，可以简化代码的编写和调试。 方法二： 1res.toArray(new int[res.size()][]); 创建长度二维数组，其中一维数组的长度不确定 1new int[][]&#123;&#123;1, 2&#125;, &#123;3&#125;, &#123;3&#125;, &#123;&#125;&#125; char转int，String转int 1234567// 将字符转换为整数char c = &#x27;8&#x27;;int num = Character.getNumericValue(c); // num = 8// 将字符串转换为整数String str = &quot;123&quot;;int num2 = Integer.parseInt(str); // num2 = 123 String转int时，什么时候用parseInt什么时候用valueOf 在Java中，parseInt和valueOf都可以将字符串转换为整数。parseInt方法将字符串转换为基本数据类型int，而valueOf方法将字符串转换为对象类型Integer。因此，使用哪个方法取决于你要使用返回的数据类型。 如果你只需要一个基本数据类型int，那么使用parseInt是最好的选择，因为它会返回一个原始类型，不会产生额外的对象开销。 例如： java Copy code String str = \"123\"; int num = Integer.parseInt(str); 如果你需要一个对象类型Integer，则使用valueOf方法是最好的选择。valueOf方法返回一个Integer对象，这在某些情况下非常有用。 例如： java Copy code String str = \"123\"; Integer num = Integer.valueOf(str); 总之，如果你只需要一个基本数据类型，那么使用parseInt方法，否则使用valueOf方法。 使用scanner.nextLine()读取行末的换行符 1234567891011public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); scanner.nextLine(); for (int i = 0; i &lt; n; ++i) &#123; String word = scanner.nextLine(); System.out.println(&quot;word: &quot; + word); Main main = new Main(); String ans = main.process(word); System.out.println(ans); &#125; 这段代码首先从标准输入中读取一个整数n，然后通过调用scanner.nextLine()读取掉n后面的换行符。接下来，通过for循环n次，读取n行字符串，每次读取一行字符串后，调用process方法进行处理，最后将处理结果打印到标准输出中。 需要注意的是，在使用Scanner读取完整行时，由于nextInt只读取整数，因此需要在nextInt后面调用nextLine读取行末的换行符。这样做是为了防止接下来的nextLine方法误读取行末的换行符。 创建长度不同的二维数组 在Java中，可以创建长度不同的二维数组。以下是创建长度不同的二维数组的示例： 1234int[][] arr = new int[3][];arr[0] = new int[2];arr[1] = new int[3];arr[2] = new int[4]; 在这个示例中，我们创建了一个3 x n的二维数组，其中n的长度不同。第一行有两个元素，第二行有三个元素，第三行有四个元素。我们可以通过以下方式访问数组的元素： 123456789arr[0][0] = 1;arr[0][1] = 2;arr[1][0] = 3;arr[1][1] = 4;arr[1][2] = 5;arr[2][0] = 6;arr[2][1] = 7;arr[2][2] = 8;arr[2][3] = 9; 请注意，当您创建长度不同的二维数组时，每行的长度必须在运行时确定。因此，您必须在运行时动态地为每行分配内存空间。 12345678910182 1 1 2 22 1 1 1 42 1 1 2 22 2 2 1 4001 1 11 1 1 数组拷贝：ch.clone与Arrays.copyOf的区别 对基础类型的拷贝都是值传递的拷贝(深拷贝)，对对象的拷贝都是拷贝的引用(浅拷贝) 笔试面试 5.8小红书 第一题. 第二题. 123456789101112131415161718192021222324最大最小值 时间限制： 1000MS 内存限制： 65536KB 题目描述： 有一个长度为n的序列，其中第i个元素ai，你现在可以对这个序列进行最多k次操作，每次可选择一个连续的区间将其中的元素删掉，但剩余的元素个数必须大于0。 现在想让剩余元素的最小值尽可能大，求上述情况下的最大值。 输入描述 第一行两个正整数n和k，分别表示初始序列中元素的个数以及最多的操作次数。 接下来1行，n个正整数，其中第i个数为ai。 对于所有数据，1&lt;=n&lt;=10^5，0&lt;=k&lt;=10^5，1&lt;=ai &lt;=10^6。 输出描述 输出仅包含一个正整数，表示答案。 样例输入 8 1 58 57 86 89 25 26 61 42 样例输出 58 123这道题是要求给定一个序列，你可以进行最多k次操作，每次操作可以删除序列中的某个连续区间，但是最后删除后剩余元素的最小值尽可能大。你需要输出这个最大的最小值。举个例子，对于样例输入 [58, 57, 86, 89, 25, 26, 61, 42]，可以进行1次操作，比如删除区间[86,89]，剩下的序列为[58, 57, 25, 26, 61, 42]，此时剩余元素的最小值为25，最大的最小值就是25。你需要编写一个程序来自动寻找最大的最小值。 第三题. 5.10 微众银行 第一题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293```![1](https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/1.jpg) ### 第二题![第二题](https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/第二题.jpg) ```javapackage 面试题.微众银行暑期实习.第2题;import java.lang.reflect.Array;import java.util.*;public class Main &#123; public static void main(String[] args) &#123; Main main = new Main(); Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); int k = scanner.nextInt(); scanner.nextLine(); long[] energy = new long[n], score = new long[n]; for (int i = 0; i &lt; n; ++i) &#123; energy[i] = scanner.nextLong(); &#125; scanner.nextLine(); for (int i = 0; i &lt; n; ++i) &#123; score[i] = scanner.nextLong(); &#125; long[] res = main.process(n, k, energy, score); for (long i : res) System.out.print(i + &quot; &quot;); &#125; Queue&lt;Long&gt; queue = new PriorityQueue&lt;&gt;(); private long[] process(int n, int k, long[] energy, long[] score) &#123; long[] res = new long[n]; Map&lt;Long, Long&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; n; ++i) &#123; map.put(energy[i], score[i]); &#125; long[] oriEnery = new long[n]; for (int i = 0; i &lt; n; ++i) oriEnery[i] = energy[i]; Arrays.sort(energy); for (int i = 0; i &lt; k; ++i) &#123; long s = map.get(energy[i]); queue.offer(s); &#125; long sum = map.get(energy[0]); for (int i = 1; i &lt; k; ++i) &#123; res[i] = sum; sum += map.get(energy[i]); &#125; for (int i = k; i &lt; n; ++i) &#123; res[i] = getKMax(); long s = map.get(energy[i]); if (s &gt; queue.peek()) &#123; queue.poll(); queue.offer(s); &#125; &#125; long[] res2 = new long[n]; //resAsOriginalSequence for (int i = 0; i &lt; n; ++i) &#123; long e = oriEnery[i]; int index = 0; for (; index &lt; n; ++index) &#123; if (energy[index] == e) break; &#125; res2[i] = res[index]; &#125; return res2; &#125; private int getKMax() &#123; int sum = 0; Queue&lt;Long&gt; queue2 = new PriorityQueue&lt;&gt;(); while (!queue.isEmpty()) &#123; long temp = queue.poll(); sum += temp; queue2.offer(temp); &#125; queue = queue2; return sum; &#125;&#125; 第三题 第三题","categories":[],"tags":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://leopol1d.github.io/tags/Algorithms/"}]}],"categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://leopol1d.github.io/categories/Algorithms/"},{"name":"dynamic programming","slug":"Algorithms/dynamic-programming","permalink":"https://leopol1d.github.io/categories/Algorithms/dynamic-programming/"},{"name":"backtracking","slug":"Algorithms/backtracking","permalink":"https://leopol1d.github.io/categories/Algorithms/backtracking/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://leopol1d.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"回溯","slug":"回溯","permalink":"https://leopol1d.github.io/tags/%E5%9B%9E%E6%BA%AF/"},{"name":"Algorithms","slug":"Algorithms","permalink":"https://leopol1d.github.io/tags/Algorithms/"}]}