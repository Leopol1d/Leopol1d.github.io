{"meta":{"title":"Leopold's Blog","subtitle":"Algorithms","description":"For offers","author":"Leopold","url":"https://leopol1d.github.io","root":"/"},"pages":[{"title":"","date":"2023-05-23T10:05:13.718Z","updated":"2023-05-23T10:05:13.718Z","comments":false,"path":"css/fluid-extension.css","permalink":"https://leopol1d.github.io/css/fluid-extension.css","excerpt":"","text":"::-webkit-scrollbar { width: 8px; height: 8px; } ::-webkit-scrollbar-track { border-radius: 4px; background-color: rgba(255, 255, 255, .1); } ::-webkit-scrollbar-thumb { border-radius: 4px; background-color: rgba(0, 120, 231, .5); } ::-webkit-scrollbar-thumb:window-inactive { background-color: rgba(0, 120, 231, .3) } ::-webkit-scrollbar-thumb:hover { background-color: rgba(0, 120, 231, .7) } ::-webkit-scrollbar-thumb:active { background-color: rgba(0, 120, 231, .9) } figure.highlight { background: #FFFFFF; border-radius: 5px; box-shadow: 0 4px 7px 0 rgba(0, 0, 0, .4); padding-top: 30px } figure.highlight::before { background: #fc625d; border-radius: 50%; box-shadow: 20px 0 #fdbc40, 40px 0 #35cd4b; content: ' '; height: 12px; left: 12px; margin-top: -20px; position: absolute; width: 12px; } .table-container { overflow: auto; margin-bottom: 16px; } /* Avoid affecting the style of codeblock */ .markdown-body .table-container table { display: table !important; margin-bottom: 0 !important; } #navbar { -webkit-backdrop-filter: blur(3px); backdrop-filter: blur(3px); } div.dropdown-menu { min-width: inherit !important; text-align: center !important; background-color: var(--navbar-bg-color) !important; right: 0; left: initial !important; box-shadow: 0 4px 7px 0 rgba(0, 0, 0, .5); -webkit-animation: sub_menus .3s .1s ease both; -moz-animation: sub_menus .3s .1s ease both; -o-animation: sub_menus .3s .1s ease both; -ms-animation: sub_menus .3s .1s ease both; animation: sub_menus .3s .1s ease both; } @-moz-keyframes sub_menus { 0% { opacity: 0; -webkit-transform: translateY(10px); -moz-transform: translateY(10px); -o-transform: translateY(10px); -ms-transform: translateY(10px); transform: translateY(10px); } 100% { opacity: 1; -webkit-transform: translateY(0); -moz-transform: translateY(0); -o-transform: translateY(0); -ms-transform: translateY(0); transform: translateY(0); } } @-webkit-keyframes sub_menus { 0% { opacity: 0; -webkit-transform: translateY(10px); -moz-transform: translateY(10px); -o-transform: translateY(10px); -ms-transform: translateY(10px); transform: translateY(10px); } 100% { opacity: 1; -webkit-transform: translateY(0); -moz-transform: translateY(0); -o-transform: translateY(0); -ms-transform: translateY(0); transform: translateY(0); } } @-o-keyframes sub_menus { 0% { opacity: 0; -webkit-transform: translateY(10px); -moz-transform: translateY(10px); -o-transform: translateY(10px); -ms-transform: translateY(10px); transform: translateY(10px); } 100% { opacity: 1; -webkit-transform: translateY(0); -moz-transform: translateY(0); -o-transform: translateY(0); -ms-transform: translateY(0); transform: translateY(0); } } @keyframes sub_menus { 0% { opacity: 0; -webkit-transform: translateY(10px); -moz-transform: translateY(10px); -o-transform: translateY(10px); -ms-transform: translateY(10px); transform: translateY(10px); } 100% { opacity: 1; -webkit-transform: translateY(0); -moz-transform: translateY(0); -o-transform: translateY(0); -ms-transform: translateY(0); transform: translateY(0); } } /* 代码和表格设置最大高度，高度或宽度超出都不会显示在页面中，可以通过滚动条查看 */ table { padding: 0; word-break: initial; overflow-x: auto; max-height: 44em; overflow-y: auto !important; }"},{"title":"标题","date":"2023-05-21T03:11:41.458Z","updated":"2023-05-21T03:11:41.458Z","comments":false,"path":"about/index.html","permalink":"https://leopol1d.github.io/about/index.html","excerpt":"","text":""},{"title":"tags~","date":"2023-05-20T07:00:53.000Z","updated":"2023-05-20T07:05:43.906Z","comments":false,"path":"tags/index.html","permalink":"https://leopol1d.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"AWS ELB & ASG","slug":"AWS-ELB-ASG","date":"2024-01-15T03:37:16.000Z","updated":"2024-01-15T12:03:46.848Z","comments":true,"path":"2024/01/15/AWS-ELB-ASG/","link":"","permalink":"https://leopol1d.github.io/2024/01/15/AWS-ELB-ASG/","excerpt":"","text":"Scalability 可扩展性是指应用/系统能通过调整，承担更大的负荷 可拓展性分为：纵向可拓展性(为单个实例分配更多的CPU，内存)和横向可拓展性(elasticity) Horizontal Scalability Scale out / in Vertical Scalability Scale up / down High Availability 可拓展性、高可用是紧密相关的 高可用在AWS中指系统或应用至少运行在两个可用区 高可用性的目标是在某个数据中心发生故障（灾难）时，另一个数据中心能够失效备援 Elastic Load Balancer 将流量转发给下游的EC2实例 为你的应用暴露DNS(单点入口) 处理下游EC2实例的failures 定期检查EC2实例的健康状况 跨可用区 ELB Hands On 创建两台EC2实例 使用公共IP访问他们 创建一个ALB(layer 7)，用一个单点入口(DNS)来访问EC2实例 将ALB部署在以下两个可用区 创建一个新的安全组，只允许HTTP请求(80)与HTTPS请求(443) 创建一个目标组(EC2实例组) 将两个实例加入目标组 绑定在ALB上 成功创建ALB 访问DNS名称ALB-1723269650.us-east-1.elb.amazonaws.com，报错 发现目标组未注册目标(第7步) 重新注册 再次根据DNS名称访问，成功！并且多次访问，流量会被分发到不同的EC2实例 终止第二个EC2实例，注意私有IP 在目标组中查看到，第二个是李的运行状态是Unused 之后通过ALB访问，流量只会被转发给第一台EC2实例 Auto Scaling Group 根据流量迅速自动创建(scale out)与删除(scale in)EC2实例 自动注册新的EC2实例到Load Balancer 自动替换不健康的EC2实例 ASG + ALB Hands On 创建ASG 创建启动模板 选择所有的可用区和子网 新建一个ALB，选择之前创建的目标组 配置组大小 创建成功 创建好ASG后，EC2实例会被自动创建，目标组自动关联这些实例 根据ALB的DNS NAME来访问 终止一个实例，看看会发生什么 activity页面，检测到不健康实例，所以自动扩展了一个新的实例 ASG - Scaling Strategies Manual Scaling Dynamic Scaling Simple Scaling 当CloudWatch alarm被触发，比如CPU使用率 &gt; 70%，增加两个EC2实例 当CloudWatch alarm被触发，比如CPU使用率 &lt; 30%，删除一个EC2实例 Target Tracking Scaling 比如：我想让ASG CPU的平均使用率为60%，高于或者低于都可能进行缩放 Scheduled Scaling 根据已知的使用模式预测缩放，比如：每天晚上十点缩容，每天上午八点扩容 Predictive Scaling 使用机器学习预测未来的流量，并调整EC2实例的个数","categories":[{"name":"AWS","slug":"AWS","permalink":"https://leopol1d.github.io/categories/AWS/"},{"name":"Ultimate AWS Certified Cloud Practitioner CLF-C02","slug":"AWS/Ultimate-AWS-Certified-Cloud-Practitioner-CLF-C02","permalink":"https://leopol1d.github.io/categories/AWS/Ultimate-AWS-Certified-Cloud-Practitioner-CLF-C02/"},{"name":"ELB & ASG","slug":"AWS/Ultimate-AWS-Certified-Cloud-Practitioner-CLF-C02/ELB-ASG","permalink":"https://leopol1d.github.io/categories/AWS/Ultimate-AWS-Certified-Cloud-Practitioner-CLF-C02/ELB-ASG/"}],"tags":[{"name":"Cloud Computing","slug":"Cloud-Computing","permalink":"https://leopol1d.github.io/tags/Cloud-Computing/"},{"name":"AWS","slug":"AWS","permalink":"https://leopol1d.github.io/tags/AWS/"},{"name":"Scalability","slug":"Scalability","permalink":"https://leopol1d.github.io/tags/Scalability/"},{"name":"High Availability","slug":"High-Availability","permalink":"https://leopol1d.github.io/tags/High-Availability/"}]},{"title":"2023 2023 Leetcode Cup Graph Theory List","slug":"2023-2023-Leetcode-Cup-Graph-Theory-List","date":"2024-01-14T11:32:03.000Z","updated":"2024-01-18T01:49:59.232Z","comments":true,"path":"2024/01/14/2023-2023-Leetcode-Cup-Graph-Theory-List/","link":"","permalink":"https://leopol1d.github.io/2024/01/14/2023-2023-Leetcode-Cup-Graph-Theory-List/","excerpt":"","text":"2022年(上) 2368. 受限条件下可到达节点的数目 Rank:1477 方法一：DFS Map建图+dfs 12345678910111213141516171819202122232425262728293031323334class Solution &#123; public int reachableNodes(int n, int[][] edges, int[] restricted) &#123; this.n = n; this.edges = edges; this.restricted = restricted; for (int[] edge : edges) &#123; int from = edge[0], to = edge[1]; graph.putIfAbsent(from, new ArrayList&lt;&gt;()); graph.putIfAbsent(to, new ArrayList&lt;&gt;()); graph.get(from).add(to); graph.get(to).add(from); &#125; for (int x : restricted) banList.add(x); dfs(0, -1); return res; &#125; public void dfs(int node, int parent) &#123; ++res; List&lt;Integer&gt; nexts = graph.get(node); for (int next : nexts) &#123; if (next != parent &amp;&amp; !banList.contains(next)) &#123; dfs(next, node); &#125; &#125; &#125; int n, res = 0; int[][] edges; int[] restricted; Map&lt;Integer, List&lt;Integer&gt;&gt; graph = new HashMap&lt;&gt;(); Set&lt;Integer&gt; banList = new HashSet&lt;&gt;();&#125; 2385. 感染二叉树需要的总时间 Rank:1711 方法一：DFS + BFS 每遍历一层，秒数加一 res初始化为-1，因为如果只有一个节点，答案是0秒，即不需要扩散 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public int amountOfTime(TreeNode root, int start) &#123; visited.add(start); buildGraph(root); // for (Map.Entry&lt;Integer, List&lt;Integer&gt;&gt; entry : graph.entrySet()) &#123; // System.out.print(entry.getKey() + &quot;: &quot;); // for (int x : entry.getValue()) &#123; // System.out.print(x + &quot; &quot;); // &#125; // System.out.println(); // &#125; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); queue.offer(start); while (!queue.isEmpty()) &#123; int size = queue.size(); ++res; for (int i = 0; i &lt; size; ++i) &#123; int node = queue.poll(); visited.add(node); List&lt;Integer&gt; list = graph.get(node); for (int next : list) &#123; if (node != next &amp;&amp; !visited.contains(next)) &#123; queue.offer(next); &#125; &#125; &#125; &#125; return res; &#125; public void buildGraph(TreeNode root) &#123; if (root == null) return; graph.putIfAbsent(root.val, new ArrayList&lt;&gt;()); if (root.left != null) &#123; graph.putIfAbsent(root.left.val, new ArrayList&lt;&gt;()); graph.get(root.val).add(root.left.val); graph.get(root.left.val).add(root.val); buildGraph(root.left); &#125; if (root.right != null) &#123; graph.putIfAbsent(root.right.val, new ArrayList&lt;&gt;()); graph.get(root.val).add(root.right.val); graph.get(root.right.val).add(root.val); buildGraph(root.right); &#125; &#125; Map&lt;Integer, List&lt;Integer&gt;&gt; graph = new HashMap&lt;&gt;(); int res = -1; Set&lt;Integer&gt; visited = new HashSet&lt;&gt;(); &#125; 2359. 找到离给定两个节点最近的节点 Rank:1715 方法一：内向基环树 12345678910111213141516171819202122232425262728293031class Solution &#123; public int closestMeetingNode(int[] edges, int node1, int node2) &#123; n = edges.length; this.edges = edges; int minDist = inf; int[] dist1 = calcDistance(node1), dist2 = calcDistance(node2); for (int i = 0; i &lt; n; ++i) &#123; int d = Math.max(dist1[i], dist2[i]); if (d &lt; minDist) &#123; res = i; minDist = d; &#125; &#125; return res; &#125; public int[] calcDistance(int x) &#123; int[] dist = new int[n]; Arrays.fill(dist, inf); int d = 0; while (x != -1 &amp;&amp; dist[x] == inf) &#123; dist[x] = d++; x = edges[x]; &#125; return dist; &#125; int inf = Integer.MAX_VALUE, n, res = -1; int[] edges;&#125; 2360. 图中的最长环 Rank:1897 方法一：时间戳 也是内向基环树 123456789101112131415161718192021class Solution &#123; public int longestCycle(int[] edges) &#123; int res = -1, n = edges.length, clock = 1; int[] time = new int[n]; for (int i = 0; i &lt; n; ++i) &#123; if (time[i] &gt; 0) continue; int startTime = clock, x = i; while (x != -1) &#123; if (time[x] &gt; 0) &#123; if (time[x] &gt;= startTime) res = Math.max(res, clock - time[x]); break; &#125; time[x] = clock++; x = edges[x]; &#125; &#125; return res; &#125;&#125; 2467. 树上最大得分和路径 Rank:2053 方法一：时间戳 + 两次dfs 先dfs一次bob的路径，只有找到0的最短路径的节点用时间戳记录 根据规则再对alice路径dfs 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution &#123; public int mostProfitablePath(int[][] edges, int bob, int[] amount) &#123; n = edges.length + 1; graph = new List[n]; this.amount = amount; Arrays.setAll(graph, o -&gt; new ArrayList&lt;&gt;()); time = new int[n]; Arrays.fill(time, n); for (int[] edge : edges) &#123; int from = edge[0], to = edge[1]; graph[from].add(to); graph[to].add(from); &#125; graph[0].add(-1); getDistFromRoot(bob, -1, 0); dfs(0, -1, 0, 0); return res; &#125; private void dfs(int alice, int parent, int aliceTime, int score) &#123; if (aliceTime == time[alice]) score += amount[alice] / 2; if (aliceTime &lt; time[alice]) score += amount[alice]; if (graph[alice].size() == 1) &#123; res = Math.max(res, score); return; &#125; for (int next : graph[alice]) if (next != parent) dfs(next, alice, aliceTime + 1, score); &#125; private boolean getDistFromRoot(int cur, int parent, int t) &#123; if (cur == 0) &#123; time[cur] = t; return true; &#125; for (int next : graph[cur]) &#123; if (next != parent &amp;&amp; getDistFromRoot(next, cur, t + 1)) &#123; time[cur] = t; return true; &#125; &#125; return false; &#125; List&lt;Integer&gt;[] graph; int[] time; int n; int[] amount; int res = Integer.MIN_VALUE;&#125; 2022年(下) 2641. 二叉树的堂兄弟节点 II Rank:1677 方法一：双BFS(双链表实现) 类似换根DP 首先算出下一层的节点值总和 再遍历一次当前层，给孩子节点赋值(如果用queue来遍历，无法重复遍历这一次，还需要用数组记录每一层的和) 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public TreeNode replaceValueInTree(TreeNode root) &#123; List&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); q.add(root); root.val = 0; while (!q.isEmpty()) &#123; List&lt;TreeNode&gt; temp = q; q = new ArrayList&lt;&gt;(); int nextLevelSum = 0; for (TreeNode node : temp) &#123; if (node.left != null) &#123; q.add(node.left); nextLevelSum += node.left.val; &#125; if (node.right != null) &#123; q.add(node.right); nextLevelSum += node.right.val; &#125; &#125; for (TreeNode node : temp) &#123; int childSum = (node.left != null ? node.left.val : 0) + (node.right != null ? node.right.val : 0); if (node.left != null) node.left.val = nextLevelSum - childSum; if (node.right != null) node.right.val = nextLevelSum - childSum; &#125; &#125; return root; &#125;&#125; 2684. Maximum Number of Moves in a Grid Rank:1626 方法一：BFS 注意用visited数组剪枝 123456789101112131415161718192021222324252627282930313233class Solution &#123; public int maxMoves(int[][] grid) &#123; m = grid.length; n = grid[0].length; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); int[][] dirs = new int[][]&#123;&#123;-1, 1&#125;, &#123;0, 1&#125;, &#123;1, 1&#125;&#125;; boolean[][] visited = new boolean[m][n]; for (int i = 0; i &lt; m; ++i) queue.offer(new int[]&#123;i, 0&#125;); while (!queue.isEmpty()) &#123; int[] node = queue.poll(); int i = node[0], j = node[1]; res = Math.max(res, j); for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col) &amp;&amp; !visited[row][col] &amp;&amp; grid[row][col] &gt; grid[i][j]) &#123; visited[row][col] = true; queue.offer(new int[]&#123;row, col&#125;); if (col == n - 1) return n - 1; &#125; &#125; &#125; return res; &#125; int m, n, res = 0; public boolean isValid(int i, int j) &#123; return i &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; n; &#125; &#125; 方法二：记忆化搜索 和半年前的提交完全一样！一个字母都不差，属实是肌肉记忆了 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public int maxMoves(int[][] grid) &#123; m = grid.length; n = grid[0].length; this.grid = grid; dp = new int[m][n]; for (int[] arr : dp) Arrays.fill(arr, -1); for (int i = 0; i &lt; m; ++i) res = Math.max(res, dfs(i, 0)); return res; &#125; public int dfs(int i, int j) &#123; if (j == n - 1) return 0; if (dp[i][j] != -1) return dp[i][j]; int ans = 0; for (int[] dir : dirs) &#123; int len = 0; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col) &amp;&amp; grid[row][col] &gt; grid[i][j]) len = dfs(row, col) + 1; ans = Math.max(ans, len); &#125; return dp[i][j] = ans; &#125; int m, n, res = 0; int[][] dp, dirs = new int[][]&#123;&#123;-1, 1&#125;, &#123;0, 1&#125;, &#123;1, 1&#125;&#125;, grid; public boolean isValid(int i, int j) &#123; return i &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; n; &#125; &#125; 2685. Count the Number of Complete Components 方法一：DFS 遍历每个连通分量，将edge数加上当前节点的邻居数，最后这个连通分量的边会被计算两次 如果是完全连通分量，e = (v - 1) * v / 2 由于这里边计算了两次，如果e = (v - 1) * v，那么是完全连通分量 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public int countCompleteComponents(int n, int[][] edges) &#123; graph = new ArrayList[n]; Arrays.setAll(graph, e -&gt; new ArrayList&lt;&gt;()); visited = new boolean[n]; int cnt = 0; for (int[] edge : edges) &#123; int x = edge[0], y = edge[1]; graph[x].add(y); graph[y].add(x); &#125; for (int i = 0; i &lt; n; ++i) &#123; if (!visited[i]) &#123; e = 0; v = 0; dfs(i); if (e == v * (v - 1)) ++cnt; &#125; &#125; return cnt; &#125; public void dfs(int i) &#123; visited[i] = true; List&lt;Integer&gt; nexts = graph[i]; ++v; e += nexts.size(); for (int next : nexts) if (!visited[next]) dfs(next); &#125; List&lt;Integer&gt;[] graph; boolean[] visited; int e, v; &#125; 2642. Design Graph With Shortest Path Calculator Rank:1811 方法一:Dijkstra 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Graph &#123; int[][] graph; int n, inf = Integer.MAX_VALUE &gt;&gt; 1; public Graph(int n, int[][] edges) &#123; this.n = n; graph = new int[n][n]; for (int[] arr : graph) Arrays.fill(arr, inf); for (int[] edge : edges) &#123; int from = edge[0], to = edge[1], weight = edge[2]; graph[from][to] = weight; &#125; &#125; public void addEdge(int[] edge) &#123; int from = edge[0], to = edge[1], weight = edge[2]; graph[from][to] = weight; &#125; public int shortestPath(int from, int to) &#123; boolean[] visited = new boolean[n]; int[] dist = new int[n]; Arrays.fill(dist, inf); dist[from] = 0; for (int i = 0; i &lt; n; ++i) &#123; // 每遍历一次，一个节点被visit，需要遍历n次 int minIndex = -1, minDist = inf; for (int j = 0; j &lt; n; ++j) &#123; if (!visited[j] &amp;&amp; dist[j] &lt; minDist) &#123; minIndex = j; minDist = dist[j]; &#125; &#125; if (minIndex == -1) // 非连通 return -1; if (minIndex == to) return minDist; visited[minIndex] = true; for (int j = 0; j &lt; n; ++j) &#123; if (!visited[j] &amp;&amp; dist[j] &gt; minDist + graph[minIndex][j]) dist[j] = minDist + graph[minIndex][j]; &#125; &#125; return dist[to]; &#125;&#125;/** * Your Graph object will be instantiated and called as such: * Graph obj = new Graph(n, edges); * obj.addEdge(edge); * int param_2 = obj.shortestPath(node1,node2); */ 2608. Shortest Cycle in a Graph Rank:1904 方法一：BFS 问：为什么说发现一个已经入队的点，就说明有环？ 答：这说明到同一个点有两条不同的路径，这两条路径组成了一个环。 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public int findShortestCycle(int n, int[][] edges) &#123; this.n = n; graph = new List[n]; Arrays.setAll(graph, e -&gt; new ArrayList&lt;&gt;()); for (int[] edge : edges) &#123; int from = edge[0], to = edge[1]; graph[from].add(to); graph[to].add(from); &#125; int res = inf; for (int i = 0; i &lt; n; ++i) res = Math.min(res, bfs(i)); return res == inf ? - 1 : res; &#125; public int bfs(int i) &#123; int[] dist = new int[n]; Arrays.fill(dist, -1); dist[i] = 0; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); queue.offer(new int[]&#123;i, -1&#125;); int ans = inf; while (!queue.isEmpty()) &#123; int[] node = queue.poll(); int x = node[0], y = node[1]; for (int next : graph[x]) &#123; if (dist[next] &lt; 0) &#123; // not visited dist[next] = dist[x] + 1; queue.offer(new int[]&#123;next, x&#125;); &#125; else if (next != y) // 访问过，且不是父节点，说明两条简单路径交汇，形成环 ans = Math.min(ans, dist[x] + dist[next] + 1); &#125; &#125; return ans; &#125; List&lt;Integer&gt;[] graph; int n, inf = Integer.MAX_VALUE;&#125; 2577. Minimum Time to Visit a Cell In a Grid Rank:2356 方法一：堆优化dijkstra 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; public int minimumTime(int[][] grid) &#123; if (grid[0][1] &gt; 1 &amp;&amp; grid[1][0] &gt; 1) return -1; m = grid.length; n = grid[0].length; int[][] dist = new int[m][n]; for (int[] arr : dist) Arrays.fill(arr, inf); dist[0][0] = 0; PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;((o1, o2) -&gt; o1[2] - o2[2]); pq.offer(new int[]&#123;0, 0, 0&#125;); while (true) &#123; int[] node = pq.poll(); int i = node[0], j = node[1], d = node[2]; if (i == m - 1 &amp;&amp; j == n - 1) return d; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col)) &#123; int nd = Math.max(d + 1, grid[row][col]); nd += (nd - row - col) % 2; if (nd &lt; dist[row][col]) &#123; dist[row][col] = nd; pq.offer(new int[]&#123;row, col, nd&#125;); &#125; &#125; &#125; &#125; &#125; int m, n, inf = Integer.MAX_VALUE; int[][] dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; public boolean isValid(int i, int j) &#123; return i &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; n; &#125; &#125; 方法二：二分 + BFS 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123; public int minimumTime(int[][] grid) &#123; if (grid[0][1] &gt; 1 &amp;&amp; grid[1][0] &gt; 1) return -1; m = grid.length; n = grid[0].length; int l = Math.max(m + n - 2, grid[m - 1][n - 1]), r = (int) 1e5 + m + n; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if (check(mid, grid)) r = mid - 1; else l = mid + 1; &#125; return l + (l + m + n) % 2; &#125; public boolean check(int limit, int[][] grid) &#123; boolean[][] visited = new boolean[m][n]; visited[m - 1][n - 1] = true; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); queue.offer(new int[]&#123;m - 1, n - 1, limit - 1&#125;); while (!queue.isEmpty()) &#123; int[] node = queue.poll(); int i = node[0], j = node[1], t = node[2]; if (i == 0 &amp;&amp; j == 0) return true; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col) &amp;&amp; !visited[row][col] &amp;&amp; t &gt;= grid[row][col]) &#123; queue.offer(new int[]&#123;row, col, t - 1&#125;); visited[row][col] = true; &#125; &#125; &#125; return false; &#125; int m, n, inf = Integer.MAX_VALUE; int[][] dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; public boolean isValid(int i, int j) &#123; return i &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; n; &#125; &#125; 2812. 找出最安全路径 Rank:2154 方法一：多源BFS + 二分 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class Solution &#123; public int maximumSafenessFactor(List&lt;List&lt;Integer&gt;&gt; grid) &#123; n = grid.size(); Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); dist = new int[n][n]; for (int[] arr : dist) Arrays.fill(arr, -1); for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (grid.get(i).get(j) == 1) &#123; queue.offer(new int[]&#123;i, j&#125;); dist[i][j] = 0; &#125; &#125; &#125; while (!queue.isEmpty()) &#123; int[] node = queue.poll(); int i = node[0], j = node[1]; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col) &amp;&amp; dist[row][col] &lt; 0) &#123; dist[row][col] = dist[i][j] + 1; queue.offer(new int[]&#123;row, col&#125;); &#125; &#125; &#125; int l = 0, r = 3 * n; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if (check(mid)) l = mid + 1; else r = mid - 1; &#125; return r; &#125; public boolean check(int limit) &#123; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); boolean[][] visited = new boolean[n][n]; if (dist[0][0] &lt; limit) return false; queue.offer(new int[]&#123;0, 0, 0&#125;); visited[0][0] = true; while (!queue.isEmpty()) &#123; int[] node = queue.poll(); int i = node[0], j = node[1]; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col) &amp;&amp; !visited[row][col] &amp;&amp; limit &lt;= dist[row][col]) &#123; queue.offer(new int[]&#123;row, col&#125;); visited[row][col] = true; &#125; &#125; &#125; return visited[n - 1][n - 1]; &#125; int n, inf = Integer.MAX_VALUE &gt;&gt; 1; int[][] dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;, dist; public boolean isValid(int i, int j) &#123; return i &gt;= 0 &amp;&amp; i &lt; n &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; n; &#125; &#125;","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://leopol1d.github.io/categories/Algorithms/"},{"name":"Graph","slug":"Algorithms/Graph","permalink":"https://leopol1d.github.io/categories/Algorithms/Graph/"}],"tags":[{"name":"图论","slug":"图论","permalink":"https://leopol1d.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"DFS","slug":"DFS","permalink":"https://leopol1d.github.io/tags/DFS/"},{"name":"BFS","slug":"BFS","permalink":"https://leopol1d.github.io/tags/BFS/"},{"name":"Shortest Path Problem","slug":"Shortest-Path-Problem","permalink":"https://leopol1d.github.io/tags/Shortest-Path-Problem/"},{"name":"Topological Sort","slug":"Topological-Sort","permalink":"https://leopol1d.github.io/tags/Topological-Sort/"}]},{"title":"AWS Security Group","slug":"AWS-Security-Group","date":"2024-01-14T07:18:27.000Z","updated":"2024-01-14T08:22:28.067Z","comments":true,"path":"2024/01/14/AWS-Security-Group/","link":"","permalink":"https://leopol1d.github.io/2024/01/14/AWS-Security-Group/","excerpt":"","text":"Introduciton of Security Group 安全组是AWS网络安全的重要组件 安全组控制流量是否被允许入站或者出站到EC2实例 安全组只包含allow规则 安全组规则可以按照IP或者安全组连接(reference) Security Groups Deeper Dive 安全组是EC2实例层面的firewall 规则 允许访问EC2实例的端口 授权IP范围 控制入站流量 控制出站流量 Security Group Diagram 被授权的IP的入站流量是允许进入Security Group1，访问端口号为22 未被授权的IP入站流量无法进入Security Group1，具体表现为time out Security Groups Good to know 一个安全组能附加到多个实例 绑定在一个区域或者VPC 被安全组拒绝访问表现为time out，如果应用(访问的一方)给出“connection refused” error，那么是应用内部的错误 所有的入站流量默认是阻塞的 所有的出站流量默认是允许的","categories":[{"name":"AWS","slug":"AWS","permalink":"https://leopol1d.github.io/categories/AWS/"},{"name":"Ultimate AWS Certified Cloud Practitioner CLF-C02","slug":"AWS/Ultimate-AWS-Certified-Cloud-Practitioner-CLF-C02","permalink":"https://leopol1d.github.io/categories/AWS/Ultimate-AWS-Certified-Cloud-Practitioner-CLF-C02/"},{"name":"EC2 - Elastic Compute Cloud","slug":"AWS/Ultimate-AWS-Certified-Cloud-Practitioner-CLF-C02/EC2-Elastic-Compute-Cloud","permalink":"https://leopol1d.github.io/categories/AWS/Ultimate-AWS-Certified-Cloud-Practitioner-CLF-C02/EC2-Elastic-Compute-Cloud/"}],"tags":[{"name":"Cloud Computing","slug":"Cloud-Computing","permalink":"https://leopol1d.github.io/tags/Cloud-Computing/"},{"name":"AWS","slug":"AWS","permalink":"https://leopol1d.github.io/tags/AWS/"},{"name":"Security Group","slug":"Security-Group","permalink":"https://leopol1d.github.io/tags/Security-Group/"}]},{"title":"AWS EC2 Elastic Compute Cloud","slug":"AWS-EC2-Elastic-Compute-Cloud","date":"2024-01-14T02:14:21.000Z","updated":"2024-01-14T07:22:00.874Z","comments":true,"path":"2024/01/14/AWS-EC2-Elastic-Compute-Cloud/","link":"","permalink":"https://leopol1d.github.io/2024/01/14/AWS-EC2-Elastic-Compute-Cloud/","excerpt":"","text":"EC2 Instance types t2.micro在free tier中(750小时) EC2 User Data 实例启动时会运行EC2 User Data脚本 比如 12345678#!/bin/bash# Use this for your user data (script from top to bottom)# install httpd (Linux 2 version)yum update -yyum install -y httpdsystemctl start httpdsystemctl enable httpdecho &quot;&lt;h1&gt;Hello World from $(hostname -f)&lt;/h1&gt;&quot; &gt; /var/www/html/index.html Hands on: Create an EC2 Instance with EC2 User Data to have a Website 在dashboard搜索EC2，进入EC2实例，点击创建新实例 输入tag，选择镜像，选择AMI 实例类型选择t2.micro 创建密钥对 将密钥保存在本机 配置安全组，由于要创建一个网页，所以需要接收来自互联网的HTTP流量 配置数据卷 在高级详细信息-&gt;用户数据中编写user data script 更新下载开启一些配置，将hello world写入EC2实例/var/www/html/index.html下 启动实例 实例详情 访问实例，注意使用http而不是https 值得注意的是，重启实例，实例的public ip会发生改变","categories":[{"name":"AWS","slug":"AWS","permalink":"https://leopol1d.github.io/categories/AWS/"},{"name":"Ultimate AWS Certified Cloud Practitioner CLF-C02","slug":"AWS/Ultimate-AWS-Certified-Cloud-Practitioner-CLF-C02","permalink":"https://leopol1d.github.io/categories/AWS/Ultimate-AWS-Certified-Cloud-Practitioner-CLF-C02/"},{"name":"EC2 - Elastic Compute Cloud","slug":"AWS/Ultimate-AWS-Certified-Cloud-Practitioner-CLF-C02/EC2-Elastic-Compute-Cloud","permalink":"https://leopol1d.github.io/categories/AWS/Ultimate-AWS-Certified-Cloud-Practitioner-CLF-C02/EC2-Elastic-Compute-Cloud/"}],"tags":[{"name":"EC2","slug":"EC2","permalink":"https://leopol1d.github.io/tags/EC2/"},{"name":"Cloud Computing","slug":"Cloud-Computing","permalink":"https://leopol1d.github.io/tags/Cloud-Computing/"},{"name":"AWS","slug":"AWS","permalink":"https://leopol1d.github.io/tags/AWS/"}]},{"title":"AWS Security","slug":"AWS-Security","date":"2024-01-13T02:54:06.000Z","updated":"2024-01-14T07:06:04.801Z","comments":true,"path":"2024/01/13/AWS-Security/","link":"","permalink":"https://leopol1d.github.io/2024/01/13/AWS-Security/","excerpt":"","text":"DDoS Protection: WAF &amp; Shield What is DDOS? akamai DDOS 分布式拒绝服务攻击 (DDoS) 是一种网络攻击。在此类攻击中，攻击者通过发送大量恶意流量造成网站、服务器或网络资源不堪重负，从而导致目标无法工作或崩溃，拒绝向合法用户提供服务，使得合法流量无法到达其目的地。 概括来说，DDoS 或 DoS 攻击就如同成百上千个虚假拼车请求所导致的意外交通堵塞。这些请求在拼车服务看来似乎合法，因此服务会调度驾驶员接人，从而不可避免地使城市街道拥堵。这会导致正常的合法流量无法到达目的地。 Solution Architect AWS Best Practices for DDOS Resiliency AWS Shield：保护网络层和应用层 AWS WAF(Web Application Firewall)：过滤基于规则的特殊请求 CloudFront(AWS CDN) and Route 53(AWS DNS)：基于边缘网络，结合AWS Shield，在边缘提供攻击缓解 WAF - Web Application Firewall 保护网络应用程序免受常见网络攻击(layer 7) 7层指HTTP / HTTPS (vs 4层 TCP) 可以部署在Application Load Balancer, API Gateway, CloudFront 定义Web ACL(Web Access Control List) 规则可以包含IP地址，HTTP headers, HTTP body, URI strings Rate-based rules(每个用户的请求有5秒间距) for DDos protection 防止SQL injection， Cross-Site Scripting Network Firewall-VPC level 保护整个VPC(Virtual Private Cloud)： layer 3 ~ layer 7 Firewall Manager 管理VPC Security Group 管理 WAF rules 管理Shield Advanced(Shield的高级版本，每月3000$) 管理Network Firewall Penetration Testing 渗透测试：攻击自己的基础设施来确保安全性(不能使用DDos, Port flooding, Protocol flooding, Request flooding) Encryption with KMS &amp; CloudHSM Data at rest vs. Data in transit 在设备中的静态数据与传输中的数据都需要被加密！ KMS - Key Management Service 与encryption相关的AWS服务，大概率与KMS相关 AWS为用户管理加密的key CloudHSM - Cloud Hardware Security Management AWS提供专用加密硬件 完全由自己管理加密的key(硬件由AWS管理) FIPS 140-2 Level 3 compliance ACM - AWS Certificate Manager 管理、部署SSL/TLS证书 in-flight encryption - 传输过程中加密 Secrets Manager Secrets Manager管理、修改(定时)secret secrets被KMS加密 与RDS集成 Artifact 下载、查看compliance, agreement GuardDuty 使用基于机器学习的算法来保护AWS账号 输入数据是一系列logs 最佳实践是配合EventBridge使用，当检测出异常，通过EventBridge发送消息给Lambda或者SNS Inspector 主要用于检测正在运行实例的脆弱性、网络可达性 在将镜像推送至ECR之前，先通过Inspector检查(绿：没问题，黄：脆弱，红：严重错误) 检查Lambda Function中代码与依赖的脆弱性 将结果发送给Security Hub或者EventBridge Config Macie 基于机器学习与模式识别来发现并保护AWS中的敏感数据 Macie会检测敏感数据，比如PII(Personally identifiable Information)，通过EventBridge告警 pronuciation:Macy Security Hub Security Dashboard 在多个 AWS 账户中集中自动进行安全检查 Amazon GuardDuty - Amazon GuardDuty is a threat detection service that monitors malicious activity and unauthorized behavior to protect your AWS account. Amazon GuardDuty analyzes billions of events across your AWS accounts from AWS CloudTrail (AWS user and API activity in your accounts), Amazon VPC Flow Logs (network traffic data), and DNS Logs (name query patterns). AWS Trusted Advisor - AWS Trusted Advisor is an online tool that provides real-time guidance to help you provision your resources following AWS best practices. Whether establishing new workflows, developing applications, or as part of ongoing improvement, recommendations provided by AWS Trusted Advisor on a regular basis help keep your solutions provisioned optimally. The AWS Cloud Adoption Framework (AWS CAF) leverages AWS experience and best practices to help you digitally transform and accelerate your business outcomes through innovative use of AWS. AWS CAF identifies specific organizational capabilities that underpin successful cloud transformations. AWS CAF groups its capabilities in six perspectives: Business, People, Governance, Platform, Security, and Operations. Amazon Machine Image (AMI) An Amazon Machine Image (AMI) provides the information required to launch an instance. You must specify an Amazon Machine Image (AMI) when you launch an instance. Cloud Foundations Cloud Foundations provides a guided path to help customers deploy, configure, and secure their new workloads while ensuring they are ready for on-going operations in the cloud. Cloud Foundations helps customers navigate through the decisions they need to make through curated AWS Services, AWS Solutions, Partner Solutions, and Guidance. Amazon Rekognition With Amazon Rekognition, you can identify objects, people, text, scenes, and activities in images and videos, as well as detect any inappropriate content. Amazon Rekognition also provides highly accurate facial analysis and facial search capabilities that you can use to detect, analyze, and compare faces for a wide variety of user verification, people counting, and public safety use cases. Amazon Rekognition is a regional service. EC2 instances can access files on an Amazon Elastic File System (Amazon EFS) file system across many Availability Zones (AZ), Regions and VPCs Amazon EFS is a regional service storing data within and across multiple Availability Zones (AZs) for high availability and durability. Amazon EC2 instances can access your file system across AZs, regions, and VPCs, while on-premises servers can access using AWS Direct Connect or AWS VPN. Amazon CloudWatch - Amazon CloudWatch can be used to create alarm to monitor your estimated charges. When you enable the monitoring of estimated charges for your AWS account, the estimated charges are calculated and sent several times daily to CloudWatch as metric data. You can choose to receive alerts by email when charges have exceeded a certain threshold. Think resource performance monitoring, events, and alerts; think CloudWatch. Amazon CloudWatch cannot be used to identify under-utilized Amazon EC2 instances without manually configuring an alarm with the appropriate threshold to track the Amazon EC2 utilization, so this option is incorrect.","categories":[{"name":"AWS","slug":"AWS","permalink":"https://leopol1d.github.io/categories/AWS/"},{"name":"Ultimate AWS Certified Cloud Practitioner CLF-C02","slug":"AWS/Ultimate-AWS-Certified-Cloud-Practitioner-CLF-C02","permalink":"https://leopol1d.github.io/categories/AWS/Ultimate-AWS-Certified-Cloud-Practitioner-CLF-C02/"}],"tags":[{"name":"Cloud Computing","slug":"Cloud-Computing","permalink":"https://leopol1d.github.io/tags/Cloud-Computing/"},{"name":"AWS","slug":"AWS","permalink":"https://leopol1d.github.io/tags/AWS/"},{"name":"Ultimate AWS Certified Cloud Practitioner CLF-C02","slug":"Ultimate-AWS-Certified-Cloud-Practitioner-CLF-C02","permalink":"https://leopol1d.github.io/tags/Ultimate-AWS-Certified-Cloud-Practitioner-CLF-C02/"},{"name":"DDoS","slug":"DDoS","permalink":"https://leopol1d.github.io/tags/DDoS/"},{"name":"WAF","slug":"WAF","permalink":"https://leopol1d.github.io/tags/WAF/"},{"name":"Shield","slug":"Shield","permalink":"https://leopol1d.github.io/tags/Shield/"},{"name":"Network Firewall","slug":"Network-Firewall","permalink":"https://leopol1d.github.io/tags/Network-Firewall/"},{"name":"Penetration Testing","slug":"Penetration-Testing","permalink":"https://leopol1d.github.io/tags/Penetration-Testing/"},{"name":"CloudHSM","slug":"CloudHSM","permalink":"https://leopol1d.github.io/tags/CloudHSM/"},{"name":"Artifact","slug":"Artifact","permalink":"https://leopol1d.github.io/tags/Artifact/"},{"name":"GuardDuty","slug":"GuardDuty","permalink":"https://leopol1d.github.io/tags/GuardDuty/"},{"name":"Inspector","slug":"Inspector","permalink":"https://leopol1d.github.io/tags/Inspector/"},{"name":"Macie","slug":"Macie","permalink":"https://leopol1d.github.io/tags/Macie/"},{"name":"Security Hub","slug":"Security-Hub","permalink":"https://leopol1d.github.io/tags/Security-Hub/"}]},{"title":"AWS Solutions Architecture of DBS","slug":"AWS-Solutions-Architecture-of-DBS","date":"2024-01-12T11:05:15.000Z","updated":"2024-01-12T13:11:43.121Z","comments":true,"path":"2024/01/12/AWS-Solutions-Architecture-of-DBS/","link":"","permalink":"https://leopol1d.github.io/2024/01/12/AWS-Solutions-Architecture-of-DBS/","excerpt":"","text":"RDB (Relational Database) 解决方案架构一：读副本(左) 解决方案架构二：多可用区(右) 可用区概念 读副本有助于提升读效率，多可用区支持灾难恢复 共同点是只能写入数据至主数据库 解决方案架构三：多区域读副本 请注意可用区和区域的概念！ 可用区是一个区域内的单个数据中心或一组数据中心。可用区彼此相距数十英里(光信号毫秒级传输)。这个距离足够近，可以在可用区之间实现低延迟（请求内容与接收内容之间的时间）。但是，如果区域内的某个部分发生灾难，这个距离又足够远，可以降低多个可用区受到影响的几率。 区域的距离远超过数十英里 方案优势 容灾能力极强 部署在不同区域(如中国、美国)，全球读效率高 主节点将数据备份给从节点需要付费(流量传输) 总结 RDS Multi-AZ 部署的主要目的是高可用性，而 RDS Read Replicas 的主要目的是可扩展性。此外，多区域部署的主要目的是灾难恢复和本地性能。 高可用是指数据库的持久性、冗余性和自动故障转移能力。 容灾是指在相隔较远的异地，搭建一个完整的集群环境，当一个地方发生灾难停止工作时，可以切换到另一处，使得系统可以正常提供服务。 Aurora 可以看作是云原生(cloud-native)版本的RDB ElasticCache 类似于redis，不过拥有AWS的features：弹性伸缩，故障恢复，自动备份 DynamoDB AWS旗舰产品，features: 自动托管在三个可用区 NoSQL database serveless(无法访问服务器底层) low latency 表结构 结合DAX(DynamoDB专用缓存) DynamoDB Global Tables 解决方案架构 多区域部署，实现低延迟 Active-Active replication，任何副本都能进行读和写 Redshift 数仓 serverless EMR(Elastic MapReduce) 用于创建Hadoop集群(包含数百个EC2实例)处理大数据 支持Spark, HBase, Presto, Flink Athena serverless，用于分析存储在S3中的数据 使用标准SQL Use Cases: BI(Business Intelligence/analytic/reportings/logs/CloudTrail trails) QuickSight 基于机器学习生成交互dashboard 主要用于分析，可视化 DocumentDB 类似于云原生版本的MongoDB Neptune 图数据库 主要用于社交网络 Timestream 时间序列数据库 QLDB Quantum Ledger Database:量子分类账数据库 检阅所有发生改变的应用数据的历史记录 immutable(无法被修改或者删除) 主要用于财务 Managed Blockchain 区块链：在多方执行事务时，无需授权，构建应用 兼容两种框架 Glue serverless，ETL(extract, transform, load)服务 从S3或者RDS中提取数据，清洗，导入到RedShift中进行分析 DMS(Database Migration Service) 提供同质数据迁移(oracle to oracle)与异质数据迁移(Microsoft SQL Server to Aurora)","categories":[{"name":"AWS","slug":"AWS","permalink":"https://leopol1d.github.io/categories/AWS/"},{"name":"Ultimate AWS Certified Cloud Practitioner CLF-C02","slug":"AWS/Ultimate-AWS-Certified-Cloud-Practitioner-CLF-C02","permalink":"https://leopol1d.github.io/categories/AWS/Ultimate-AWS-Certified-Cloud-Practitioner-CLF-C02/"}],"tags":[{"name":"Cloud Computing","slug":"Cloud-Computing","permalink":"https://leopol1d.github.io/tags/Cloud-Computing/"},{"name":"AWS","slug":"AWS","permalink":"https://leopol1d.github.io/tags/AWS/"},{"name":"Ultimate AWS Certified Cloud Practitioner CLF-C02","slug":"Ultimate-AWS-Certified-Cloud-Practitioner-CLF-C02","permalink":"https://leopol1d.github.io/tags/Ultimate-AWS-Certified-Cloud-Practitioner-CLF-C02/"},{"name":"RDB","slug":"RDB","permalink":"https://leopol1d.github.io/tags/RDB/"},{"name":"ElasticCache","slug":"ElasticCache","permalink":"https://leopol1d.github.io/tags/ElasticCache/"},{"name":"DynamoDB","slug":"DynamoDB","permalink":"https://leopol1d.github.io/tags/DynamoDB/"},{"name":"DynamoDB Global Tables","slug":"DynamoDB-Global-Tables","permalink":"https://leopol1d.github.io/tags/DynamoDB-Global-Tables/"},{"name":"Redshift","slug":"Redshift","permalink":"https://leopol1d.github.io/tags/Redshift/"},{"name":"EMR","slug":"EMR","permalink":"https://leopol1d.github.io/tags/EMR/"},{"name":"Athena","slug":"Athena","permalink":"https://leopol1d.github.io/tags/Athena/"},{"name":"QuickSight","slug":"QuickSight","permalink":"https://leopol1d.github.io/tags/QuickSight/"},{"name":"DocumentDB","slug":"DocumentDB","permalink":"https://leopol1d.github.io/tags/DocumentDB/"},{"name":"Neptune","slug":"Neptune","permalink":"https://leopol1d.github.io/tags/Neptune/"},{"name":"Timestream","slug":"Timestream","permalink":"https://leopol1d.github.io/tags/Timestream/"},{"name":"QLDB","slug":"QLDB","permalink":"https://leopol1d.github.io/tags/QLDB/"},{"name":"Managed Blockchain","slug":"Managed-Blockchain","permalink":"https://leopol1d.github.io/tags/Managed-Blockchain/"},{"name":"Glue","slug":"Glue","permalink":"https://leopol1d.github.io/tags/Glue/"},{"name":"DMS","slug":"DMS","permalink":"https://leopol1d.github.io/tags/DMS/"}]},{"title":"Amazon Elastic Block Store","slug":"Amazon-Elastic-Block-Store","date":"2024-01-09T11:08:29.000Z","updated":"2024-01-09T11:30:47.399Z","comments":true,"path":"2024/01/09/Amazon-Elastic-Block-Store/","link":"","permalink":"https://leopol1d.github.io/2024/01/09/Amazon-Elastic-Block-Store/","excerpt":"","text":"实例存储 使用具体某台EC2实例主机的磁盘存储，当EC2实例终止(比如更换EC2实例)，实例存储中的数据会丢失。 EBS 将数据卷驱动器与 EC2 实例的主机分离开来 Amazon Elastic Block Store (Amazon EBS)(opens in a new tab) 是一项提供块级存储卷的服务，可以将其用于 Amazon EC2 实例。如果停止或终止 Amazon EC2 实例，附加的 EBS 卷上的所有数据仍然可用。 创建 EBS 卷后，您可以将它附加到 Amazon EC2 实例。 EBS 卷用于存储需要持久保存的数据，因此备份数据非常重要。您可以通过创建 Amazon EBS 快照为 EBS 卷创建递增备份。 Amazon EBS 快照 增量备份 通过 Amazon EBS 快照为 EBS 卷创建递增备份。第一天，备份两个卷。第 2 天，增加一个新卷，并备份新卷。第 3 天，再增加两个卷，共有五个卷。仅备份两个新卷。","categories":[{"name":"AWS","slug":"AWS","permalink":"https://leopol1d.github.io/categories/AWS/"},{"name":"AWS Cloud Practitioner Essentials","slug":"AWS/AWS-Cloud-Practitioner-Essentials","permalink":"https://leopol1d.github.io/categories/AWS/AWS-Cloud-Practitioner-Essentials/"}],"tags":[{"name":"Cloud Computing","slug":"Cloud-Computing","permalink":"https://leopol1d.github.io/tags/Cloud-Computing/"},{"name":"AWS","slug":"AWS","permalink":"https://leopol1d.github.io/tags/AWS/"},{"name":"AWS Cloud Practitioner Essentials","slug":"AWS-Cloud-Practitioner-Essentials","permalink":"https://leopol1d.github.io/tags/AWS-Cloud-Practitioner-Essentials/"}]},{"title":"Amazon ACL","slug":"Amazon-ACL","date":"2024-01-09T10:30:48.000Z","updated":"2024-01-09T11:40:37.100Z","comments":true,"path":"2024/01/09/Amazon-ACL/","link":"","permalink":"https://leopol1d.github.io/2024/01/09/Amazon-ACL/","excerpt":"","text":"AWS网络架构 子网 子网是 VPC 的一部分，可以在其中根据安全性或操作需求对资源进行分组。子网可以是公有子网，也可以是私有子网。 公有子网包含需要能够公开访问的资源，例如在线商店的网站。 私有子网包含只能通过私有网络访问的资源，例如包含客户个人信息和订单历史记录的数据库。 在 VPC 中，子网可以相互通信。例如，可能有一个应用程序，该应用程序包含位于公有子网中的 Amazon EC2 实例，该实例与位于私有子网中的数据库通信。 Access Control List 网络 ACL 是一种虚拟防火墙，用于在子网级别控制入站和出站流量。 每个 AWS 账户都包含一个默认网络 ACL。配置 VPC 时，您可以使用账户的默认网络 ACL，也可以创建自定义网络 ACL。 默认情况下，默认网络 ACL 允许所有入站和出站流量，但可以通过添加自己的规则对其进行修改。自定义网络 ACL 会拒绝所有入站和出站流量，除非添加规则，指定允许哪些流量。此外，所有网络 ACL 都具有显式拒绝规则。该规则可以确保拒绝不符合列表中的任何其他规则的数据包。 无状态数据包筛选 ACL是无状态的，无论数据包是入站还是出站，都会通过进行检查 安全组 安全组是一个虚拟防火墙，可控制 Amazon EC2 实例的入站和出站流量。 默认情况下，安全组拒绝所有入站流量并允许所有出站流量 数据包通过ACL的检查，进入子网后，系统必须评估其对子网内的资源（例如 Amazon EC2 实例）拥有的权限。 检查数据包对 Amazon EC2 实例拥有的权限的 VPC 组件是安全组(opens in a new tab)。 有状态数据包筛选 安全组是有状态的，当该请求的数据包响应返回实例时，安全组会记得之前的请求。安全组会允许响应进入，而不考虑入站安全组规则。","categories":[{"name":"AWS","slug":"AWS","permalink":"https://leopol1d.github.io/categories/AWS/"},{"name":"AWS Cloud Practitioner Essentials","slug":"AWS/AWS-Cloud-Practitioner-Essentials","permalink":"https://leopol1d.github.io/categories/AWS/AWS-Cloud-Practitioner-Essentials/"}],"tags":[{"name":"Cloud Computing","slug":"Cloud-Computing","permalink":"https://leopol1d.github.io/tags/Cloud-Computing/"},{"name":"AWS","slug":"AWS","permalink":"https://leopol1d.github.io/tags/AWS/"},{"name":"AWS Cloud Practitioner Essentials","slug":"AWS-Cloud-Practitioner-Essentials","permalink":"https://leopol1d.github.io/tags/AWS-Cloud-Practitioner-Essentials/"}]},{"title":"Amazon Network","slug":"Amazon-Network","date":"2024-01-09T09:57:50.000Z","updated":"2024-01-09T11:40:59.361Z","comments":true,"path":"2024/01/09/Amazon-Network/","link":"","permalink":"https://leopol1d.github.io/2024/01/09/Amazon-Network/","excerpt":"","text":"Amazon Virtual Private Cloud (Amazon VPC) 可以使用一项联网服务在 AWS 资源周围建立边界，这项服务就是 Amazon Virtual Private Cloud (Amazon VPC)(opens in a new tab)。 借助 Amazon VPC，您可以在 AWS 云中预置隔离的部分。在这个隔离的部分中，您可以在自己定义的虚拟网络中启动资源。在 Virtual Private Cloud (VPC) 中，您可以将资源组织到子网中。子网是 VPC 的一部分，可以包含 Amazon EC2 实例等资源。 互联网网关 要允许来自互联网的公共流量访问您的 VPC，您可以在 VPC 中附加互联网网关。 互联网网关图标附加到 VPC，VPC 中包含三个 EC2 实例。箭头通过互联网将客户端连接到网关，表示客户端的请求已获得对 VPC 的访问权限。 互联网网关是 VPC 和互联网之间的连接。可以将互联网网关看作顾客进入咖啡店的大门。如果没有互联网网关，任何人都无法访问 VPC 中的资源。 虚拟私有网关 要访问 VPC 中的私有资源，您可以使用虚拟私有网关。 使用虚拟私有网络 (VPN) 连接，对互联网流量进行加密（或保护），使其免受周围所有其他请求的影响。 借助虚拟私有网关，可以在 VPC 和私有网络（例如本地数据中心或企业内部网络）之间建立虚拟专用网络 (VPN) 连接。虚拟私有网关仅允许来自经批准的网络的流量流入 VPC。 AWS Direct Connect AWS Direct Connect(opens in a new tab) 是一项服务，能够在数据中心和 VPC 之间建立专用私有连接。 假设有一栋公寓大楼，它的走廊直接将大楼与咖啡店相连。只有公寓大楼里面的住户才能穿过这个走廊。 这个私人走廊提供的专用连接与 AWS Direct Connect 提供的专用连接性质相同。住户无需走过与其他顾客共享的公共道路就能进入咖啡店。 AWS Direct Connect 提供的私有连接可以帮助您降低网络成本，同时增加通过网络传输的带宽。","categories":[{"name":"AWS","slug":"AWS","permalink":"https://leopol1d.github.io/categories/AWS/"},{"name":"AWS Cloud Practitioner Essentials","slug":"AWS/AWS-Cloud-Practitioner-Essentials","permalink":"https://leopol1d.github.io/categories/AWS/AWS-Cloud-Practitioner-Essentials/"}],"tags":[{"name":"Cloud Computing","slug":"Cloud-Computing","permalink":"https://leopol1d.github.io/tags/Cloud-Computing/"},{"name":"AWS","slug":"AWS","permalink":"https://leopol1d.github.io/tags/AWS/"},{"name":"AWS Cloud Practitioner Essentials","slug":"AWS-Cloud-Practitioner-Essentials","permalink":"https://leopol1d.github.io/tags/AWS-Cloud-Practitioner-Essentials/"}]},{"title":"Amazon Infrastructure High Availability","slug":"Amazon-infrastructure-High-Availability","date":"2024-01-09T07:27:40.000Z","updated":"2024-01-12T11:55:30.474Z","comments":true,"path":"2024/01/09/Amazon-infrastructure-High-Availability/","link":"","permalink":"https://leopol1d.github.io/2024/01/09/Amazon-infrastructure-High-Availability/","excerpt":"","text":"可用区 最佳实践：至少在两个可用区部署基础设施 可用区是一个区域内的单个数据中心或一组数据中心。可用区彼此相距数十英里(光信号毫秒级传输)。这个距离足够近，可以在可用区之间实现低延迟（请求内容与接收内容之间的时间）。但是，如果区域内的某个部分发生灾难，这个距离又足够远，可以降低多个可用区受到影响的几率。 可用区发生故障 边缘站点 边缘站点是靠近客户地理位置的站点，Amazon CloudFront 使用它将缓存的内容副本存储在更靠近客户的位置，以便加快分发速度。 CDN(Content Distribution Network内容分发网络)：一种根据用户的地理位置从边缘站点向他们分发内容的网络 Amazon CloudFront 是一种内容分发网络（CDN）服务，旨在获得优异性能、安全性和开发人员便利性。可以使用 Amazon CloudFront 执行以下任务： 借助自动网络映射和智能路由，通过 450 多个分散在全球各地的入网点（PoP）交付数据。 通过流量加密和访问控制提高安全性，并使用 AWS Shield Standard 防御分布式拒绝服务（DDoS）攻击，无需额外费用。 使用无服务器计算功能自定义您在 AWS 网络边缘运行的代码，以平衡成本、性能和安全性。 自动扩展，以高传输速率大规模分发软件、游戏补丁和 IoT 更新内容。 示例1 假设公司的数据存储在巴西，而有客户居住在中国。要向这些客户提供内容，不必将所有内容移动到其中一个中国区域。 可以在靠近中国客户的边缘站点本地缓存一份副本，而不是要求客户从巴西获取数据。 当中国客户请求某个文件时，Amazon CloudFront 会从边缘站点的缓存中检索该文件，然后分发给客户。该文件来自中国附近的边缘站点而不是巴西的原始源，因此可以更快地将其分发给客户。 示例2 Amazon Route 53 (AWS的DNS服务器)和 Amazon CloudFront 如何分发内容 假设 AnyCompany 的应用程序正在多个 Amazon EC2 实例上运行。这些实例位于附加到 Application Load Balancer 的 Auto Scaling 组。 客户通过访问 AnyCompany 网站向应用程序请求数据。 Amazon Route 53 利用 DNS 解析来识别 AnyCompany.com 对应的 IP 地址，即 192.0.2.0。系统将这一信息发送给客户。 客户的请求通过 Amazon CloudFront 发送到最近的边缘站点。 Amazon CloudFront 连接到 Application Load Balancer，后者将传入的数据包发送到 Amazon EC2 实例。","categories":[{"name":"AWS","slug":"AWS","permalink":"https://leopol1d.github.io/categories/AWS/"},{"name":"AWS Cloud Practitioner Essentials","slug":"AWS/AWS-Cloud-Practitioner-Essentials","permalink":"https://leopol1d.github.io/categories/AWS/AWS-Cloud-Practitioner-Essentials/"}],"tags":[{"name":"Cloud Computing","slug":"Cloud-Computing","permalink":"https://leopol1d.github.io/tags/Cloud-Computing/"},{"name":"AWS","slug":"AWS","permalink":"https://leopol1d.github.io/tags/AWS/"},{"name":"High Availability","slug":"High-Availability","permalink":"https://leopol1d.github.io/tags/High-Availability/"},{"name":"AWS Cloud Practitioner Essentials","slug":"AWS-Cloud-Practitioner-Essentials","permalink":"https://leopol1d.github.io/tags/AWS-Cloud-Practitioner-Essentials/"},{"name":"Disaster Tolerance","slug":"Disaster-Tolerance","permalink":"https://leopol1d.github.io/tags/Disaster-Tolerance/"}]},{"title":"Amazon Computing Service","slug":"Amazon-Computing-Service","date":"2024-01-09T06:57:02.000Z","updated":"2024-01-12T11:53:57.996Z","comments":true,"path":"2024/01/09/Amazon-Computing-Service/","link":"","permalink":"https://leopol1d.github.io/2024/01/09/Amazon-Computing-Service/","excerpt":"","text":"无服务器计算 无法访问底层基础设备，运维工作(无需考虑扩容，调整资源)交给服务提供者(AWS)解决 “无服务器”一词是指代码在服务器上运行，但无需预置或管理这些服务器。借助无服务器计算，您可以将更多精力放在新产品和功能创新上，而不是放在维护服务器上。 无服务器计算的另一项优势在于可以灵活地自动扩展无服务器应用程序。无服务器计算可以通过修改使用单位（例如吞吐量和内存）来调整应用程序的容量。 AWS 的无服务器计算服务是 AWS Lambda。 AWS Lambda的工作原理 将代码上传到 Lambda。 将代码设置为从事件源（例如 AWS 服务、移动应用程序或 HTTP 终端节点）触发。 Lambda 仅在触发时才运行代码。 只需为使用的计算时间付费。 事件触发类似于Webhook(GitLab -&gt; Jenkins) Amazon Elastic Container Service (Amazon ECS) Amazon Elastic Container Service (Amazon ECS)(opens in a new tab) 是一种高度可扩展的高性能容器管理系统，可以在 AWS 上运行和扩展容器化应用程序。 Amazon ECS 支持 Docker 容器。Docker(opens in a new tab) 是一种软件平台，让您能够快速构建、测试和部署应用程序。AWS 支持使用开源 Docker 社区版和基于订阅的 Docker 企业版。借助 Amazon ECS，您可以使用 API 调用来启动和停止支持 Docker 的应用程序。 docker：把应用程序、依赖、环境配置打包成一个镜像，通过容器与操作系统交互，通过这种方式，我们可以将软件环境标准化 Amazon Elastic Kubernetes Service (Amazon EKS) Amazon Elastic Kubernetes Service (Amazon EKS)(opens in a new tab) 是一项完全托管式服务，可用于在 AWS 上运行 Kubernetes。 Kubernetes(opens in a new tab) 是一款开源软件，让您能够大规模部署和管理容器化应用程序。Kubernetes 由一个大型志愿者社区维护，而 AWS 积极地与 Kubernetes 社区展开合作。随着 Kubernetes 应用程序的新功能特性发布，您可以轻松地将这些更新应用到由 Amazon EKS 管理的应用程序中。 AWS Fargate AWS Fargate(opens in a new tab) 是一种适用于容器的无服务器计算引擎。它可与 Amazon ECS 和 Amazon EKS 一起使用。 使用 AWS Fargate 时，无需预置或管理服务器。AWS Fargate 为您管理服务器基础设施。您可以更加专注于应用程序的创新和开发，并且只需为运行容器所需的资源付费。","categories":[{"name":"AWS","slug":"AWS","permalink":"https://leopol1d.github.io/categories/AWS/"},{"name":"AWS Cloud Practitioner Essentials","slug":"AWS/AWS-Cloud-Practitioner-Essentials","permalink":"https://leopol1d.github.io/categories/AWS/AWS-Cloud-Practitioner-Essentials/"}],"tags":[{"name":"Cloud Computing","slug":"Cloud-Computing","permalink":"https://leopol1d.github.io/tags/Cloud-Computing/"},{"name":"AWS","slug":"AWS","permalink":"https://leopol1d.github.io/tags/AWS/"},{"name":"AWS Cloud Practitioner Essentials","slug":"AWS-Cloud-Practitioner-Essentials","permalink":"https://leopol1d.github.io/tags/AWS-Cloud-Practitioner-Essentials/"}]},{"title":"Amazon EC2 Auto Scaling","slug":"AWS-Cloud-Practitioner-Essentials","date":"2024-01-09T06:27:50.000Z","updated":"2024-01-09T06:40:57.726Z","comments":true,"path":"2024/01/09/AWS-Cloud-Practitioner-Essentials/","link":"","permalink":"https://leopol1d.github.io/2024/01/09/AWS-Cloud-Practitioner-Essentials/","excerpt":"","text":"Amazon EC2 Auto Scaling 介绍 利用 Amazon EC2 Auto Scaling自动添加或删除 Amazon EC2 实例，以响应不断变化的应用程序需求。根据需要自动缩减和扩展实例，能够保持更好的应用程序可用性。 **EC2 Auto Scaling与Kubernetes中的HPA，deployments(滚动更新)十分相似 ** 拓展方案：动态拓展和预测性拓展 动态扩展可以响应不断变化的需求 预测性扩展根据预测的需求自动安排合适数量的 Amazon EC2 实例 预测性拓展使用场景：业务量根据时间(比如限时活动)或者季节有比较大的浮动 建议可以结合使用动态扩展和预测性扩展 示例 在云中，计算能力是一种编程资源，因此可以采取更灵活的方法来解决扩展问题。通过向应用程序添加 Amazon EC2 Auto Scaling 功能，可以在需要时向应用程序添加新实例，并在不再需要这些实例时终止它们。 假设在 Amazon EC2 实例上启动一个应用程序。在配置 Auto Scaling 组的大小时，您可以将 Amazon EC2 实例的最小数量设置为 1。这意味着在任何时候都必须至少运行一个 Amazon EC2 实例。","categories":[{"name":"AWS","slug":"AWS","permalink":"https://leopol1d.github.io/categories/AWS/"},{"name":"AWS Cloud Practitioner Essentials","slug":"AWS/AWS-Cloud-Practitioner-Essentials","permalink":"https://leopol1d.github.io/categories/AWS/AWS-Cloud-Practitioner-Essentials/"}],"tags":[{"name":"Cloud Computing","slug":"Cloud-Computing","permalink":"https://leopol1d.github.io/tags/Cloud-Computing/"},{"name":"AWS","slug":"AWS","permalink":"https://leopol1d.github.io/tags/AWS/"},{"name":"AWS Cloud Practitioner Essentials","slug":"AWS-Cloud-Practitioner-Essentials","permalink":"https://leopol1d.github.io/tags/AWS-Cloud-Practitioner-Essentials/"}]},{"title":"gap between me and top algorithm experts","slug":"gap-between-me-and-top-algorithm-experts","date":"2023-11-18T02:42:12.000Z","updated":"2023-11-18T03:25:42.040Z","comments":true,"path":"2023/11/18/gap-between-me-and-top-algorithm-experts/","link":"","permalink":"https://leopol1d.github.io/2023/11/18/gap-between-me-and-top-algorithm-experts/","excerpt":"","text":"距离上一次打比赛要追溯到上个月leetcode cup 367，虽然第二题意外WA了四次，还是成功AK。秋招拿了4个offer，休息了一个多月。 今天无聊做了做每日一题，看完数据范围，设计好方法后，感觉我真是个天才，ac后看了灵神的题解，自愧不如。。。 2342. 数位和相等数对的最大和 my proposed method 要求数位和(digit sum)相等的数组元素中最大的数组元素和，看数据范围，$nums[i] \\in [1, 10^9]$，那么极限范围是999999999，数位和最大81，那我创建82个treemap，遍历完数组后，降序从treemap中找答案不就行了，easy 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public int maximumSum(int[] nums) &#123; int n = nums.length, res = -1; // nums最大1e9,9个9相加是81 // treemap中存放数位和相同的数组元素 TreeMap&lt;Integer, Integer&gt;[] maps = new TreeMap[82]; Arrays.setAll(maps, e -&gt; new TreeMap&lt;&gt;()); for (int x : nums) &#123; int bitSum = 0, num = x; while (num &gt; 0) &#123; bitSum += num % 10; num /= 10; &#125; TreeMap&lt;Integer, Integer&gt; map = maps[bitSum]; map.put(x, map.getOrDefault(x, 0) + 1); &#125; for (int i = 81; i &gt;= 0; --i) &#123; TreeMap&lt;Integer, Integer&gt; map = maps[i]; int key1 = -1; for (int key : map.descendingKeySet()) &#123; if (key1 == -1 &amp;&amp; map.get(key) &gt;= 2) &#123; res = Math.max(res, key * 2); break; &#125; else if (key1 == -1 &amp;&amp; map.get(key) == 1) key1 = key; else if (key1 != -1) &#123; res = Math.max(res, key1 + key); break; &#125; &#125; &#125; return res; &#125;&#125; expert solution 1234567891011121314151617class Solution: def maximumSum(self, nums: List[int]) -&gt; int: ans = -1 mx = [0] * 82 # 至多 9 个 9 相加 for num in nums: # s = sum(map(int, str(num))) # 不转成 str，效率更高 s = 0 x = num while x: # 枚举 num 的每个数位 s += x % 10 x //= 10 if mx[s]: # 说明左边也有数位和等于 s 的元素 ans = max(ans, mx[s] + num) # 更新答案的最大值 mx[s] = max(mx[s], num) # 维护数位和等于 s 的最大元素 return ans","categories":[{"name":".*","slug":"","permalink":"https://leopol1d.github.io/categories/"}],"tags":[{"name":"hash","slug":"hash","permalink":"https://leopol1d.github.io/tags/hash/"}]},{"title":"lcp366","slug":"lcp366","date":"2023-10-09T10:36:41.000Z","updated":"2023-10-09T11:23:46.015Z","comments":true,"path":"2023/10/09/lcp366/","link":"","permalink":"https://leopol1d.github.io/2023/10/09/lcp366/","excerpt":"","text":"2894. 分类求和并作差 方法一：求和公式 123456789class Solution &#123; public int differenceOfSums(int n, int m) &#123; // 能被m整除的和 s1 = m + 2m + 3m + ... + n / m * m // = m(1 + 2 + 3 + ... + n / m) = m * (n / m * (1 + n / m) / 2) // 不能被m整除的和 s2 = n * (1 + n) / 2 - s1 // res = s2 - s1 return n * (1 + n) / 2 - n / m * m * (1 + n / m); &#125;&#125; 2895. 最小处理时间 方法一：贪心 12345678910111213class Solution &#123; public int minProcessingTime(List&lt;Integer&gt; processorTime, List&lt;Integer&gt; tasks) &#123; Collections.sort(processorTime); Collections.sort(tasks, ((o1, o2) -&gt; o2 - o1)); int n = processorTime.size(), res = 0; int index = 0; for (int i = 0; i &lt; 4 * n; i += 4) &#123; res = Math.max(res, processorTime.get(index) + tasks.get(i)); index++; &#125; return res; &#125;&#125; 2896. 执行操作使两个字符串相等 方法一：记忆化搜索 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public int minOperations(String s1, String s2, int x) &#123; n = s1.length(); int cnt1 = 0, cnt2 = 0; for (int i = 0; i &lt; n; ++i) &#123; if (s1.charAt(i) == &#x27;1&#x27;) ++cnt1; if (s2.charAt(i) == &#x27;1&#x27;) ++cnt2; &#125; if (cnt1 % 2 != cnt2 % 2) return -1; this.s1 = s1; this.s2 = s2; this.x = x; dp = new int[n][n + 1][2]; for (int[][] a : dp) for (int[] b : a) Arrays.fill(b, -1); return dfs(0, 0, false); &#125; public int dfs(int index, int key, boolean reverse) &#123; if (index &gt;= n) return key == 0 &amp;&amp; !reverse ? 0 : inf; if (dp[index][key][reverse ? 1 : 0] != -1) return dp[index][key][reverse ? 1 : 0]; char ch1 = s1.charAt(index), ch2 = s2.charAt(index); if ((ch1 == ch2) == !reverse) return dp[index][key][reverse ? 1 : 0] = dfs(index + 1, key, false); int res = Math.min(dfs(index + 1, key + 1, false) + x, dfs(index + 1, key, true) + 1); if (key &gt; 0) res = Math.min(res, dfs(index + 1, key - 1, false)); return dp[index][key][reverse ? 1 : 0] = res; &#125; String s1, s2; int x, inf = Integer.MAX_VALUE &gt;&gt; 1, n; int[][][] dp; &#125;","categories":[{"name":"Contest","slug":"Contest","permalink":"https://leopol1d.github.io/categories/Contest/"},{"name":"LCP","slug":"Contest/LCP","permalink":"https://leopol1d.github.io/categories/Contest/LCP/"}],"tags":[{"name":"力扣杯","slug":"力扣杯","permalink":"https://leopol1d.github.io/tags/%E5%8A%9B%E6%89%A3%E6%9D%AF/"}]},{"title":"lcpBi114","slug":"lcpBi114","date":"2023-10-01T05:58:42.000Z","updated":"2023-10-01T07:11:15.981Z","comments":true,"path":"2023/10/01/lcpBi114/","link":"","permalink":"https://leopol1d.github.io/2023/10/01/lcpBi114/","excerpt":"","text":"8038. 收集元素的最少操作次数 方法一：HashSet 1234567891011121314151617181920212223class Solution &#123; public int minOperations(List&lt;Integer&gt; nums, int k) &#123; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); int n = nums.size(); int res = 0; for (int i = n - 1; i &gt;= 0; --i) &#123; int x = nums.get(i); set.add(x); ++res; if (check(set, k)) return res; &#125; return 0; &#125; private boolean check(Set&lt;Integer&gt; set, int k) &#123; for (int i = 1; i &lt;= k; ++i) &#123; if (!set.contains(i)) return false; &#125; return true; &#125;&#125; 100032. 使数组为空的最少操作次数 方法一：HashMap 123456789101112131415161718192021class Solution &#123; public int minOperations(int[] nums) &#123; Map&lt;Integer, Integer&gt; cnt = new HashMap&lt;&gt;(); int res = 0; for (int x : nums) cnt.put(x, cnt.getOrDefault(x, 0) + 1); for (int x : cnt.values()) &#123; if (x == 1) return -1; int a = x / 3; if (x % 3 == 0) res += a; else &#123; res += a + 1; &#125; &#125; return res; &#125;&#125; 100019. 将数组分割成最多数目的子数组 方法一：二分查找 + 贪心 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123; public int maxSubarrays(int[] nums) &#123; //二分 int n = nums.length; int cnt0 = 0, cur = nums[0]; boolean flag = false; for (int x : nums) &#123; if (flag) &#123; cur = x; flag = false; &#125; else cur &amp;= x; if (cur == 0) &#123; ++cnt0; flag = true; &#125; &#125; int l = cnt0, r = n; int target = nums[0]; for (int x : nums) target &amp;= x; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if (check(nums, mid, target)) l = mid + 1; else r = mid - 1; &#125; return r; &#125; private boolean check(int[] nums, int k, int target) &#123; int sum = 0, cur = nums[0], cnt = 0, n = nums.length; for (int i = 0; i &lt; n; ++i) &#123; int x = nums[i]; cur &amp;= x; if (cur &lt;= target &amp;&amp; sum + cur &lt;= target) &#123; ++cnt; sum += cur; if (i == n - 1) break; cur = nums[i + 1]; &#125; &#125; return cnt &gt;= k &amp;&amp; sum == target; &#125;&#125; 2872. 可以被 K 整除连通块的最大数目 方法一：树形DP 123456789101112131415161718192021222324252627282930313233class Solution &#123; public int maxKDivisibleComponents(int n, int[][] edges, int[] values, int k) &#123; this.k = k; this.values = values; g = new List[n]; Arrays.setAll(g, e -&gt; new ArrayList&lt;&gt;()); for (int[] e : edges) &#123; int a = e[0], b = e[1]; g[a].add(b); g[b].add(a); &#125; return dfs(0, -1)[0]; &#125; List&lt;Integer&gt;[] g; int k; int[] values; private int[] dfs(int x, int p) &#123; int[] arr = new int[2]; arr[1] = values[x]; for (int next : g[x]) &#123; if (next != p) &#123; int[] temp = dfs(next, x); arr[0] += temp[0]; arr[1] += temp[1]; &#125; &#125; if (arr[1] % k == 0) &#123; arr[1] = 0; arr[0]++; &#125; return arr; &#125;&#125;","categories":[{"name":"Contest","slug":"Contest","permalink":"https://leopol1d.github.io/categories/Contest/"},{"name":"LCP","slug":"Contest/LCP","permalink":"https://leopol1d.github.io/categories/Contest/LCP/"}],"tags":[{"name":"力扣杯","slug":"力扣杯","permalink":"https://leopol1d.github.io/tags/%E5%8A%9B%E6%89%A3%E6%9D%AF/"}]},{"title":"lcp365","slug":"lcp365","date":"2023-10-01T05:58:27.000Z","updated":"2023-10-03T14:19:08.132Z","comments":true,"path":"2023/10/01/lcp365/","link":"","permalink":"https://leopol1d.github.io/2023/10/01/lcp365/","excerpt":"","text":"100088. 有序三元组中的最大值 I 方法一：暴力 12345678910111213class Solution &#123; public long maximumTripletValue(int[] nums) &#123; long n = nums.length, res = 0; for (int i = 0; i &lt; n; ++i) &#123; for (int j = i + 1; j &lt; n; ++j) &#123; for (int k = j + 1; k &lt; n; ++k) &#123; res = Math.max(res, (long) (nums[i] - nums[j]) * nums[k]); &#125; &#125; &#125; return Math.max(res, 0); &#125;&#125; 100086. 有序三元组中的最大值 II 方法一：滑动窗口 123456789101112131415class Solution &#123; public long maximumTripletValue(int[] nums) &#123; int n = nums.length, l = 0; long res = 0, diff = 0, preMax = Integer.MIN_VALUE, maxK = 0; for (int i = 1; i &lt; n - 1; ++i) &#123; diff = nums[l] - nums[i]; if (nums[l] &lt; nums[i]) l = i; if (preMax &lt; diff) preMax = diff; res = Math.max(res, preMax * nums[i + 1]); &#125; return Math.max(res, 0); &#125;&#125; 方法二：维护左右最大值 123456789101112131415class Solution &#123; public long maximumTripletValue(int[] nums) &#123; int n = nums.length; long res = 0, max = nums[n - 1]; int[] l = new int[n]; l[0] = nums[0]; for (int i = 1; i &lt; n; ++i) l[i] = Math.max(nums[i], l[i - 1]); for (int i = n - 2; i &gt;= 0; --i) &#123; res = Math.max(res, (l[i] - nums[i]) * max); max = Math.max(max, nums[i]); &#125; return Math.max(res, 0); &#125;&#125; 100076. 无限数组的最短子数组 方法二：滑动窗口 123456789101112131415161718192021class Solution &#123; public int minSizeSubarray(int[] nums, int target) &#123; int n = nums.length, res = Integer.MAX_VALUE / 2, sum = 0; long s = 0; for (int x : nums) sum += x; int cnt = target / sum; target = target % sum; int l = 0; for (int i = 0; i &lt; 2 * n; ++i) &#123; s += nums[i % n]; while (s &gt; target) &#123; s -= nums[l % n]; ++l; &#125; if (s == target) res = Math.min(res, i - l + 1); &#125; return res == Integer.MAX_VALUE / 2 ? -1 : res + cnt * n; &#125;&#125; 方法一：前缀和 + HashMap 12345678910111213141516171819202122232425262728293031323334class Solution &#123; public int minSizeSubarray(int[] nums, int t) &#123; int n = nums.length; long res = Integer.MAX_VALUE / 2; Map&lt;Long, Integer&gt; map = new HashMap&lt;&gt;(); int[] arr = new int[3 * n]; long sum = 0, target = t; for (int i = 0; i &lt; 3 * n; ++i) &#123; arr[i] = nums[i % n]; if (i &lt; n) sum += nums[i]; &#125; boolean flag = false; long extra = 0; if (target &gt;= 2 * sum) &#123; extra = target / sum * n; target %= sum; flag = true; &#125; sum = 0; boolean find = false; for (int i = 0; i &lt; 3 * n; ++i) &#123; sum += arr[i]; map.put(sum, i); if (map.containsKey(sum - target)) &#123; find = true; res = Math.min(res, i - map.get(sum - target)); &#125; &#125; if (flag) res += extra; return !find ? -1 : (int) res; &#125;&#125; 2876. 有向图访问计数 方法一：拓扑排序 + 反向图 注意内向基环图可以包含多个环！！！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123; public int[] countVisitedNodes(List&lt;Integer&gt; g) &#123; int n = g.size(); int[] degree = new int[n]; List&lt;Integer&gt;[] rg = new List[n]; Arrays.setAll(rg, e -&gt; new ArrayList&lt;&gt;()); for (int i = 0; i &lt; n; ++i) &#123; int from = i, to = g.get(i); degree[to]++; rg[to].add(from); &#125; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; n; ++i) if (degree[i] == 0) queue.offer(i); while (!queue.isEmpty()) &#123; int node = queue.poll(); int next = g.get(node); if (--degree[next] == 0) queue.offer(next); &#125; int[] res = new int[n]; for (int i = 0; i &lt; n; ++i) &#123; if (degree[i] &lt;= 0) continue; List&lt;Integer&gt; ring = new ArrayList&lt;&gt;(); int j = i; while (true) &#123; ring.add(j); degree[j] = -1; j = g.get(j); if (j == i) break; &#125; for (int x : ring) dfs(x, ring.size(), rg, res, degree); &#125; return res; &#125; private void dfs(int x, int size, List&lt;Integer&gt;[] rg, int[] res, int[] degree) &#123; res[x] = size; for (int next : rg[x]) &#123; if (degree[next] == 0) dfs(next, size + 1, rg, res, degree); &#125; &#125;&#125;","categories":[{"name":"Contest","slug":"Contest","permalink":"https://leopol1d.github.io/categories/Contest/"},{"name":"LCP","slug":"Contest/LCP","permalink":"https://leopol1d.github.io/categories/Contest/LCP/"}],"tags":[{"name":"力扣杯","slug":"力扣杯","permalink":"https://leopol1d.github.io/tags/%E5%8A%9B%E6%89%A3%E6%9D%AF/"}]},{"title":"lcp364","slug":"lcp364","date":"2023-09-24T06:02:53.000Z","updated":"2023-09-24T06:05:16.462Z","comments":true,"path":"2023/09/24/lcp364/","link":"","permalink":"https://leopol1d.github.io/2023/09/24/lcp364/","excerpt":"","text":"8048. 最大二进制奇数 方法一：贪心 1234567891011121314151617class Solution &#123; public String maximumOddBinaryNumber(String s) &#123; int n = s.length(), cnt = 0; for (int i = 0; i &lt; n; ++i) if (s.charAt(i) == &#x27;1&#x27;) ++cnt; if (cnt == 0) return s; StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; cnt - 1; ++i) sb.append(&#x27;1&#x27;); for (int i = 0; i &lt; n - cnt; ++i) sb.append(&#x27;0&#x27;); sb.append(&#x27;1&#x27;); return sb.toString(); &#125;&#125; 100049. 美丽塔 I 方法一：暴力$O(n^2)$ 123456789101112131415161718192021222324252627class Solution &#123; public long maximumSumOfHeights(List&lt;Integer&gt; nums) &#123; int n = nums.size(); long res = 0; for (int i = 0; i &lt; n; ++i) &#123; int x = nums.get(i), pre = x; long sum = x; for (int j = i - 1; j &gt;= 0; --j) &#123; int y = nums.get(j); if (y &gt; pre) y = pre; sum += y; pre = y; &#125; pre = x; for (int j = i + 1; j &lt; n; ++j) &#123; int y = nums.get(j); if (y &gt; pre) y = pre; sum += y; pre = y; &#125; res = Math.max(res, sum); &#125; return res; &#125;&#125; 100048. 美丽塔 II","categories":[{"name":"Contest","slug":"Contest","permalink":"https://leopol1d.github.io/categories/Contest/"},{"name":"LCP","slug":"Contest/LCP","permalink":"https://leopol1d.github.io/categories/Contest/LCP/"}],"tags":[{"name":"力扣杯","slug":"力扣杯","permalink":"https://leopol1d.github.io/tags/%E5%8A%9B%E6%89%A3%E6%9D%AF/"}]},{"title":"lcpBi113","slug":"lcpBi113","date":"2023-09-17T06:24:59.000Z","updated":"2023-09-17T07:15:00.404Z","comments":true,"path":"2023/09/17/lcpBi113/","link":"","permalink":"https://leopol1d.github.io/2023/09/17/lcpBi113/","excerpt":"","text":"8039. 使数组成为递增数组的最少右移次数 方法一：模拟 123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public int minimumRightShifts(List&lt;Integer&gt; nums) &#123; int n = nums.size(); int[] arr = new int[n]; for (int i = 0; i &lt; n; ++i) &#123; arr[i] = nums.get(i); &#125; boolean flag = true; for (int i = 1; i &lt; n; ++i) &#123; if (nums.get(i) &lt; nums.get(i - 1)) flag = false; &#125; if (flag) return 0; int[] temp = arr.clone(); for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; arr[(j + 1) % n] = temp[j]; &#125; flag = true; for (int j = 1; j &lt; n; ++j) &#123; if (arr[j] &lt; arr[j - 1]) &#123; flag = false; break; &#125; &#125; if (flag) return i; temp = arr; arr = new int[n]; &#125; return -1; &#125;&#125; 方法二：O(n) 2856. 删除数对后的最小数组长度 方法一：TreeMap二分 同lcp334 t3 12345678910111213141516171819202122class Solution &#123; public int minLengthAfterRemovals(List&lt;Integer&gt; nums) &#123; int n = nums.size(); TreeMap&lt;Integer, Integer&gt; map = new TreeMap&lt;&gt;(); for (int i = n / 2 + (n % 2); i &lt; n; ++i) map.put(nums.get(i), map.getOrDefault(nums.get(i), 0) + 1); int res = n; for (int i = 0; i &lt; n / 2; ++i) &#123; int x = nums.get(i); Integer ceil = map.higherKey(x); if (ceil == null) break; else &#123; res -= 2; map.put(ceil, map.get(ceil) - 1); if (map.get(ceil) == 0) map.remove(ceil); &#125; &#125; return res; &#125;&#125; 6988. 统计距离为 k 的点对 方法一：前缀和 + HashMap 两数之和 123456789101112131415161718class Solution &#123; public int countPairs(List&lt;List&lt;Integer&gt;&gt; coordinates, int k) &#123; long res = 0; Map&lt;Long, Integer&gt; map = new HashMap&lt;&gt;(); for (List&lt;Integer&gt; arr : coordinates) &#123; int x = arr.get(0), y = arr.get(1); for (int i = 0; i &lt;= 100; ++i) &#123; long t1 = x ^ i, t2 = y ^ (k - i); res += map.getOrDefault((t1 &lt;&lt; 32) | t2, 0); &#125; long key = ((long) x &lt;&lt; 32) | y; map.put(key, map.getOrDefault(key, 0) + 1); &#125; System.out.println(); return (int) res; &#125; &#125;","categories":[{"name":"Contest","slug":"Contest","permalink":"https://leopol1d.github.io/categories/Contest/"},{"name":"LCP","slug":"Contest/LCP","permalink":"https://leopol1d.github.io/categories/Contest/LCP/"}],"tags":[{"name":"力扣杯","slug":"力扣杯","permalink":"https://leopol1d.github.io/tags/%E5%8A%9B%E6%89%A3%E6%9D%AF/"}]},{"title":"lcp363","slug":"lcp363","date":"2023-09-17T06:02:33.000Z","updated":"2023-09-17T06:13:42.564Z","comments":true,"path":"2023/09/17/lcp363/","link":"","permalink":"https://leopol1d.github.io/2023/09/17/lcp363/","excerpt":"","text":"100031. 计算 K 置位下标对应元素的和 方法一：模拟 1234567891011class Solution &#123; public int sumIndicesWithKSetBits(List&lt;Integer&gt; nums, int k) &#123; int n = nums.size(), res = 0; for (int i = 0; i &lt; n; ++i) &#123; int x = Integer.bitCount(i); if (x == k) res += nums.get(i); &#125; return res; &#125;&#125; 100040. 让所有学生保持开心的分组方法数 方法一：排序 + 贪心 判断起初和结束位置：即全不选和全选 12345678910111213141516171819class Solution &#123; public int countWays(List&lt;Integer&gt; nums) &#123; int n = nums.size(), res = 0; Collections.sort(nums); int cnt = 0; if (nums.get(0) != 0) res++; for (int i = 0; i &lt; n - 1; ++i) &#123; ++cnt; int x = nums.get(i), y = nums.get(i + 1); if (cnt &gt; x &amp;&amp; cnt &lt; y) ++res; &#125; ++cnt; if (cnt &gt; nums.get(n - 1)) ++res; return res; &#125;&#125; 100033. 最大合金数 方法一：二分查找 以后二分r都用1e18！！！ 123456789101112131415161718192021222324252627class Solution &#123; public int maxNumberOfAlloys(int n, int k, int budget, List&lt;List&lt;Integer&gt;&gt; composition, List&lt;Integer&gt; stock, List&lt;Integer&gt; cost) &#123; long res = 0; for (List&lt;Integer&gt; comp : composition) &#123; long l = 0, r = Integer.MAX_VALUE; while (l &lt;= r) &#123; long mid = (l + r) &gt;&gt; 1; if (check(mid, n, budget, comp, stock, cost)) l = mid + 1; else r = mid - 1; &#125; res = Math.max(res, r); &#125; return (int) res; &#125; private boolean check(long cnt, int n, long budget, List&lt;Integer&gt; comp, List&lt;Integer&gt; stock,List&lt;Integer&gt; cost) &#123; long[] requires = new long[n]; for (int i = 0; i &lt; n; ++i) &#123; requires[i] = Math.max(comp.get(i) * cnt - stock.get(i), 0); budget -= requires[i] * cost.get(i); &#125; return budget &gt;= 0; &#125;&#125; 8041. 完全子集的最大元素和 方法一：","categories":[{"name":"Contest","slug":"Contest","permalink":"https://leopol1d.github.io/categories/Contest/"},{"name":"LCP","slug":"Contest/LCP","permalink":"https://leopol1d.github.io/categories/Contest/LCP/"}],"tags":[{"name":"力扣杯","slug":"力扣杯","permalink":"https://leopol1d.github.io/tags/%E5%8A%9B%E6%89%A3%E6%9D%AF/"}]},{"title":"lcp362","slug":"lcp362","date":"2023-09-10T07:40:51.000Z","updated":"2023-09-10T08:10:29.655Z","comments":true,"path":"2023/09/10/lcp362/","link":"","permalink":"https://leopol1d.github.io/2023/09/10/lcp362/","excerpt":"","text":"8029. 与车相交的点 方法一：差分数组 1234567891011121314151617class Solution &#123; public int numberOfPoints(List&lt;List&lt;Integer&gt;&gt; nums) &#123; int n = nums.size(), cnt = 0; int[] diff = new int[103]; for (List&lt;Integer&gt; list : nums) &#123; diff[list.get(0)]++; diff[list.get(1) + 1]--; &#125; int s = 0; for (int i = 0; i &lt; diff.length; ++i) &#123; s += diff[i]; if (s &gt; 0) ++cnt; &#125; return cnt; &#125;&#125; 8049. 判断能否在给定时间到达单元格 方法一：数学 123456789101112class Solution &#123; public boolean isReachableAtTime(int x, int y, int fx, int fy, int t) &#123; if (x == fx &amp;&amp; y == fy &amp;&amp; t == 1) return false; int a = Math.abs(fx - x), b = Math.abs(fy - y), min = Math.min(a, b); t -= min; a -= min; b -= min; t = t - a - b; return t &gt;= 0; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455List&lt;int[]&gt; map0 = new ArrayList&lt;&gt;(), map2 = new ArrayList&lt;&gt;();int n, m;public int minimumMoves(int[][] grid) &#123; for (int i = 0; i &lt; 3; ++i) &#123; for (int j = 0; j &lt; 3; ++j) &#123; if (grid[i][j] == 0) map0.add(new int[]&#123;i, j, 0&#125;); else if (grid[i][j] &gt; 1) map2.add(new int[]&#123;i, j, grid[i][j]&#125;); &#125; &#125; if (map0.isEmpty()) return 0; n = map2.size(); m = map0.size(); int res = 0; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); boolean[][] visited = new boolean[3][3]; return dfs(0, 0, visited);&#125;private int dfs(int i, int j, boolean[][] visited) &#123; if (i == map2.size()) return 0; if (j == map0.size()) return map2.get(i)[2] == 1 ? 0 : Integer.MAX_VALUE / 2; int[] x = map2.get(i), y = map0.get(j); int pass = dfs(i, j + 1, visited), choose = Integer.MAX_VALUE / 2; if (x[2] &gt; 1) &#123; if (visited[y[0]][y[1]]) choose = dfs(i, j + 1, visited); else &#123; visited[y[0]][y[1]] = true; map2.get(i)[2]--; choose = dfs(i, j + 1, visited) + Math.abs(x[0] - y[0]) + Math.abs(x[1] - y[1]); map2.get(i)[2]++; visited[y[0]][y[1]] = false; &#125; &#125; else if (x[2] == 1) &#123; int xx = dfs(i + 1, 0, visited); choose += xx; pass += xx; &#125; return Math.min(pass, choose);&#125;private boolean isValid(int i, int j) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; 3 &amp;&amp; j &lt; 3;&#125;int[][] dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;;","categories":[{"name":"Contest","slug":"Contest","permalink":"https://leopol1d.github.io/categories/Contest/"},{"name":"LCP","slug":"Contest/LCP","permalink":"https://leopol1d.github.io/categories/Contest/LCP/"}],"tags":[{"name":"力扣杯","slug":"力扣杯","permalink":"https://leopol1d.github.io/tags/%E5%8A%9B%E6%89%A3%E6%9D%AF/"}]},{"title":"广联达笔试","slug":"广联达笔试","date":"2023-09-06T10:06:25.000Z","updated":"2023-09-07T07:44:02.161Z","comments":true,"path":"2023/09/06/广联达笔试/","link":"","permalink":"https://leopol1d.github.io/2023/09/06/%E5%B9%BF%E8%81%94%E8%BE%BE%E7%AC%94%E8%AF%95/","excerpt":"","text":"方法：线性二分 + DP 可以将三行输入放在一个大小为n * 3的二维数组nums中，nums[i][0]表示起始时间startTime，nums[i][1]表示送完这单的结束时间endTime，nums[i][2]表示获得的报酬profit。 定义 f[i + 1]表示按照结束时间排序后处理(接单或不接单)前 i 个订单的最大报酬 对于一个外卖订单有两种选择：1.接单 2.不接单 对于第i个订单， 不接单：f[i + 1] = f[i] 接单，f[i + 1] = f[j + 1] + nums[i][2](报酬)，其中j是满足最大的endTime[j] &lt;= startTime[i] 取 接单与不接单所能获得的的最大值,$f[i + 1] = Math.max(f[i], f[j + 1] + nums[i][2])$ 如果从i往后面遍历，找到符合条件的j，时间复杂度是$O(n^2)$，数据有50000，一定会超时。可以通过二分来找到j，时间复杂度为$O(nlogn)。$ 举例 123451 3 6 7 114 3 4 3 92 5 5 3 4 大概长这个样子 1 2 3 4 5 [1,5,2] [3,6,5] [6,10,5] [7,10,4] [11,20,4] 手动计算一下，按照结束时间排序后： 对于前1个订单，能获得的最大报酬是2 对于前2个订单，能获得的最大报酬是5 对于前3个订单，能获得的最大报酬是: 前2个订单最大报酬 + 5 = 5 + 5 = 10 对于前4个订单，能获得的最大报酬是10: 选择第4个订单获得的最大报酬 &lt; 不选择第4个订单获得的最大报酬 对于前5个订单，能获得的最大报酬是14 代码 123456789101112131415161718192021222324252627282930313233343536373839404142package 秋招笔试.广联达0906.第1题;import java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); scanner.nextLine(); int[][] nums = new int[n][3]; for (int i = 0; i &lt; n; ++i) nums[i][0] = scanner.nextInt(); scanner.nextLine(); for (int i = 0; i &lt; n; ++i) nums[i][1] = nums[i][0] + scanner.nextInt(); scanner.nextLine(); for (int i = 0; i &lt; n; ++i) nums[i][2] = scanner.nextInt(); Arrays.sort(nums, (o1, o2) -&gt; o1[1] - o2[1]); long[] f = new long[n + 1]; for (int i = 0; i &lt; n; ++i) &#123; f[i + 1] = f[i]; int j = bisearch(nums, i, nums[i][0]); f[i + 1] = Math.max(f[i + 1], f[j + 1] + nums[i][2]); &#125; System.out.println(f[n]); &#125; private static int bisearch(int[][] nums, int r, int start) &#123; int l = 0; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if (nums[mid][1] &lt;= start) l = mid + 1; else r = mid - 1; &#125; return r; &#125;&#125;","categories":[],"tags":[]},{"title":"lcp361","slug":"lcp361","date":"2023-09-03T02:24:18.000Z","updated":"2023-09-05T06:11:14.095Z","comments":true,"path":"2023/09/03/lcp361/","link":"","permalink":"https://leopol1d.github.io/2023/09/03/lcp361/","excerpt":"","text":"7020. 统计对称整数的数目 方法一：枚举 1234567891011121314151617181920212223242526class Solution &#123; public int countSymmetricIntegers(int low, int high) &#123; int res = 0; for (int i = low; i &lt;= Math.min(high, 99); ++i) &#123; int l = i % 10, r = i / 10; if (l == r) ++res; &#125; if (high &gt; 1000) &#123; for (int i = Math.max(low, 1000); i &lt;= Math.min(high, 10000); ++i) &#123; int pre = 0, suff = 0; int l = i; pre += (l % 10); l /= 10; pre += (l % 10); int r = i / 100; suff += (r % 10); r /= 10; suff += (r % 100); if (pre == suff) ++res; &#125; &#125; return res; &#125;&#125; 8040. 生成特殊数字的最少操作 方法一：贪心 从后往前找，找到子序列25， 50， 75， 00，统计最少需要删除的个数；如果没找到，那么如果字符串中没有0，那么全部删除；如果有0，则删除n-1个字符 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution &#123; public int minimumOperations(String s) &#123; int n = s.length(); int cnt0 = 0; for (int i = 0; i &lt; n; ++i) &#123; if (s.charAt(i) == &#x27;0&#x27;) cnt0++; &#125; int res = 101; int flag = 0; int cnt = 0; for (int i = n - 1; i &gt;= 0; --i) &#123; char ch = s.charAt(i); if (flag == 0) &#123; if (ch == &#x27;0&#x27;) flag = 1; else ++cnt; &#125; else if (flag == 1) &#123; if (ch == &#x27;0&#x27; || ch == &#x27;5&#x27;) flag = 2; else ++cnt; &#125; else break; &#125; if (flag == 2) res = Math.min(res, cnt); flag = 0; cnt = 0; for (int i = n - 1; i &gt;= 0; --i) &#123; char ch = s.charAt(i); if (flag == 0) &#123; if (ch == &#x27;5&#x27;) flag = 1; else ++cnt; &#125; else if (flag == 1) &#123; if (ch == &#x27;2&#x27; || ch == &#x27;7&#x27;) flag = 2; else ++cnt; &#125; else break; &#125; if (flag == 2) res = Math.min(res, cnt); if (res == 101) &#123; res = cnt0 == 0 ? n : n - 1; &#125; return res; &#125;&#125; 6952. 统计趣味子数组的数目 方法一：前缀和 + HashMap + 公式转换 类似两数之和 12345678910111213public long countInterestingSubarrays(List&lt;Integer&gt; nums, int modulo, int k) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); map.put(0, 1); long res = 0; int s = 0; for (int x : nums) &#123; if (x % modulo == k) s = (s + 1) % modulo; res += map.getOrDefault((s - k + modulo) % modulo, 0); map.put(s, map.getOrDefault(s, 0) + 1); &#125; return res;&#125;","categories":[{"name":"Contest","slug":"Contest","permalink":"https://leopol1d.github.io/categories/Contest/"},{"name":"LCP","slug":"Contest/LCP","permalink":"https://leopol1d.github.io/categories/Contest/LCP/"}],"tags":[{"name":"力扣杯","slug":"力扣杯","permalink":"https://leopol1d.github.io/tags/%E5%8A%9B%E6%89%A3%E6%9D%AF/"}]},{"title":"lcpBi112","slug":"lcpBi112","date":"2023-09-02T14:22:25.000Z","updated":"2023-09-08T07:48:13.337Z","comments":true,"path":"2023/09/02/lcpBi112/","link":"","permalink":"https://leopol1d.github.io/2023/09/02/lcpBi112/","excerpt":"","text":"2839. 判断通过操作能否让字符串相等 I 方法一：模拟 12345678910111213141516171819202122232425class Solution &#123; public boolean canBeEqual(String s1, String s2) &#123; if (s1.equals(s2)) return true; boolean[] flag = new boolean[4]; int cnt = 0; for (int i = 0; i &lt; 4; ++i) &#123; char ch1 = s1.charAt(i), ch2 = s2.charAt(i); if (flag[i]) &#123; continue; &#125; if (ch1 == ch2) &#123; flag[i] = true; ++cnt; continue; &#125; if ((i == 0 || i == 1) &amp;&amp; s1.charAt(i + 2) == ch2 &amp;&amp; s2.charAt(i + 2) == ch1) &#123; flag[i] = true; flag[i + 2] = true; cnt += 2; &#125; &#125; return cnt == 4; &#125;&#125; 2840. 判断通过操作能否让字符串相等 II 方法一：计数 123456789101112131415161718192021222324class Solution &#123; public boolean checkStrings(String s1, String s2) &#123; int n = s1.length(); int[] cntEven = new int[26], cntOdd = new int[26]; for (int i = 0; i &lt; n; ++i) &#123; char ch1 = s1.charAt(i), ch2 = s2.charAt(i); if (i % 2 == 0) &#123; ++cntEven[ch1 - &#x27;a&#x27;]; --cntEven[ch2 - &#x27;a&#x27;]; &#125; else &#123; ++cntOdd[ch1 - &#x27;a&#x27;]; --cntOdd[ch2 - &#x27;a&#x27;]; &#125; &#125; for (int i = 0; i &lt; 26; ++i) &#123; if (cntEven[i] != 0) return false; if (cntOdd[i] != 0) return false; &#125; return true; &#125;&#125; 2841. 几乎唯一子数组的最大和 方法一：滑动窗口 123456789101112131415161718192021class Solution &#123; public long maxSum(List&lt;Integer&gt; nums, int m, int k) &#123; long res = 0, s = 0; Map&lt;Integer, Integer&gt; cnt = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.size(); ++i) &#123; int x = nums.get(i); s += x; cnt.put(x, cnt.getOrDefault(x, 0) + 1); if (i &gt;= k - 1) &#123; if (cnt.size() &gt;= m) res = Math.max(res, s); int y = nums.get(i - k + 1); s -= y; cnt.put(y, cnt.get(y) - 1); if (cnt.get(y) == 0) cnt.remove(y); &#125; &#125; return res; &#125;&#125; 2842. 统计一个字符串的 k 子序列美丽值最大的数目 方法一：组合数学 + 快速幂 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123; int MOD = (int) 1e9 + 7; public int countKSubsequencesWithMaxBeauty(String s, int k) &#123; int n = s.length(); int[] cnt = new int[26]; for (int i = 0; i &lt; n; ++i) cnt[s.charAt(i) - &#x27;a&#x27;]++; var cc = new TreeMap&lt;Integer, Integer&gt;(); for (int c : cnt) if (c &gt; 0) cc.put(c, cc.getOrDefault(c, 0) + 1); long res = 1; for (Map.Entry&lt;Integer, Integer&gt; entry : cc.descendingMap().entrySet()) &#123; int num = entry.getKey(), count = entry.getValue(); if (count &gt;= k) return (int) ((res * comb(count, k) % MOD ) % MOD * pow(num, k) % MOD); res = res * pow(num, count) % MOD; k -= count; &#125; return 0; &#125; private long pow(long x, int n) &#123; long res = 1; for (; n &gt; 0; n /= 2) &#123; if (n % 2 &gt; 0) res = res * x % MOD; x = x * x % MOD; &#125; return res; &#125; // 适用于 n 和 k 都比较小的场景（本题至多 26） private long comb(long n, int k) &#123; long res = n; for (int i = 2; i &lt;= k; i++) res = res * --n / i; // n,n-1,n-2,... 中的前 i 个数至少有一个因子 i return res % MOD; &#125;&#125;","categories":[{"name":"Contest","slug":"Contest","permalink":"https://leopol1d.github.io/categories/Contest/"},{"name":"LCP","slug":"Contest/LCP","permalink":"https://leopol1d.github.io/categories/Contest/LCP/"}],"tags":[{"name":"力扣杯","slug":"力扣杯","permalink":"https://leopol1d.github.io/tags/%E5%8A%9B%E6%89%A3%E6%9D%AF/"}]},{"title":"lcp329","slug":"lcp329","date":"2023-09-01T02:25:12.000Z","updated":"2023-09-01T04:37:12.919Z","comments":true,"path":"2023/09/01/lcp329/","link":"","permalink":"https://leopol1d.github.io/2023/09/01/lcp329/","excerpt":"","text":"交替数字和 方法一：模拟 12345678910111213141516171819class Solution &#123; public int alternateDigitSum(int n) &#123; String str = String.valueOf(n); int len = str.length(); int res = 0; boolean flag = len % 2 == 1? true : false; for (int i = 0; i &lt; len; ++i) &#123; int x = n % 10; n /= 10; if (flag) res += x; else res -= x; flag = !flag; &#125; return res; &#125;&#125; 根据第 K 场考试的分数排序 方法一：排序 123456class Solution &#123; public int[][] sortTheStudents(int[][] score, int k) &#123; Arrays.sort(score, (o1, o2) -&gt; o2[k] - o1[k]); return score; &#125;&#125; 执行逐位运算使字符串相等 方法一：贪心 1234567891011121314class Solution &#123; public boolean makeStringsEqual(String s, String target) &#123; int n = s.length(); int cntS = 0, cntT = 0; for (int i = 0; i &lt; n; ++i) &#123; if (s.charAt(i) == &#x27;1&#x27;) ++cntS; if (target.charAt(i) == &#x27;1&#x27;) ++ cntT; &#125; if (cntT == 0) return cntS == 0 ? true : false; else return cntS &gt; 0 ? true : false; &#125;&#125; 拆分数组的最小代价 方法一：DP 12345678910111213141516171819class Solution &#123; public int minCost(int[] nums, int k) &#123; int n = nums.length; int[] f = new int[n + 1]; Arrays.fill(f, Integer.MAX_VALUE &gt;&gt; 1); f[0] = 0; for (int i = 1; i &lt;= n; ++i) &#123; int[] cnt = new int[n]; int t = 0; for (int j = i - 1; j &gt;= 0; --j) &#123; int x = ++cnt[nums[j]]; if (x == 2) t += 2; else if (x &gt; 2) t += 1; f[i] = Math.min(f[i], t + f[j] + k); &#125; &#125; return f[n]; &#125;&#125;","categories":[{"name":"Contest","slug":"Contest","permalink":"https://leopol1d.github.io/categories/Contest/"},{"name":"LCP","slug":"Contest/LCP","permalink":"https://leopol1d.github.io/categories/Contest/LCP/"}],"tags":[{"name":"力扣杯","slug":"力扣杯","permalink":"https://leopol1d.github.io/tags/%E5%8A%9B%E6%89%A3%E6%9D%AF/"}]},{"title":"lcp330","slug":"lcp330","date":"2023-08-31T08:20:13.000Z","updated":"2023-08-31T09:15:28.062Z","comments":true,"path":"2023/08/31/lcp330/","link":"","permalink":"https://leopol1d.github.io/2023/08/31/lcp330/","excerpt":"","text":"统计桌面上的不同数字 方法一: Queue + HashSet 1234567891011121314151617181920class Solution &#123; public int distinctIntegers(int n) &#123; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); queue.offer(n); while (!queue.isEmpty()) &#123; int size = queue.size(); for (int k = 0; k &lt; size; ++k) &#123; int x = queue.poll(); for (int i = 1; i &lt;= n; ++i) &#123; if (!set.contains(i) &amp;&amp; x % i == 1) &#123; queue.offer(i); set.add(i); &#125; &#125; &#125; &#125; return set.size() + 1; &#125;&#125; 猴子碰撞的方法数 方法一: 快速幂 123456789101112131415class Solution &#123; int MOD = (int) 1e9 + 7; public int monkeyMove(int n) &#123; // 只有所有猴子沿着顺时针或者逆时针走，才不会发生碰撞，所以猴子至少发生 一次碰撞 的移动方法数为 Math.pow(2,n) - 2，考察快速幂 long res = 1, x = 2; while (n &gt; 0) &#123; if (n % 2 == 1) res = res * x % MOD; x = x * x % MOD; n /= 2; &#125; return (int) ((res - 2 + MOD) % MOD); &#125;&#125; 将珠子放入背包中 方法一: 1 统计上升四元组 方法一: 1","categories":[{"name":"Contest","slug":"Contest","permalink":"https://leopol1d.github.io/categories/Contest/"},{"name":"LCP","slug":"Contest/LCP","permalink":"https://leopol1d.github.io/categories/Contest/LCP/"}],"tags":[{"name":"力扣杯","slug":"力扣杯","permalink":"https://leopol1d.github.io/tags/%E5%8A%9B%E6%89%A3%E6%9D%AF/"}]},{"title":"lcpBi97","slug":"lcpBi97","date":"2023-08-30T13:45:05.000Z","updated":"2023-08-31T07:54:03.708Z","comments":true,"path":"2023/08/30/lcpBi97/","link":"","permalink":"https://leopol1d.github.io/2023/08/30/lcpBi97/","excerpt":"","text":"分割数组中数字的数位 方法一：双端队列 123456789101112131415class Solution &#123; public int[] separateDigits(int[] nums) &#123; Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;(); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int x : nums) &#123; while (x != 0) &#123; deque.offerFirst(x % 10); x /= 10; &#125; while (!deque.isEmpty()) list.add(deque.pollFirst()); &#125; return list.stream().mapToInt(i-&gt;i).toArray(); &#125;&#125; 从一个范围内选择最多整数 I 方法一：HashSet 1234567891011121314151617class Solution &#123; public int maxCount(int[] banned, int n, int maxSum) &#123; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int x : banned) set.add(x); int sum = 0, res = 0; for (int i = 1; i &lt;= n; ++i) &#123; if (set.contains(i)) continue; if (sum + i &lt;= maxSum) &#123; sum += i; ++res; &#125; &#125; return res; &#125;&#125; 两个线段获得的最多奖品 方法一：同向双指针 12345678910111213class Solution &#123; public int maximizeWin(int[] pos, int k) &#123; int n = pos.length, res = 0, l = 0; int[] pre = new int[n + 1]; for (int i = 0; i &lt; n; ++i) &#123; while (pos[i] - pos[l] &gt; k) ++l; res = Math.max(res, pre[l] + i - l + 1); pre[i + 1] = Math.max(pre[i], i - l + 1); &#125; return res; &#125;&#125; 二进制矩阵中翻转最多一次使路径不连通 方法一：两次DFS 12345678910111213141516171819202122232425262728class Solution &#123; public boolean isPossibleToCutPath(int[][] grid) &#123; m = grid.length; n = grid[0].length; this.grid = grid; return !dfs(0, 0) || !dfs(0, 0); &#125; private boolean dfs(int i, int j) &#123; if (i == m - 1 &amp;&amp; j == n - 1) return true; grid[i][j] = 0; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col) &amp;&amp; grid[row][col] == 1 &amp;&amp; dfs(row, col)) return true; &#125; return false; &#125; int m, n; int[][] dirs = new int[][]&#123;&#123;1, 0&#125;, &#123;0, 1&#125;&#125;, grid; private boolean isValid(int i, int j) &#123; return i &lt; m &amp;&amp; j &lt; n; &#125;&#125;","categories":[{"name":"Contest","slug":"Contest","permalink":"https://leopol1d.github.io/categories/Contest/"},{"name":"LCP","slug":"Contest/LCP","permalink":"https://leopol1d.github.io/categories/Contest/LCP/"}],"tags":[{"name":"力扣杯","slug":"力扣杯","permalink":"https://leopol1d.github.io/tags/%E5%8A%9B%E6%89%A3%E6%9D%AF/"}]},{"title":"lcp331","slug":"lcp331","date":"2023-08-29T01:01:05.000Z","updated":"2023-08-31T08:20:22.433Z","comments":true,"path":"2023/08/29/lcp331/","link":"","permalink":"https://leopol1d.github.io/2023/08/29/lcp331/","excerpt":"","text":"从数量最多的堆取走礼物 方法一：大根堆 12345678910111213141516class Solution &#123; public long pickGifts(int[] gifts, int k) &#123; int n = gifts.length; long res = 0; PriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;(((o1, o2) -&gt; o2 - o1)); for (int x : gifts) queue.add(x); while (k-- &gt; 0) &#123; int x = queue.poll(), sqrt = (int) Math.sqrt(x); queue.add(sqrt); &#125; for (int x : queue) res += x; return res; &#125;&#125; 统计范围内的元音字符串数 方法一：前缀和 + 预处理 123456789101112131415161718192021222324252627class Solution &#123; public int[] vowelStrings(String[] words, int[][] queries) &#123; int m = queries.length, n = words.length; boolean[] check = new boolean[n]; Set&lt;Character&gt; set = new HashSet&lt;&gt;(); set.add(&#x27;a&#x27;); set.add(&#x27;e&#x27;); set.add(&#x27;i&#x27;); set.add(&#x27;o&#x27;); set.add(&#x27;u&#x27;); int index = 0; for (String word : words) &#123; check[index] = (set.contains(word.charAt(0)) &amp;&amp; set.contains(word.charAt(word.length() - 1))) ? true : false; ++index; &#125; int[] preSum = new int[n + 1]; for (int i = 0; i &lt; n; ++i) preSum[i + 1] = preSum[i] + (check[i] ? 1 : 0); int[] res = new int[m]; index = 0; for (int[] query : queries) &#123; res[index] = preSum[query[1] + 1] - preSum[query[0]]; ++index; &#125; return res; &#125;&#125; 打家劫舍 IV 方法一：二分 + 记忆化搜索 枚举nums中的数字limit作为小偷的窃取能力，换句话说，小偷只能偷价值小于等于limit的房屋，如果在这个limit下，能偷大于等于k个房屋，limit可以尝试更小的数；否则limit需要尝试更大的数 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public int minCapability(int[] nums, int k) &#123; this.nums = nums; n = nums.length; int[] temp = nums.clone(); Arrays.sort(temp); int l = 0, r = n - 1; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if (check(mid, temp, k)) r = mid - 1; else l = mid + 1; &#125; return temp[l]; &#125; private boolean check(int mid, int[] temp, int k) &#123; dp = new int[n]; Arrays.fill(dp, -1); int limit = temp[mid]; return dfs(0, limit) &gt;= k ? true : false; &#125; private int dfs(int index, int limit) &#123; if (index == n) return 0; if (dp[index] != -1) return dp[index]; int pass = dfs(index + 1, limit), rob = 0; if (nums[index] &lt;= limit) rob = dfs(index + 2, limit) + 1; return dp[index] = Math.max(pass, rob); &#125; int[] nums, dp; int n;&#125; 方法二：记忆化搜索转DP 123456789101112131415161718192021222324252627282930313233class Solution &#123; public int minCapability(int[] nums, int k) &#123; this.nums = nums; n = nums.length; int[] temp = nums.clone(); Arrays.sort(temp); int l = 0, r = n - 1; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if (check(mid, temp, k)) r = mid - 1; else l = mid + 1; &#125; return temp[l]; &#125; private boolean check(int mid, int[] temp, int k) &#123; int limit = temp[mid]; // dp[i]：从房屋0~i，做多能偷的房屋数量 dp = new int[n + 2]; for (int i = 2; i &lt; n + 2; ++i) &#123; dp[i] = dp[i - 1]; if (nums[i - 2] &lt;= limit) dp[i] = Math.max(dp[i], dp[i - 2] + 1); &#125; return dp[n + 1] &gt;= k; &#125; int[] nums, dp; int n;&#125; 方法三：滚动数组 123456789101112131415161718192021222324252627282930313233class Solution &#123; public int minCapability(int[] nums, int k) &#123; this.nums = nums; n = nums.length; int[] temp = nums.clone(); Arrays.sort(temp); int l = 0, r = n - 1; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if (check(mid, temp, k)) r = mid - 1; else l = mid + 1; &#125; return temp[l]; &#125; private boolean check(int mid, int[] temp, int k) &#123; int limit = temp[mid]; // dp[i]：从房屋0~i，做多能偷的房屋数量 dp = new int[3]; for (int i = 2; i &lt; n + 2; ++i) &#123; dp[i % 3] = dp[(i - 1) % 3]; if (nums[i - 2] &lt;= limit) dp[i % 3] = Math.max(dp[i % 3], dp[(i - 2) % 3] + 1); &#125; return dp[(n + 1) % 3] &gt;= k; &#125; int[] nums, dp; int n;&#125;","categories":[{"name":"Contest","slug":"Contest","permalink":"https://leopol1d.github.io/categories/Contest/"},{"name":"LCP","slug":"Contest/LCP","permalink":"https://leopol1d.github.io/categories/Contest/LCP/"}],"tags":[{"name":"力扣杯","slug":"力扣杯","permalink":"https://leopol1d.github.io/tags/%E5%8A%9B%E6%89%A3%E6%9D%AF/"}]},{"title":"lcp332","slug":"lcp332","date":"2023-08-28T08:30:16.000Z","updated":"2023-08-29T01:01:37.021Z","comments":true,"path":"2023/08/28/lcp332/","link":"","permalink":"https://leopol1d.github.io/2023/08/28/lcp332/","excerpt":"","text":"找出数组的串联值 方法一：模拟 123456789101112class Solution &#123; public long findTheArrayConcVal(int[] nums) &#123; int n = nums.length; long res = 0; for (int i = 0; i &lt; n / 2; ++i) &#123; String s = String.valueOf(nums[i]) + String.valueOf(nums[n - i - 1]); res += Long.parseLong(s); &#125; res += n % 2 == 1 ? Long.parseLong(String.valueOf(nums[n / 2])) : 0; return res; &#125;&#125; 统计公平数对的数目 方法一：二分查找 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public long countFairPairs(int[] nums, int lower, int upper) &#123; long res = 0; int n = nums.length; Arrays.sort(nums); for (int i = 0; i &lt; n; ++i) &#123; int ceiling = ceiling(nums, lower - nums[i], i + 1);// 大于等于lower - nums[i]的最小值 int floor = floor(nums, upper - nums[i], i + 1); // 小于等于upper - nums[i]的最大值 res += floor - ceiling + 1; &#125; return res; &#125; private int floor(int[] nums, int x, int i) &#123; int l = i, r = nums.length - 1; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if (nums[mid] &lt;= x) l = mid + 1; else r = mid - 1; &#125; return r; &#125; private int ceiling(int[] nums, int x, int i) &#123; int l = i, r = nums.length - 1; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if (nums[mid] &gt;= x) r = mid - 1; else l = mid + 1; &#125; return l; &#125;&#125; 子字符串异或查询 方法一：位运算预处理 s 中的所有数字 当x不存在map中或者当前子串长度小于之前存的子串长度，更新map 123456789101112131415161718192021class Solution &#123; public int[][] substringXorQueries(String s, int[][] queries) &#123; int n = s.length(), m = queries.length; Map&lt;Integer, int[]&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; n; ++i) &#123; int x = 0; for (int j = i; j &lt; Math.min(i + 30, n); ++j) &#123; x = x &lt;&lt; 1 | (s.charAt(j) - &#x27;0&#x27;); if (!map.containsKey(x) || map.get(x)[1] - map.get(x)[0] &gt; j - i) map.put(x, new int[]&#123;i, j&#125;); &#125; &#125; int[][] res = new int[m][2]; int[] NOTFOUND = new int[]&#123;-1, -1&#125;; for (int i = 0; i &lt; m; ++i) &#123; int val = queries[i][0] ^ queries[i][1]; res[i] = map.getOrDefault(val, NOTFOUND); &#125; return res; &#125;&#125;","categories":[{"name":"Contest","slug":"Contest","permalink":"https://leopol1d.github.io/categories/Contest/"},{"name":"LCP","slug":"Contest/LCP","permalink":"https://leopol1d.github.io/categories/Contest/LCP/"}],"tags":[{"name":"力扣杯","slug":"力扣杯","permalink":"https://leopol1d.github.io/tags/%E5%8A%9B%E6%89%A3%E6%9D%AF/"}]},{"title":"lcp360","slug":"lcp360","date":"2023-08-27T02:27:09.000Z","updated":"2023-08-28T08:27:07.947Z","comments":true,"path":"2023/08/27/lcp360/","link":"","permalink":"https://leopol1d.github.io/2023/08/27/lcp360/","excerpt":"","text":"方法一：暴力 1234567891011121314class Solution &#123; public int furthestDistanceFromOrigin(String moves) &#123; int n = moves.length(); int cntL = 0, cntR = 0; for (int i = 0; i &lt; n; ++i) &#123; char ch = moves.charAt(i); if (ch == &#x27;L&#x27;) ++cntL; else if (ch == &#x27;R&#x27;) ++cntR; &#125; return Math.abs(cntL - cntR) + n - (cntL + cntR); &#125;&#125; 方法一：HashSet 1234567891011121314151617class Solution &#123; public long minimumPossibleSum(int n, int target) &#123; long res = 0; HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;(); int cnt = 0, i = 1; while (cnt &lt; n) &#123; if (set.contains(target - i)) &#123; ++i; continue; &#125; set.add(i); res += i++; cnt++; &#125; return res; &#125;&#125;","categories":[{"name":"Contest","slug":"Contest","permalink":"https://leopol1d.github.io/categories/Contest/"},{"name":"LCP","slug":"Contest/LCP","permalink":"https://leopol1d.github.io/categories/Contest/LCP/"}],"tags":[{"name":"力扣杯","slug":"力扣杯","permalink":"https://leopol1d.github.io/tags/%E5%8A%9B%E6%89%A3%E6%9D%AF/"}]},{"title":"lcp333","slug":"lcp333","date":"2023-08-25T01:12:12.000Z","updated":"2023-09-10T14:24:46.096Z","comments":true,"path":"2023/08/25/lcp333/","link":"","permalink":"https://leopol1d.github.io/2023/08/25/lcp333/","excerpt":"","text":"合并两个二维数组 - 求和法 方法二：归并排序 注意边界条件是i == m, j == n 123456789101112131415161718192021222324252627class Solution &#123; public int[][] mergeArrays(int[][] nums1, int[][] nums2) &#123; List&lt;int[]&gt; list = new ArrayList&lt;&gt;(); int i = 0, j = 0, m = nums1.length, n = nums2.length; while (true) &#123; if (i == m) &#123; while (j &lt; n) list.add(nums2[j++]); break; &#125; if (j == n) &#123; while (i &lt; m) list.add(nums1[i++]); break; &#125; if (nums1[i][0] &lt; nums2[j][0]) list.add(nums1[i++]); else if (nums1[i][0] &gt; nums2[j][0]) list.add(nums2[j++]); else &#123; nums1[i][1] += nums2[j++][1]; list.add(nums1[i++]); &#125; &#125; return list.toArray(new int[list.size()][]); &#125;&#125; 方法一：TreeMap 12345678910111213141516class Solution &#123; public int[][] mergeArrays(int[][] nums1, int[][] nums2) &#123; TreeMap&lt;Integer, Integer&gt; map = new TreeMap&lt;&gt;(); for (int[] arr : nums1) map.put(arr[0], map.getOrDefault(arr[0], 0) + arr[1]); for (int[] arr : nums2) map.put(arr[0], map.getOrDefault(arr[0], 0) + arr[1]); int[][] res = new int[map.size()][2]; int index = 0; for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123; res[index][0] = entry.getKey(); res[index++][1] = entry.getValue(); &#125; return res; &#125;&#125; 将整数减少到零需要的最少操作数 方法二：记忆化搜索 考虑将每个lowerbit +1或者-1操作，取最小值 123456789101112131415class Solution &#123; public int minOperations(int num) &#123; dp = new int[Integer.toBinaryString(num).length()]; return dfs(num); &#125; private int dfs(int num) &#123; if (Integer.bitCount(num) == 0) return 0; int lowerbit = num &amp; -num; return Math.min(dfs(num + lowerbit), dfs(num - lowerbit)) + 1; &#125; int[] dp;&#125; base case 可以换成以下形式，如果num &amp; (num - 1)) == 0,那么num是2的幂次，等价于Integer.bitCount(num) == 1 12if ((num &amp; (num - 1)) == 0) return 1; 方法一：贪心 从前往后遍历(遍历顺序无所谓)，将连续的1分段加入treemap中， 如果一段后一段第一个元素与前一段最后一个元素的下标差为2（前一个1与后一个1中间只隔了1个0），先++res 如果前一段只有一个元素，不与下一段合并 否则，与下一段合并，把flag置为true 如果一段后一段第一个元素与前一段最后一个元素的下标差&gt;2 如果第一段只有一个元素，并且前一段不和当前第一段合并，那么++res 否则，上一段是需要和这一段合并的，res+=2（将最低位+1，比如111 -&gt; 1000，再将这个1减去，两次操作），并将flag还原为false 最开始 s = s + “000”;是为了最后遍历的时候，不用再考虑最后一段 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123; public int minOperations(int num) &#123; if (num == 1) return 1; String s = Integer.toBinaryString(num); s = s + &quot;000&quot;; int res = 0, n = s.length(); TreeMap&lt;Integer, Integer&gt; map = new TreeMap&lt;&gt;(); int preIndex = 0; for (int i = 0; i &lt; n - 1; ++i) &#123; char ch1 = s.charAt(i), ch2 = s.charAt(i + 1); if (ch1 == &#x27;1&#x27; &amp;&amp; preIndex == i) map.put(i, i); if (ch1 == &#x27;1&#x27; &amp;&amp; ch2 == &#x27;1&#x27;) &#123; map.put(preIndex, i + 1); &#125; else if (ch1 == &#x27;0&#x27;) &#123; preIndex = i + 1; &#125; &#125; int[][] arr = new int[map.size() + 1][2]; int index = 0; for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123; arr[index][0] = entry.getKey(); arr[index++][1] = entry.getValue(); &#125; int i; boolean flag = false; for (i = 0; i &lt; arr.length - 1; ++i) &#123; int[] a = arr[i], b = arr[i + 1]; int len1 = a[1] - a[0]; if (b[0] - a[1] == 2) &#123; ++res; if (len1 &gt; 0) flag = true; &#125; else &#123; if (len1 == 0 &amp;&amp; !flag) ++res; else &#123; res += 2; flag = false; &#125; &#125; &#125; return res; &#125;&#125; 无平方子集计数 找出对应 LCP 矩阵的字符串 方法一： 1","categories":[{"name":"Contest","slug":"Contest","permalink":"https://leopol1d.github.io/categories/Contest/"},{"name":"LCP","slug":"Contest/LCP","permalink":"https://leopol1d.github.io/categories/Contest/LCP/"}],"tags":[{"name":"力扣杯","slug":"力扣杯","permalink":"https://leopol1d.github.io/tags/%E5%8A%9B%E6%89%A3%E6%9D%AF/"}]},{"title":"lcpBi99","slug":"lcpBi99","date":"2023-08-23T07:19:50.000Z","updated":"2023-08-23T09:18:13.880Z","comments":true,"path":"2023/08/23/lcpBi99/","link":"","permalink":"https://leopol1d.github.io/2023/08/23/lcpBi99/","excerpt":"","text":"最小和分割 方法一：HashMap 12345678910111213141516171819202122class Solution &#123; public int splitNum(int num) &#123; String s = String.valueOf(num); int n = s.length(); int[] cnt = new int[10]; for (int i = 0; i &lt; s.length(); ++i) cnt[s.charAt(i) - &#x27;0&#x27;]++; StringBuilder sb1 = new StringBuilder(), sb2 = new StringBuilder(); boolean flag = false; for (int i = 0; i &lt; 10; ++i) &#123; while (cnt[i]-- &gt; 0) &#123; if (flag) sb2.append(i); else sb1.append(i); flag = !flag; &#125; &#125; System.out.println(); return Integer.parseInt(sb1.toString()) + Integer.parseInt(sb2.toString()); &#125;&#125; 统计染色格子数 方法一：等差数列 12345678910111213141516class Solution &#123; static long[] sum = new long[100002]; static &#123; sum[1] = 1; int diff = 4; for (int i = 2; i &lt; sum.length; ++i) &#123; sum[i] = sum[i - 1] + diff; diff += 4; &#125; &#125; public long coloredCells(int n) &#123; return sum[n]; &#125;&#125; 统计将重叠区间合并成组的方案数 方法一：贪心 + 快速幂 1234567891011121314class Solution &#123; static int MOD = (int) 1e9 + 7; public int countWays(int[][] ranges) &#123; Arrays.sort(ranges, (o1,o2)-&gt;o1[0] - o2[0]); int res = 2, r = ranges[0][1]; for (int[] range : ranges) &#123; if (range[0] &gt; r) res = res * 2 % MOD; r = Math.max(r, range[1]); &#125; return res; &#125;&#125; 统计可能的树根数目 方法一： 1","categories":[{"name":"Contest","slug":"Contest","permalink":"https://leopol1d.github.io/categories/Contest/"},{"name":"LCP","slug":"Contest/LCP","permalink":"https://leopol1d.github.io/categories/Contest/LCP/"}],"tags":[{"name":"力扣杯","slug":"力扣杯","permalink":"https://leopol1d.github.io/tags/%E5%8A%9B%E6%89%A3%E6%9D%AF/"}]},{"title":"lcp359","slug":"lcp359","date":"2023-08-20T02:27:39.000Z","updated":"2023-08-21T15:17:40.135Z","comments":true,"path":"2023/08/20/lcp359/","link":"","permalink":"https://leopol1d.github.io/2023/08/20/lcp359/","excerpt":"","text":"判别首字母缩略词 方法一：暴力 12345678class Solution &#123; public boolean isAcronym(List&lt;String&gt; words, String s) &#123; StringBuilder sb = new StringBuilder(); for (String word : words) sb.append(word.charAt(0)); return s.equals(sb.toString()); &#125;&#125; k-avoiding 数组的最小总和 方法一：HashSet 123456789101112131415class Solution &#123; public int minimumSum(int n, int k) &#123; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); int i = 1, sum = 0; while (n &gt; 0) &#123; if (!set.contains(k - i)) &#123; set.add(i); sum += i; --n; &#125; ++i; &#125; return sum; &#125;&#125; 销售利润最大化 方法一：线性DP 相似题目 2008. 出租车的最大盈利（和本题几乎一样） 1235. 规划兼职工作（数据范围更大的情况，我的题解） 1751. 最多可以参加的会议数目 II（区间个数限制） 2054. 两个最好的不重叠活动 12345678910111213141516171819class Solution &#123; public int maximizeTheProfit(int n, List&lt;List&lt;Integer&gt;&gt; offers) &#123; List&lt;int[]&gt;[] list = new List[n]; Arrays.setAll(list, e -&gt; new ArrayList&lt;&gt;()); for (List&lt;Integer&gt; offer : offers) &#123; int start = offer.get(0), end = offer.get(1), val = offer.get(2); list[end].add(new int[]&#123;start, val&#125;); &#125; int[] dp = new int[n + 1]; for (int i = 1; i &lt;= n; ++i) &#123; dp[i] = dp[i - 1]; for (int[] arr : list[i - 1]) &#123; int start = arr[0], val = arr[1]; dp[i] = Math.max(dp[i], dp[start] + val); &#125; &#125; return dp[n]; &#125;&#125; 方法二：二分 + DP 12345678910111213141516171819202122232425class Solution &#123; public int maximizeTheProfit(int n, List&lt;List&lt;Integer&gt;&gt; offers) &#123; Collections.sort(offers, (o1, o2) -&gt; o1.get(1) - o2.get(1)); // 处理标号为0~i的房子能获得的最大利润 int[] dp = new int[offers.size() + 1]; for (int i = 0; i &lt; offers.size(); ++i) &#123; dp[i + 1] = dp[i]; int j = bisearch(offers, i, offers.get(i).get(0)); dp[i + 1] = Math.max(dp[i + 1], (j &gt;= -1 ? dp[j + 1] : 0) + offers.get(i).get(2)); &#125; return dp[offers.size()]; &#125; private int bisearch(List&lt;List&lt;Integer&gt;&gt; offers, int r, int start) &#123; int l = 0; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if (offers.get(mid).get(1) &lt; start) l = mid + 1; else r = mid - 1; &#125; return r; &#125;&#125; 找出最长等值子数组 方法一：滑动窗口 同向双指针 将每个值的下标存到List中，例如对于nums = [1,3,2,3,1,3], k = 3 list[1]: [0, 4] list[2] : [4] list[3]: [1, 3, 5] 枚举每个list，即把元素替换成1或2或3，例如枚举list[3]: [1, 3, 5]，l = 0, r = 1时，nums数组有list.get® - list.get(0) + 1 = 3 - 1 + 1 = 3个数：[3，2，3]，这个子数组中有r - l + 1 = 1 - 0 + 1 = 2个3，所以需要删除3 - 2 = 1个数 当需要删除的数大于k时，将左端点右移，直到满足需要删除的元素小于等于k 12345678910111213141516171819class Solution &#123; public int longestEqualSubarray(List&lt;Integer&gt; nums, int k) &#123; int n = nums.size(); List&lt;Integer&gt;[] pos = new List[n + 1]; Arrays.setAll(pos, e -&gt; new ArrayList&lt;&gt;()); for (int i = 0; i &lt; n; ++i) pos[nums.get(i)].add(i); int res = 0; for (List&lt;Integer&gt; list : pos) &#123; int l = 0; for (int r = 0; r &lt; list.size(); ++r) &#123; while (list.get(r) - list.get(l) + 1 - (r - l + 1) &gt; k) ++l; res = Math.max(res, r - l + 1); &#125; &#125; return res; &#125;&#125;","categories":[{"name":"Contest","slug":"Contest","permalink":"https://leopol1d.github.io/categories/Contest/"},{"name":"LCP","slug":"Contest/LCP","permalink":"https://leopol1d.github.io/categories/Contest/LCP/"}],"tags":[{"name":"力扣杯","slug":"力扣杯","permalink":"https://leopol1d.github.io/tags/%E5%8A%9B%E6%89%A3%E6%9D%AF/"}]},{"title":"lcpBi111","slug":"lcpBi111","date":"2023-08-19T14:29:53.000Z","updated":"2023-09-02T14:22:50.954Z","comments":true,"path":"2023/08/19/lcpBi111/","link":"","permalink":"https://leopol1d.github.io/2023/08/19/lcpBi111/","excerpt":"","text":"统计和小于目标的下标对数目 方法一：暴力 123456789101112class Solution &#123; public int countPairs(List&lt;Integer&gt; nums, int target) &#123; int res = 0, n = nums.size(); for (int i = 0; i &lt; n; ++i) &#123; for (int j = i + 1; j &lt; n; ++j) &#123; if (nums.get(i) + nums.get(j) &lt; target) ++res; &#125; &#125; return res; &#125;&#125; 循环增长使字符串子序列等于另一个字符串 方法一：模拟 1234567891011121314151617181920212223class Solution &#123; public boolean canMakeSubsequence(String str1, String str2) &#123; int m = str1.length(), n = str2.length(); if (m &lt; n) return false; Map&lt;Character, Character&gt; next = new HashMap&lt;&gt;(); for (char i = &#x27;a&#x27;; i &lt; &#x27;z&#x27;; ++i) next.put(i, (char) (i + 1)); next.put(&#x27;z&#x27;, &#x27;a&#x27;); int l = 0, r = 0; while (l &lt; m &amp;&amp; r &lt; n) &#123; char ch1 = str1.charAt(l), ch2 = str2.charAt(r); if (ch1 == ch2 || next.get(ch1) == ch2) &#123; ++l; ++r; &#125; else &#123; ++l; &#125; &#125; return r == n; &#125;&#125; 将三个组排序 方法一：n - 最长非递减子序列 https://leetcode.cn/submissions/detail/460143737/ 算出最长非递减子序列，修改剩余的元素 12345678910111213141516class Solution &#123; public int minimumOperations(List&lt;Integer&gt; nums) &#123; int n = nums.size(), res = 1; int[] dp = new int[n]; Arrays.fill(dp, 1); for (int i = 1; i &lt; n; ++i) &#123; for (int j = 0; j &lt; i; ++j) &#123; if (nums.get(j) &lt;= nums.get(i)) &#123; dp[i] = Math.max(dp[i], dp[j] + 1); res = Math.max(res, dp[i]); &#125; &#125; &#125; return n - res; &#125;&#125; 方法二：状态机DP 12345678910111213141516171819class Solution &#123; public int minimumOperations(List&lt;Integer&gt; nums) &#123; int n = nums.size(); int[][] dp = new int[n + 1][4]; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 1; j &lt;= 3; ++j) &#123; dp[i + 1][j] = Integer.MAX_VALUE; for (int k = 1; k &lt;= j; ++k) &#123; dp[i + 1][j] = Math.min(dp[i + 1][j], dp[i][k]); &#125; dp[i + 1][j] += (nums.get(i) == j ? 0 : 1); &#125; &#125; int min = dp[n][1]; for (int i = 2; i &lt;= 3; ++i) min = Math.min(min, dp[n][i]); return min; &#125;&#125;","categories":[{"name":"Contest","slug":"Contest","permalink":"https://leopol1d.github.io/categories/Contest/"},{"name":"LCP","slug":"Contest/LCP","permalink":"https://leopol1d.github.io/categories/Contest/LCP/"}],"tags":[{"name":"力扣杯","slug":"力扣杯","permalink":"https://leopol1d.github.io/tags/%E5%8A%9B%E6%89%A3%E6%9D%AF/"}]},{"title":"lcp335","slug":"lcp335","date":"2023-08-19T08:25:49.000Z","updated":"2023-08-19T09:36:05.982Z","comments":true,"path":"2023/08/19/lcp335/","link":"","permalink":"https://leopol1d.github.io/2023/08/19/lcp335/","excerpt":"","text":"递枕头 方法一：模拟 123456789101112131415161718class Solution &#123; public int passThePillow(int n, int time) &#123; boolean reverse = false; int i = 1; while (time-- &gt; 0) &#123; if (i == n) reverse = true; if (i == 1) reverse = false; if (reverse) &#123; i--; &#125; else &#123; i++; &#125; &#125; return i; &#125;&#125; 二叉树中的第 K 大层和 方法一：BFS 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public long kthLargestLevelSum(TreeNode root, int k) &#123; List&lt;Long&gt; res = new ArrayList&lt;&gt;(); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while (!queue.isEmpty()) &#123; int size = queue.size(); long sum = 0; for (int i = 0; i &lt; size; ++i) &#123; TreeNode node = queue.poll(); sum += node.val; if (node.left != null) queue.offer(node.left); if (node.right != null) queue.offer(node.right); &#125; res.add(sum); &#125; if (k &gt; res.size()) return -1; Collections.sort(res); return res.get(res.size() - k); &#125;&#125; 分割数组使乘积互质 方法一： 1 获得分数的方法数 方法一：记忆化搜索(分组背包) 1234567891011121314151617181920212223242526class Solution &#123; static final int MOD = (int) 1e9 + 7; int n ; int[][] types, dp; Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); public int waysToReachTarget(int target, int[][] types) &#123; this.types = types; n = types.length; dp = new int[n][1002]; for (int[] arr : dp) Arrays.fill(arr, -1); return dfs(0, target); &#125; private int dfs(int index, int target) &#123; if (index == n) return target == 0 ? 1 : 0; if (dp[index][target] != -1) return dp[index][target]; int res = 0, count = types[index][0], marks = types[index][1]; for (int i = 0; i &lt;= Math.min(target / marks, count); ++i) res = (res + (dfs(index + 1, target - i * marks) % MOD)) % MOD; return dp[index][target] = res; &#125;&#125;","categories":[{"name":"Contest","slug":"Contest","permalink":"https://leopol1d.github.io/categories/Contest/"},{"name":"LCP","slug":"Contest/LCP","permalink":"https://leopol1d.github.io/categories/Contest/LCP/"}],"tags":[{"name":"力扣杯","slug":"力扣杯","permalink":"https://leopol1d.github.io/tags/%E5%8A%9B%E6%89%A3%E6%9D%AF/"}]},{"title":"lcp336","slug":"lcp336","date":"2023-08-19T06:52:54.000Z","updated":"2023-08-19T07:49:57.976Z","comments":true,"path":"2023/08/19/lcp336/","link":"","permalink":"https://leopol1d.github.io/2023/08/19/lcp336/","excerpt":"","text":"统计范围内的元音字符串数 方法一：HashSet 1234567891011121314151617class Solution &#123; public int vowelStrings(String[] words, int left, int right) &#123; int res = 0; Set&lt;Character&gt; set = new HashSet&lt;&gt;(); set.add(&#x27;a&#x27;); set.add(&#x27;e&#x27;); set.add(&#x27;i&#x27;); set.add(&#x27;o&#x27;); set.add(&#x27;u&#x27;); for (int i = left; i &lt;= right; ++i) &#123; String str = words[i]; if (set.contains(str.charAt(0)) &amp;&amp; set.contains(str.charAt(str.length() - 1))) ++res; &#125; return res; &#125;&#125; 重排数组以得到最大前缀分数 方法一：贪心 123456789101112131415class Solution &#123; public int maxScore(int[] nums) &#123; int n = nums.length, res = 0; Arrays.sort(nums); long[] preSum = new long[n + 1]; for (int i = n - 1; i &gt;= 0; --i) &#123; preSum[i] = preSum[i + 1] + nums[i]; if (preSum[i] &gt; 0) ++res; else break; &#125; return res; &#125;&#125; 统计美丽子数组数目 方法一：求异或和等于0 的子数组个数 123456789101112131415class Solution &#123; public long beautifulSubarrays(int[] nums) &#123; int n = nums.length; long res = 0; int[] s = new int[n + 1]; for (int i = 0; i &lt; n; ++i) s[i + 1] = s[i] ^ nums[i]; Map&lt;Integer, Integer&gt; cnt = new HashMap&lt;&gt;(); for (int x : s) &#123; res += cnt.getOrDefault(x, 0); cnt.put(x, cnt.getOrDefault(x, 0) + 1); &#125; return res; &#125;&#125; 完成所有任务的最少时间 方法一： 1","categories":[{"name":"Contest","slug":"Contest","permalink":"https://leopol1d.github.io/categories/Contest/"},{"name":"LCP","slug":"Contest/LCP","permalink":"https://leopol1d.github.io/categories/Contest/LCP/"}],"tags":[{"name":"力扣杯","slug":"力扣杯","permalink":"https://leopol1d.github.io/tags/%E5%8A%9B%E6%89%A3%E6%9D%AF/"}]},{"title":"lcp337","slug":"lcp337","date":"2023-08-18T11:50:56.000Z","updated":"2023-08-18T13:52:02.432Z","comments":true,"path":"2023/08/18/lcp337/","link":"","permalink":"https://leopol1d.github.io/2023/08/18/lcp337/","excerpt":"","text":"奇偶位数 方法一：暴力 12345678910111213141516171819class Solution &#123; public int[] evenOddBit(int n) &#123; int odd = 0, even = 0; String str = Integer.toBinaryString(n); StringBuilder sb = new StringBuilder(str); sb.reverse(); str = sb.toString(); for (int i = 0; i &lt; str.length(); ++i) &#123; char ch = str.charAt(i); if (ch == &#x27;1&#x27;) &#123; if (i % 2 == 0) even++; else odd++; &#125; &#125; return new int[]&#123;even, odd&#125;; &#125;&#125; 检查骑士巡视方案 方法一：dfs 123456789101112131415161718192021222324252627class Solution &#123; public boolean checkValidGrid(int[][] grid) &#123; if (grid[0][0] != 0) return false; this.grid = grid; n = grid.length; return dfs(0, 0, 0); &#125; private boolean dfs(int i, int j, int step) &#123; if (step == n * n - 1) return grid[i][j] == n * n - 1; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col) &amp;&amp; grid[row][col] == step + 1 &amp;&amp; dfs(row, col, step + 1)) return true; &#125; return false; &#125; private boolean isValid(int row, int col) &#123; return row &gt;= 0 &amp;&amp; col &gt;= 0 &amp;&amp; row &lt; n &amp;&amp; col &lt; n; &#125; int[][] grid, dirs = new int[][]&#123;&#123;-2, -1&#125;, &#123;-1, -2&#125;, &#123;1, -2&#125;, &#123;2, -1&#125;, &#123;-2, 1&#125;, &#123;-1, 2&#125;, &#123;2, 1&#125;, &#123;1, 2&#125;&#125;; int n;&#125; 美丽子集的数目 方法一：backtrack 不能用containsKey判断，数量为0就好！ 1234567891011121314151617181920212223class Solution &#123; int ans = -1; Map&lt;Integer, Integer&gt; cnt = new HashMap&lt;&gt;(); public int beautifulSubsets(int[] nums, int k) &#123; dfs(nums, k, 0); return ans; &#125; private void dfs(int[] nums, int k, int i) &#123; if (i == nums.length) &#123; ans++; return; &#125; dfs(nums, k, i + 1); int x = nums[i]; if (cnt.getOrDefault(x - k, 0) == 0 &amp;&amp; cnt.getOrDefault(x + k, 0) == 0) &#123; cnt.put(x, cnt.getOrDefault(x, 0) + 1); dfs(nums, k, i + 1); cnt.put(x, cnt.get(x) - 1); &#125; &#125;&#125; 执行操作后的最大 MEX 方法一： 1","categories":[{"name":"Contest","slug":"Contest","permalink":"https://leopol1d.github.io/categories/Contest/"},{"name":"LCP","slug":"Contest/LCP","permalink":"https://leopol1d.github.io/categories/Contest/LCP/"}],"tags":[{"name":"力扣杯","slug":"力扣杯","permalink":"https://leopol1d.github.io/tags/%E5%8A%9B%E6%89%A3%E6%9D%AF/"}]},{"title":"lcp334","slug":"lcp334","date":"2023-08-17T13:06:25.000Z","updated":"2023-10-01T14:12:18.876Z","comments":true,"path":"2023/08/17/lcp334/","link":"","permalink":"https://leopol1d.github.io/2023/08/17/lcp334/","excerpt":"","text":"左右元素和的差值 方法一：模拟 12345678910111213class Solution &#123; public int[] leftRightDifference(int[] nums) &#123; int n = nums.length; int[] res = new int[n], leftSum = new int[n], rightSum = new int[n]; for (int i = 1; i &lt; n; ++i) leftSum[i] = leftSum[i - 1] + nums[i - 1]; for (int i = n - 2; i &gt;= 0; --i) rightSum[i] = rightSum[i + 1] + nums[i + 1]; for (int i = 0; i &lt; n; ++i) res[i] = Math.abs(leftSum[i] - rightSum[i]); return res; &#125;&#125; 找出字符串的可整除数组 方法一： 12345678910111213class Solution &#123; public int[] divisibilityArray(String s, int m) &#123; int n = s.length(); int[] res = new int[n]; long pre = 0; for (int i = 0; i &lt; n; ++i) &#123; long cur = pre * 10 + s.charAt(i) - &#x27;0&#x27;; pre = cur % m; res[i] = pre == 0 ? 1 : 0; &#125; return res; &#125;&#125; 求出最多标记下标 方法一：贪心 + TreeMap 123456789101112131415161718192021222324class Solution &#123; public int maxNumOfMarkedIndices(int[] nums) &#123; int res = 0, n = nums.length; Arrays.sort(nums); TreeMap&lt;Integer, Integer&gt; map = new TreeMap&lt;&gt;(); for (int i = (n + 1) / 2; i &lt; n; ++i) &#123; int x = nums[i]; map.put(x, map.getOrDefault(x, 0) + 1); &#125; for (int i = 0; i &lt; n; ++i) &#123; int left = nums[i]; Integer floor = map.ceilingKey(2 * left); if (floor == null) break; else &#123; res += 2; map.put(floor, map.get(floor) - 1); if (map.get(floor) == 0) map.remove(floor); &#125; &#125; return res; &#125;&#125; 在网格图中访问一个格子的最少时间 二刷 dijkstra 无需visited数组 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; public int minimumTime(int[][] grid) &#123; int m = grid.length, n = grid[0].length; if (grid[1][0] &gt; 1 &amp;&amp; grid[0][1] &gt; 1) return -1; int[][] dist = new int[m][n]; for (int[] arr : dist) Arrays.fill(arr, Integer.MAX_VALUE &gt;&gt; 1); dist[0][0] = 0; boolean[][] visited = new boolean[m][n]; PriorityQueue&lt;int[]&gt; q = new PriorityQueue&lt;&gt;((o1, o2) -&gt; o1[2] - o2[2]); q.offer(new int[]&#123;0, 0, 0&#125;); while (true) &#123; int[] node = q.poll(); int i = node[0], j = node[1], d = node[2]; if (i == m - 1 &amp;&amp; j == n - 1) return d; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col, m, n)) &#123; int nd = Math.max(d, grid[row][col]); nd += (nd + row + col) % 2; if (nd &lt; dist[row][col]) &#123; dist[row][col] = nd; q.offer(new int[]&#123;row, col, nd&#125;); &#125; &#125; &#125; &#125; &#125; public boolean isValid(int i, int j, int m, int n) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125; int[][] dirs = new int[][]&#123;&#123;1,0&#125;, &#123;-1,0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;; &#125; 方法一：堆优化的dijkstra dist[i][j]与 i + j 同奇偶 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123; public int minimumTime(int[][] grid) &#123; this.grid = grid; m = grid.length; n = grid[0].length; if (grid[0][1] &gt; 1 &amp;&amp; grid[1][0] &gt; 1) return -1; int[][] dist = new int[m][n]; int inf = Integer.MAX_VALUE &gt;&gt; 1; for (int[] arr : dist) Arrays.fill(arr, inf); dist[0][0] = 0; boolean[][] visited = new boolean[m][n]; PriorityQueue&lt;int[]&gt; queue = new PriorityQueue&lt;&gt;(((o1, o2) -&gt; o1[0] - o2[0])); queue.offer(new int[]&#123;0, 0, 0&#125;); while (!queue.isEmpty()) &#123; int[] arr = queue.poll(); int d = arr[0], i = arr[1], j = arr[2]; if (i == m - 1 &amp;&amp; j == n - 1) return d; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col)) &#123; int nd = Math.max(d + 1, grid[row][col]); nd += (nd - row - col) % 2; if (nd &lt; dist[row][col]) &#123; dist[row][col] = nd; queue.offer(new int[]&#123;nd, row, col&#125;); &#125; &#125; &#125; &#125; return dist[m - 1][n - 1]; &#125; int[][] grid, dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; int m, n; private boolean isValid(int i, int j) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125;&#125; 方法二：二分+ BFS 双数组 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution &#123; public int minimumTime(int[][] grid) &#123; this.grid = grid; m = grid.length; n = grid[0].length; if (grid[0][1] &gt; 1 &amp;&amp; grid[1][0] &gt; 1) return -1; int left = Math.max(m + n - 2, grid[m - 1][n - 1]), right = (int) 1e5 + m + n; while (left &lt;= right) &#123; int mid = (left + right) &gt;&gt; 1; if (check(mid)) right = mid - 1; else left = mid + 1; &#125; return left + (left + m + n) % 2; // 答案要与 m + n - 2同奇偶 &#125; private boolean check(int limit) &#123; boolean[][] visited = new boolean[m][n]; visited[m - 1][n - 1] = true; List&lt;int[]&gt; queue = new ArrayList&lt;&gt;(); int t = limit - 1; queue.add(new int[]&#123;m - 1, n - 1&#125;); while (!queue.isEmpty()) &#123; List&lt;int[]&gt; temp = queue; queue = new ArrayList&lt;&gt;(); for (int[] arr : temp) &#123; int i = arr[0], j = arr[1]; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col) &amp;&amp; !visited[row][col] &amp;&amp; grid[row][col] &lt;= t) &#123; if (row == 0 &amp;&amp; col == 0) return true; visited[row][col] = true; queue.add(new int[]&#123;row, col&#125;); &#125; &#125; &#125; --t; &#125; return false; &#125; int[][] grid, dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; int m, n; private boolean isValid(int i, int j) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125;&#125; Queue q.offer(new int[]{m - 1, n - 1, limit - 1});表示终点在limit时访问过，邻居的grid值要小于limit - 1 从limit - 1开始 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; public int minimumTime(int[][] grid) &#123; int m = grid.length, n = grid[0].length; if (grid[1][0] &gt; 1 &amp;&amp; grid[0][1] &gt; 1) return -1; int l = Math.max(m + n - 2, grid[m - 1][n - 1]), r = (int) 1e5; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if (check(mid, grid, m, n)) r = mid - 1; else l = mid + 1; &#125; return l + (l + m + n - 2) % 2; // 答案需要和重点坐标[m - 1, n - 1]之和同奇偶 &#125; public boolean check(int limit, int[][] grid, int m, int n) &#123; boolean[][] visited = new boolean[m][n]; Queue&lt;int[]&gt; q = new LinkedList&lt;&gt;(); q.offer(new int[]&#123;m - 1, n - 1, limit - 1&#125;); visited[m - 1][n - 1] = true; while (!q.isEmpty()) &#123; int[] node = q.poll(); int i = node[0], j = node[1], t = node[2]; if (i == 0 &amp;&amp; j == 0) return true; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col, m, n) &amp;&amp; !visited[row][col] &amp;&amp; t &gt;= grid[row][col]) &#123; q.offer(new int[]&#123;row, col, t - 1&#125;); visited[row][col] = true; &#125; &#125; &#125; return false; &#125; public boolean isValid(int i, int j, int m, int n) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125; int[][] dirs = new int[][]&#123;&#123;1,0&#125;, &#123;-1,0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;; &#125;","categories":[{"name":"Contest","slug":"Contest","permalink":"https://leopol1d.github.io/categories/Contest/"},{"name":"LCP","slug":"Contest/LCP","permalink":"https://leopol1d.github.io/categories/Contest/LCP/"}],"tags":[{"name":"力扣杯","slug":"力扣杯","permalink":"https://leopol1d.github.io/tags/%E5%8A%9B%E6%89%A3%E6%9D%AF/"}]},{"title":"lcpBi101","slug":"lcpBi101","date":"2023-08-17T01:47:39.000Z","updated":"2023-08-17T07:21:53.276Z","comments":true,"path":"2023/08/17/lcpBi101/","link":"","permalink":"https://leopol1d.github.io/2023/08/17/lcpBi101/","excerpt":"","text":"从两个数字数组里生成最小数字 方法二：位运算 Integer.numberOfTrailingZeros(m)表示m的二进制串中，最低为1后面0的个数 举例 nums1 = [1， 3]， nums2 = [2, 3] mask1 = 1010, mask2 = 1100 m = mask1 &amp; mask2 = 1000 Integer.numberOfTrailingZeros(m) = 3 123456789101112class Solution &#123; public int minNumber(int[] nums1, int[] nums2) &#123; int mask1 = 0, mask2 = 0; for (int x : nums1) mask1 |= 1 &lt;&lt; x; for (int x : nums2) mask2 |= 1 &lt;&lt; x; int m = mask1 &amp; mask2; if (m &gt; 0) return Integer.numberOfTrailingZeros(m); int x = Integer.numberOfTrailingZeros(mask1), y = Integer.numberOfTrailingZeros(mask2); return Math.min(x * 10 + y, x + y * 10); &#125;&#125; 方法一：排序 + HashSet 1234567891011121314class Solution &#123; public int minNumber(int[] nums1, int[] nums2) &#123; Arrays.sort(nums1); Arrays.sort(nums2); int res = nums1[0] &lt; nums2[0] ? nums1[0] * 10 + nums2[0] : nums2[0] * 10 + nums1[0]; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int x : nums1) set.add(x); for (int x : nums2) if (set.contains(x)) return x; return res; &#125;&#125; 找到最大开销的子字符串 方法一：最大子数组和 12345678910111213141516171819202122class Solution &#123; public int maximumCostSubstring(String s, String chars, int[] vals) &#123; int[] map = new int[26]; for (int i = 0; i &lt; 26; ++i) map[i] = i + 1; for (int i = 0; i &lt; chars.length(); ++i) &#123; char ch = chars.charAt(i); int val = vals[i]; map[ch - &#x27;a&#x27;] = val; &#125; int res = 0, sum = 0; for (int i = 0; i &lt; s.length(); ++i) &#123; char ch = s.charAt(i); int val = map[ch - &#x27;a&#x27;]; sum += val; res = Math.max(res, sum); if (sum &lt; 0) sum = 0; &#125; return res; &#125;&#125; 使子数组元素和相等 方法一：【转换】中位数贪心+裴蜀定理（Python/Java/C++/Go） 图中的最短环 不需要Visited数组 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public int findShortestCycle(int n, int[][] edges) &#123; List&lt;Integer&gt;[] g = new List[n]; Arrays.setAll(g, o -&gt; new ArrayList&lt;&gt;()); for (int[] edge : edges) &#123; int from = edge[0], to = edge[1]; g[from].add(to); g[to].add(from); &#125; int res = Integer.MAX_VALUE; for (int i = 0; i &lt; n; ++i) res = Math.min(res, bfs(i, n, g)); return res == Integer.MAX_VALUE ? -1 : res; &#125; public int bfs(int i, int n, List&lt;Integer&gt;[] g) &#123; int res = Integer.MAX_VALUE; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); queue.offer(new int[]&#123;i, -1&#125;); int[] dist = new int[n]; Arrays.fill(dist, -1); dist[i] = 0; while (!queue.isEmpty()) &#123; int[] arr = queue.poll(); int node = arr[0], pre = arr[1]; for (int next : g[node]) &#123; if (dist[next] == -1) &#123; // 没有被访问过 dist[next] = dist[node] + 1; queue.offer(new int[]&#123;next, node&#125;); &#125; else if (next != pre) // 被访问过，且不是父节点 res = Math.min(res, dist[next] + dist[node] + 1); &#125; &#125; return res; &#125;&#125; 方法一：BFS 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123; public int findShortestCycle(int n, int[][] edges) &#123; List&lt;Integer&gt;[] g = new List[n]; Arrays.setAll(g, o -&gt; new ArrayList&lt;&gt;()); for (int[] edge : edges) &#123; int from = edge[0], to = edge[1]; g[from].add(to); g[to].add(from); &#125; int res = Integer.MAX_VALUE; for (int i = 0; i &lt; n; ++i) &#123; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); queue.offer(new int[]&#123;i, -1&#125;); Set&lt;Integer&gt; visited= new HashSet&lt;&gt;(); int[] dist = new int[n]; dist[i] = 0; visited.add(i); while (!queue.isEmpty()) &#123; int size = queue.size(); for (int j = 0; j &lt; size; ++j) &#123; int[] arr = queue.poll(); int node = arr[0], pre = arr[1]; for (int next : g[node]) &#123; if (next == pre) continue; if (visited.contains(next)) &#123; res = Math.min(res, dist[next] + dist[node] + 1); break; &#125; visited.add(next); queue.offer(new int[]&#123;next, node&#125;); dist[next] = dist[node] + 1; &#125; &#125; &#125; &#125; return res == Integer.MAX_VALUE ? -1 : res; &#125;&#125;","categories":[{"name":"Contest","slug":"Contest","permalink":"https://leopol1d.github.io/categories/Contest/"},{"name":"LCP","slug":"Contest/LCP","permalink":"https://leopol1d.github.io/categories/Contest/LCP/"}],"tags":[{"name":"力扣杯","slug":"力扣杯","permalink":"https://leopol1d.github.io/tags/%E5%8A%9B%E6%89%A3%E6%9D%AF/"}]},{"title":"lcp338","slug":"lcp338","date":"2023-08-16T06:18:17.000Z","updated":"2023-09-15T14:41:33.593Z","comments":true,"path":"2023/08/16/lcp338/","link":"","permalink":"https://leopol1d.github.io/2023/08/16/lcp338/","excerpt":"","text":"K 件物品的最大和 方法一：模拟 12345678910class Solution &#123; public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) &#123; if (k &lt;= numOnes) return k; else if (k &gt; numOnes &amp;&amp; k &lt;= numOnes + numZeros) return numOnes; else return numOnes - (k - numOnes - numZeros); &#125;&#125; 质数减法运算 方法一：TreeSet 1234567891011121314151617181920212223242526272829303132class Solution &#123; static public int MAX = 1000; static public TreeSet&lt;Integer&gt; set = new TreeSet&lt;&gt;(); static &#123; boolean[] notPrime = new boolean[MAX + 1]; for (int i = 2; i &lt; MAX; ++i) &#123; if (!notPrime[i]) &#123; set.add(i); if ((long) i * i &lt; MAX) &#123; for (int j = i * i; j &lt; MAX; j+=i) notPrime[j] = true; &#125; &#125; &#125; &#125; public boolean primeSubOperation(int[] nums) &#123; int n = nums.length; for (int i = n - 1; i &gt;= 1; --i) &#123; int pre = nums[i - 1], next = nums[i]; if (pre &gt;= next) &#123; int diff = pre - next; Integer higher = set.higher(diff); if (higher == null || higher &gt;= pre) return false; nums[i - 1] -= higher; &#125; &#125; return true; &#125;&#125; 使数组元素全部相等的最少操作次数 方法一：排序 + 前缀和 + 二分 long long long!!! 12345678910111213141516171819202122232425262728class Solution &#123; public List&lt;Long&gt; minOperations(int[] nums, int[] queries) &#123; Arrays.sort(nums); List&lt;Long&gt; res = new ArrayList&lt;&gt;(); long[] preSum = new long[nums.length + 1]; for (int i = 0; i &lt; nums.length; ++i) preSum[i + 1] = preSum[i] + nums[i]; for (int q : queries) &#123; int index = lower(q, nums); long left = index * (long) q - preSum[index]; long right = preSum[nums.length] - preSum[index] - (long) q * (nums.length - index); res.add(left + right); &#125; return res; &#125; private int lower(int q, int[] nums) &#123; int l = 0, r = nums.length - 1; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if (nums[mid] &gt;= q) r = mid - 1; else l = mid + 1; &#125; return l; &#125;&#125; 方法二：和lcp339那题类似的做法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution &#123; public List&lt;Long&gt; minOperations(int[] nums, int[] queries) &#123; Arrays.sort(nums); List&lt;Long&gt; res = new ArrayList&lt;&gt;(); long s = 0, q1 = queries[0]; long[] preSum = new long[nums.length + 1]; int index = 1; for (int x : nums) &#123; s += Math.abs(x - q1); preSum[index] = preSum[index++ - 1] + x; &#125; res.add(s); for (int j = 1; j &lt; queries.length; ++j) &#123; // 找到 &gt;= q的nums下标 int i = findIndex2(queries[j - 1], nums); int k = findIndex(queries[j], nums); long middleSum = preSum[k] - preSum[i + 1]; int size = k - i - 1; long diff = ((long) queries[j] * size - middleSum) - (middleSum - (long) queries[j - 1] * size); int left = i + 1; int right = nums.length - k; s += (left - right) * ((long) queries[j] - queries[j - 1]) + diff; res.add(s); &#125; return res; &#125; private int findIndex(int q, int[] nums) &#123; int l = 0, r = nums.length - 1; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if (nums[mid] &gt;= q) r = mid - 1; else l = mid + 1; &#125; return l; &#125; private int findIndex2(int q, int[] nums) &#123; int l = 0, r = nums.length - 1; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if (nums[mid] &gt; q) r = mid - 1; else l = mid + 1; &#125; return r; &#125;&#125; 2603. 收集树中金币 方法一：两次拓扑排序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123; public int collectTheCoins(int[] coins, int[][] edges) &#123; int n = edges.length + 1; List&lt;Integer&gt;[] g = new List[n]; Arrays.setAll(g, e -&gt; new ArrayList&lt;&gt;()); int[] degree = new int[n]; for (int[] edge : edges) &#123; int from = edge[0], to = edge[1]; g[from].add(to); g[to].add(from); ++degree[from]; ++degree[to]; &#125; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; n; ++i) if (degree[i] == 1 &amp;&amp; coins[i] == 0) queue.offer(i); while (!queue.isEmpty()) &#123; int node = queue.poll(); for (int next : g[node]) if (--degree[next] == 1 &amp;&amp; coins[next] == 0) queue.offer(next); &#125; for (int i = 0; i &lt; n; ++i) if (degree[i] == 1 &amp;&amp; coins[i] == 1) queue.offer(i); int[] times = new int[n]; int t = 1; while (!queue.isEmpty()) &#123; int size= queue.size(); for (int i = 0; i &lt; size; ++i) &#123; int node = queue.poll(); for (int next : g[node]) &#123; if (--degree[next] == 1) &#123; queue.offer(next); times[next] = t; &#125; &#125; &#125; ++t; &#125; int res = 0; for (int[] edge : edges) if (times[edge[0]] &gt;= 2 &amp;&amp; times[edge[1]] &gt;= 2) res += 2; return res; &#125;&#125;","categories":[{"name":"Contest","slug":"Contest","permalink":"https://leopol1d.github.io/categories/Contest/"},{"name":"LCP","slug":"Contest/LCP","permalink":"https://leopol1d.github.io/categories/Contest/LCP/"}],"tags":[{"name":"力扣杯","slug":"力扣杯","permalink":"https://leopol1d.github.io/tags/%E5%8A%9B%E6%89%A3%E6%9D%AF/"}]},{"title":"lcp339","slug":"lcp339","date":"2023-08-16T01:12:51.000Z","updated":"2023-08-16T05:41:04.854Z","comments":true,"path":"2023/08/16/lcp339/","link":"","permalink":"https://leopol1d.github.io/2023/08/16/lcp339/","excerpt":"","text":"最长平衡子字符串 方法二：一次遍历 12345678910111213141516class Solution &#123; public int findTheLongestBalancedSubstring(String s) &#123; int n = s.length(), pre = 0, cur = 0, res = 0; for (int i = 0; i &lt; n; ++i) &#123; ++cur; char ch = s.charAt(i); if (i == n - 1 || s.charAt(i + 1) != ch) &#123; // 分界点 if (ch == &#x27;1&#x27;) res = Math.max(res, Math.min(pre, cur) * 2); pre = cur; cur = 0; &#125; &#125; return res; &#125;&#125; 方法一：模拟 123456789101112131415161718192021222324252627282930class Solution &#123; public int findTheLongestBalancedSubstring(String s) &#123; if (s.equals(&quot;&quot;)) return 0; int res = 0, n = s.length(); for (int i = 0; i &lt; s.length(); ++i) &#123; int cnt0 = 0, cnt1 = 0; char pre = &#x27;2&#x27;; // pre = for (int j = i; j &lt; n; ++j) &#123; char ch = s.charAt(j); if (ch == &#x27;0&#x27;) &#123; if (pre == &#x27;1&#x27;) break; ++cnt0; &#125; else &#123; // ch == &#x27;1&#x27; if (pre == &#x27;0&#x27; || pre == &#x27;1&#x27; ) ++cnt1; if (cnt1 == cnt0) &#123; res = Math.max(res, cnt0 + cnt1); break; &#125; &#125; pre = ch; &#125; &#125; return res; &#125;&#125; 转换二维数组 方法一：哈希数组 12345678910111213141516171819202122class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; findMatrix(int[] nums) &#123; int[] cnt = new int[201]; int max = -1; for (int x : nums) &#123; cnt[x]++; max = Math.max(max, cnt[x]); &#125; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); for (int k = 0; k &lt; max; ++k) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; cnt.length; ++i) &#123; if (cnt[i] &gt; 0) &#123; --cnt[i]; list.add(i); &#125; &#125; res.add(list); &#125; return res; &#125;&#125; 老鼠和奶酪 方法一：贪心 + 排序 贪心 $10^{10}$复杂度，dp会超时 思路： 如果老鼠1不吃奶酪，全部给老鼠2吃，那么分数为s = sum(reward2)。 如果老鼠1吃了第i颗奶酪，那么分数为s + reward1[i] - reward2[i] 求一个diff数组，并且排序，老鼠1吃diff[i]最大的k个奶酪 1234567891011121314class Solution &#123; public int miceAndCheese(int[] reward1, int[] reward2, int k) &#123; int sum = 0, n = reward1.length; int[] diff = new int[n]; for (int i = 0; i &lt; n; ++i) &#123; sum += reward2[i]; diff[i] = reward1[i] - reward2[i]; &#125; Arrays.sort(diff); for (int i = n - 1; i &gt;= n - k; --i) sum += diff[i]; return sum; &#125;&#125; 2612. 最少翻转操作数 方法一： 1","categories":[{"name":"Contest","slug":"Contest","permalink":"https://leopol1d.github.io/categories/Contest/"},{"name":"LCP","slug":"Contest/LCP","permalink":"https://leopol1d.github.io/categories/Contest/LCP/"}],"tags":[{"name":"力扣杯","slug":"力扣杯","permalink":"https://leopol1d.github.io/tags/%E5%8A%9B%E6%89%A3%E6%9D%AF/"}]},{"title":"lcp340","slug":"lcp340","date":"2023-08-15T06:36:42.000Z","updated":"2023-08-16T06:16:15.089Z","comments":true,"path":"2023/08/15/lcp340/","link":"","permalink":"https://leopol1d.github.io/2023/08/15/lcp340/","excerpt":"","text":"对角线上的质数 方法一：埃氏筛 1234567891011121314151617181920212223242526272829class Solution &#123; static int n = 4 * (int) 1e6 + 1; static boolean[] notPrime = new boolean[n]; static &#123; notPrime[0] = true; notPrime[1] = true; for (int i = 2; i &lt; n; ++i) &#123; if (!notPrime[i]) &#123; if ((long) i * i &lt; n) &#123; for (int j = i * i; j &lt; n; j+=i) &#123; notPrime[j] = true; &#125; &#125; &#125; &#125; &#125; public int diagonalPrime(int[][] nums) &#123; int res = 0, m = nums.length, n = nums[0].length; for (int i = 0; i &lt; m; ++i) &#123; if (!notPrime[nums[i][m - 1 - i]]) res = Math.max(res, nums[i][m - 1 - i]); if (!notPrime[nums[i][i]]) res = Math.max(res, nums[i][i]); &#125; return res; &#125;&#125; 等值距离和 方法一：相同元素分组+考虑增量 如下图 左边距离增加了的个数，右边距离减少了的个数 long size = (j - 1) - (list.size() - 1 - j)= j * 2 - list.size(); 1234567891011121314151617181920212223242526class Solution &#123; public long[] distance(int[] nums) &#123; int n = nums.length; long[] res = new long[n]; Map&lt;Integer, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; n; ++i) &#123; int num = nums[i]; if (!map.containsKey(num)) map.putIfAbsent(num, new ArrayList&lt;&gt;()); map.get(num).add(i); &#125; for (List&lt;Integer&gt; list : map.values()) &#123; long first = 0; for (int x : list) first += x - list.get(0); res[list.get(0)] = first; for (int j = 1; j &lt; list.size(); ++j) &#123; long diff = list.get(j) - list.get(j - 1); long size = (long) (j * 2 - list.size()); res[list.get(j)] = res[list.get(j - 1)] + diff * size; &#125; &#125; return res; &#125;&#125; 2616. 最小化数对的最大差值 方法一：贪心 + 二分 1234567891011121314151617181920212223242526class Solution &#123; public int minimizeMax(int[] nums, int p) &#123; int n = nums.length; Arrays.sort(nums); int l = 0, r = nums[n - 1] - nums[0]; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if (check(nums, mid, p)) r = mid - 1; else l = mid + 1; &#125; return l; &#125; private boolean check(int[] nums, int limit, int p) &#123; int cnt = 0; for (int i = 0; i &lt; nums.length - 1; ++i) &#123; if (Math.abs(nums[i] - nums[i + 1]) &lt;= limit) &#123; ++cnt; i++; &#125; &#125; return cnt &gt;= p; &#125;&#125;","categories":[{"name":"Contest","slug":"Contest","permalink":"https://leopol1d.github.io/categories/Contest/"},{"name":"LCP","slug":"Contest/LCP","permalink":"https://leopol1d.github.io/categories/Contest/LCP/"}],"tags":[{"name":"力扣杯","slug":"力扣杯","permalink":"https://leopol1d.github.io/tags/%E5%8A%9B%E6%89%A3%E6%9D%AF/"}]},{"title":"Tree-DP","slug":"tree-dp","date":"2023-08-14T01:23:07.000Z","updated":"2023-09-05T09:26:05.177Z","comments":true,"path":"2023/08/14/tree-dp/","link":"","permalink":"https://leopol1d.github.io/2023/08/14/tree-dp/","excerpt":"","text":"337. 打家劫舍 III 方法一：树形DP 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public int rob(TreeNode root) &#123; int[] res = dfs(root); return Math.max(res[0], res[1]); // 选或不选 &#125; public int[] dfs(TreeNode root) &#123; if (root == null) return new int[2]; int[] left = dfs(root.left); int[] right = dfs(root.right); int rob = root.val + left[1] + right[1]; int pass = Math.max(left[0], left[1]) + Math.max(right[0], right[1]); return new int[]&#123;rob, pass&#125;; &#125;&#125; 2646. 最小化旅行的价格总和 方法一：树形DP 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution &#123; public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) &#123; // 建图 this.price = price; graph = new List[n]; for (int i = 0; i &lt; n; ++i) graph[i] = new ArrayList&lt;&gt;(); for (int[] edge : edges) &#123; int from = edge[0], to = edge[1]; graph[from].add(to); graph[to].add(from); &#125; count = new int[n]; // 获取每个节点经过的次数 for (int[] trip : trips) dfs(trip[0], -1, trip[1]); // 类似打家劫舍：打折或者不打折 // 随便选一个点作为根节点，所有情况都会考虑到 int[] res = dfs2(0, -1); return Math.min(res[0], res[1]); &#125; private int[] dfs2(int cur, int parent) &#123; int notHalve = 0, halve = 0; for (int next : graph[cur]) &#123; if (next != parent) &#123; int[] arr = dfs2(next, cur); int nh = arr[0], h = arr[1]; notHalve += Math.min(nh, h); halve += nh; &#125; &#125; notHalve += count[cur] * price[cur]; halve += (count[cur] * price[cur]) / 2; return new int[]&#123;notHalve, halve&#125;; &#125; int[] count, price; List&lt;Integer&gt;[] graph; private boolean dfs(int cur, int parent, int end) &#123; if (cur == end) &#123; count[cur]++; return true; &#125; for (int next : graph[cur]) &#123; if (next != parent &amp;&amp; dfs(next, cur, end)) &#123; count[cur]++; return true; &#125; &#125; return false; &#125;&#125; 1377. T 秒后青蛙的位置 方法一：树形DP 思路：如果在给定步数t内找到target，则返回true，“归”的时候将概率prob / 当前节点的子树个数 特判根节点情况 (leftStep &gt;= 0 &amp;&amp; graph[cur].size() &lt;= 1)表示走到根节点，但是步数没用完，可以原地起跳 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public double frogPosition(int n, int[][] edges, int t, int target) &#123; if (n == 1 &amp;&amp; target == 1) return 1.0; else if (target == 1 &amp;&amp; t &gt; 1) return 0.0; this.n = n; this.t = t; this.target = target; graph = new List[n + 1]; Arrays.setAll(graph, o -&gt; new ArrayList&lt;&gt;()); for (int[] edge : edges) &#123; int from = edge[0], to = edge[1]; graph[from].add(to); graph[to].add(from); &#125; if (!findPath(1, -1, t)) return 0; return prob; &#125; private boolean findPath(int cur, int parent, int leftStep) &#123; // (leftStep &gt;= 0 &amp;&amp; graph[cur].size() &lt;= 1)表示走到根节点，但是步数没用完，可以原地起跳 if (cur == target &amp;&amp; (leftStep == 0 || (leftStep &gt;= 0 &amp;&amp; graph[cur].size() &lt;= 1))) return true; for (int next : graph[cur]) &#123; if (next != parent &amp;&amp; findPath(next, cur, leftStep - 1)) &#123; if (parent == -1) // root prob /= graph[cur].size(); else prob /= (graph[cur].size() - 1); return true; &#125; &#125; return false; &#125; List&lt;Integer&gt;[] graph; int n, t, target; double prob = 1.0;&#125; 2467. 树上最大得分和路径 方法一：树形DP 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution &#123; public int mostProfitablePath(int[][] edges, int bob, int[] amount) &#123; n = edges.length + 1; graph = new List[n]; this.amount = amount; Arrays.setAll(graph, o -&gt; new ArrayList&lt;&gt;()); time = new int[n]; Arrays.fill(time, n); for (int[] edge : edges) &#123; int from = edge[0], to = edge[1]; graph[from].add(to); graph[to].add(from); &#125; graph[0].add(-1); getDistFromRoot(bob, -1, 0); dfs(0, -1, 0, 0); return res; &#125; private void dfs(int alice, int parent, int aliceTime, int score) &#123; if (aliceTime == time[alice]) score += amount[alice] / 2; if (aliceTime &lt; time[alice]) score += amount[alice]; if (graph[alice].size() == 1) &#123; res = Math.max(res, score); return; &#125; for (int next : graph[alice]) if (next != parent) dfs(next, alice, aliceTime + 1, score); &#125; private boolean getDistFromRoot(int cur, int parent, int t) &#123; if (cur == 0) &#123; time[cur] = t; return true; &#125; for (int next : graph[cur]) &#123; if (next != parent &amp;&amp; getDistFromRoot(next, cur, t + 1)) &#123; time[cur] = t; return true; &#125; &#125; return false; &#125; List&lt;Integer&gt;[] graph; int[] time; int n; int[] amount; int res = Integer.MIN_VALUE;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import java.util.*;public class _5 &#123; public static void main(String[] args) &#123; new _5().solve(); &#125; int n; int[] v; List&lt;List&lt;Integer&gt;&gt; graph = new ArrayList&lt;&gt;(); void solve() &#123; Scanner sc = new Scanner(System.in); n = sc.nextInt(); v = new int[n+1]; for (int i = 1; i &lt;= n; i++) &#123; v[i] = sc.nextInt(); &#125; for (int i = 0; i &lt;= n; i++) graph.add(new LinkedList&lt;&gt;()); int res = 0; for (int i = 0 ; i &lt; n - 1; i ++) &#123; int a = sc.nextInt(); int b = sc.nextInt(); graph.get(a).add(b); graph.get(b).add(a); &#125; dp = new int[n+1][2]; dfs(1,-1); System.out.println(Math.max(dp[1][0], dp[1][1])); &#125; int[][] dp; //node 0不染色 1染色 void dfs(int node, int pre) &#123; for (int next : graph.get(node)) &#123; if (next != pre) &#123; dfs(next,node); &#125; &#125; //不染色 for (int next : graph.get(node)) &#123; if (next != pre) &#123; dp[node][0] += Math.max(dp[next][0], dp[next][1]) ; &#125; &#125; for (int next : graph.get(node)) &#123; if (next != pre) &#123; if (isAns(v[next], v[node])) dp[node][1] = Math.max(dp[node][0] - Math.max(dp[next][0], dp[next][1])+2+dp[next][0], dp[node][1]); &#125; &#125; &#125; boolean isAns(int a, int b) &#123; if (a &lt; 0 || b &lt; 0) return false; long c = a*b; int sq = (int) Math.sqrt(c); return sq*sq == c; &#125;&#125; 1372. 二叉树中的最长交错路径 方法一：树形DP 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; Map&lt;TreeNode, Integer&gt; f = new HashMap&lt;&gt;(), g = new HashMap&lt;&gt;(); int res = 0; public int longestZigZag(TreeNode root) &#123; if (root == null) return 0; f.put(root, 0); g.put(root, 0); dfs(root, null); for (TreeNode t : f.keySet()) res = Math.max(res, Math.max(f.get(t), g.get(t))); return res; &#125; public void dfs(TreeNode root, TreeNode pre) &#123; if (root == null) return; if (pre != null) &#123; if (root == pre.left) &#123; f.put(root, g.get(pre) + 1); g.put(root, 0); &#125; else &#123; f.put(root, 0); g.put(root, f.get(pre) + 1); &#125; &#125; dfs(root.left, root); dfs(root.right, root); &#125; &#125; 方法二：DFS(post) 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; int res = 0; public int longestZigZag(TreeNode root) &#123; if (root == null) return 0; dfs(root, null); return res; &#125; public int dfs(TreeNode root, TreeNode pre) &#123; if (root == null) return 0; int l = dfs(root.left, root); int r = dfs(root.right, root); if (pre != null) &#123; if (root == pre.left) &#123; res = Math.max(res, r + 1); return r + 1; &#125; else &#123; res = Math.max(res, l + 1); return l + 1; &#125; &#125; return Math.max(l, r) + 1; &#125; &#125; 方法三：DFS 1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; int res = 0; public int longestZigZag(TreeNode root) &#123; dfs(root); return res; &#125; public int[] dfs(TreeNode root) &#123; if (root == null) return new int[]&#123;-1, -1&#125;; int l = dfs(root.left)[1] + 1; int r = dfs(root.right)[0] + 1; res = Math.max(res, Math.max(l, r)); return new int[]&#123;l, r&#125;; &#125; &#125;","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://leopol1d.github.io/categories/Algorithms/"},{"name":"Dynamic Programming","slug":"Algorithms/Dynamic-Programming","permalink":"https://leopol1d.github.io/categories/Algorithms/Dynamic-Programming/"}],"tags":[{"name":"树形DP","slug":"树形DP","permalink":"https://leopol1d.github.io/tags/%E6%A0%91%E5%BD%A2DP/"}]},{"title":"lcp358","slug":"lcp358","date":"2023-08-13T02:28:48.000Z","updated":"2023-08-18T07:39:58.507Z","comments":true,"path":"2023/08/13/lcp358/","link":"","permalink":"https://leopol1d.github.io/2023/08/13/lcp358/","excerpt":"","text":"第一题数组中的最大数对和 1234567891011121314151617181920212223242526class Solution &#123; public int maxSum(int[] nums) &#123; int max = -1; for (int i = 0; i &lt; nums.length; ++i) &#123; for (int j = i + 1; j &lt; nums.length; ++j) &#123; int temp1 = nums[i], temp2 = nums[j], maxDig1 = -1, maxDig2 = -1; while (temp1 != 0) &#123; int a = temp1 % 10; temp1 /= 10; if (a &gt; maxDig1) maxDig1 = a; &#125; while (temp2 != 0) &#123; int a = temp2 % 10; temp2 /= 10; if (a &gt; maxDig2) maxDig2 = a; &#125; if (maxDig1 == maxDig2 &amp;&amp; nums[i] + nums[j] &gt; max) &#123; max = nums[i] + nums[j]; &#125; &#125; &#125; return max; &#125;&#125; 第一题翻倍以链表形式表示的数字 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode doubleIt(ListNode head) &#123; ListNode cur = reverse(head), pre = null, tail = cur; int c = 0; while (cur != null) &#123; cur.val = cur.val * 2 + c; c = 0; if (cur.val &gt;= 10) &#123; cur.val -= 10; c++; &#125; pre = cur; cur = cur.next; &#125; ListNode n = null; cur = reverse(tail); if (c &gt; 0) &#123; n = new ListNode(1); n.next = head; &#125; return c &gt; 0 ? n : head; &#125; private ListNode reverse(ListNode cur) &#123; ListNode next = null, pre = null; while (cur != null) &#123; next = cur.next; cur.next = pre; pre = cur; cur = next; &#125; return pre; &#125;&#125; 第一题限制条件下元素之间的最小绝对差 方法一：双指针 + TreeSet 指针i(左)初始化为0，指针r(右)初始化为x，遍历整个数组。每轮开始，将nums[i]加入TreeSet中，在treeset查询是否存在小于等于nums[r]的最大值哥大于等于nums[r]的最小值，与全局遍历min进行比较。由于右指针r指向的元素与TreeSet中的元素的间隔至少为x，满足题意 1234567891011121314151617181920class Solution &#123; public int minAbsoluteDifference(List&lt;Integer&gt; g, int x) &#123; int[] nums = g.stream().mapToInt(i-&gt;i).toArray(); TreeSet&lt;Integer&gt; set = new TreeSet&lt;&gt;(); int n = nums.length, min = Integer.MAX_VALUE; int r = x; for (int i = 0; i &lt; n; ++i) &#123; set.add(nums[i]); Integer lower = set.floor(nums[r]), higher = set.ceiling(nums[r]); if (lower != null) min = Math.min(min, Math.abs(lower - nums[r])); if (higher != null) min = Math.min(min, Math.abs(higher - nums[r])); ++r; if (r == n) break; &#125; return min; &#125;&#125;","categories":[{"name":"Contest","slug":"Contest","permalink":"https://leopol1d.github.io/categories/Contest/"},{"name":"LCP","slug":"Contest/LCP","permalink":"https://leopol1d.github.io/categories/Contest/LCP/"}],"tags":[{"name":"力扣杯","slug":"力扣杯","permalink":"https://leopol1d.github.io/tags/%E5%8A%9B%E6%89%A3%E6%9D%AF/"}]},{"title":"lcp341","slug":"lcp341","date":"2023-08-12T11:19:53.000Z","updated":"2023-08-12T12:28:08.797Z","comments":true,"path":"2023/08/12/lcp341/","link":"","permalink":"https://leopol1d.github.io/2023/08/12/lcp341/","excerpt":"","text":"一最多的行 方法一：模拟 12345678910111213141516171819class Solution &#123; public int[] rowAndMaximumOnes(int[][] mat) &#123; int m = mat.length, n = mat[0].length, max = 0; int[] res = new int[2]; for (int i = 0; i &lt; m; ++i) &#123; int count = 0; for (int j = 0; j &lt; n; ++j) &#123; if (mat[i][j] == 1) ++count; &#125; if (count &gt; max) &#123; res[0] = i; res[1] = count; max = count; &#125; &#125; return res; &#125;&#125; 找出可整除性得分最大的整数 方法一：整除与被整除？ 12345678910111213141516171819202122class Solution &#123; public int maxDivScore(int[] nums, int[] divisors) &#123; int max = 0, val = divisors[0]; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int i = 0; i &lt; divisors.length; ++i) &#123; if (set.contains(divisors[i])) continue; set.add(divisors[i]); int count = 0; for (int j = 0; j &lt; nums.length; ++j) &#123; int num = nums[j]; if (nums[j] % divisors[i] == 0) ++count; &#125; if (count &gt; max || (count == max &amp;&amp; divisors[i] &lt; val)) &#123; max = count; val = divisors[i]; &#125; &#125; return val; &#125;&#125; 构造有效字符串的最少插入数 方法一：bullshit 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution &#123; public int addMinimum(String word) &#123; if (word.equals(&quot;abc&quot;)) return 0; int res = 0, n = word.length(); int flag = 1; for (int i = 0; i &lt; n; ++i) &#123; char ch = word.charAt(i); if (ch == &#x27;a&#x27;) &#123; if (i + 2 &lt; n &amp;&amp; word.charAt(i + 1) == &#x27;b&#x27; &amp;&amp; word.charAt(i + 2) == &#x27;c&#x27;) i = i + 2; else if (i + 2 &gt;= n) &#123; if (i == n - 1) res += 2; else if (i == n - 2 &amp;&amp; word.charAt(i + 1) != &#x27;a&#x27;) &#123; res += 1; i = n - 1; &#125; else if (i == n - 2 &amp;&amp; word.charAt(i + 1) == &#x27;a&#x27;) res += 2; &#125; else if (word.charAt(i + 1) == &#x27;a&#x27;) &#123; res += 2; &#125; else if (word.charAt(i + 1) != &#x27;a&#x27;) &#123; res += 1; i = i + 1; &#125; else if (word.charAt(i + 2) != &#x27;c&#x27;) &#123; res += 1; i += 1; &#125; &#125; else if (ch == &#x27;b&#x27;) &#123; if (i + 1 &lt; n) &#123; if (word.charAt(i + 1) == &#x27;c&#x27;) &#123; res += 1; ++i; &#125; else &#123; res += 2; &#125; &#125; else if (i == n - 1) &#123; res += 2; &#125; &#125; else &#123; // &#x27;c&#x27; res += 2; &#125; &#125; return res; &#125;&#125; 最小化旅行的价格总和","categories":[{"name":"Contest","slug":"Contest","permalink":"https://leopol1d.github.io/categories/Contest/"},{"name":"LCP","slug":"Contest/LCP","permalink":"https://leopol1d.github.io/categories/Contest/LCP/"}],"tags":[{"name":"力扣杯","slug":"力扣杯","permalink":"https://leopol1d.github.io/tags/%E5%8A%9B%E6%89%A3%E6%9D%AF/"}]},{"title":"lcp342","slug":"lcp342","date":"2023-08-12T08:30:12.000Z","updated":"2023-08-12T11:12:03.742Z","comments":true,"path":"2023/08/12/lcp342/","link":"","permalink":"https://leopol1d.github.io/2023/08/12/lcp342/","excerpt":"","text":"计算列车到站时间 方法一： 12345class Solution &#123; public int findDelayedArrivalTime(int arrivalTime, int delayedTime) &#123; return (arrivalTime + delayedTime) % 24; &#125;&#125; 倍数求和 方法二：数学 1234567891011class Solution &#123; public int sumOfMultiples(int n) &#123; this.n = n; return s(3) + s(5) + s(7) - s(15) - s(21) - s(35) + s(105); &#125; private int s(int m) &#123; return (1 + n / m) * (n / m) / 2 * m; &#125; int n;&#125; 方法一：暴力 1234567891011class Solution &#123; public int sumOfMultiples(int n) &#123; int res = 0; for (int i = 3; i &lt;= n; ++i) &#123; if (i % 3 == 0 || i % 5 == 0 || i % 7 == 0) res += i; &#125; return res; &#125;&#125; 滑动子数组的美丽值 方法一：双TreeMap 题解 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123; public int[] getSubarrayBeauty(int[] nums, int k, int x) &#123; int n = nums.length; int[] res = new int[n - k + 1]; TreeMap&lt;Integer, Integer&gt; greater = new TreeMap&lt;&gt;(), smaller = new TreeMap&lt;&gt;(); for (int i = 0; i &lt; n; ++i) &#123; smaller.put(nums[i], smaller.getOrDefault(nums[i], 0) + 1); if (i &gt;= x) &#123; // smaller 弹出最大元素 int curMax = smaller.lastKey(); greater.put(curMax, greater.getOrDefault(curMax, 0) + 1); if (smaller.get(curMax) == 1) smaller.remove(curMax); else smaller.put(curMax, smaller.get(curMax) - 1); &#125; if (i &gt;= k) &#123; // 移除nums[i-k] int target = nums[i - k]; if (greater.containsKey(target)) &#123; if (greater.get(target) == 1) greater.remove(target); else greater.put(target, greater.get(target) - 1); &#125; else &#123; if (smaller.get(target) == 1) smaller.remove(target); else smaller.put(target, smaller.get(target) - 1); int temp = greater.firstKey(); smaller.put(temp, smaller.getOrDefault(temp, 0) + 1); if (greater.get(temp) == 1) greater.remove(temp); else greater.put(temp, greater.get(temp) - 1); &#125; &#125; if (i &gt;= k - 1) res[i - k + 1] = Math.min(0, smaller.lastKey()); &#125; return res; &#125;&#125; 2654. 使数组所有元素变成 1 的最少操作次数 方法一： 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public int minOperations(int[] nums) &#123; int n = nums.length, gcdAll = 0, count1 = 0; for (int x : nums) &#123; gcdAll = gcd(gcdAll, x); if (x == 1) ++count1; &#125; if (gcdAll &gt; 1) return -1; if (count1 &gt; 0) return n - count1; int minSize = n; for (int i = 0; i &lt; n; ++i) &#123; int g = 0; for (int j = i; j &lt; n; ++j) &#123; g = gcd(g, nums[j]); if (g == 1) &#123; minSize = Math.min(minSize, j - i + 1); break; &#125; &#125; &#125; return minSize + n - 2; &#125; private int gcd(int a, int b) &#123; while (a != 0) &#123; int temp = a; a = b % a; b = temp; &#125; return b; &#125;&#125;","categories":[{"name":"Contest","slug":"Contest","permalink":"https://leopol1d.github.io/categories/Contest/"},{"name":"LCP","slug":"Contest/LCP","permalink":"https://leopol1d.github.io/categories/Contest/LCP/"}],"tags":[{"name":"力扣杯","slug":"力扣杯","permalink":"https://leopol1d.github.io/tags/%E5%8A%9B%E6%89%A3%E6%9D%AF/"}]},{"title":"lcp357","slug":"lcp357","date":"2023-08-06T02:29:06.000Z","updated":"2023-08-09T06:27:12.973Z","comments":true,"path":"2023/08/06/lcp357/","link":"","permalink":"https://leopol1d.github.io/2023/08/06/lcp357/","excerpt":"","text":"故障键盘 方法二：双端队列 12345678910111213141516171819202122232425class Solution &#123; public String finalString(String s) &#123; Deque&lt;Character&gt; queue = new LinkedList&lt;&gt;(); boolean shouldReverse = false; for (int i = 0; i &lt; s.length(); ++i) &#123; char ch = s.charAt(i); if (ch == &#x27;i&#x27;) shouldReverse = !shouldReverse; else &#123; if (!shouldReverse) queue.offerFirst(ch); else queue.offerLast(ch); &#125; &#125; StringBuilder sb = new StringBuilder(); while (!queue.isEmpty()) &#123; if (shouldReverse) sb.append(queue.pollFirst()); else sb.append(queue.pollLast()); &#125; return sb.toString(); &#125;&#125; 方法一：暴力 1234567891011121314151617181920class Solution &#123; public String finalString(String s) &#123; int n = s.length(); StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; n; ++i) &#123; char ch = s.charAt(i); if (ch != &#x27;i&#x27;) &#123; sb.append(ch); &#125; else &#123; reverse(sb); &#125; &#125; return sb.toString(); &#125; private void reverse(StringBuilder sb) &#123; sb.reverse(); &#125;&#125; 判断是否能拆分数组 方法一：记忆化搜索 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public boolean canSplitArray(List&lt;Integer&gt; nums, int m) &#123; this.nums = nums; n = nums.size(); if (n &lt;= 2) return true; this.m = m; preSum = new int[n + 1]; for (int i = 0; i &lt; n; ++i) preSum[i + 1] = preSum[i] + nums.get(i); return dfs(0, n); &#125; // [) private boolean dfs(int l, int r) &#123; if (r - l == 1) return true; String key = l + &quot;#&quot; + r; if (map.containsKey(key)) return map.get(key); if (preSum[r] - preSum[l] &lt; m) &#123; map.put(key, false); return false; &#125; boolean res = false; for (int i = l + 1; i &lt; r; ++i) &#123; res = dfs(l, i) &amp;&amp; dfs(i, r); if (res) &#123; map.put(key, res); return true; &#125; &#125; map.put(key, res); return false; &#125; List&lt;Integer&gt; nums; int m, n; Map&lt;String, Boolean&gt; map = new HashMap&lt;&gt;(); int[] preSum;&#125; 方法二：贪心 12345678class Solution &#123; public boolean canSplitArray(List&lt;Integer&gt; nums, int m) &#123; for (int i = 0; i &lt; nums.size() - 1; ++i) if (nums.get(i) + nums.get(i + 1) &gt;= m) return true; return nums.size() &lt;= 2; &#125;&#125; 6951. 找出最安全路径 方法一：多源BFS 二分做右端点的初始 1int l = 0, r = Math.min(dist[0][0], dist[n - 1][n - 1]); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class Solution &#123; public int maximumSafenessFactor(List&lt;List&lt;Integer&gt;&gt; g) &#123; n = g.size(); grid = new int[n][n]; for (int i = 0; i &lt; n; ++i) for (int j = 0; j &lt; n; ++j) grid[i][j] = g.get(i).get(j); int[][] dist = new int[n][n]; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); for (int[] arr : dist) Arrays.fill(arr, -1); for (int i = 0; i &lt; n; ++i) for (int j = 0; j &lt; n; ++j) if (grid[i][j] == 1) &#123; queue.offer(new int[]&#123;i, j&#125;); dist[i][j] = 0; &#125; while (!queue.isEmpty()) &#123; int[] node = queue.poll(); for (int[] dir : dirs) &#123; int row = node[0] + dir[0], col = node[1] + dir[1]; if (isValid(row, col) &amp;&amp; dist[row][col] == -1) &#123; dist[row][col] = dist[node[0]][node[1]] + 1; queue.offer(new int[]&#123;row, col&#125;); &#125; &#125; &#125; int l = 0, r = Math.min(dist[0][0], dist[n - 1][n - 1]); while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if (check(mid, dist)) l = mid + 1; else r = mid - 1; &#125; return r; &#125; private boolean check(int limit, int[][] dist) &#123; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); boolean[][] visited = new boolean[n][n]; queue.offer(new int[]&#123;0, 0&#125;); visited[0][0] = true; while (!queue.isEmpty()) &#123; int[] node = queue.poll(); for (int[] dir : dirs) &#123; int row = node[0] + dir[0], col = node[1] + dir[1]; if (isValid(row, col) &amp;&amp; !visited[row][col] &amp;&amp; dist[row][col] &gt;= limit) &#123; visited[row][col] = true; queue.offer(new int[]&#123;row, col&#125;); &#125; &#125; &#125; return visited[n - 1][n - 1]; &#125; private boolean isValid(int i, int j) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; n &amp;&amp; j &lt; n; &#125; int[][] grid, dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; int n;&#125; 在check中判断初始位置，r = 2 * n - 1 (大一点也没关系) 12if (dist[0][0] &lt; limit) return false; 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class Solution &#123; public int maximumSafenessFactor(List&lt;List&lt;Integer&gt;&gt; g) &#123; n = g.size(); grid = new int[n][n]; for (int i = 0; i &lt; n; ++i) for (int j = 0; j &lt; n; ++j) grid[i][j] = g.get(i).get(j); int[][] dist = new int[n][n]; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); for (int[] arr : dist) Arrays.fill(arr, -1); for (int i = 0; i &lt; n; ++i) for (int j = 0; j &lt; n; ++j) if (grid[i][j] == 1) &#123; queue.offer(new int[]&#123;i, j&#125;); dist[i][j] = 0; &#125; while (!queue.isEmpty()) &#123; int[] node = queue.poll(); for (int[] dir : dirs) &#123; int row = node[0] + dir[0], col = node[1] + dir[1]; if (isValid(row, col) &amp;&amp; dist[row][col] == -1) &#123; dist[row][col] = dist[node[0]][node[1]] + 1; queue.offer(new int[]&#123;row, col&#125;); &#125; &#125; &#125; int l = 0, r = 2 * n; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if (check(mid, dist)) l = mid + 1; else r = mid - 1; &#125; return r; &#125; private boolean check(int limit, int[][] dist) &#123; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); boolean[][] visited = new boolean[n][n]; if (dist[0][0] &lt; limit) return false; queue.offer(new int[]&#123;0, 0&#125;); visited[0][0] = true; while (!queue.isEmpty()) &#123; int[] node = queue.poll(); for (int[] dir : dirs) &#123; int row = node[0] + dir[0], col = node[1] + dir[1]; if (isValid(row, col) &amp;&amp; !visited[row][col] &amp;&amp; dist[row][col] &gt;= limit) &#123; visited[row][col] = true; queue.offer(new int[]&#123;row, col&#125;); &#125; &#125; &#125; return visited[n - 1][n - 1]; &#125; private boolean isValid(int i, int j) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; n &amp;&amp; j &lt; n; &#125; int[][] grid, dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; int n;&#125; check使用DFS 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class Solution &#123; public int maximumSafenessFactor(List&lt;List&lt;Integer&gt;&gt; g) &#123; n = g.size(); grid = new int[n][n]; dist = new int[n][n]; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; grid[i][j] = g.get(i).get(j); dist[i][j] = -1; if (grid[i][j] == 1) &#123; dist[i][j] = 0; queue.offer(new int[]&#123;i, j&#125;); &#125; &#125; &#125; // bfs while (!queue.isEmpty()) &#123; int[] node = queue.poll(); for (int[] dir : dirs) &#123; int row = node[0] + dir[0], col = node[1] + dir[1]; if (isValid(row, col) &amp;&amp; dist[row][col] == -1) &#123; queue.offer(new int[]&#123;row, col&#125;); dist[row][col] = dist[node[0]][node[1]] + 1; &#125; &#125; &#125; int l = 0, r = (n - 1) &lt;&lt; 1; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if (check(mid)) l = mid + 1; else r = mid - 1; &#125; return r; &#125; private boolean check(int minDist) &#123; if (dist[0][0] &lt; minDist) return false; boolean[][] visited = new boolean[n][n]; return dfs(0, 0, minDist, visited); &#125; private boolean dfs(int i, int j, int minDist, boolean[][] visited) &#123; if (i == n -1 &amp;&amp; j == n - 1) return true; visited[i][j] = true; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col) &amp;&amp; !visited[row][col] &amp;&amp; dist[row][col] &gt;= minDist) &#123; if (dfs(row, col, minDist, visited)) return true; &#125; &#125; return false; &#125; private boolean isValid(int i, int j) &#123; return i &gt;=0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; n &amp;&amp; j &lt; n; &#125; int[][] grid, dist, dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; int n;&#125; 方法二：多源BFS + 并查集 关于从dists.size() - 2开始枚举：最后一步是空集，所以最大的距离为 dists.size() - 2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384class Solution &#123; public int maximumSafenessFactor(List&lt;List&lt;Integer&gt;&gt; g) &#123; n = g.size(); grid = new int[n][n]; int[][] dist = new int[n][n]; for (int[] arr : dist) Arrays.fill(arr, -1); List&lt;int[]&gt; queue = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; grid[i][j] = g.get(i).get(j); if (grid[i][j] == 1) &#123; dist[i][j] = 0; queue.add(new int[]&#123;i, j&#125;); &#125; &#125; &#125; // 多源BFS List&lt;List&lt;int[]&gt;&gt; dists = new ArrayList&lt;&gt;(); dists.add(queue); List&lt;int[]&gt; temp = new LinkedList&lt;&gt;(); while (!queue.isEmpty()) &#123; temp = queue; queue = new LinkedList&lt;&gt;(); for (int[] node : temp) &#123; for (int[] dir : dirs) &#123; int row = node[0] + dir[0], col = node[1] + dir[1]; if (isValid(row, col) &amp;&amp; dist[row][col] == -1) &#123; // 没有被访问过 queue.add(new int[]&#123;row, col&#125;); dist[row][col] = dists.size(); &#125; &#125; &#125; // 最后一步是空集，所以最大的距离为 dists.size() - 2 dists.add(queue); &#125; // 初始化并查集 init(n * n); for (int i = dists.size() - 2; i &gt; 0; --i) &#123; List&lt;int[]&gt; q = dists.get(i); for (int[] node : q) &#123; for (int[] dir : dirs) &#123; int row = node[0] + dir[0], col = node[1] + dir[1]; if (isValid(row, col) &amp;&amp; dist[row][col] &gt;= i) union(node[0] * n + node[1],row * n + col); &#125; &#125; if (findParent(0) == findParent(n * n - 1)) return i; &#125; return 0; &#125; private boolean isValid(int i, int j) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; n &amp;&amp; j &lt; n; &#125; int[][] grid, dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; int n; int[] parent; private boolean union(int i, int j) &#123; int rootI = findParent(i), rootJ = findParent(j); if (rootI != rootJ) &#123; parent[rootI] = rootJ; return true; &#125; return false; &#125; private int findParent(int i) &#123; if (i != parent[i]) parent[i] = findParent(parent[i]); return parent[i]; &#125; private void init(int n) &#123; parent = new int[n]; for (int i = 0; i &lt; n; ++i) parent[i] = i; &#125;&#125; 补充题 1631. 最小体力消耗路径 方法一：多源BFS + 二分 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; public int minimumEffortPath(int[][] heights) &#123; this.heights = heights; m = heights.length; n = heights[0].length; visited = new boolean[m][n]; int l = 0, r = (int) 1e6; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if (check(mid)) r = mid - 1; else l = mid + 1; &#125; return l; &#125; private boolean check(int limit) &#123; visited = new boolean[m][n]; return dfs(0, 0, limit); &#125; private boolean dfs(int i, int j, int limit) &#123; if (i == m - 1 &amp;&amp; j == n - 1) return true; visited[i][j] = true; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col) &amp;&amp; !visited[row][col] &amp;&amp; Math.abs(heights[i][j] - heights[row][col]) &lt;= limit) if (dfs(row, col, limit)) return true; &#125; return false; &#125; int[][] heights, dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; int m, n; boolean[][] visited; private boolean isValid(int i, int j) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125;&#125; 方法二：并查集 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Solution &#123; public int minimumEffortPath(int[][] heights) &#123; this.heights = heights; m = heights.length; n = heights[0].length; visited = new boolean[m][n]; List&lt;int[]&gt; edges = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; int id = i * n + j; if (i &gt; 0) edges.add(new int[]&#123;id - n, id, Math.abs(heights[i][j] - heights[i - 1][j])&#125;); if (j &gt; 0) edges.add(new int[]&#123;id - 1, id, Math.abs(heights[i][j] - heights[i][j - 1])&#125;); &#125; &#125; Collections.sort(edges, (o1, o2) -&gt; o1[2] - o2[2]); // 初始化并查集 init(m * n); for (int[] edge : edges) &#123; int from = edge[0], to = edge[1], weight = edge[2]; union(from, to); if (findParent(0) == findParent(m * n - 1)) return weight; &#125; return 0; &#125; int[] parent; private boolean union(int i, int j) &#123; int rootI = findParent(i), rootJ = findParent(j); if (rootI != rootJ) &#123; parent[rootI] = rootJ; return true; &#125; return false; &#125; private int findParent(int i) &#123; if (i != parent[i]) parent[i] = findParent(parent[i]); return parent[i]; &#125; private void init(int n) &#123; parent = new int[n]; for (int i = 0; i &lt; n; ++i) parent[i] = i; &#125; int[][] heights, dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; int m, n; boolean[][] visited; private boolean isValid(int i, int j) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125;&#125;","categories":[{"name":"Contest","slug":"Contest","permalink":"https://leopol1d.github.io/categories/Contest/"},{"name":"LCP","slug":"Contest/LCP","permalink":"https://leopol1d.github.io/categories/Contest/LCP/"}],"tags":[{"name":"力扣杯","slug":"力扣杯","permalink":"https://leopol1d.github.io/tags/%E5%8A%9B%E6%89%A3%E6%9D%AF/"}]},{"title":"lcpBi110","slug":"lcpBi110","date":"2023-08-05T14:24:22.000Z","updated":"2023-08-06T07:15:36.704Z","comments":true,"path":"2023/08/05/lcpBi110/","link":"","permalink":"https://leopol1d.github.io/2023/08/05/lcpBi110/","excerpt":"","text":"第一题取整购买后的账户余额 123456789101112131415161718class Solution &#123; public int accountBalanceAfterPurchase(int purchaseAmount) &#123; if (purchaseAmount == 100) return 0; if (purchaseAmount &lt; 5) return 100; if (purchaseAmount &lt; 10) return 90; int round = 0, min = 100; for (int i = 10; i &lt;= 100; i += 10) &#123; if (Math.abs(i - purchaseAmount) &lt;= min) &#123; round = i; min = Math.abs(i - purchaseAmount); &#125; &#125; return 100 - round; &#125;&#125; 第二题在链表中插入最大公约数 123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode insertGreatestCommonDivisors(ListNode head) &#123; ListNode cur = head; while (cur.next != null) &#123; ListNode next = cur.next; int val = calc(cur.val, next.val); ListNode x = new ListNode(val, next); cur.next = x; cur = next; &#125; return head; &#125; private int calc(int a, int b) &#123; int min = Math.min(a, b); int res = 1; for (int i = 1; i &lt;= min; ++i) &#123; if (a % i == 0 &amp;&amp; b % i == 0) res = i; &#125; return res; &#125;&#125; 第三题使循环数组所有元素相等的最少秒数 1 第四题使数组和小于等于 x 的最少时间 1","categories":[{"name":"Contest","slug":"Contest","permalink":"https://leopol1d.github.io/categories/Contest/"},{"name":"LCP","slug":"Contest/LCP","permalink":"https://leopol1d.github.io/categories/Contest/LCP/"}],"tags":[{"name":"力扣杯","slug":"力扣杯","permalink":"https://leopol1d.github.io/tags/%E5%8A%9B%E6%89%A3%E6%9D%AF/"}]},{"title":"leetcode_hot100","slug":"leetcode-hot100","date":"2023-08-01T02:52:37.000Z","updated":"2023-08-17T06:55:25.361Z","comments":true,"path":"2023/08/01/leetcode-hot100/","link":"","permalink":"https://leopol1d.github.io/2023/08/01/leetcode-hot100/","excerpt":"","text":"1. 两数之和 方法一：HashMap 1234567891011class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; ++i) &#123; if (map.containsKey(target - nums[i])) return new int[]&#123;map.get(target - nums[i]), i&#125;; map.put(nums[i], i); &#125; return new int[0]; &#125;&#125; 2. 两数相加 方法一：链表 1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode dummy = new ListNode(0), cur = dummy; int carry = 0; while (l1 != null || l2 != null) &#123; int val = (l1 != null ? l1.val : 0) + (l2 != null ? l2.val : 0) + carry; carry = val &gt;= 10 ? 1 : 0; cur.next = new ListNode(carry == 0 ? val : val % 10); cur = cur.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; &#125; if (carry == 1) cur.next = new ListNode(1); return dummy.next; &#125;&#125; 3. 无重复字符的最长子串 方法一：滑动窗口 12345678910111213141516class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int res = 0, n = s.length(); Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); for (int left = 0, right = 0; right &lt; n; ++right) &#123; char ch = s.charAt(right); while (map.containsKey(ch)) &#123; left = Math.max(left, map.get(ch) + 1); map.remove(ch); &#125; map.put(ch, right); res = Math.max(res, right - left + 1); &#125; return res; &#125;&#125; 4. 寻找两个正序数组的中位数 方法一：划分区间 123456789101112131415161718192021222324252627282930class Solution &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; if (nums1.length &gt; nums2.length) return findMedianSortedArrays(nums2, nums1); int m = nums1.length, n = nums2.length; int median1 = 0, median2 = 0; // 如果有m + n是偶数，median2是第二个中位数 int left = 0, right = m; // i == m时，表示nums1全被划分为前一部分 while (left &lt;= right) &#123; // 前一部分包含 nums1[0 .. i-1] 和 nums2[0 .. j-1] // 后一部分包含 nums1[i .. m-1] 和 nums2[j .. n-1] // 当m + n是偶数，规定前一部分和后一部分的长度相同 // 当m + n是奇数，规定前一部分的长度 == 后一部分的长度 + 1 // j = (m + n + 1 ) / 2 - i 可以很好地满足，不管m+n是奇数还是偶数 int i = (left + right) / 2, j = (m + n + 1) / 2 - i; int nums_i = i == m ? Integer.MAX_VALUE : nums1[i]; int nums_im1 = i == 0 ? Integer.MIN_VALUE : nums1[i - 1]; int nums_j = j == n ? Integer.MAX_VALUE : nums2[j]; int nums_jm1 = j == 0 ? Integer.MIN_VALUE : nums2[j - 1]; if (nums_im1 &lt;= nums_j) &#123; median1 = Math.max(nums_im1, nums_jm1); median2 = Math.min(nums_i, nums_j); left = i + 1; &#125; else &#123; right = i - 1; &#125; &#125; return (m + n) % 2 == 0 ? (median1 + median2) / 2.0 : median1; &#125;&#125; 5. 最长回文子串 方法一：DP 注意遍历顺序 1234567891011121314151617181920212223class Solution &#123; public String longestPalindrome(String s) &#123; int n = s.length(), max = 0; int[] maxIndex = new int[2]; int[][] dp = new int[n][n]; for (int i = n - 1; i &gt;= 0; --i) &#123; char ch1 = s.charAt(i); for (int j = i; j &lt; n; ++j) &#123; char ch2 = s.charAt(j); if (j - i + 1 &lt;= 2) dp[i][j] = ch1 == ch2 ? j - i + 1 : 0; else dp[i][j] = (ch1 == ch2 &amp;&amp; dp[i + 1][j - 1] &gt; 0) ? 2 + dp[i + 1][j - 1] : 0; if (dp[i][j] &gt; max) &#123; max = dp[i][j]; maxIndex[0] = i; maxIndex[1] = j; &#125; &#125; &#125; return s.substring(maxIndex[0], maxIndex[1] + 1); &#125;&#125; 10. 正则表达式匹配 方法一：DP 题解 初始化非常重要！！！！ 123456789101112131415161718192021222324class Solution &#123; public boolean isMatch(String s, String p) &#123; int m = s.length(), n = p.length(); // dp[i][j]:s[0:i]与p[0:j]是否匹配 boolean[][] dp = new boolean[m + 1][n + 1]; dp[0][0] = true; // 空串与空串匹配 for (int j = 1; j &lt;= n; ++j) if (p.charAt(j - 1) == &#x27;*&#x27;) dp[0][j] = dp[0][j - 2]; for (int i = 1; i &lt;= m; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == &#x27;.&#x27;) dp[i][j] = dp[i - 1][j - 1]; else if (p.charAt(j - 1) == &#x27;*&#x27;) &#123; if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == &#x27;.&#x27;) dp[i][j] = dp[i][j - 2] || dp[i - 1][j]; else dp[i][j] = dp[i][j - 2]; &#125; &#125; &#125; return dp[m][n]; &#125;&#125; 11. 盛最多水的容器 方法一：双指针贪心 移动短板，可以证明不会漏掉最大的结果 1234567891011class Solution &#123; public int maxArea(int[] height) &#123; int n = height.length, max = 0; int left = 0, right = n - 1; while (left &lt; right) &#123; int length = right - left; max = height[left] &lt; height[right] ? Math.max(max, length * height[left++]) : Math.max(max, length * height[right--]); &#125; return max; &#125;&#125; 方法二：回溯(超时) 123456789101112131415161718192021class Solution &#123; public int maxArea(int[] height) &#123; n = height.length; this.height = height; dfs(0, n - 1); return res; &#125; private void dfs(int left, int right) &#123; if (left == right) &#123; return; &#125; res = Math.max(res, (right - left) * Math.min(height[right], height[left])); dfs(left + 1, right); dfs(left, right - 1); &#125; int n, res = 0; int[] height;&#125; 15. 三数之和二刷没做出来 方法一：排序 + 双指针 123456789101112131415161718192021222324252627282930class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Arrays.sort(nums); int n = nums.length; for (int i = 0; i &lt; n - 2; ++i) &#123; if (nums[i] &gt; 0) break; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue; int left = i + 1, right = n - 1; while (left &lt; right) &#123; if (nums[i] + nums[left] + nums[right] == 0) &#123; res.add(Arrays.asList(nums[i], nums[left], nums[right])); while (left &lt; right &amp;&amp; nums[left + 1] == nums[left]) ++left; while (left &lt; right &amp;&amp; nums[right - 1] == nums[right]) --right; ++left; --right; &#125; else if (nums[i] + nums[left] + nums[right] &lt; 0) ++left; else --right; &#125; &#125; return res; &#125;&#125; 17. 电话号码的字母组合 方法一：回溯 12345678910111213141516171819202122232425class Solution &#123; public List&lt;String&gt; letterCombinations(String digits) &#123; dfs(digits, 0); return res; &#125; private void dfs(String digits, int index) &#123; if (index == digits.length()) &#123; if (sb.length() &gt; 0) res.add(new String(sb)); return; &#125; int curDigit = digits.charAt(index) - &#x27;0&#x27;; // 2 String curStr = map[curDigit]; for (int i = 0; i &lt; curStr.length(); ++i) &#123; sb.append(curStr.charAt(i)); dfs(digits, index + 1); sb.deleteCharAt(sb.length() - 1); &#125; &#125; String[] map = new String[]&#123;&quot;&quot;, &quot;&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;&#125;; List&lt;String&gt; res = new ArrayList&lt;&gt;(); StringBuilder sb = new StringBuilder();&#125; 19. 删除链表的倒数第 N 个结点 方法一：模拟 1234567891011121314151617181920212223/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode dummyHead = new ListNode(-1, head), cur = head, pre = dummyHead; for (int i = 0; i &lt; n; ++i) cur = cur.next; while (cur != null) &#123; cur = cur.next; pre = pre.next; &#125; pre.next = pre.next.next; return dummyHead.next; &#125;&#125; 20. 有效的括号 方法一：栈 + HashMap 模拟 123456789101112131415161718192021class Solution &#123; public boolean isValid(String s) &#123; Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); Map&lt;Character, Character&gt; map = new HashMap&lt;&gt;(); map.put(&#x27;)&#x27;, &#x27;(&#x27;); map.put(&#x27;&#125;&#x27;, &#x27;&#123;&#x27;); map.put(&#x27;]&#x27;, &#x27;[&#x27;); for (int i = 0; i &lt; s.length(); ++i) &#123; char ch = s.charAt(i); if (ch == &#x27;(&#x27; || ch == &#x27;[&#x27; || ch == &#x27;&#123;&#x27;) stack.push(ch); else &#123; if (stack.isEmpty()) return false; if (map.get(ch) != stack.pop()) return false; &#125; &#125; return stack.isEmpty(); &#125;&#125; 21. 合并两个有序链表 方法二：递归 题解 1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode mergeTwoLists(ListNode list1, ListNode list2) &#123; if (list1 == null) return list2; if (list2 == null) return list1; if (list1.val &lt; list2.val) &#123; list1.next = mergeTwoLists(list1.next, list2); return list1; &#125; else &#123; list2.next = mergeTwoLists(list1, list2.next); return list2; &#125; &#125;&#125; 方法三：迭代 123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if (l1 == null || l2 == null) return l1 == null ? l2 : l1; ListNode dummyHead = new ListNode(), cur = dummyHead; while (l1 != null &amp;&amp; l2 != null) &#123; if (l1.val &lt; l2.val) &#123; cur.next = l1; l1 = l1.next; &#125; else &#123; cur.next = l2; l2 = l2.next; &#125; cur = cur.next; &#125; cur.next = l1 == null ? l2 : l1; return dummyHead.next; &#125;&#125; 方法一：模拟 1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode mergeTwoLists(ListNode list1, ListNode list2) &#123; if (list1 == null) return list2; if (list2 == null) return list1; ListNode dummyHead = new ListNode(-1), cur = dummyHead; while (list1 != null &amp;&amp; list2 != null) &#123; if (list1.val &lt; list2.val) &#123; cur.next = new ListNode(list1.val); list1 = list1.next; &#125; else &#123; cur.next = new ListNode(list2.val); list2 = list2.next; &#125; cur = cur.next; &#125; if (list1 == null) cur.next = list2; if (list2 == null) cur.next = list1; return dummyHead.next; &#125;&#125; 22. 括号生成 方法一：回溯 12345678910111213141516171819202122232425262728class Solution &#123; public List&lt;String&gt; generateParenthesis(int n) &#123; this.n = n; dfs(0, 0); return res; &#125; private void dfs(int left, int right) &#123; if (left + right == 2 * n) &#123; res.add(new String(sb)); return; &#125; if (left &lt; n) &#123; sb.append(&#x27;(&#x27;); dfs(left + 1, right); sb.deleteCharAt(sb.length() - 1); &#125; if (left &gt; right) &#123; sb.append(&#x27;)&#x27;); dfs(left, right + 1); sb.deleteCharAt(sb.length() - 1); &#125; &#125; List&lt;String&gt; res = new ArrayList&lt;&gt;(); StringBuilder sb = new StringBuilder(); int n;&#125; 23. 合并 K 个升序链表 方法一：暴力 把所有ListNode的值加入小根堆 不断弹出小根堆，并创建新节点 12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode mergeKLists(ListNode[] lists) &#123; PriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;(); for (ListNode node : lists) &#123; ListNode cur = node; while (cur != null) &#123; queue.add(cur.val); cur = cur.next; &#125; &#125; ListNode dummyHead = new ListNode(-1), cur = dummyHead; while (!queue.isEmpty()) &#123; cur.next = new ListNode(queue.poll()); cur = cur.next; &#125; return dummyHead.next; &#125;&#125; 方法二：迭代 **注意：**debug很久，类比一道题：给出一个链表的头节点head，初始cur指向head，然后遍历cur，让cur = cur.next，head的位置没有变 12 // minNode = minNode.next; 没有修改头节点的指针lists[minIndex] = lists[minIndex].next; // 添加这行代码以更新指针 代码 123456789101112131415161718192021222324252627282930313233343536/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode mergeKLists(ListNode[] lists) &#123; ListNode dummyHead = new ListNode(-1), cur = dummyHead; int k = lists.length; while (true) &#123; int minIndex = -1, minVal = 10001; ListNode minNode = null; for (int i = 0; i &lt; k; ++i) &#123; if (lists[i] == null) continue; if (minVal &gt; lists[i].val) &#123; minVal = lists[i].val; minIndex = i; minNode = lists[i]; &#125; &#125; if (minIndex == -1) break; cur.next = minNode; cur = cur.next; // minNode = minNode.next; 没有修改头节点的指针 lists[minIndex] = lists[minIndex].next; // 添加这行代码以更新指针 &#125; return dummyHead.next; &#125;&#125; 方法三：小根堆优化方法二 不能按照以下方式初始化queue的大小，会报错 1PriorityQueue&lt;ListNode&gt; queue = new PriorityQueue&lt;&gt;(k, (v1, v2) -&gt; v1.val - v2.val); 代码 1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode mergeKLists(ListNode[] lists) &#123; ListNode dummyHead = new ListNode(-1), cur = dummyHead; int k = lists.length; PriorityQueue&lt;ListNode&gt; queue = new PriorityQueue&lt;&gt;((v1, v2) -&gt; v1.val - v2.val); for (ListNode x : lists) if (x != null) queue.add(x); while (!queue.isEmpty()) &#123; ListNode minNode = queue.poll(); cur.next = minNode; cur = cur.next; minNode = minNode.next; if (minNode != null) queue.add(minNode); &#125; return dummyHead.next; &#125;&#125; 方法四：分治 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode mergeKLists(ListNode[] lists) &#123; return merge(lists, 0, lists.length - 1); &#125; public ListNode merge(ListNode[] lists, int l, int r) &#123; if (l == r) return lists[l]; else if (l &gt; r) return null; int mid = (l + r) &gt;&gt; 1; ListNode l1 = merge(lists, l, mid); ListNode l2 = merge(lists, mid + 1, r); return mergeTwoList(l1, l2); &#125; public ListNode mergeTwoList(ListNode l1, ListNode l2) &#123; if (l1 == null || l2 == null) return l1 == null ? l2 : l1; if (l1.val &lt; l2.val) &#123; l1.next = mergeTwoList(l1.next, l2); return l1; &#125; else &#123; l2.next = mergeTwoList(l1, l2.next); return l2; &#125; &#125;&#125; 31. 下一个排列 方法一：双指针模拟 题解 123456789101112131415161718192021222324252627282930class Solution &#123; public void nextPermutation(int[] nums) &#123; // 1. 从后往前，找到第一个升序序列，nums[i] &lt; nums[j] (i &lt; j) int n = nums.length, i = n - 2, j = n - 1, k = n - 1; if (n == 1) return; while (i &gt;= 0 &amp;&amp; nums[i] &gt;= nums[j]) &#123; --i; --j; &#125; // 如果i == -1，则此时nums是最大的逆序对，跳转到第3步(全部翻转) // 2.从后往前，找到第一个大于nums[i]的数nums[k]，并swap (nums[k]是最小的大于nums[i]的数) if (i &gt;= 0) &#123; while (nums[k] &lt;= nums[i]) --k; int temp = nums[i]; nums[i] = nums[k]; nums[k] = temp; &#125; // 3.将j到末尾的子数组翻转 k = n - 1; while (j &lt; k) &#123; int temp = nums[j]; nums[j] = nums[k]; nums[k] = temp; ++j; --k; &#125; &#125;&#125; 32. 最长有效括号 方法一：DP 123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public int longestValidParentheses(String s) &#123; int n = s.length(), max = 0; // dp[i]: 以s.charAt(i)结尾的子串的最长有效括号长度 int[] dp = new int[n]; // 1.找到第一个左括号，前面的右括号是无效的 int start = 0; while (start &lt; n) &#123; if (s.charAt(start) == &#x27;(&#x27;) break; ++start; &#125; for (int i = start + 1; i &lt; n; ++i) &#123; char pre = s.charAt(i - 1), ch = s.charAt(i); // 2.只考虑右括号 if (ch == &#x27;)&#x27;) &#123; // 如果前一个括号是左括号，那么以ch结尾的子串至少长为2，如果前面也有有小括号，把长度累加 if (pre == &#x27;(&#x27;) dp[i] = 2 + (i - 2 &gt; start ? dp[i - 2] : 0); // 前一个括号是右括号 else &#123; // 3.考虑 &quot;((()))&quot; // 如果前一个右括号形成了有效括号，并且这个有效括号的前一个字符是&#x27;(&#x27;，那么以ch结尾的子串至少 // 长为2 + dp[i - 1] //4.考虑 &quot;()(())&quot;，计算出&quot;(())&quot;后，再往前面找一位，如果有有效括号，继续累加 // 在3.的基础上，在 if (dp[i - 1] &gt; 0 &amp;&amp; i - dp[i - 1] &gt; start &amp;&amp; s.charAt(i - dp[i - 1] - 1) == &#x27;(&#x27;) &#123; dp[i] = 2 + dp[i - 1] + (i - dp[i - 1] - 2 &gt; start ? dp[i - dp[i - 1] - 2] : 0); &#125; &#125; &#125; max = Math.max(max, dp[i]); &#125; return max; &#125;&#125;","categories":[],"tags":[]},{"title":"Digit Dynamic Programming","slug":"digit-dynamic-programming","date":"2023-07-30T15:03:39.000Z","updated":"2023-07-31T14:48:40.024Z","comments":true,"path":"2023/07/30/digit-dynamic-programming/","link":"","permalink":"https://leopol1d.github.io/2023/07/30/digit-dynamic-programming/","excerpt":"","text":"数位 DP 灵神视频 数位是指把一个数字按照个、十、百、千等等一位一位地拆开，关注它每一位上的数字。如果拆的是十进制数，那么每一位数字都是 0~9，其他进制可类比十进制。 数位 DP：用来解决一类特定问题，这种问题比较好辨认，一般具有这几个特征： 要求统计满足一定条件的数的数量（即，最终目的为计数）； 这些条件经过转化后可以使用「数位」的思想去理解和判断； 输入会提供一个数字区间（有时也只提供上界）来作为统计的限制； 上界很大（比如 ），暴力枚举验证会超时。 数位 DP 的基本原理： 考虑人类计数的方式，最朴素的计数就是从小到大开始依次加一。但我们发现对于位数比较多的数，这样的过程中有许多重复的部分。例如，从 7000 数到 7999、从 8000 数到 8999、和从 9000 数到 9999 的过程非常相似，它们都是后三位从 000 变到 999，不一样的地方只有千位这一位，所以我们可以把这些过程归并起来，将这些过程中产生的计数答案也都存在一个通用的数组里。此数组根据题目具体要求设置状态，用递推或 DP 的方式进行状态转移。 数位 DP 中通常会利用常规计数问题技巧，比如把一个区间内的答案拆成两部分相减（即 ） 那么有了通用答案数组，接下来就是统计答案。统计答案可以选择记忆化搜索，也可以选择循环迭代递推。为了不重不漏地统计所有不超过上限的答案，要从高到低枚举每一位，再考虑每一位都可以填哪些数字，最后利用通用答案数组统计答案。 2719. 统计整数数目 方法一：数位DP 题解 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123; int min_sum, max_sum, n, MOD = (int) (1e9 + 7); int[][] dp; public int count(String num1, String num2, int min_sum, int max_sum) &#123; this.min_sum = min_sum; this.max_sum = max_sum; int res = count(num2) - count(num1) + MOD; int temp = count(num2); int sum = 0; for (int i = 0; i &lt; num1.length(); ++i) sum += num1.charAt(i) - &#x27;0&#x27;; if (sum &gt;= min_sum &amp;&amp; sum &lt;= max_sum) ++res; return res % MOD; &#125; private int count(String num) &#123; n = num.length(); dp = new int[n][401]; for (int[] arr : dp) Arrays.fill(arr, -1); return dfs(num, 0, 0, true); &#125; private int dfs(String num, int index, int preSum, boolean isLimit) &#123; if (preSum &gt; max_sum) return 0; if (index == num.length()) return preSum &gt;= min_sum ? 1 : 0; if (!isLimit &amp;&amp; dp[index][preSum] != -1) return dp[index][preSum]; int upperBound = isLimit ? num.charAt(index) - &#x27;0&#x27; : 9; int res = 0; for (int i = 0; i &lt;= upperBound; ++i) res = (res + dfs(num, index + 1, preSum + i, isLimit &amp;&amp; i == upperBound)) % MOD; if (!isLimit) dp[index][preSum] = res; return res; &#125;&#125; 2376. 统计特殊整数 方法一：数位DP 123456789101112131415161718192021222324252627282930313233class Solution &#123; int n; int[][] dp; String num; public int countSpecialNumbers(int n) &#123; num = String.valueOf(n); this.n = num.length(); dp = new int[this.n][1 &lt;&lt; 10]; for (int[] arr : dp) Arrays.fill(arr, -1); return dfs(0, 0, true, false); &#125; private int dfs(int index, int mask, boolean isLimit, boolean isNum) &#123; if (index == n) return isNum ? 1 : 0;// isNum 为 true 表示得到了一个合法数字 if (!isLimit &amp;&amp; isNum &amp;&amp; dp[index][mask] != -1) return dp[index][mask]; int res = 0; if (!isNum) // 可以跳过当前数位 (继续填0) res += dfs(index + 1, mask, false, false); // 如果前面填的数字都和 n 的一样，那么这一位至多填数字 s[i]（否则就超过 n 啦） int upperBound = isLimit ? num.charAt(index) - &#x27;0&#x27; : 9; // 如果isNum,是前导0，那么i从0开始；否则不是前导0，i从1开始 for (int i = isNum ? 0 : 1; i &lt;= upperBound; ++i) if ((mask &gt;&gt; i &amp; 1) == 0) // d 不在 mask 中 res += dfs(index + 1, mask | 1 &lt;&lt; i, isLimit &amp;&amp; i == upperBound, true); if (!isLimit &amp;&amp; isNum) dp[index][mask] = res; return res; &#125;&#125; 233. 数字 1 的个数 方法一：数位DP 12345678910111213141516171819202122232425262728class Solution &#123; int n; int[][] dp; String num; public int countDigitOne(int n) &#123; num = String.valueOf(n); dp = new int[num.length()][9]; for (int[] arr : dp) Arrays.fill(arr, -1); this.n = num.length(); return dfs(0, 0, true); &#125; private int dfs(int index, int count, boolean isLimit) &#123; if (index == n) return count; if (!isLimit &amp;&amp; dp[index][count] != -1) return dp[index][count]; int res = 0, cur = num.charAt(index) - &#x27;0&#x27;; int upperBound = isLimit ? cur : 9; for (int i = 0; i &lt;= upperBound; ++i) res += dfs(index + 1, count + (i == 1 ? 1 : 0), isLimit &amp;&amp; i == upperBound); if (!isLimit) dp[index][count] = res; return res; &#125;&#125; 面试题 17.06. 2出现的次数 方法一：数位DP 把上一题的1改成2即可 12345678910111213141516171819202122232425262728class Solution &#123; int n; int[][] dp; String num; public int numberOf2sInRange(int n) &#123; num = String.valueOf(n); dp = new int[num.length()][9]; for (int[] arr : dp) Arrays.fill(arr, -1); this.n = num.length(); return dfs(0, 0, true); &#125; private int dfs(int index, int count, boolean isLimit) &#123; if (index == n) return count; if (!isLimit &amp;&amp; dp[index][count] != -1) return dp[index][count]; int res = 0, cur = num.charAt(index) - &#x27;0&#x27;; int upperBound = isLimit ? cur : 9; for (int i = 0; i &lt;= upperBound; ++i) res += dfs(index + 1, count + (i == 2 ? 1 : 0), isLimit &amp;&amp; i == upperBound); if (!isLimit) dp[index][count] = res; return res; &#125;&#125; 1012. 至少有 1 位重复的数字 方法一：数位DP n - 2719. 统计整数数目返回的结果 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public int numDupDigitsAtMostN(int n) &#123; return n - countSpecialNumbers(n); &#125; int n; int[][] dp; String num; public int countSpecialNumbers(int n) &#123; num = String.valueOf(n); this.n = num.length(); dp = new int[this.n][1 &lt;&lt; 10]; for (int[] arr : dp) Arrays.fill(arr, -1); return dfs(0, 0, true, false); &#125; private int dfs(int index, int mask, boolean isLimit, boolean isNum) &#123; if (index == n) return isNum ? 1 : 0;// isNum 为 true 表示得到了一个合法数字 if (!isLimit &amp;&amp; isNum &amp;&amp; dp[index][mask] != -1) return dp[index][mask]; int res = 0; if (!isNum) // 可以跳过当前数位 (继续填0) res += dfs(index + 1, mask, false, false); // 如果前面填的数字都和 n 的一样，那么这一位至多填数字 s[i]（否则就超过 n 啦） int upperBound = isLimit ? num.charAt(index) - &#x27;0&#x27; : 9; // 如果isNum,是前导0，那么i从0开始；否则不是前导0，i从1开始 for (int i = isNum ? 0 : 1; i &lt;= upperBound; ++i) if ((mask &gt;&gt; i &amp; 1) == 0) // d 不在 mask 中 res += dfs(index + 1, mask | 1 &lt;&lt; i, isLimit &amp;&amp; i == upperBound, true); if (!isLimit &amp;&amp; isNum) dp[index][mask] = res; return res; &#125;&#125; 600. 不含连续1的非负整数 方法一：数位DP 注意：res += dfs(index + 1, i, isLimit &amp;&amp; i == upperBound);不要把i写成cur！！！ 12345678910111213141516171819202122232425262728293031class Solution &#123; int length; int[][] dp; String num; public int findIntegers(int n) &#123; num = Integer.toBinaryString(n); length = num.length(); dp = new int[length][2]; for (int[] arr : dp) Arrays.fill(arr, -1); return dfs(0, 0, true); &#125; private int dfs(int index, int pre, boolean isLimit) &#123; if (index == length) return 1; if (!isLimit &amp;&amp; dp[index][pre] != -1) return dp[index][pre]; int res = 0, cur = num.charAt(index) - &#x27;0&#x27;; int upperBound = isLimit ? cur : 1; for (int i = 0; i &lt;= upperBound; ++i) &#123; if (pre == 1 &amp;&amp; i == 1) continue; res += dfs(index + 1, i, isLimit &amp;&amp; i == upperBound); &#125; if (!isLimit) dp[index][pre] = res; return res; &#125;&#125; 902. 最大为 N 的数字组合 方法一：数位DP 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; String[] digits; int length, n; String num; int[] dp; public int atMostNGivenDigitSet(String[] digits, int n) &#123; this.n = n; this.digits = digits; num = String.valueOf(n); length = num.length(); dp = new int[length]; Arrays.fill(dp, -1); return dfs(0, true, false); &#125; private int dfs(int index, boolean isLimit, boolean isNum) &#123; if (index == length) return isNum ? 1 : 0; if (!isLimit &amp;&amp; isNum &amp;&amp; dp[index] != -1) return dp[index]; int res = 0, cur = num.charAt(index) - &#x27;0&#x27;; if (!isNum) res += dfs(index + 1, false, false); for (String x : digits) &#123; int val = Integer.parseInt(x); if (isLimit &amp;&amp; val &gt; cur) break; res += dfs(index + 1, isLimit &amp;&amp; val == cur, true); &#125; if (!isLimit &amp;&amp; isNum) dp[index] = res; return res; &#125;&#125; 1397. 找到所有好字符串","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://leopol1d.github.io/categories/Algorithms/"},{"name":"Dynamic Programming","slug":"Algorithms/Dynamic-Programming","permalink":"https://leopol1d.github.io/categories/Algorithms/Dynamic-Programming/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://leopol1d.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"lcp356","slug":"lcp356","date":"2023-07-30T02:18:06.000Z","updated":"2023-08-01T08:29:05.050Z","comments":true,"path":"2023/07/30/lcp356/","link":"","permalink":"https://leopol1d.github.io/2023/07/30/lcp356/","excerpt":"","text":"第一题 满足目标工作时长的员工数目 方法一：模拟 123456789class Solution &#123; public int numberOfEmployeesWhoMetTarget(int[] hours, int target) &#123; int res = 0; for (int x : hours) if (x &gt;= target) ++res; return res; &#125;&#125; 第二题统计完全子数组的数目 方法一：HashSet 12345678910111213141516171819class Solution &#123; public int countCompleteSubarrays(int[] nums) &#123; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int x : nums) set.add(x); int length = set.size(), res = 0, n = nums.length; // 以第i位结尾，有多少完全子数组，i &gt;= length for (int i = length - 1; i &lt; n; ++i) &#123; Set s = new HashSet(); for (int j = i; j &gt;= 0; --j) &#123; s.add(nums[j]); if (s.size() == length) &#123; ++res; &#125; &#125; &#125; return res; &#125;&#125; 第三题包含三个字符串的最短字符串 方法一： 1 第四题 方法一： 1 2719. 统计整数数目 2376. 统计特殊整数","categories":[{"name":"Contest","slug":"Contest","permalink":"https://leopol1d.github.io/categories/Contest/"},{"name":"LCP","slug":"Contest/LCP","permalink":"https://leopol1d.github.io/categories/Contest/LCP/"}],"tags":[{"name":"力扣杯","slug":"力扣杯","permalink":"https://leopol1d.github.io/tags/%E5%8A%9B%E6%89%A3%E6%9D%AF/"}]},{"title":"Binary Index Tree","slug":"binary-index-tree","date":"2023-07-29T14:18:22.000Z","updated":"2023-07-30T02:19:54.159Z","comments":true,"path":"2023/07/29/binary-index-tree/","link":"","permalink":"https://leopol1d.github.io/2023/07/29/binary-index-tree/","excerpt":"","text":"数组不变，区间查询：前缀和、树状数组、线段树； 数组单点修改，区间查询：树状数组、线段树； 数组区间修改，单点查询：差分、线段树； 数组区间修改，区间查询：线段树。 链接 优质博客 模板 1234567891011121314151617181920212223242526272829303132333435 // 上来先把三个方法写出来&#123; int[] tree; int lowbit(int x) &#123; return x &amp; -x; &#125; // 查询前缀和的方法 int query(int x) &#123; int ans = 0; for (int i = x; i &gt; 0; i -= lowbit(i)) ans += tree[i]; return ans; &#125; // 在树状数组 x 位置中增加值 u void add(int x, int u) &#123; for (int i = x; i &lt;= n; i += lowbit(i)) tree[i] += u; &#125;&#125;// 初始化「树状数组」，要默认数组是从 1 开始&#123; for (int i = 0; i &lt; n; i++) add(i + 1, nums[i]);&#125;// 使用「树状数组」：&#123; void update(int i, int val) &#123; // 原有的值是 nums[i]，要使得修改为 val，需要增加 val - nums[i] add(i + 1, val - nums[i]); nums[i] = val; &#125; int sumRange(int l, int r) &#123; return query(r + 1) - query(l); &#125;&#125; 307. 区域和检索 - 数组可修改 方法一：树状数组 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class NumArray &#123; int n; int[] tree, nums; int lowbit(int x) &#123; return x &amp; -x; &#125; // 查询前缀和的方法 int query(int x) &#123; int ans = 0; for (int i = x; i &gt; 0; i -= lowbit(i)) ans += tree[i]; return ans; &#125; // 在树状数组 x 位置中增加值 u void add(int x, int u) &#123; for (int i = x; i &lt;= n; i += lowbit(i)) tree[i] += u; &#125; void init(int[] nums) &#123; tree = new int[nums.length + 1]; for (int i = 0; i &lt; nums.length; ++i) add(i + 1, nums[i]); &#125; public NumArray(int[] nums) &#123; this.nums = nums; n = nums.length; init(nums); &#125; public void update(int index, int val) &#123; add(index + 1, val - nums[index]); nums[index] = val; &#125; public int sumRange(int left, int right) &#123; return query(right + 1) - query(left); &#125;&#125;/** * Your NumArray object will be instantiated and called as such: * NumArray obj = new NumArray(nums); * obj.update(index,val); * int param_2 = obj.sumRange(left,right); */","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://leopol1d.github.io/categories/Algorithms/"},{"name":"Binary Index Tree","slug":"Algorithms/Binary-Index-Tree","permalink":"https://leopol1d.github.io/categories/Algorithms/Binary-Index-Tree/"}],"tags":[{"name":"树状数组","slug":"树状数组","permalink":"https://leopol1d.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"}]},{"title":"lcpBi103","slug":"lcpBi103","date":"2023-07-29T07:50:13.000Z","updated":"2023-08-01T08:29:10.244Z","comments":true,"path":"2023/07/29/lcpBi103/","link":"","permalink":"https://leopol1d.github.io/2023/07/29/lcpBi103/","excerpt":"","text":"K 个元素的最大和 方法二：等差数列 123456789class Solution &#123; public int maximizeSum(int[] nums, int k) &#123; int max = 0; for (int x : nums) max = Math.max(max, x); // max + (max + 1) + ... + (max + k - 1) return (max * 2 + k - 1) * k / 2; &#125;&#125; 时间复杂度：$O(n)$ 方法一：模拟 1234567891011class Solution &#123; public int maximizeSum(int[] nums, int k) &#123; Arrays.sort(nums); int n = nums.length, res = 0, cur = nums[n - 1]; for (int i = 0; i &lt; k; ++i) &#123; res += cur; ++cur; &#125; return res; &#125;&#125; 时间复杂度：$O(nlogn)$ 找到两个数组的前缀公共数组 方法二：位运算 左移的时候是1L!!!,1是整型 12345678910111213class Solution &#123; public int[] findThePrefixCommonArray(int[] A, int[] B) &#123; long a = 0, b = 0; int n = A.length; int[] res = new int[n]; for (int i = 0; i &lt; n; ++i) &#123; a |= 1L &lt;&lt; A[i]; b |= 1L &lt;&lt; B[i]; res[i] = Long.bitCount(a &amp; b); &#125; return res; &#125;&#125; 方法一：HashMap 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public int[] findThePrefixCommonArray(int[] A, int[] B) &#123; int n = A.length; int[] res = new int[n]; Map&lt;Integer, Integer&gt; map1 = new HashMap&lt;&gt;(), map2 = new HashMap&lt;&gt;(); for (int i = 0; i &lt; n; ++i) &#123; int temp = 0; if (A[i] == B[i]) &#123; if (i == 0) res[i] = 1; else &#123; res[i] = res[i - 1] + 1; &#125; &#125; else &#123; if (map2.containsKey(A[i])) &#123; ++temp; map2.remove(A[i]); &#125; else map1.put(A[i], i); if (map1.containsKey(B[i])) &#123; ++temp; map1.remove(B[i]); &#125; else map2.put(B[i], i); if (i == 0) res[0] = 0; else &#123; res[i] = res[i - 1] + temp; &#125; &#125; &#125; return res; &#125;&#125; 网格图中鱼的最大数目 方法一：DFS 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public int findMaxFish(int[][] grid) &#123; this.grid = grid; m = grid.length; n = grid[0].length; visited = new boolean[m][n]; for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (grid[i][j] &gt; 0) &#123; res = Math.max(res, dfs(i, j)); &#125; &#125; &#125; return res; &#125; private int dfs(int i, int j) &#123; visited[i][j] = true; int count = grid[i][j]; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col) &amp;&amp; grid[row][col] &gt; 0 &amp;&amp; !visited[row][col]) &#123; count += dfs(row, col); &#125; &#125; return count; &#125; int m, n, res = 0; int[][] grid, dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; boolean[][] visited; private boolean isValid(int i, int j) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125;&#125; 方法二：并查集 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution &#123; public int findMaxFish(int[][] grid) &#123; this.grid = grid; m = grid.length; n = grid[0].length; init(m * n); for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (grid[i][j] &gt; 0) &#123; int index = i * n + j; fish[index] = grid[i][j]; if (i &gt; 0 &amp;&amp; grid[i - 1][j] &gt; 0) &#123; union(index, index - n); &#125; if (j &gt; 0 &amp;&amp; grid[i][j - 1] &gt; 0) &#123; union(index, index - 1); &#125; &#125; &#125; &#125; for (int x : fish) res = Math.max(res, x); return res; &#125; int m, n, res = 0; int[][] grid; int[] parent, fish; private boolean union(int i, int j) &#123; int rootI = findParent(i), rootJ = findParent(j); if (rootI != rootJ) &#123; parent[rootJ] = rootI; fish[rootI] += fish[rootJ]; fish[rootJ] = 0; return true; &#125; return false; &#125; private int findParent(int i) &#123; if (i != parent[i]) parent[i] = findParent(parent[i]); return parent[i]; &#125; private void init(int n) &#123; parent = new int[n]; for (int i = 0; i &lt; n; ++i) parent[i] = i; fish = new int[n]; &#125;&#125;","categories":[{"name":"Contest","slug":"Contest","permalink":"https://leopol1d.github.io/categories/Contest/"},{"name":"LCP","slug":"Contest/LCP","permalink":"https://leopol1d.github.io/categories/Contest/LCP/"}],"tags":[{"name":"力扣杯","slug":"力扣杯","permalink":"https://leopol1d.github.io/tags/%E5%8A%9B%E6%89%A3%E6%9D%AF/"}]},{"title":"lcpBi102","slug":"lcpBi102","date":"2023-07-27T07:12:45.000Z","updated":"2023-08-01T08:29:07.845Z","comments":true,"path":"2023/07/27/lcpBi102/","link":"","permalink":"https://leopol1d.github.io/2023/07/27/lcpBi102/","excerpt":"","text":"查询网格图中每一列的宽度 方法一：模拟 12345678910111213141516171819class Solution &#123; public int[] findColumnWidth(int[][] grid) &#123; int m = grid.length, n = grid[0].length; int[] res = new int[n]; for (int j = 0; j &lt; n; ++j) &#123; int max = 0; for (int i = 0; i &lt; m; ++i) &#123; int num = grid[i][j], count = num &gt; 0 ? 0 : 1; while (num != 0) &#123; num /= 10; ++count; &#125; max = Math.max(max, count); res[j] = max; &#125; &#125; return res; &#125;&#125; 一个数组所有前缀的分数 方法一：前缀和 12345678910111213class Solution &#123; public long[] findPrefixScore(int[] nums) &#123; int n = nums.length; long[] conver = new long[n], res = new long[n]; long max = 0; for (int i = 0; i &lt; n; ++i) &#123; max = Math.max(max, nums[i]); conver[i] = nums[i] + max; res[i] = (i &gt; 0 ? res[i - 1] : 0)+ conver[i]; &#125; return res; &#125;&#125; 二叉树的堂兄弟节点 II 方法一： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public TreeNode replaceValueInTree(TreeNode root) &#123; Map&lt;Integer, int[]&gt; map = new HashMap&lt;&gt;(); Map&lt;Integer, Integer&gt; sum = new HashMap&lt;&gt;(); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); root.val = 0; if (root.left != null) &#123; root.left.val = 0; queue.offer(root.left); &#125; if (root.right != null) &#123; root.right.val = 0; queue.offer(root.right); &#125; int level = 1; while (!queue.isEmpty()) &#123; int size = queue.size(); int levelSum = 0; for (int i = 0; i &lt; size; ++i) &#123; TreeNode node = queue.poll(); levelSum += node.val; if (node.left != null) queue.offer(node.left); if (node.right != null) queue.offer(node.right); &#125; if (level &gt;= 2) sum.put(level, levelSum); ++level; &#125; level = 0; queue.offer(root); while (!queue.isEmpty()) &#123; int size = queue.size(); int levelSum = 0; if (level &gt;= 1) levelSum = sum.getOrDefault(level + 1, 0); for (int i = 0; i &lt; size; ++i) &#123; int curSum = 0; TreeNode node = queue.poll(); if (node.left != null) &#123; curSum += node.left.val; queue.offer(node.left); &#125; if (node.right != null) &#123; curSum += node.right.val; queue.offer(node.right); &#125; if (node.left != null) &#123; node.left.val = levelSum - curSum; &#125; if (node.right != null) &#123; node.right.val = levelSum - curSum; &#125; &#125; ++level; &#125; return root; &#125;&#125; 设计可以求最短路径的图类 方法一：dijkstra 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 class Graph &#123; int n; int inf = Integer.MAX_VALUE &gt;&gt; 1; int[][] graph; public Graph(int n, int[][] edges) &#123; this.n = n; graph = new int[n][n]; for (int[] arr : graph) Arrays.fill(arr, inf); for (int[] edge : edges) &#123; graph[edge[0]][edge[1]] = edge[2]; &#125; &#125; public void addEdge(int[] edge) &#123; graph[edge[0]][edge[1]] = edge[2]; &#125; public int shortestPath(int from, int to) &#123; int[] dist = new int[n]; Arrays.fill(dist, inf); boolean[] visited = new boolean[n]; dist[from] = 0; for (int i = 0; i &lt; n; ++i) &#123; int minIndex = -1, minDist = inf; for (int j = 0; j &lt; n; ++j) &#123; if (!visited[j] &amp;&amp; dist[j] &lt; minDist) &#123; minDist = dist[j]; minIndex = j; &#125; &#125; if (minIndex == to) return minDist; if (minIndex == -1) // not connected return -1; visited[minIndex] = true; for (int j = 0; j &lt; n; ++j) &#123; if (!visited[j] &amp;&amp; dist[j] &gt; minDist + graph[minIndex][j]) dist[j] = minDist + graph[minIndex][j]; &#125; &#125; return -1; &#125; &#125;/** * Your Graph object will be instantiated and called as such: * Graph obj = new Graph(n, edges); * obj.addEdge(edge); * int param_2 = obj.shortestPath(node1,node2); */ 方法二：floyd 123456789101112131415161718192021222324252627282930313233343536373839404142 class Graph &#123; int n; int inf = Integer.MAX_VALUE &gt;&gt; 2; // 只右移一位会溢出 int[][] dp; public Graph(int n, int[][] edges) &#123; this.n = n; dp = new int[n][n]; for (int[] arr : dp) Arrays.fill(arr, inf); for (int i = 0; i &lt; n; ++i) dp[i][i] = 0; // 为了增加边时更新 for (int[] edge : edges) dp[edge[0]][edge[1]] = edge[2]; for (int k = 0; k &lt; n; ++k) for (int i = 0; i &lt; n; ++i) for (int j = 0; j &lt; n; ++j) dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k][j]); &#125; public void addEdge(int[] edge) &#123; int x = edge[0], y = edge[1], w = edge[2]; if (w &gt;= dp[x][y]) // 如果权重比原来的还大，不更新(bu&#x27;neng&#x27;sheng) return; dp[x][y] = w; for (int i = 0; i &lt; n; ++i) for (int j = 0; j &lt; n; ++j) dp[i][j] = Math.min(dp[i][j], dp[i][x] + dp[x][y] + dp[y][j]); &#125; public int shortestPath(int from, int to) &#123; return dp[from][to] &lt; inf ? dp[from][to] : -1; &#125; &#125;/** * Your Graph object will be instantiated and called as such: * Graph obj = new Graph(n, edges); * obj.addEdge(edge); * int param_2 = obj.shortestPath(node1,node2); */","categories":[{"name":"Contest","slug":"Contest","permalink":"https://leopol1d.github.io/categories/Contest/"},{"name":"LCP","slug":"Contest/LCP","permalink":"https://leopol1d.github.io/categories/Contest/LCP/"}],"tags":[{"name":"力扣杯","slug":"力扣杯","permalink":"https://leopol1d.github.io/tags/%E5%8A%9B%E6%89%A3%E6%9D%AF/"}]},{"title":"lcp343","slug":"lcp343","date":"2023-07-26T06:44:10.000Z","updated":"2023-08-01T08:28:29.051Z","comments":true,"path":"2023/07/26/lcp343/","link":"","permalink":"https://leopol1d.github.io/2023/07/26/lcp343/","excerpt":"","text":"保龄球游戏的获胜者 方法一：模拟 1234567891011121314151617class Solution &#123; public int isWinner(int[] player1, int[] player2) &#123; int sum1 = 0, sum2 = 0; int flag1 = 0, flag2 = 0; for (int i = 0; i &lt; player1.length; ++i) &#123; sum1 += player1[i] + (flag1-- &gt; 0 ? player1[i] : 0); sum2 += player2[i] + (flag2-- &gt; 0 ? player2[i] : 0); if (player1[i] == 10) flag1 = 2; if (player2[i] == 10) flag2 = 2; &#125; if (sum1 == sum2) return 0; return sum1 &gt; sum2 ? 1 : 2; &#125;&#125; 找出叠涂元素 方法一：HashMap 1234567891011121314151617181920class Solution &#123; public int firstCompleteIndex(int[] arr, int[][] mat) &#123; int m = mat.length, n = mat[0].length; Map&lt;Integer, int[]&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; m; ++i) for (int j = 0; j &lt; n; ++j) map.put(mat[i][j], new int[]&#123;i, j&#125;); int[] countR = new int[m], countC = new int[n]; Arrays.fill(countR, n); Arrays.fill(countC, m); for (int i = 0; i &lt; m * n; ++i) &#123; int[] rc = map.get(arr[i]); if (--countR[rc[0]] == 0) return i; if (--countC[rc[1]] == 0) return i; &#125; return m * n - 1; &#125;&#125; 2662. 前往目标的最小代价 方法一：dijkstra Debug两小时的原因 int vx = (int) minIndex &gt;&gt; 32应该加括号int vx = (int) (minIndex &gt;&gt; 32)，前者先把minIndex转成int，再右移 map里的节点不一定是specialRoads.length + 2个，可能有重复节点，所以要while(true) 初始化时，如果specialRoads有到达起点的点，那么所有点的距离都是max，所以dist.put(startLong, 0);要在此之后 123for (int i = 0; i &lt; specialRoads.length; ++i) dist.put((long) specialRoads[i][2] &lt;&lt; 32 | specialRoads[i][3], Integer.MAX_VALUE);dist.put(startLong, 0); 代码 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123; public int minimumCost(int[] start, int[] target, int[][] specialRoads) &#123; return dijkstra(start, target, specialRoads); &#125; private int dijkstra(int[] start, int[] target, int[][] specialRoads) &#123; Map&lt;Long, Integer&gt; dist = new HashMap&lt;&gt;(); // key: 64位，前32位表示横坐标，后32位表示纵坐标; // val: 距离targetLong的最短距离 // 大小为2 + specialRoads.length，顶点为：起点，target，specialRoads的所有终点 long targetLong = (long) target[0] &lt;&lt; 32 | target[1], startLong = (long) start[0] &lt;&lt; 32 | start[1]; dist.put(targetLong, Integer.MAX_VALUE); for (int i = 0; i &lt; specialRoads.length; ++i) dist.put((long) specialRoads[i][2] &lt;&lt; 32 | specialRoads[i][3], Integer.MAX_VALUE); dist.put(startLong, 0); Set&lt;Long&gt; visited = new HashSet&lt;&gt;(); while (true) &#123; int minDist = Integer.MAX_VALUE; long minIndex = -1; for (Long key : dist.keySet()) &#123; if (!visited.contains(key) &amp;&amp; dist.get(key) &lt; minDist) &#123; minDist = dist.get(key); minIndex = key; &#125; &#125; if (minIndex == targetLong) return minDist; visited.add(minIndex); int vx = (int) (minIndex &gt;&gt; 32), vy = (int) minIndex &amp; Integer.MAX_VALUE; // 更新终点的最短距离 dist.merge(targetLong, minDist + Math.abs(target[0] - vx) + Math.abs(target[1] - vy), Math::min); for (int[] sr : specialRoads) &#123; long node = (long) sr[2] &lt;&lt; 32 | sr[3]; int manhattanDist = minDist + Math.min(Math.abs(vx - sr[0]) + Math.abs(vy - sr[1]) + sr[4], Math.abs(vx - sr[2]) + Math.abs(vy - sr[3])); if (manhattanDist &lt; dist.get(node)) dist.put(node, manhattanDist); &#125; &#125; &#125;&#125; 字典序最小的美丽字符串 方法一：贪心 12345678910111213141516171819202122class Solution &#123; public String smallestBeautifulString(String s, int k) &#123; char[] chars = s.toCharArray(); k = (char) (&#x27;a&#x27; + k); int n = s.length(), i = n - 1; ++chars[i]; while (i &lt; n) &#123; if (chars[i] == k) &#123; if (i == 0) return &quot;&quot;; // 进位 chars[i] = &#x27;a&#x27;; ++chars[--i]; &#125; else if ((i &gt; 0 &amp;&amp; chars[i] == chars[i - 1]) || (i &gt; 1 &amp;&amp; chars[i] == chars[i - 2])) ++chars[i]; else ++i; &#125; return new String(chars); &#125;&#125;","categories":[{"name":"Contest","slug":"Contest","permalink":"https://leopol1d.github.io/categories/Contest/"},{"name":"LCP","slug":"Contest/LCP","permalink":"https://leopol1d.github.io/categories/Contest/LCP/"}],"tags":[{"name":"力扣杯","slug":"力扣杯","permalink":"https://leopol1d.github.io/tags/%E5%8A%9B%E6%89%A3%E6%9D%AF/"}]},{"title":"What is Memorization Search","slug":"what-is-memorization-search","date":"2023-07-25T02:50:16.000Z","updated":"2023-11-18T03:24:24.711Z","comments":true,"path":"2023/07/25/what-is-memorization-search/","link":"","permalink":"https://leopol1d.github.io/2023/07/25/what-is-memorization-search/","excerpt":"","text":"记忆化搜索一个模板秒杀6道股票题 121. 买卖股票的最佳时机：买入卖出一支股票 首先可以从最暴力的方法出发，再加上缓存就是记忆化搜索啦 方法一：回溯 从第0天开始到第n-1天，枚举买入或者不买入两种操作，记录能获得的最大值。 定义了三种状态state state == 0，初始状态，没有买入卖出股票 当前可以不买入股票，此时能获得的价值为：dfs(index + 1, state) 或者买入股票，此时能获得的价值为：dfs(index + 1, state + 1) - prices[index] state == 1，已经买入了一支股票 当前可以不卖出股票，此时能获得的价值为：dfs(index + 1, state) 或者卖出股票，此时能获得的价值为：dfs(index + 1, state + 1) + prices[index] state == 2，已经买入卖出一支股票，操作结束 在state == 0 和 state == 1的时候返回最大的价值 123456789101112131415161718class Solution &#123; public int maxProfit(int[] prices) &#123; this.prices = prices; return dfs(0, 0); &#125; int[] prices; private int dfs(int index, int state) &#123; if (index == prices.length || state == 2) return 0; if (state == 0) // 不操作 买入 return Math.max(dfs(index + 1, state), dfs(index + 1, state + 1) - prices[index]); // 不操作 卖出 return Math.max(dfs(index + 1, state), dfs(index + 1, state + 1) + prices[index]); &#125;&#125; 方法二：记忆化搜索 定义dp数组，用于遍历过每种状态能获得的值，dp = new int[2][prices.length]; 在return前，把当前的值记录在dp数组中 return dp[state][index] = Math.max(dfs(index + 1, state), dfs(index + 1, state + 1) - prices[index]); return dp[state][index] = Math.max(dfs(index + 1, state), dfs(index + 1, state + 1) + prices[index]); 很多子问题可能会被多次调用，导致重复计算，这会极大地增加算法的时间复杂度。记忆化数组的作用就是将已经计算过的子问题的结果保存起来，下次遇到相同的子问题时，直接从记忆数组中取得结果，避免重复计算。 12if (dp[state][index] != -1) return dp[state][index]; base case：index超过了数组长度或者卖出了股票 12if (index == prices.length || state == 2) return 0; 代码 123456789101112131415161718192021222324class Solution &#123; public int maxProfit(int[] prices) &#123; this.prices = prices; dp = new int[2][prices.length]; for (int[] arr : dp) Arrays.fill(arr, -1); return dfs(0, 0); &#125; int[] prices; int[][] dp; private int dfs(int index, int state) &#123; if (index == prices.length || state == 2) return 0; if (dp[state][index] != -1) return dp[state][index]; if (state == 0) // 不操作 买入 return dp[state][index] = Math.max(dfs(index + 1, 0), dfs(index + 1, 1) - prices[index]); // 不操作 卖出 return dp[state][index] = Math.max(dfs(index + 1, 1), dfs(index + 1, 2) + prices[index]); &#125;&#125; 接下来使用记忆化搜索解决其他5道股票问题 122. 买卖股票的最佳时机 II：可以买卖任意支股票 有两处代码需要修改 买入一只股票后，可以不操作，或者卖出，由于可以买卖任意支股票，选择卖出股票后，状态回到0 1return dp[state][index] = Math.max(dfs(index + 1, 1), dfs(index + 1, 0) + prices[index]); base case：删除state == 2，这段条件，因为现在可以买卖任意支股票 12if (index == prices.length) return 0; 代码 123456789101112131415161718192021222324class Solution &#123; public int maxProfit(int[] prices) &#123; this.prices = prices; dp = new int[2][prices.length]; for (int[] arr : dp) Arrays.fill(arr, -1); return dfs(0, 0); &#125; int[] prices; int[][] dp; private int dfs(int index, int state) &#123; if (index == prices.length) return 0; if (dp[state][index] != -1) return dp[state][index]; if (state == 0) // 不操作 买入 return dp[state][index] = Math.max(dfs(index + 1, 0), dfs(index + 1, 1) - prices[index]); // 不操作 卖出 return dp[state][index] = Math.max(dfs(index + 1, 1), dfs(index + 1, 0) + prices[index]); &#125;&#125; 123. 买卖股票的最佳时机 III：最多买卖两支股票 多定义两种state即可 ，state为偶数的时候可以选择不操作或者不买入，state为奇数的时候可以选择不操作或不卖出 代码 12345678910111213141516171819202122232425class Solution &#123; public int maxProfit(int[] prices) &#123; this.prices = prices; dp = new int[4][prices.length]; for (int[] arr : dp) Arrays.fill(arr, -1); return dfs(0, 0); &#125; int[] prices; int[][] dp; private int dfs(int index, int state) &#123; if (index == prices.length || state == 4) return 0; if (dp[state][index] != -1) return dp[state][index]; if (state == 0 || state == 2) // 不操作 买入 return dp[state][index] = Math.max(dfs(index + 1, state), dfs(index + 1, state + 1) - prices[index]); // 不操作 卖出 else return dp[state][index] = Math.max(dfs(index + 1, state), dfs(index + 1, state + 1) + prices[index]); &#125;&#125; 188. 买卖股票的最佳时机 IV：最多买卖k支股票 和123. 买卖股票的最佳时机 III：最多买卖两支股票类似，买卖一支股票我们需要开2个dp数组，买卖两支股票我们需要开4个dp数组，买卖k支股票需要开2*k个dp数组 代码 123456789101112131415161718192021222324252627class Solution &#123; public int maxProfit(int k, int[] prices) &#123; this.prices = prices; this.k = k; dp = new int[2 * k][prices.length]; for (int[] arr : dp) Arrays.fill(arr, -1); return dfs(0, 0); &#125; int[] prices; int[][] dp; int k; private int dfs(int index, int state) &#123; if (index == prices.length || state == 2 * k) return 0; if (dp[state][index] != -1) return dp[state][index]; if (state % 2 == 0) // 不操作 买入 return dp[state][index] = Math.max(dfs(index + 1, state), dfs(index + 1, state + 1) - prices[index]); // 不操作 卖出 else return dp[state][index] = Math.max(dfs(index + 1, state), dfs(index + 1, state + 1) + prices[index]); &#125;&#125; 714. 买卖股票的最佳时机含手续费 与122. 买卖股票的最佳时机 II：可以买卖任意支股票类似，在卖出的时候多 - fee就ok 1return dp[state][index] = Math.max(dfs(index + 1, 1), dfs(index + 1, 0) + prices[index] - fee); 代码 123456789101112131415161718192021222324252627class Solution &#123; public int maxProfit(int[] prices, int fee) &#123; this.prices = prices; this.fee = fee; dp = new int[2][prices.length]; for (int[] arr : dp) Arrays.fill(arr, -1); return dfs(0, 0); &#125; int[] prices; int[][] dp; int fee; private int dfs(int index, int state) &#123; if (index == prices.length) return 0; if (dp[state][index] != -1) return dp[state][index]; if (state == 0) // 不操作 买入 return dp[state][index] = Math.max(dfs(index + 1, 0), dfs(index + 1, 1) - prices[index]); // 不操作 卖出 else return dp[state][index] = Math.max(dfs(index + 1, 1), dfs(index + 1, 0) + prices[index] - fee); &#125;&#125; 309. 最佳买卖股票时机含冷冻期 与122. 买卖股票的最佳时机 II：可以买卖任意支股票类似，在卖出的时候往后走两天即可dfs(index + 2, 0)，同时base case小修 base case 12if (index &gt;= prices.length) return 0; state == 1 1return dp[state][index] = Math.max(dfs(index + 1, 1), dfs(index + 2, 0) + prices[index]); 代码 12345678910111213141516171819202122232425class Solution &#123; public int maxProfit(int[] prices) &#123; this.prices = prices; dp = new int[2][prices.length]; for (int[] arr : dp) Arrays.fill(arr, -1); return dfs(0, 0); &#125; int[] prices; int[][] dp; private int dfs(int index, int state) &#123; if (index &gt;= prices.length) return 0; if (dp[state][index] != -1) return dp[state][index]; if (state == 0) // 不操作 买入 return dp[state][index] = Math.max(dfs(index + 1, 0), dfs(index + 1, 1) - prices[index]); // 不操作 卖出 else return dp[state][index] = Math.max(dfs(index + 1, 1), dfs(index + 2, 0) + prices[index]); &#125;&#125; 最后 打个比方 dp(手动挡)：需要初始化，考虑遍历顺序 记忆化搜索(自动挡)：不需要初始化，考虑遍历顺序 记忆化搜索和动态规划都是解决问题的常用方法，它们各自有一些优点和缺点。 记忆化搜索的优点： 减少重复计算：记忆化搜索通过缓存已经计算过的结果，避免了重复计算，提高了算法的效率。简单易实现：相对于动态规划，记忆化搜索的实现通常更加简单直观，只需要在递归的基础上加上缓存即可。记忆化搜索的缺点： 可能会占用较大的内存：记忆化搜索需要缓存所有的中间结果，如果问题规模较大，可能会占用较多的内存空间。递归调用可能导致栈溢出：对于问题规模较大的情况，递归调用深度可能较深，可能导致栈溢出。动态规划的优点： 自底向上的思路：动态规划通常采用自底向上的计算方式，从小规模问题开始逐步推导得到最终结果，确保所有子问题的解都被计算到。适用于一些具有最优子结构的问题：动态规划适用于具有最优子结构的问题，即整个问题的最优解可以由子问题的最优解推导得到。动态规划的缺点： 实现较为复杂：相对于记忆化搜索，动态规划的实现通常较为复杂，需要设计合适的状态转移方程和数组结构。可能会占用较大的内存：类似于记忆化搜索，动态规划也需要维护一个数组来保存中间结果，可能会占用较多的内存空间。综上所述，记忆化搜索适用于递归问题，能够减少重复计算，但可能会占用较大内存和导致栈溢出。动态规划适用于具有最优子结构的问题，通过自底向上的方式计算，但实现较为复杂且可能会占用较多内存。在实际应用中，根据问题的性质和规模选择合适的方法来解决问题。","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://leopol1d.github.io/categories/Algorithms/"},{"name":".*","slug":"","permalink":"https://leopol1d.github.io/categories/"},{"name":"Memorization Search","slug":"Algorithms/Memorization-Search","permalink":"https://leopol1d.github.io/categories/Algorithms/Memorization-Search/"}],"tags":[{"name":"记忆化搜索","slug":"记忆化搜索","permalink":"https://leopol1d.github.io/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"}]},{"title":"lcp355","slug":"lcp355","date":"2023-07-24T01:15:34.000Z","updated":"2023-08-01T08:29:02.735Z","comments":true,"path":"2023/07/24/lcp355/","link":"","permalink":"https://leopol1d.github.io/2023/07/24/lcp355/","excerpt":"","text":"按分隔符拆分字符串 方法一：模拟 123456789101112131415161718192021222324class Solution &#123; public List&lt;String&gt; splitWordsBySeparator(List&lt;String&gt; words, char separator) &#123; List&lt;String&gt; res = new LinkedList&lt;&gt;(); for (String word : words) &#123; StringBuilder sb = new StringBuilder(); boolean add = false; for (int i = 0; i &lt; word.length(); ++i) &#123; char ch = word.charAt(i); if (ch == separator) &#123; if (sb.length() &gt; 0) &#123; res.add(sb.toString()); sb.setLength(0); &#125; add = !add; &#125; else if (ch != &#x27; &#x27;) sb.append(ch); if (i == word.length() - 1 &amp;&amp; sb.length() &gt; 0) res.add(sb.toString()); &#125; &#125; return res; &#125;&#125; 合并后数组中的最大元素 方法一：贪心 不要直接用数组元素累加，会超出整型范围 1234567891011121314151617class Solution &#123; public long maxArrayValue(int[] nums) &#123; int n = nums.length; long max = 0, pre = nums[n - 1]; max = Math.max(max, nums[n - 1]); for (int i = n - 1; i &gt;= 1; --i) &#123; if (pre &gt;= nums[i - 1]) &#123; pre += nums[i - 1]; &#125; else &#123; pre = nums[i - 1]; &#125; max = Math.max(max, pre); &#125; return max; &#125;&#125; 长度递增组的最大数目 方法一：排序 + 二分 思路 贫富差距，富人压榨穷人，穷人不能向富人索取 123456789101112131415161718192021222324class Solution &#123; public int maxIncreasingGroups(List&lt;Integer&gt; usageLimits) &#123; Collections.sort(usageLimits, Collections.reverseOrder()); int n = usageLimits.size(), left = 0, right = n; while (left &lt;= right) &#123; int mid= (left + right) &gt;&gt; 1; if (check(mid, usageLimits)) left = mid + 1; else right = mid - 1; &#125; return right; &#125; private boolean check(int mid, List&lt;Integer&gt; usageLimits) &#123; int gap = 0; for (int x : usageLimits) &#123; gap = Math.min(0, gap + x - mid); if (mid &gt; 0) --mid; &#125; return gap &gt;= 0; &#125;&#125; 6942. 树中可以形成回文的路径数 方法一：异或 视频讲解 可以排列的回文串等价于至多一个字母出现奇数次，其余字母出现偶数次 12345678910111213141516171819202122232425262728class Solution &#123; public long countPalindromePaths(List&lt;Integer&gt; parent, String s) &#123; int n = parent.size(); for (int i = 0; i &lt; n; ++i) graph.put(i, new HashMap&lt;&gt;()); for (int i = 1; i &lt; parent.size(); ++i) graph.get(parent.get(i)).put(i, 1 &lt;&lt; (s.charAt(i) - &#x27;a&#x27; )); dfs(0, 0); return res; &#125; private void dfs(int node, int xorVal) &#123; res += xorCount.getOrDefault(xorVal, 0); for (int i = 0; i &lt; 26; ++i) res += xorCount.getOrDefault(xorVal ^ (1 &lt;&lt; i), 0); xorCount.put(xorVal, xorCount.getOrDefault(xorVal, 0) + 1); Map&lt;Integer, Integer&gt; nexts = graph.get(node); for (int next : nexts.keySet()) dfs(next, xorVal ^ graph.get(node).get(next)); &#125; long res = 0; // 第二个map key: 下标, val: 字符 - &#x27;a&#x27; Map&lt;Integer, Map&lt;Integer, Integer&gt;&gt; graph = new HashMap&lt;&gt;(); // key: xor的值，val: xor的值出现的次数 Map&lt;Integer, Integer&gt; xorCount = new HashMap&lt;&gt;();&#125;","categories":[{"name":"Contest","slug":"Contest","permalink":"https://leopol1d.github.io/categories/Contest/"},{"name":"LCP","slug":"Contest/LCP","permalink":"https://leopol1d.github.io/categories/Contest/LCP/"}],"tags":[{"name":"力扣杯","slug":"力扣杯","permalink":"https://leopol1d.github.io/tags/%E5%8A%9B%E6%89%A3%E6%9D%AF/"}]},{"title":"lcpBi109","slug":"lcpBi109","date":"2023-07-22T14:23:06.000Z","updated":"2023-09-15T03:07:31.520Z","comments":true,"path":"2023/07/22/lcpBi109/","link":"","permalink":"https://leopol1d.github.io/2023/07/22/lcpBi109/","excerpt":"","text":"第一题检查数组是否是好的 方法一： 1234567891011121314151617181920212223242526272829303132class Solution &#123; public boolean isGood(int[] nums) &#123; int n = nums.length; if (n &lt; 2) return false; if (n == 2) &#123; if (nums[0] == 1 &amp;&amp; nums[1] == 1) return true; else return false; &#125; int[] count = new int[201]; int max = 0; for (int i = 0; i &lt; n; ++i) &#123; count[nums[i]]++; max = Math.max(max, nums[i]); &#125; if (n &lt; max + 1) return false;// if (nums[max - 2] != nums[max - 1])// return false; if (count[max] != 2) return false; for (int i = 1; i &lt; n; ++i) &#123; if (i == n || i == n - 1) break; if (count[i] != 1) return false; &#125; return true; &#125;&#125; 第二题将字符串中的元音字母排序 方法一： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Solution &#123; public String sortVowels(String s) &#123; int n = s.length(); StringBuilder sb = new StringBuilder(s); List&lt;Integer&gt; emptyIndex = new LinkedList&lt;&gt;(); int[] count = new int[128]; for (int i = 0; i &lt; n; ++i) &#123; char ch = s.charAt(i); if (ch == &#x27;a&#x27; || ch == &#x27;A&#x27; || ch == &#x27;e&#x27; || ch == &#x27;E&#x27; || ch == &#x27;i&#x27; || ch == &#x27;I&#x27; || ch == &#x27;o&#x27; || ch == &#x27;O&#x27; || ch == &#x27;u&#x27; || ch == &#x27;U&#x27;) &#123; emptyIndex.add(i); ++count[ch]; &#125; &#125; int[] temp = emptyIndex.stream().mapToInt(i-&gt;i).toArray(); for (int i = 0; i &lt; temp.length; ++i) &#123; int index = temp[i]; char ch = &#x27; &#x27;; if (count[&#x27;A&#x27;] &gt; 0) &#123; --count[&#x27;A&#x27;]; sb.setCharAt(index, &#x27;A&#x27;); &#125; else if (count[&#x27;E&#x27;] &gt; 0) &#123; sb.setCharAt(index, &#x27;E&#x27;); --count[&#x27;E&#x27;]; &#125; else if (count[&#x27;I&#x27;] &gt; 0) &#123; sb.setCharAt(index, &#x27;I&#x27;); --count[&#x27;I&#x27;]; &#125; else if (count[&#x27;O&#x27;] &gt; 0) &#123; sb.setCharAt(index, &#x27;O&#x27;); --count[&#x27;O&#x27;]; &#125; else if (count[&#x27;U&#x27;] &gt; 0) &#123; sb.setCharAt(index, &#x27;U&#x27;); --count[&#x27;U&#x27;]; &#125; else if (count[&#x27;a&#x27;] &gt; 0) &#123; sb.setCharAt(index, &#x27;a&#x27;); --count[&#x27;a&#x27;]; &#125; else if (count[&#x27;e&#x27;] &gt; 0) &#123; sb.setCharAt(index, &#x27;e&#x27;); --count[&#x27;e&#x27;]; &#125; else if (count[&#x27;i&#x27;] &gt; 0) &#123; sb.setCharAt(index, &#x27;i&#x27;); --count[&#x27;i&#x27;]; &#125; else if (count[&#x27;o&#x27;] &gt; 0) &#123; sb.setCharAt(index, &#x27;o&#x27;); --count[&#x27;o&#x27;]; &#125; else if (count[&#x27;u&#x27;] &gt; 0) &#123; sb.setCharAt(index, &#x27;u&#x27;); --count[&#x27;u&#x27;]; &#125; &#125; return sb.toString(); &#125;&#125; 第三题访问数组中的位置使分数最大 方法一：记忆化搜索 选或不选 123456789101112131415161718192021222324252627class Solution &#123; public long maxScore(int[] nums, int x) &#123; this.nums = nums; this.x = x; n = nums.length; dp = new long[n][2]; for (long[] arr : dp) Arrays.fill(arr, -1); return dfs(1, nums[0] % 2) + nums[0]; &#125; long[][] dp; private long dfs(int index, int k) &#123; if (index == n) return 0; if (dp[index][k] != -1) return dp[index][k]; int num = nums[index], v = num % 2; long pass = dfs(index + 1, k); long choose = dfs(index + 1, v) + num - (k != v ? x : 0); return dp[index][k] = Math.max(pass, choose); &#125; int[] nums; int x, n;&#125; 第四题 2787. 将一个数字表示成幂的和的方案数 方法一：01背包 123456789101112131415161718class Solution &#123; public int numberOfWays(int n, int x) &#123; int mod = (int) 1e9 + 7; // 01背包， 从1^x, 2^x,...,n^x里选物品，恰好能装满容量为n的背包的方案数 int[][] dp = new int[n + 1][n + 1]; // 没有物品，恰好装满容量为0的背包的方案数：1,什么都不装 dp[0][0] = 1; for (int i = 1; i &lt;= n; ++i) &#123; int s = (int) Math.pow(i, x); for (int j = 0; j &lt;= n; ++j) &#123; dp[i][j] = dp[i - 1][j]; if (j &gt;= s) dp[i][j] = (dp[i][j] + dp[i - 1][j - s]) % mod; &#125; &#125; return dp[n][n]; &#125;&#125; 方法二：滚动数组 12345678910111213141516class Solution &#123; public int numberOfWays(int n, int x) &#123; int mod = (int) 1e9 + 7; // 01背包， 从1^x, 2^x,...,n^x里选物品，恰好能装满容量为n的背包的方案数 int[] dp = new int[n + 1]; // 没有物品，恰好装满容量为0的背包的方案数：1,什么都不装 dp[0] = 1; for (int i = 1; i &lt;= n; ++i) &#123; int s = (int) Math.pow(i, x); for (int j = n; j &gt;= s; --j) &#123; dp[j] = (dp[j] + dp[j - s]) % mod; &#125; &#125; return dp[n]; &#125;&#125; 方法三：静态处理 所有x,n在static语句块中处理好 1234567891011121314151617181920212223class Solution &#123; static int[][] dp; static &#123; int n = 300, x = 5; int mod = (int) 1e9 + 7; // 01背包， 从1^x, 2^x,...,n^x里选物品，恰好能装满容量为n的背包的方案数 dp = new int[x][n + 1]; // 没有物品，恰好装满容量为0的背包的方案数：1,什么都不装 for (int i = 0; i &lt; x; ++i) dp[i][0] = 1; for (int k = 1; k &lt;= x; ++k) &#123; for (int i = 1; i &lt;= n; ++i) &#123; int s = (int) Math.pow(i, k); for (int j = n; j &gt;= s; --j) &#123; dp[k - 1][j] = (dp[k - 1][j] + dp[k - 1][j - s]) % mod; &#125; &#125; &#125; &#125; public int numberOfWays(int n, int x) &#123; return dp[x - 1][n]; &#125;&#125;","categories":[{"name":"Contest","slug":"Contest","permalink":"https://leopol1d.github.io/categories/Contest/"},{"name":"LCP","slug":"Contest/LCP","permalink":"https://leopol1d.github.io/categories/Contest/LCP/"}],"tags":[{"name":"力扣杯","slug":"力扣杯","permalink":"https://leopol1d.github.io/tags/%E5%8A%9B%E6%89%A3%E6%9D%AF/"}]},{"title":"lcp344","slug":"lcp344","date":"2023-07-20T01:12:18.000Z","updated":"2023-08-01T08:28:37.877Z","comments":true,"path":"2023/07/20/lcp344/","link":"","permalink":"https://leopol1d.github.io/2023/07/20/lcp344/","excerpt":"","text":"找出不同元素数目差数组 方法一：模拟 123456789101112131415class Solution &#123; public int[] distinctDifferenceArray(int[] nums) &#123; int n = nums.length; int[] res = new int[n]; for (int i = 0; i &lt; n; ++i) &#123; Set&lt;Integer&gt; preSet = new HashSet&lt;&gt;(), postSet = new HashSet&lt;&gt;(); for (int j = i; j &gt;= 0; --j) preSet.add(nums[j]); for (int j = i + 1; j &lt; n; ++j) postSet.add(nums[j]); res[i] = preSet.size() - postSet.size(); &#125; return res; &#125;&#125; 频率跟踪器 方法一：HashMap 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class FrequencyTracker &#123; int[] nums; Map&lt;Integer, Set&lt;Integer&gt;&gt; map; public FrequencyTracker() &#123; nums = new int[100001]; map = new HashMap&lt;&gt;(); &#125; public void add(int number) &#123; ++nums[number]; int freq = nums[number]; if (!map.containsKey(freq)) map.put(freq, new HashSet&lt;&gt;()); map.get(freq).add(number); if (map.containsKey(freq - 1)) map.get(freq - 1).remove(number); &#125; public void deleteOne(int number) &#123; int freq = nums[number]; if (nums[number] == 0) return; else &#123; --nums[number]; map.get(freq).remove(number); if (!map.containsKey(freq - 1)) map.put(freq - 1, new HashSet&lt;&gt;()); map.get(freq - 1).add(number); &#125; &#125; public boolean hasFrequency(int frequency) &#123; if (map.containsKey(frequency) &amp;&amp; map.get(frequency).size() &gt; 0) return true; else return false; &#125;&#125;/** * Your FrequencyTracker object will be instantiated and called as such: * FrequencyTracker obj = new FrequencyTracker(); * obj.add(number); * obj.deleteOne(number); * boolean param_3 = obj.hasFrequency(frequency); */ 方法二：前后缀分解 1234567891011121314151617class Solution &#123; public int[] distinctDifferenceArray(int[] nums) &#123; int n = nums.length; int[] res = new int[n], suffix = new int[n + 1]; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int i = n - 1; i &gt;= 0; --i) &#123; set.add(nums[i]); suffix[i] = set.size(); &#125; set.clear(); for (int i = 0; i &lt; n; ++i) &#123; set.add(nums[i]); res[i] = set.size() - suffix[i + 1]; &#125; return res; &#125;&#125; 有相同颜色的相邻元素数目 方法一：模拟 12345678910111213141516171819202122class Solution &#123; public int[] colorTheArray(int n, int[][] queries) &#123; int[] res = new int[queries.length], nums = new int[n + 1]; int count = 0, idx = 0; for (int[] query : queries) &#123; int index = query[0], color = query[1]; if (nums[index] &gt; 0) &#123; if (index &gt; 0 &amp;&amp; nums[index] == nums[index - 1]) --count; if (index &lt; n &amp;&amp; nums[index] == nums[index + 1]) --count; &#125; nums[index] = color; if (index &gt; 0 &amp;&amp; nums[index] == nums[index - 1]) ++count; if (index &lt; n &amp;&amp; nums[index] == nums[index + 1]) ++count; res[idx++] = count; &#125; return res; &#125;&#125; 使二叉树所有路径值相等的最小代价 方法一：树上贪心 12345678910class Solution &#123; public int minIncrements(int n, int[] cost) &#123; int res = 0; for (int i = n / 2; i &gt; 0; --i) &#123; res += Math.abs(cost[2 * i - 1] - cost[2 * i]); cost[i - 1] += Math.max(cost[2 * i - 1], cost[2 * i]); &#125; return res; &#125;&#125;","categories":[{"name":"Contest","slug":"Contest","permalink":"https://leopol1d.github.io/categories/Contest/"},{"name":"LCP","slug":"Contest/LCP","permalink":"https://leopol1d.github.io/categories/Contest/LCP/"}],"tags":[{"name":"力扣杯","slug":"力扣杯","permalink":"https://leopol1d.github.io/tags/%E5%8A%9B%E6%89%A3%E6%9D%AF/"}]},{"title":"lcpBi104","slug":"lcpBi104","date":"2023-07-19T01:11:52.000Z","updated":"2023-08-01T08:29:11.977Z","comments":true,"path":"2023/07/19/lcpBi104/","link":"","permalink":"https://leopol1d.github.io/2023/07/19/lcpBi104/","excerpt":"","text":"老人的数目 方法一：模拟 1234567891011class Solution &#123; public int countSeniors(String[] details) &#123; int res = 0; for (String detail : details) &#123; int age = Integer.parseInt(detail.substring(11, 13)); if (age &gt; 60) ++res; &#125; return res; &#125;&#125; 矩阵中的和 方法一：错 TreeSet中不能存放重复的元素，使用大根堆！ 123456789101112131415161718192021222324public int matrixSum(int[][] nums) &#123; int m = nums.length, n = 0; TreeSet&lt;Integer&gt;[] treeSets = new TreeSet[m]; for (int i = 0; i &lt; m; ++i) &#123; treeSets[i] = new TreeSet&lt;&gt;(); for (int j = 0; j &lt; nums[i].length; ++j) &#123; n = Math.max(n, nums[i].length); treeSets[i].add(nums[i][j]); &#125; &#125; int res = 0; for (int j = 0; j &lt; n; ++j) &#123; int max = Integer.MIN_VALUE; for (int i = 0; i &lt; m; ++i) &#123; if (!treeSets[i].isEmpty()) &#123; int cur = treeSets[i].last(); treeSets[i].remove(cur); max = Math.max(max, cur); &#125; &#125; res += max; &#125; return res;&#125; 方法二：排序 12345678910111213141516class Solution &#123; public int matrixSum(int[][] nums) &#123; for (int[] row : nums) Arrays.sort(row); int res = 0; for (int j = 0; j &lt; nums[0].length; ++j) &#123; int max = 0; for (int i = 0; i &lt; nums.length; ++i) &#123; if (nums[i][j] &gt; max) max = nums[i][j]; &#125; res += max; &#125; return res; &#125;&#125; 方法三：大根堆 用的小根堆，和大根堆一样，先把每行最小的弹出 123456789101112131415161718192021class Solution &#123; public int matrixSum(int[][] nums) &#123; int m = nums.length, n = nums[0].length; PriorityQueue&lt;Integer&gt;[] queues = new PriorityQueue[m]; for (int i = 0; i &lt; m; ++i) &#123; queues[i] = new PriorityQueue&lt;&gt;(); for (int j = 0; j &lt; nums[i].length; ++j) &#123; queues[i].add(nums[i][j]); &#125; &#125; int res = 0; for (int j = 0; j &lt; n; ++j) &#123; int max = 0; for (int i = 0; i &lt; m; ++i) &#123; max = Math.max(max, queues[i].poll()); &#125; res += max; &#125; return res; &#125;&#125; 最大或值 方法一：前后缀+ 记忆化搜索 一定要用数组！不要用哈希表 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution &#123; public long maximumOr(int[] nums, int k) &#123; this.nums = nums; n = nums.length; dp = new long[n + 1][16]; for (long[] arr : dp) Arrays.fill(arr, -1); preOr = new long[n + 1]; for (int i = 1; i &lt;= n; ++i) preOr[i] = nums[i - 1] | preOr[i - 1]; postOr = new long[n + 1]; for (int i = n - 1; i &gt;= 0; --i) postOr[i] = nums[i] | postOr[i + 1]; return dfs(0, k); &#125; private long dfs(int index, int k) &#123; if (dp[index][k] != -1) return dp[index][k]; if (index == n) // 走到这说明k的次数没用完 return preOr[n]; if (k == 0) &#123; int pre = -1; long temp1 = 0, temp2; for (int i : change.keySet()) &#123; temp2 = preOr[i] | preOr[pre + 1]; temp2 = temp2 | ((long) nums[i] &lt;&lt; change.get(i)); temp1 |= temp2; pre = i; &#125; temp2 = postOr[pre + 1]; temp1 |= temp2; return temp1; &#125; long res, changeNext = 0; long pass = dfs(index + 1, k); if (k &gt; 0) &#123; change.put(index, change.getOrDefault(index, 0) + 1); changeNext = dfs(index, k - 1); change.put(index, change.get(index) - 1); if (change.get(index) == 0) change.remove(index); &#125; res = Math.max(pass, changeNext); return dp[index][k] = res; &#125; int[] nums; long[] preOr, postOr; int n; TreeMap&lt;Integer, Integer&gt; change = new TreeMap&lt;&gt;(); long[][] dp;&#125; 方法二：贪心 把「乘 2」分配给多个数，不如只分配给一个数，这样更有可能得到更大的答案。 123456789101112131415161718192021222324252627class Solution &#123; public long maximumOr(int[] nums, int k) &#123; int n = nums.length; var suf = new int[n + 1]; for (int i = n - 1; i &gt; 0; i--) suf[i] = suf[i + 1] | nums[i]; long ans = 0; for (int i = 0, pre = 0; i &lt; n; i++) &#123; ans = Math.max(ans, pre | ((long) nums[i] &lt;&lt; k) | suf[i + 1]); pre |= nums[i]; &#125; return ans; &#125;&#125; 英雄的力量 方法一：贡献法 1234567891011class Solution &#123; public int sumOfPower(int[] nums) &#123; Arrays.sort(nums); long MOD = (int) 1e9 + 7, res = 0, s = 0; for (long x : nums) &#123; res = (res + x * x % MOD * (x + s)) % MOD; s = (s * 2 + x) % MOD; &#125; return (int) res; &#125;&#125;","categories":[{"name":"Contest","slug":"Contest","permalink":"https://leopol1d.github.io/categories/Contest/"},{"name":"LCP","slug":"Contest/LCP","permalink":"https://leopol1d.github.io/categories/Contest/LCP/"}],"tags":[{"name":"力扣杯","slug":"力扣杯","permalink":"https://leopol1d.github.io/tags/%E5%8A%9B%E6%89%A3%E6%9D%AF/"}]},{"title":"lcp345","slug":"lcp345","date":"2023-07-17T01:15:05.000Z","updated":"2023-08-01T08:28:39.832Z","comments":true,"path":"2023/07/17/lcp345/","link":"","permalink":"https://leopol1d.github.io/2023/07/17/lcp345/","excerpt":"","text":"找出转圈游戏输家 模拟 123456789101112131415161718192021222324class Solution &#123; public int[] circularGameLosers(int n, int k) &#123; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); int index = 1, multiple = 1; while (true) &#123; if (set.contains(index)) break; set.add(index); int temp = index + multiple * k; if (temp % n == 0) index = n; else index = temp % n; multiple++; &#125; List&lt;Integer&gt; res = new LinkedList&lt;&gt;(); for (int i = 1; i &lt;= n; ++i) &#123; if (set.contains(i)) continue; res.add(i); &#125; return res.stream().mapToInt(i-&gt;i).toArray(); &#125;&#125; 方法二：下标从0开始 1234567891011121314151617181920class Solution &#123; public int[] circularGameLosers(int n, int k) &#123; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); int index = 0, multiple = 1; while (true) &#123; if (set.contains(index)) break; set.add(index); index = (index + multiple * k) % n; multiple++; &#125; List&lt;Integer&gt; res = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; n; ++i) &#123; if (set.contains(i)) continue; res.add(i + 1); &#125; return res.stream().mapToInt(i-&gt;i).toArray(); &#125;&#125; 相邻值的按位异或 方法一：回溯 (枚举) 枚举ori[0]为0和1，只要有一个能构造成derived数组则为true 1234567891011121314151617181920212223242526272829303132class Solution &#123; public boolean doesValidArrayExist(int[] derived) &#123; this.derived = derived; n = derived.length; if (n == 1) return derived[0] == 0; original = new int[n]; return dfs(0, 0) || dfs(0, 1); &#125; private boolean dfs(int index, int x) &#123; if (index == n - 1) &#123; if (derived[index] == 0) return original[0] == x; else return original[0] != x; &#125; String key = index + &quot;#&quot; + x; original[index] = x; int next = -1; if (derived[index] == 0) next = x == 0 ? 0 : 1; else // derived[index] == 1 next = x == 0 ? 1 : 0; if (dfs(index + 1, next)) return true; return false; &#125; int[] derived, original; int n;&#125; 矩阵中移动的最大次数 方法一：记忆化搜索 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public int maxMoves(int[][] grid) &#123; m = grid.length; n = grid[0].length; this.grid = grid; dp = new int[m][n]; for (int[] arr : dp) Arrays.fill(arr, -1); int res = 0; for (int j = 0; j &lt; m; ++j) &#123; res = Math.max(res, dfs(j, 0)); &#125; return res; &#125; private int dfs(int i, int j) &#123; if (dp[i][j] != -1) return dp[i][j]; int res = 0; for (int[] dir : dirs) &#123; int step = 0; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col) &amp;&amp; grid[row][col] &gt; grid[i][j]) &#123; step = dfs(row, col) + 1; &#125; res = Math.max(res, step); &#125; return dp[i][j] = res; &#125; int m, n; int[][] dp, grid, dirs = new int[][]&#123;&#123;0, 1&#125;, &#123;-1, 1&#125;, &#123;1, 1&#125;&#125;; private boolean isValid(int i, int j) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125;&#125; 加上base case 可以在j = n - 1时直接return 12if (j == n - 1) return 0; 代码 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; public int maxMoves(int[][] grid) &#123; m = grid.length; n = grid[0].length; this.grid = grid; dp = new int[m][n]; for (int[] arr : dp) Arrays.fill(arr, -1); int res = 0; for (int j = 0; j &lt; m; ++j) &#123; res = Math.max(res, dfs(j, 0)); &#125; return res; &#125; private int dfs(int i, int j) &#123; if (j == n - 1) return 0; if (dp[i][j] != -1) return dp[i][j]; int res = 0; for (int[] dir : dirs) &#123; int step = 0; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col) &amp;&amp; grid[row][col] &gt; grid[i][j]) &#123; step = dfs(row, col) + 1; &#125; res = Math.max(res, step); &#125; return dp[i][j] = res; &#125; int m, n; int[][] dp, grid, dirs = new int[][]&#123;&#123;0, 1&#125;, &#123;-1, 1&#125;, &#123;1, 1&#125;&#125;; private boolean isValid(int i, int j) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125;&#125; 简化(去掉step) 123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public int maxMoves(int[][] grid) &#123; m = grid.length; n = grid[0].length; this.grid = grid; dp = new int[m][n]; for (int[] arr : dp) Arrays.fill(arr, -1); int res = 0; for (int j = 0; j &lt; m; ++j) &#123; res = Math.max(res, dfs(j, 0)); &#125; return res; &#125; private int dfs(int i, int j) &#123; if (j == n - 1) return 0; if (dp[i][j] != -1) return dp[i][j]; int res = 0; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col) &amp;&amp; grid[row][col] &gt; grid[i][j]) res = Math.max(res, dfs(row, col) + 1); &#125; return dp[i][j] = res; &#125; int m, n; int[][] dp, grid, dirs = new int[][]&#123;&#123;0, 1&#125;, &#123;-1, 1&#125;, &#123;1, 1&#125;&#125;; private boolean isValid(int i, int j) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125;&#125; 时间复杂度：$O(mn)$ 方法二：DP 记忆化搜索(自动挡)转DP(手动挡)需要考虑 初始化 遍历顺序 步骤 记忆化搜索转DP，有几个状态(i,j)就有几个for循环 状态转移方程直接搬过来 12if (isValid(row, col) &amp;&amp; grid[row][col] &gt; grid[i][j]) res = Math.max(res, dfs(row, col) + 1); 遍历顺序 如下图，遍历顺序是从上到下，从右到左 最后的答案是在第一列里找最大值！不要用一个变量在所有列里找最大值 代码 123456789101112131415161718192021222324252627class Solution &#123; public int maxMoves(int[][] grid) &#123; m = grid.length; n = grid[0].length; this.grid = grid; dp = new int[m][n]; int res = 0; for (int j = n - 2; j &gt;= 0; --j) for (int i = 0; i &lt; m; ++i) for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col) &amp;&amp; grid[i][j] &lt; grid[row][col]) dp[i][j] = Math.max(dp[i][j], dp[row][col] + 1); &#125; for (int i = 0; i &lt; m; ++i) res = Math.max(res, dp[i][0]); return res; &#125; int m, n; int[][] dp, grid, dirs = new int[][]&#123;&#123;0, 1&#125;, &#123;-1, 1&#125;, &#123;1, 1&#125;&#125;; private boolean isValid(int i, int j) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125;&#125; 方法三：BFS ?why 双队列会超时 123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public int maxMoves(int[][] grid) &#123; m = grid.length; n = grid[0].length; this.grid = grid; int res = 0; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); boolean[][] visited = new boolean[m][n]; for (int i = 0; i &lt; m; ++i) queue.offer(new int[]&#123;i, 0&#125;); while (!queue.isEmpty()) &#123; int[] arr = queue.poll(); int row = arr[0], col = arr[1]; res = Math.max(res, col); for (int[] dir : dirs) &#123; int nextRow = row + dir[0], nextCol = col + 1; if (isValid(nextRow, nextCol) &amp;&amp; !visited[nextRow][nextCol] &amp;&amp; grid[nextRow][nextCol] &gt; grid[row][col]) &#123; if (nextCol == n - 1) return n - 1; visited[nextRow][nextCol] = true; queue.offer(new int[]&#123;nextRow, nextCol&#125;); &#125; &#125; &#125; return res; &#125; int m, n; int[][] grid, dirs = new int[][]&#123;&#123;0, 1&#125;, &#123;-1, 0&#125;, &#123;1, 0&#125;&#125;; private boolean isValid(int i, int j) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125;&#125; 统计完全连通分量的数量 方法一：并查集 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Solution &#123; public int countCompleteComponents(int n, int[][] edges) &#123; // 并查集确定连通分量 // 遍历每个连通分量，如果每个节点的入度 == 连通分量节点数 - 1，则是完全连通(或者只有一个顶点) init(n); int[] inDegrees = new int[n];// Set&lt;Integer&gt; visited = new HashSet&lt;&gt;(); // 如果某个节点没有与其他节点有边，算一个完全连通分量 for (int[] edge : edges) &#123;// visited.add(edge[0]);// visited.add(edge[1]); ++inDegrees[edge[0]]; ++inDegrees[edge[1]]; union(edge[0], edge[1]); &#125;// int notVisitedNum = n - visited.size(), res = 0; int res = 0; Map&lt;Integer, List&gt; graph = new HashMap&lt;&gt;(); for (int i = 0; i &lt; n; ++i) &#123; graph.putIfAbsent(findParent(i), new LinkedList()); graph.get(findParent(i)).add(i); &#125; for (Map.Entry&lt;Integer, List&gt; entry : graph.entrySet()) &#123; List&lt;Integer&gt; nodes = entry.getValue(); int size = nodes.size(); boolean flag = true; for (int node : nodes) &#123; if (inDegrees[node] != size - 1) &#123; flag = false; break; &#125; &#125; if (flag) ++res; &#125; return res; &#125; int[] parent; private boolean union(int i, int j) &#123; int rootI = findParent(i), rootJ = findParent(j); if (rootI != rootJ) &#123; parent[rootI] = rootJ; return true; &#125; return false; &#125; private int findParent(int i) &#123; if (i != parent[i]) parent[i] = findParent(parent[i]); return parent[i]; &#125; private void init(int n) &#123; parent = new int[n]; for (int i = 0; i &lt; n; ++i) parent[i] = i; &#125;&#125; 记忆化搜索的缺点 值域大的时候，不能使用记忆化搜索，占用太多内存空间 比如不能解决https://leetcode.cn/problems/maximum-subarray/description/","categories":[{"name":"Contest","slug":"Contest","permalink":"https://leopol1d.github.io/categories/Contest/"},{"name":"LCP","slug":"Contest/LCP","permalink":"https://leopol1d.github.io/categories/Contest/LCP/"}],"tags":[{"name":"力扣杯","slug":"力扣杯","permalink":"https://leopol1d.github.io/tags/%E5%8A%9B%E6%89%A3%E6%9D%AF/"}]},{"title":"lcp354","slug":"lcp354","date":"2023-07-16T01:59:02.000Z","updated":"2023-08-01T08:29:00.575Z","comments":true,"path":"2023/07/16/lcp354/","link":"","permalink":"https://leopol1d.github.io/2023/07/16/lcp354/","excerpt":"","text":"第一题 特殊元素平方和 12345678910class Solution &#123; public int sumOfSquares(int[] nums) &#123; int n = nums.length, res = 0; for (int i = 0; i &lt; n; ++i) &#123; if (n % (i + 1) == 0) res += (nums[i] * nums[i]); &#125; return res; &#125;&#125; 第二题 数组的最大美丽值 方法一：二分查找 12345678910111213141516171819202122232425class Solution &#123; public int maximumBeauty(int[] nums, int k) &#123; int res = 0; Arrays.sort(nums); for (int i = 0; i &lt; nums.length; ++i) &#123; // 求小于nums[i] + 2k的最大值 int j = bisearch(nums, nums[i] + 2 * k); res = Math.max(res, j - i + 1); &#125; return res; &#125; private int bisearch(int[] nums, int num) &#123; int left = 0, right = nums.length - 1; while (left &lt;= right) &#123; int mid = (left + right) &gt;&gt; 1; if (nums[mid] &lt;= num) left = mid + 1; else right = mid - 1; &#125; return right; &#125; &#125; 滑动窗口 123456789101112class Solution &#123; public int maximumBeauty(int[] nums, int k) &#123; int res = 0; Arrays.sort(nums); for (int left = 0, right = 0; right &lt; nums.length; ++right) &#123; if (nums[right] - nums[left] &gt; 2 * k) left += 1; res = Math.max(res, right - left + 1); &#125; return res; &#125;&#125; 差分 1234567891011121314151617class Solution &#123; public int maximumBeauty(int[] nums, int k) &#123; int[] diff = new int[100003]; for (int x : nums) &#123; int left = Math.max(0, x - k); int right = Math.min(100001, x + k); ++diff[left]; --diff[right + 1]; &#125; int res = 0; for (int i = 1; i &lt; diff.length; ++i) &#123; diff[i] += diff[i - 1]; res = Math.max(res, diff[i]); &#125; return res; &#125;&#125; 第三题 12345678910111213141516171819202122232425262728293031class Solution &#123; public int minimumIndex(List&lt;Integer&gt; nums) &#123; n = nums.size(); this.nums = nums.stream().mapToInt(i-&gt;i).toArray(); Map&lt;Integer, Integer&gt; count = new HashMap&lt;&gt;(); TreeMap&lt;Integer, Integer&gt; treeMap = new TreeMap&lt;&gt;(); for (int i = 0; i &lt; n; ++i) &#123; count.put(this.nums[i], count.getOrDefault(this.nums[i], 0) + 1); treeMap.put(count.get(this.nums[i]), this.nums[i]); &#125; primary = treeMap.lastEntry().getValue(); int[] cnt = new int[n]; cnt[0] = this.nums[0] == primary ? 1 : 0; for (int i = 1; i &lt; n; ++i) &#123; cnt[i] = cnt[i - 1]; if (this.nums[i] == primary) cnt[i]++; &#125; for (int i = 0; i &lt; n - 1; ++i) &#123; if (cnt[i] * 2 &gt; i + 1 &amp;&amp; (cnt[n - 1] - cnt[i]) * 2 &gt; n - i - 1) &#123; return i; &#125; &#125; return -1; &#125; int n, MAX = Integer.MAX_VALUE, primary; int[] nums;&#125; 第四题 双指针 固定右端点，从右往左判断是否含有禁止的字符串 12345678910111213141516class Solution &#123; public int longestValidSubstring(String word, List&lt;String&gt; forbidden) &#123; int res = 0, n = word.length(); Set&lt;String&gt; set = new HashSet&lt;&gt;(forbidden); for (int left = 0,right = 0; right &lt; n; ++right) &#123; for (int i = right; i &gt;= left &amp;&amp; i &gt; right - 10; --i) &#123; if (set.contains(word.substring(i, right + 1))) &#123; left = i + 1; break; &#125; &#125; res = Math.max(res, right - left + 1); &#125; return res; &#125;&#125;","categories":[{"name":"Contest","slug":"Contest","permalink":"https://leopol1d.github.io/categories/Contest/"},{"name":"LCP","slug":"Contest/LCP","permalink":"https://leopol1d.github.io/categories/Contest/LCP/"}],"tags":[{"name":"力扣杯","slug":"力扣杯","permalink":"https://leopol1d.github.io/tags/%E5%8A%9B%E6%89%A3%E6%9D%AF/"}]},{"title":"lcp347","slug":"lcp347","date":"2023-07-13T02:52:25.000Z","updated":"2023-09-08T08:26:36.739Z","comments":true,"path":"2023/07/13/lcp347/","link":"","permalink":"https://leopol1d.github.io/2023/07/13/lcp347/","excerpt":"","text":"移除字符串中的尾随零 方法一：模拟 123456789101112class Solution &#123; public String removeTrailingZeros(String num) &#123; int index = -1, n = num.length(); for (int i = n - 1; i &gt;= 0; --i) &#123; if (num.charAt(i) == &#x27;0&#x27;) index = i; else break; &#125; return index == -1 ? num : num.substring(0, index); &#125;&#125; 对角线上不同值的数量差 方法一： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354```## 使所有字符相等的最小成本![ ](https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230713110131294.png) ### 方法一：```javaclass Solution &#123; public long minimumCost(String s) &#123; int n = s.length(); // left[0][j]: 将前j个字符往左边翻转，全部翻转成0需要的次数 // left[1][j]: 将前j个字符往左边翻转，全部翻转成1需要的次数 // right[0][j]：将前j个字符往后翻转，全部反转成0需要的次数 // right[1][j]：将前j个字符往后翻转，全部反转成1需要的次数 long[][] left = new long[2][n], right = new long[2][n]; char ch = s.charAt(0); left[0][0] = ch == &#x27;0&#x27; ? 0 : 1; left[1][0] = ch == &#x27;0&#x27; ? 1 : 0; for (int i = 1; i &lt; n; ++i) &#123; char num = s.charAt(i); if (num == &#x27;0&#x27;) &#123; left[0][i] = left[0][i - 1]; // yes left[1][i] = i + 1 + left[0][i - 1]; &#125; else &#123; // num == 1 left[0][i] = i + 1 + left[1][i - 1]; // ?? left[1][i] = left[1][i - 1]; // yes &#125; &#125; ch = s.charAt(n - 1); right[0][n - 1] = ch == &#x27;0&#x27; ? 0 : 1; right[1][n - 1] = ch == &#x27;0&#x27; ? 1 : 0; for (int i = n - 2; i &gt;= 0; --i) &#123; char num = s.charAt(i); if (num == &#x27;0&#x27;) &#123; right[0][i] = right[0][i + 1]; // yes right[1][i] = n - i + right[0][i + 1] ; &#125; else &#123; // num == 1 right[0][i] = n - i + right[1][i + 1] ; right[1][i] = right[1][i + 1]; // yes &#125; &#125; long res = Math.min(left[0][n - 1], left[1][n - 1]); res = Math.min(res, Math.min(right[0][0], right[1][0])); for (int i = 0; i &lt; n - 1; ++i) &#123; res = Math.min(res, left[0][i] + right[0][i + 1]); res = Math.min(res, left[1][i] + right[1][i + 1]); &#125; return res; &#125;&#125;","categories":[{"name":"Contest","slug":"Contest","permalink":"https://leopol1d.github.io/categories/Contest/"},{"name":"LCP","slug":"Contest/LCP","permalink":"https://leopol1d.github.io/categories/Contest/LCP/"}],"tags":[{"name":"力扣杯","slug":"力扣杯","permalink":"https://leopol1d.github.io/tags/%E5%8A%9B%E6%89%A3%E6%9D%AF/"}]},{"title":"Segment Tree","slug":"segment-tree","date":"2023-07-11T07:30:28.000Z","updated":"2023-07-13T02:44:21.670Z","comments":true,"path":"2023/07/11/segment-tree/","link":"","permalink":"https://leopol1d.github.io/2023/07/11/segment-tree/","excerpt":"","text":"总结数组问题 数组不变，区间查询：前缀和、树状数组、线段树； 数组单点修改，区间查询：树状数组、线段树； 数组区间修改，单点查询：差分、线段树； 数组区间修改，区间查询：线段树。 https://leetcode.cn/problems/my-calendar-i/solutions/1646079/by-lfool-xvpv/ 2286. 以组为单位订音乐会的门票","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://leopol1d.github.io/categories/Algorithms/"},{"name":"Segment Tree","slug":"Algorithms/Segment-Tree","permalink":"https://leopol1d.github.io/categories/Algorithms/Segment-Tree/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"https://leopol1d.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"Prefix Sum","slug":"prefix-sum","date":"2023-07-10T03:59:15.000Z","updated":"2023-09-28T10:34:54.400Z","comments":true,"path":"2023/07/10/prefix-sum/","link":"","permalink":"https://leopol1d.github.io/2023/07/10/prefix-sum/","excerpt":"","text":"总结数组问题 数组不变，区间查询：前缀和、树状数组、线段树； 数组单点修改，区间查询：树状数组、线段树； 数组区间修改，单点查询：差分、线段树； 数组区间修改，区间查询：线段树。 链接 差分数组 1109. 航班预订统计 方法一：差分数组 航班编号从1开始，初始化diff数组大小为n + 1，diff[0]没有意义 1234567891011121314class Solution &#123; public int[] corpFlightBookings(int[][] bookings, int n) &#123; int[] res = new int[n], diff = new int[n + 1]; for (int[] booking : bookings) &#123; diff[booking[0]] += booking[2]; if (booking[1] != n) diff[booking[1] + 1] -= booking[2]; &#125; res[0] = diff[1]; for (int i = 1; i &lt; n; ++i) res[i] = diff[i + 1] + res[i - 1]; return res; &#125;&#125; 1094. 拼车 方法一：差分数组 上车位置加，下车位置减 12diff[trip[1]] += trip[0];diff[trip[2]] -= trip[0]; 是diff[trip[2]] -= trip[0]; 而不是diff[trip[2] + 1] -= trip[0]; 12345678910111213141516class Solution &#123; public boolean carPooling(int[][] trips, int capacity) &#123; int[] diff = new int[1002]; for (int[] trip : trips) &#123; diff[trip[1]] += trip[0]; diff[trip[2]] -= trip[0]; &#125; int sum = 0; for (int x : diff) &#123; sum += x; if (sum &gt; capacity) return false; &#125; return true; &#125;&#125; 995. K 连续位的最小翻转次数 方法一：差分数组 题解 遍历到nums[i]时，如果nums[i] + count是偶数，则当前元素(可能被翻转过)实际值是0，需要翻转区间[i, i + k - 1]， 将diff[i + k]减一。遍历到i + k的时候，之前在i时的翻转不再生效，–count(–翻转次数) 12345678910111213141516171819class Solution &#123; public int minKBitFlips(int[] nums, int k) &#123; int n = nums.length; int[] diff = new int[n + 1]; // 减少一步越界处理 int res = 0, count = 0; // 当前被翻转次数 for (int i = 0; i &lt; n; ++i) &#123; if (diff[i] == -1) --count; if ((nums[i] + count) % 2 == 0) &#123; if (i + k &gt; n) return -1; ++res; ++count; --diff[i + k]; &#125; &#125; return res; &#125;&#125; 6919. 使数组中的所有元素都等于零 方法一：差分数组 与995. K 连续位的最小翻转次数相似，草稿纸上模拟，多Debug 注意diff[i + k - 1] += nums[i] + curDiff; 复原的位置是i + k - 1 举例 123456输入：nums = [2,2,3,1,1,0], k = 3输出：true解释：可以执行下述操作：- 选出子数组 [2,2,3] ，执行操作后，数组变为 nums = [1,1,2,1,1,0] 。- 选出子数组 [2,1,1] ，执行操作后，数组变为 nums = [1,1,1,0,0,0] 。- 选出子数组 [1,1,1] ，执行操作后，数组变为 nums = [0,0,0,0,0,0] 。 nums 2 2 3 1 1 0 curDiff diff i = 0 -2 0 2 0 0 0 -2 diff i = 1 -2 0 2 0 0 0 -2 diff i = 2 -2 0 1 0 1 0 -1 diff i = 3 -2 0 1 0 1 0 -1 diff i = 4 -2 0 1 0 1 0 0 diff i = 5 -2 0 1 0 1 0 0 1234567891011121314151617181920class Solution &#123; public boolean checkArray(int[] nums, int k) &#123; int n = nums.length; int[] diff = new int[n]; int curDiff = 0; for (int i = 0; i &lt; n; ++i) &#123; if (nums[i] + curDiff &gt; 0) &#123; if (i + k &gt; n) return false; diff[i] += -nums[i] - curDiff; diff[i + k - 1] += nums[i] + curDiff; &#125; else if (nums[i] + curDiff &lt; 0) return false; if (diff[i] != 0) curDiff += diff[i]; &#125; return true; &#125;&#125; 1893. 检查是否区域内所有整数都被覆盖 方法一：差分数组 1 &lt;= ranges.length &lt;= 50，所以diff大小为52，第0个位置不用，第51个位置用于防止越界 123456789101112131415161718class Solution &#123; public boolean isCovered(int[][] ranges, int left, int right) &#123; int[] diff = new int[52]; int max = 0, min = 50; for (int[] range : ranges) &#123; ++diff[range[0]]; --diff[range[1] + 1]; max = Math.max(max, range[1]); min = Math.min(min, range[0]); &#125; for (int i = min; i &lt;= max; ++i) diff[i] = diff[i - 1] + diff[i]; for (int i = left; i &lt;= right; ++i) if (diff[i] &lt;= 0) return false; return true; &#125;&#125; 方法二：差分数组 + 前缀和 12345678910111213141516class Solution &#123; public boolean isCovered(int[][] ranges, int left, int right) &#123; int[] diff = new int[52]; for (int[] range : ranges) &#123; ++diff[range[0]]; --diff[range[1] + 1]; &#125; int preSum = 0; for (int i = 1; i &lt;= 50; ++i) &#123; preSum += diff[i]; if (i &gt;= left &amp;&amp; i &lt;= right &amp;&amp; preSum &lt;= 0) return false; &#125; return true; &#125;&#125; 2251. 花期内花的数目 方法一：差分数组 + TreeMap 12345678910111213141516171819202122232425class Solution &#123; // O(n),差分数组 public int[] fullBloomFlowers(int[][] flowers, int[] people) &#123; int[] res = new int[people.length]; TreeMap&lt;Integer, Integer&gt; differMap = new TreeMap&lt;&gt;(); for (int i = 0; i &lt; flowers.length; i++) &#123; differMap.put(flowers[i][0], differMap.getOrDefault(flowers[i][0], 0) + 1); differMap.put(flowers[i][1] + 1, differMap.getOrDefault(flowers[i][1] + 1, 0) - 1); &#125; //差分数组还原 int pre = 0; for (Integer key : differMap.keySet()) &#123; pre = differMap.get(key) + pre; differMap.put(key, pre); &#125; for (int i = 0; i &lt; people.length; i++) &#123; int x = people[i]; Integer y = differMap.floorKey(x); if (y != null) res[i] = differMap.get(y); // res[i] = differMap.floorEntry(people[i]).getValue(); &#125; return res; &#125;&#125; 方法二：二分 123456789101112131415161718192021222324252627282930313233class Solution &#123; public int[] fullBloomFlowers(int[][] flowers, int[] people) &#123; int n = flowers.length; int[] start = new int[n], end = new int[n]; for (int i = 0; i &lt; n; ++i) &#123; start[i] = flowers[i][0]; end[i] = flowers[i][1]; &#125; Arrays.sort(start); Arrays.sort(end); int[] res = new int[people.length]; for (int i = 0; i &lt; people.length; ++i) &#123; int time = people[i]; // 时间time开了多少花，枯萎了多少花 int x = bisearch(start, time), y = bisearch(end, time - 1); // 花在end + 1时枯萎 res[i] = x - y; &#125; return res; &#125; // 找到小于等于t的最大数组下标 public int bisearch(int[] nums, int t) &#123; int l = 0, r = nums.length - 1; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if (nums[mid] &gt; t) r = mid - 1; else l = mid + 1; &#125; return l; &#125;&#125; 前缀和 303. 区域和检索 - 数组不可变 12345678910111213141516171819202122class NumArray &#123; int[] preSum; int n; public NumArray(int[] nums) &#123; n = nums.length; preSum = new int[n + 1]; for (int i = 1; i &lt;= n; ++i) preSum[i] = preSum[i - 1] + nums[i - 1]; &#125; public int sumRange(int left, int right) &#123; return preSum[right + 1] - preSum[left]; &#125;&#125;/** * Your NumArray object will be instantiated and called as such: * NumArray obj = new NumArray(nums); * int param_1 = obj.sumRange(left,right); */ 304. 二维区域和检索 - 矩阵不可变 看图 123456789101112131415161718192021222324class NumMatrix &#123; int[][] preSum; int m, n; public NumMatrix(int[][] matrix) &#123; m = matrix.length; n = matrix[0].length; preSum = new int[m + 1][n + 1]; for (int i = 1; i &lt;= m; ++i) for (int j = 1; j &lt;= n; ++j) preSum[i][j] = matrix[i - 1][j - 1] - preSum[i - 1][j - 1] + preSum[i][j - 1] + preSum[i - 1][j]; &#125; public int sumRegion(int row1, int col1, int row2, int col2) &#123; return preSum[row2 + 1][col2 + 1] + preSum[row1][col1] - preSum[row1][col2 + 1] - preSum[row2 + 1][col1]; &#125;&#125;/** * Your NumMatrix object will be instantiated and called as such: * NumMatrix obj = new NumMatrix(matrix); * int param_1 = obj.sumRegion(row1,col1,row2,col2); */ 363. 矩形区域不超过 K 的最大数值和 题解 方法一：朴素前缀和 1 &lt;= m, n &lt;= 100,时间复杂度$O(m2n2)$,最坏情况$10^8$刚刚好。 12345678910111213141516171819202122class Solution &#123; public int maxSumSubmatrix(int[][] matrix, int k) &#123; int m = matrix.length, n = matrix[0].length; int[][] preSum = new int[m + 1][n + 1]; for (int i = 1; i &lt;= m; ++i) for (int j = 1; j &lt;= n; ++j) preSum[i][j] = matrix[i - 1][j - 1] + preSum[i][j - 1] + preSum[i - 1][j] - preSum[i - 1][j - 1]; int max = Integer.MIN_VALUE / 2, sum = 0; for (int row1 = 0; row1 &lt; m; ++row1) &#123; for (int col1 = 0; col1 &lt; n; ++col1) &#123; for (int row2 = row1; row2 &lt; m; ++row2) &#123; for (int col2 = col1; col2 &lt; n; ++col2) &#123; sum = preSum[row2 + 1][col2 + 1] + preSum[row1][col1] - preSum[row1][col2 + 1] - preSum[row2 + 1][col1]; if (sum &lt;= k) max = Math.max(max, sum); &#125; &#125; &#125; &#125; return max; &#125;&#125; 方法二：前缀和 + 二分查找 题解 523. 连续的子数组和 方法一：前缀和 题解结论证明 preSum[i]:数组nums从下标0~i-1的和 123456789101112131415class Solution &#123; public boolean checkSubarraySum(int[] nums, int k) &#123; int n = nums.length; int[] preSum = new int[n + 1]; for (int i = 1; i &lt;= n; ++i) preSum[i] = preSum[i - 1] + nums[i - 1]; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int i = 2; i &lt;= n; ++i) &#123; set.add(preSum[i - 2] % k); if (set.contains(preSum[i] % k)) return true; &#125; return false; &#125;&#125; 6952. 统计趣味子数组的数目 方法一：前缀和 + HashMap + 公式转换 类似两数之和 12345678910111213public long countInterestingSubarrays(List&lt;Integer&gt; nums, int modulo, int k) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); map.put(0, 1); long res = 0; int s = 0; for (int x : nums) &#123; if (x % modulo == k) s = (s + 1) % modulo; res += map.getOrDefault((s - k + modulo) % modulo, 0); map.put(s, map.getOrDefault(s, 0) + 1); &#125; return res;&#125; 560. 和为 K 的子数组 方法一：前缀和 + HashMap 1234567891011121314class Solution &#123; public int subarraySum(int[] nums, int k) &#123; int n = nums.length, res = 0; Map&lt;Integer, Integer&gt; cnt = new HashMap&lt;&gt;(); int s = 0; cnt.put(0, 1); for (int x : nums) &#123; s += x; res += cnt.getOrDefault(s - k, 0); cnt.put(s, cnt.getOrDefault(s, 0) + 1); &#125; return res; &#125;&#125; 974. 和可被 K 整除的子数组 方法一：前缀和 + HashMap 1234567891011121314class Solution &#123; public int subarraysDivByK(int[] nums, int k) &#123; int res = 0, s = 0; Map&lt;Integer, Integer&gt; cnt = new HashMap&lt;&gt;(); cnt.put(0, 1); for (int x : nums) &#123; s += x; int mod = (s % k + k) % k; res += cnt.getOrDefault(mod, 0); cnt.put(mod , cnt.getOrDefault(mod, 0) + 1); &#125; return res; &#125;&#125; 523. 连续的子数组和 方法一：前缀和 + HashSet s[r + 1] - s[l] = mk =&gt; s[l] % k = s[r + 1] % k 子数组长度至少为2，那么就从2开始遍历 题解 123456789101112131415class Solution &#123; public boolean checkSubarraySum(int[] nums, int k) &#123; int n = nums.length; int[] sum = new int[n + 1]; for (int i = 0; i &lt; n; ++i) sum[i + 1] = sum[i] + nums[i]; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int i = 2; i &lt;= n; ++i) &#123; set.add(sum[i - 2] % k); if (set.contains(sum[i] % k)) return true; &#125; return false; &#125;&#125; 525. 连续数组 方法一：前缀和 + HashMap 题解 map.put(0, -1);哨兵，比如可以处理：nums = [0, 1] 12345678910111213141516class Solution &#123; public int findMaxLength(int[] nums) &#123; int n = nums.length, res = 0; int s = 0; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); map.put(0, -1); for (int i = 0; i &lt; n; ++i) &#123; s += (nums[i] == 0 ? -1 : 1); if (map.containsKey(s)) res = Math.max(res, i - map.get(s)); else map.put(s, i); &#125; return res; &#125;&#125;","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://leopol1d.github.io/categories/Algorithms/"},{"name":"Prefix Sum","slug":"Algorithms/Prefix-Sum","permalink":"https://leopol1d.github.io/categories/Algorithms/Prefix-Sum/"}],"tags":[{"name":"前缀和，差分数组","slug":"前缀和，差分数组","permalink":"https://leopol1d.github.io/tags/%E5%89%8D%E7%BC%80%E5%92%8C%EF%BC%8C%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/"}]},{"title":"lcp353","slug":"lcp353","date":"2023-07-09T02:27:08.000Z","updated":"2023-08-01T08:28:58.456Z","comments":true,"path":"2023/07/09/lcp353/","link":"","permalink":"https://leopol1d.github.io/2023/07/09/lcp353/","excerpt":"","text":"找出最大的可达成数字 12345678class Solution &#123; public int theMaximumAchievableX(int num, int t) &#123; for (int i = 0; i &lt; t; ++i) &#123; num += 2; &#125; return num; &#125;&#125; 达到末尾下标所需的最大跳跃次数 方法一：记忆化搜索 flags存储可达路径 123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public int maximumJumps(int[] nums, int target) &#123; this.nums = nums; this.target = target; dp = new int[nums.length]; Arrays.fill(dp, -1); flags = new boolean[nums.length]; int res = dfs(0, 0); return flags[0] ? res : -1; &#125; boolean flag = false; boolean[] flags; int[] nums, dp; int target; private int dfs(int index, int from) &#123; if (index == nums.length - 1) &#123; flags[from] = true; return 0; &#125; if (dp[index] != -1) return dp[index]; int res = 0; for (int i = index + 1; i &lt; nums.length; ++i) &#123; int max = 0; if (Math.abs(nums[i] - nums[index]) &lt;= target) &#123; max += dfs(i,i) + 1; if (flags[i]) flags[index] = true; if (flags[i]) &#123; res = Math.max(res, max); &#125; &#125; &#125; return dp[index] = res; &#125;&#125; 方法二： 题目中有：全部不满足情况下返回-1时，要重视dfs里res的初始化， -inf, inf等，根据具体要求具体分析 123456789101112131415161718192021222324252627class Solution &#123; public int maximumJumps(int[] nums, int target) &#123; this.nums = nums; this.target = target; dp = new int[nums.length]; Arrays.fill(dp, -1); int res = dfs(0); return res &lt; 0 ? -1 : res; &#125; int[] nums; int target; int[] dp; private int dfs(int index) &#123; if (index == nums.length - 1) return 0; if (dp[index] != -1) return dp[index]; int res = -Integer.MAX_VALUE / 2; for (int i = index + 1; i &lt; nums.length; ++i) &#123; if (Math.abs(nums[i] - nums[index]) &lt;= target) res = Math.max(res, dfs(i) + 1); &#125; return dp[index] = res; &#125;&#125; 构造最长非递减子数组 方法一：记忆化搜索 要遍历完从0到n-1开始的下标，因为最长不一定从下标0开始，比如nums1 = [8,7,4] nums2 = [13,4,4]，最大长度从下标1开始 [4,4] 1234567891011121314151617181920212223242526272829class Solution &#123; public int maxNonDecreasingLength(int[] nums1, int[] nums2) &#123; this.nums1 = nums1; this.nums2 = nums2; int res = 1; for (int i = 0; i &lt; nums1.length; ++i) res = Math.max(res, dfs(i, 0)); return res; &#125; int[] nums1, nums2; Map&lt;String, Integer&gt; dp = new HashMap&lt;&gt;(); private int dfs(int index, int pre) &#123; if (index == nums1.length) return 0; String key = index + &quot;-&quot; + pre; if (dp.containsKey(key)) return dp.get(key); int res = 0; // res最小也是1，1个数的长度为1 if (pre &lt;= nums1[index]) res = Math.max(res, dfs(index + 1, nums1[index]) + 1); if (pre &lt;= nums2[index]) res = Math.max(res, dfs(index + 1, nums2[index]) + 1); dp.put(key, res); return res; &#125; &#125; 使数组中的所有元素都等于零 方法一：差分数组 与995. K 连续位的最小翻转次数相似，草稿纸上模拟，多Debug 注意diff[i + k - 1] += nums[i] + curDiff; 复原的位置是i + k - 1 举例 123456输入：nums = [2,2,3,1,1,0], k = 3输出：true解释：可以执行下述操作：- 选出子数组 [2,2,3] ，执行操作后，数组变为 nums = [1,1,2,1,1,0] 。- 选出子数组 [2,1,1] ，执行操作后，数组变为 nums = [1,1,1,0,0,0] 。- 选出子数组 [1,1,1] ，执行操作后，数组变为 nums = [0,0,0,0,0,0] 。 nums 2 2 3 1 1 0 curDiff diff i = 0 -2 0 2 0 0 0 -2 diff i = 1 -2 0 2 0 0 0 -2 diff i = 2 -2 0 1 0 1 0 -1 diff i = 3 -2 0 1 0 1 0 -1 diff i = 4 -2 0 1 0 1 0 0 diff i = 5 -2 0 1 0 1 0 0 1234567891011121314151617181920class Solution &#123; public boolean checkArray(int[] nums, int k) &#123; int n = nums.length; int[] diff = new int[n]; int curDiff = 0; for (int i = 0; i &lt; n; ++i) &#123; if (nums[i] + curDiff &gt; 0) &#123; if (i + k &gt; n) return false; diff[i] += -nums[i] - curDiff; diff[i + k - 1] += nums[i] + curDiff; &#125; else if (nums[i] + curDiff &lt; 0) return false; if (diff[i] != 0) curDiff += diff[i]; &#125; return true; &#125;&#125;","categories":[{"name":"Contest","slug":"Contest","permalink":"https://leopol1d.github.io/categories/Contest/"},{"name":"LCP","slug":"Contest/LCP","permalink":"https://leopol1d.github.io/categories/Contest/LCP/"}],"tags":[{"name":"力扣杯","slug":"力扣杯","permalink":"https://leopol1d.github.io/tags/%E5%8A%9B%E6%89%A3%E6%9D%AF/"}]},{"title":"lcpBi108","slug":"lcpBi108","date":"2023-07-08T13:19:34.000Z","updated":"2023-08-01T08:29:16.829Z","comments":true,"path":"2023/07/08/lcpBi108/","link":"","permalink":"https://leopol1d.github.io/2023/07/08/lcpBi108/","excerpt":"","text":"最长交替子序列 123456789101112131415161718192021222324252627282930class Solution &#123; public int alternatingSubarray(int[] nums) &#123; int res = -1; for (int i = 0; i &lt; nums.length - 1; ++i) &#123; int pre = -1; for (int j = i + 1; j &lt; nums.length; ++j) &#123; if (pre == -1) &#123; if (nums[j] - nums[j - 1] == 1) &#123; res = Math.max(res, j - i + 1); pre = 1; &#125; else break; &#125; else if (pre == 1) &#123; if (nums[j] - nums[j - 1] == -1) &#123; res = Math.max(res, j - i + 1); pre = -1; &#125; else break; &#125; else &#123; break; &#125; &#125; &#125; return res; &#125;&#125; 分组循环 重新放置石块 1234567891011121314151617class Solution &#123; public List&lt;Integer&gt; relocateMarbles(int[] nums, int[] moveFrom, int[] moveTo) &#123; TreeMap&lt;Integer, Integer&gt; map = new TreeMap&lt;&gt;(); for (int x : nums) map.put(x, map.getOrDefault(x, 0) + 1); for (int i = 0; i &lt; moveFrom.length; ++i) &#123; int from = moveFrom[i], to = moveTo[i]; int fromNum = map.get(from); map.remove(from); map.put(to, map.getOrDefault(to, 0) + fromNum); &#125; List&lt;Integer&gt; res = new LinkedList&lt;&gt;(); for (int key : map.keySet()) res.add(key); return res; &#125;&#125; 将字符串分割为最少的美丽子字符串 方法一：记忆化搜索 题目中有：全部不满足情况下返回-1时，要重视dfs里res的初始化， -inf, inf等，根据具体要求具体分析 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public int minimumBeautifulSubstrings(String s) &#123; int a = (int) Math.pow(2, 15); set = new HashSet&lt;&gt;(); for (int i = 0; i &lt;= a; ++i) &#123; int num = (int) Math.pow(5, i); if (num &gt; a) break; set.add(Integer.toBinaryString(num)); &#125; int res = dfs(s, 0); return res == Integer.MAX_VALUE / 2 ? -1 : res; &#125; Set&lt;String&gt; set; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); private int dfs(String s, int index) &#123; if (index == s.length()) &#123; return 0; &#125; if (map.containsKey(index)) return map.get(index); int res = Integer.MAX_VALUE / 2; for (int i = index; i &lt; s.length(); ++i) &#123; if (s.charAt(index) == &#x27;0&#x27;) break; String sub = s.substring(index, i + 1); int splitNum = 0; if (set.contains(sub)) &#123; splitNum += dfs(s, i + 1) + 1; res = Math.min(res, splitNum); &#125; &#125; map.put(index, res); return res; &#125;&#125; 方法二：记忆化搜索 预处理 预处理部分放在静态块里，只会执行一次 123456789101112131415161718public class Solution &#123; static Set&lt;String&gt; set; static &#123; int a = (int) Math.pow(2, 15); set = new HashSet&lt;&gt;(); for (int i = 0; i &lt;= a; ++i) &#123; int num = (int) Math.pow(5, i); if (num &gt; a) break; set.add(Integer.toBinaryString(num)); &#125; &#125; public int minimumBeautifulSubstrings(String s) &#123; return -1; &#125; 黑格子的数目 方法一：Map 题解 ​ res[0] = (m - 1L) * (n - 1) - sum; 1L转成long避免m，n太大 1234567891011121314151617181920212223class Solution &#123; public long[] countBlackBlocks(int m, int n, int[][] coordinates) &#123; Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); int[][] dirs = new int[][]&#123;&#123;-1, -1&#125;, &#123;-1, 0&#125;, &#123;0, -1&#125;, &#123;0, 0&#125;&#125;; for (int[] arr : coordinates) &#123; for (int[] dir : dirs) &#123; int row = arr[0] + dir[0], col = arr[1] + dir[1]; if (row &gt;= 0 &amp;&amp; col &gt;= 0 &amp;&amp; row &lt; m - 1 &amp;&amp; col &lt; n - 1) &#123; String rc = row + &quot;-&quot; + col; map.put(rc, map.getOrDefault(rc, 0) + 1); &#125; &#125; &#125; long[] res = new long[5]; long sum = 0; for (int val : map.values()) &#123; ++res[val]; ++sum; &#125; res[0] = (m - 1L) * (n - 1) - sum; return res; &#125;&#125;","categories":[{"name":"Contest","slug":"Contest","permalink":"https://leopol1d.github.io/categories/Contest/"},{"name":"LCP","slug":"Contest/LCP","permalink":"https://leopol1d.github.io/categories/Contest/LCP/"}],"tags":[{"name":"力扣杯","slug":"力扣杯","permalink":"https://leopol1d.github.io/tags/%E5%8A%9B%E6%89%A3%E6%9D%AF/"}]},{"title":"lcp349","slug":"lcp349","date":"2023-07-06T06:10:50.000Z","updated":"2023-08-01T08:28:45.987Z","comments":true,"path":"2023/07/06/lcp349/","link":"","permalink":"https://leopol1d.github.io/2023/07/06/lcp349/","excerpt":"","text":"既不是最小值也不是最大值 方法一： 12345678910111213class Solution &#123; public int findNonMinOrMax(int[] nums) &#123; if (nums.length &lt;= 2) return -1; Arrays.sort(nums); int min = nums[0], max = nums[nums.length - 1]; for (int i = 1; i &lt; nums.length - 1; ++i) &#123; if (nums[i] != min &amp;&amp; nums[i] != max) return nums[i]; &#125; return -1; &#125;&#125; 执行子串操作后的字典序最小字符串 方法一： 至少要操作一次 也就是说如果s = “aaaa”，操作一次后是“aaaz” 1234567891011121314151617181920212223242526class Solution &#123; public String smallestString(String s) &#123; StringBuilder sb = new StringBuilder(); int edit = 0, n = s.length(); for (int i = 0; i &lt; n; ++i) &#123; char ch = s.charAt(i); if (ch == &#x27;a&#x27;) &#123; if (edit == 0) &#123; if (i == n - 1) sb.append(&#x27;z&#x27;); else sb.append(&#x27;a&#x27;); &#125; else &#123; // edit &gt; 0 sb.append(s.substring(i)); break; &#125; &#125; else &#123; sb.append((char) (ch - 1)); ++edit; &#125; &#125; return sb.toString(); &#125;&#125; 收集巧克力 最大和查询","categories":[{"name":"Contest","slug":"Contest","permalink":"https://leopol1d.github.io/categories/Contest/"},{"name":"LCP","slug":"Contest/LCP","permalink":"https://leopol1d.github.io/categories/Contest/LCP/"}],"tags":[{"name":"力扣杯","slug":"力扣杯","permalink":"https://leopol1d.github.io/tags/%E5%8A%9B%E6%89%A3%E6%9D%AF/"}]},{"title":"lcp350","slug":"lcp350","date":"2023-07-05T01:15:00.000Z","updated":"2023-09-09T13:16:17.927Z","comments":true,"path":"2023/07/05/lcp350/","link":"","permalink":"https://leopol1d.github.io/2023/07/05/lcp350/","excerpt":"","text":"总行驶距离 二刷：模拟 1234567891011121314151617class Solution &#123; public int distanceTraveled(int mainTank, int additionalTank) &#123; if (mainTank &lt; 5) return mainTank * 10; int x = mainTank, res = (mainTank - mainTank % 5) * 10, s = mainTank % 5; while (x &gt;= 5) &#123; int y = x / 5; x = x % 5; y = Math.min(y, additionalTank); additionalTank -= y; x += y; s += y; &#125; res += s * 10; return res; &#125;&#125; 时间复杂度：$O(1)$ 1234567891011121314151617class Solution &#123; public int distanceTraveled(int mainTank, int additionalTank) &#123; int res = 0, ori = mainTank; while (mainTank &gt; 0) &#123; --mainTank; res += 10; if (ori == mainTank + 5) &#123; if (additionalTank &gt; 0) &#123; --additionalTank; ++mainTank; ori = mainTank; &#125; &#125; &#125; return res; &#125;&#125; 找出分区值 二刷：排序 123456789class Solution &#123; public int findValueOfPartition(int[] nums) &#123; Arrays.sort(nums); int min = Integer.MAX_VALUE; for (int i = 0; i &lt; nums.length - 1; ++i) min = Math.min(min,nums[i + 1] - nums[i]); return min; &#125;&#125; 1234567891011121314class Solution &#123; public int findValueOfPartition(int[] nums) &#123; Arrays.sort(nums); int n = nums.length; int[] arr = new int[n - 1]; for (int i = 0; i &lt; n - 1; ++i) arr[i] = nums[i + 1] - nums[i]; int min = Integer.MAX_VALUE; for (int x : arr) &#123; min = Math.min(min, x); &#125; return min; &#125;&#125; 特别的排列 方法一：三种回溯(超时) 回溯一 123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public int specialPerm(int[] nums) &#123; visited = new boolean[nums.length]; Arrays.sort(nums); dfs(nums, 0); return res; &#125; int res = 0, MOD = (int) (1e9 + 7); Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); boolean[] visited; private void dfs(int[] nums, int index) &#123; if (path.size() == nums.length) &#123; res = (res + 1) % MOD; return; &#125; for (int i = 0; i &lt; nums.length; ++i) &#123; if (visited[i]) continue; if (i != 0 &amp;&amp; nums[i - 1] == nums[i] &amp;&amp; !visited[i - 1]) continue; if (path.isEmpty() || check(nums[i], path.peekLast())) &#123; visited[i] = true; path.offerLast(nums[i]); dfs(nums, i + 1); path.pollLast(); visited[i] = false; &#125; &#125; &#125; private boolean check(int a, int b) &#123; return (a % b == 0) || (b % a == 0); &#125;&#125; 回溯二 123456789101112131415161718192021222324252627282930313233343536public int specialPerm(int[] nums) &#123; visited = new boolean[nums.length]; dp = new HashMap&lt;&gt;(); Arrays.sort(nums); return dfs(nums);&#125;int MOD = (int) (1e9 + 7);Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;();boolean[] visited;Map&lt;String, Integer&gt; dp;private int dfs(int[] nums) &#123; if (path.size() == nums.length) return 1; int res = 0; for (int i = 0; i &lt; nums.length; ++i) &#123; if (visited[i]) continue; if (i != 0 &amp;&amp; nums[i - 1] == nums[i] &amp;&amp; !visited[i - 1]) continue; if (path.isEmpty() || check(nums[i], path.peekLast())) &#123; visited[i] = true; path.offerLast(nums[i]); res = (res + dfs(nums)) % MOD; path.pollLast(); visited[i] = false; &#125; &#125; return res;&#125;private boolean check(int a, int b) &#123; return (a % b == 0) || (b % a == 0);&#125; 回溯三 12345678910111213141516171819202122232425262728293031323334public int specialPerm(int[] nums) &#123; this.nums = nums; visited = new boolean[nums.length]; dp = new HashMap&lt;&gt;(); Arrays.sort(nums); return dfs(0, -1);&#125;private int dfs(int index, int lastChoosed) &#123; if (index == nums.length) return 1; int res = 0; for (int i = 0; i &lt; nums.length; ++i) &#123; if (visited[i]) continue; if (lastChoosed != -1 &amp;&amp; nums[lastChoosed] == nums[i] &amp;&amp; !visited[i]) continue; if (lastChoosed == -1 || check(nums[lastChoosed], nums[i])) &#123; visited[i] = true; res = (res + dfs(index + 1, i)) % MOD; visited[i] = false; &#125; &#125; return res;&#125;int MOD = (int) (1e9 + 7);boolean[] visited;int[] nums;Map&lt;String, Integer&gt; dp;private boolean check(int a, int b) &#123; return (a % b == 0) || (b % a == 0);&#125; 方法二：记忆化搜索 + 状态压缩 先看题解 举例 nums = [2, 3, 6, 6] 2，6，3，6 3，6，2，6 6，2，6，3 6，3，6，2 2，6，6，3 3，6，6，2 其中2，6，6，3与6，2，6，3可以使用记忆化搜索 [2，6]，6，3与[6，2]，6，3, 下标为2的6前[2, 6]与[6,2]是同一个组合(不考虑顺序) 只要下标为i(2)是相同的数(6)，并且前i个数是同一个组合，那么在i之后是重复计算 计算过[2，6]，6后，再遇到[6，2]，6，只要返回map里的值就行 状态压缩 u | (1 &lt;&lt; i)存储的是数组下标，初始u = 0。 | 是或运算, 1 &lt;&lt; i 将1左移i位 例如，将2(下标0)存入u中， 初始u = 0000, 0000 | (1 &lt;&lt; 0) = 0001 将6(下标1)存入u中 u = 0001 0001 | (1 &lt;&lt; 1) = 0011 将[2, 6]存入u中 u = 0011 == 将[6, 2]存入u中u = 0011 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public int specialPerm(int[] nums) &#123; this.nums = nums; visited = new boolean[nums.length]; dp = new HashMap&lt;&gt;(); Arrays.sort(nums); return dfs(0, -1, 0); &#125; private int dfs(int index, int lastChoosed, int u) &#123; if (index == nums.length) return 1; String key = lastChoosed + &quot;#&quot; + u; if (dp.containsKey(key)) return dp.get(key); int res = 0; for (int i = 0; i &lt; nums.length; ++i) &#123; if (visited[i]) continue; // 去重，这道题可以不要这段if if (lastChoosed != -1 &amp;&amp; nums[lastChoosed] == nums[i] &amp;&amp; !visited[i]) continue; if (lastChoosed == -1 || check(nums[lastChoosed], nums[i])) &#123; visited[i] = true; res = (res + dfs(index + 1, i, (u | (1 &lt;&lt; i)))) % MOD; visited[i] = false; &#125; &#125; dp.put(key, res); return res; &#125; int MOD = (int) (1e9 + 7); boolean[] visited; int[] nums; Map&lt;String, Integer&gt; dp; private boolean check(int a, int b) &#123; return (a % b == 0) || (b % a == 0); &#125;&#125; 给墙壁刷油漆 方法一：记忆化搜索 dfs(int index, int leftTime) index是遍历到的cost的下标，leftTime是可以白嫖的次数(1单位时间白嫖1次) 付费：dfs(index + 1, leftTime + time[index]) + cost[index]; 白嫖：dfs(index + 1, leftTime - 1); 初始化：dp = new int[n][2 * n]; leftTime可能是负数而且最小-n 剪枝：如果白嫖次数大于等于剩余需要刷漆的次数，那么全部白嫖的花费最小 12if (leftTime &gt;= n - index) return 0; 代码 123456789101112131415161718192021222324252627class Solution &#123; public int paintWalls(int[] cost, int[] time) &#123; n = cost.length; this.cost = cost; this.time = time; dp = new int[n][2 * n]; for (int[] arr : dp) Arrays.fill(arr, -1); return dfs(0, 0); &#125; private int dfs(int index, int leftTime) &#123; if (index == n) return leftTime &gt;= 0 ? 0 : Integer.MAX_VALUE / 2; if (leftTime &gt;= n - index) return 0; if (dp[index][leftTime + n] != -1) return dp[index][leftTime + n]; int pay = dfs(index + 1, leftTime + time[index]) + cost[index]; int free = dfs(index + 1, leftTime - 1); return dp[index][leftTime + n] = Math.min(pay, free); &#125; int[] cost, time; int[][] dp; int n;&#125;","categories":[{"name":"Contest","slug":"Contest","permalink":"https://leopol1d.github.io/categories/Contest/"},{"name":"LCP","slug":"Contest/LCP","permalink":"https://leopol1d.github.io/categories/Contest/LCP/"}],"tags":[{"name":"力扣杯","slug":"力扣杯","permalink":"https://leopol1d.github.io/tags/%E5%8A%9B%E6%89%A3%E6%9D%AF/"}]},{"title":"lcpBi107","slug":"lcpBi107","date":"2023-07-04T01:29:10.000Z","updated":"2023-08-01T08:29:14.418Z","comments":true,"path":"2023/07/04/lcpBi107/","link":"","permalink":"https://leopol1d.github.io/2023/07/04/lcpBi107/","excerpt":"","text":"最大字符串配对数目 方法一：记忆化搜索 123456789101112131415161718192021222324class Solution &#123; public int longestString(int x, int y, int z) &#123; dp = new HashMap&lt;&gt;(); return dfs(x, y, z, &#x27; &#x27;); // AA BB AB &#125; Map&lt;String, Integer&gt; dp; private int dfs(int x, int y, int z, char lastChar) &#123; if (x == 0 &amp;&amp; y == 0 &amp;&amp; z == 0) return 0; String key = x + &quot;,&quot; + y + &quot;,&quot; + z + &quot;,&quot; + lastChar; if (dp.containsKey(key)) return dp.get(key); int max = 0; if (x &gt; 0 &amp;&amp; lastChar != &#x27;A&#x27;) max = Math.max(max, dfs(x - 1, y, z, &#x27;A&#x27;) + 2); if (y &gt; 0 &amp;&amp; lastChar != &#x27;B&#x27;) max = Math.max(max, dfs(x, y - 1, z, &#x27;B&#x27;) + 2); if (z &gt; 0 &amp;&amp; lastChar != &#x27;A&#x27;) max = Math.max(max, dfs(x, y, z - 1, &#x27;B&#x27;) + 2); dp.put(key, max); return max; &#125;&#125; 方法二：记忆化搜索 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455```## 字符串连接删减字母![ ](https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230704113929490.png)### 方法一：记忆化搜索[题解](https://leetcode.cn/problems/decremental-string-concatenation/solutions/1/hui-su-ji-yi-hua-sou-suo-java-by-tailtal-dmix/)1. 如果当前要合并的单词为words[index]，并且已合并单词str的首尾字符分别为first，last，记words[index]的首尾字符分别为first2, last2。2. 现在有两种拼接方式： 1. str + words[index] ： - 如果last == first2，那么**拼接成新字符串长度的增量**为len1 = words[index].length() - 1 - 否则，**拼接成新字符串长度的增量**为len1 = words[index].length() 2. words[index] + str - 如果last2 == first，那么**拼接成新字符串长度的增量**为len2 = words[index].length() - 1 - 否则，**拼接成新字符串长度的增量**为len2 = words[index].length() 3. 取min(len1, len2)，存入map中，key为index + &quot;,&quot; + first + &quot;,&quot; + last 4. 在下次遍历到相同index，first，last的时候，**虽然已合并单词str的长度可能不同，但是字符串长度增量是相同的！**```javaclass Solution &#123; public int minimizeConcatenatedLength(String[] words) &#123; this.words = words; n = words.length; dp = new HashMap&lt;&gt;(); int res = dfs(1, words[0].charAt(0), words[0].charAt(words[0].length() - 1)) + words[0].length(); return res; &#125; String[] words; int n; Map&lt;String, Integer&gt; dp; private int dfs(int index, char first, char last) &#123; if (index == n) return 0; String key = index + &quot;,&quot; + first + &quot;,&quot; + last; if (dp.containsKey(key)) return dp.get(key); char first2 = words[index].charAt(0), last2 = words[index].charAt(words[index].length() - 1); int min = Integer.MAX_VALUE; // first插入到words[index]后面 int res1 = dfs(index + 1, first2, last); min = Math.min(min, res1 + words[index].length() - (first == last2 ? 1 : 0)); // last插入到words[index]前面 int res2 = dfs(index + 1, first, last2); min = Math.min(min, res2 + words[index].length() - (last == first2 ? 1 : 0)); dp.put(key, min); return min; &#125;&#125; 统计没有收到请求的服务器数目 方法一：模拟(超时) 123456789101112131415161718192021222324252627class Solution &#123; public int[] countServers(int n, int[][] logs, int x, int[] queries) &#123; int[] res = new int[queries.length]; int maxTime = 0; for (int q : queries) maxTime = Math.max(maxTime, q); int[][] arr = new int[n + 1][(int) 1e6]; for (int[] log : logs) &#123; arr[log[0]][log[1]] = 1; &#125; for (int k = 0; k &lt; queries.length; ++k) &#123; int right = queries[k], left = right - x; for (int i = 1; i &lt;= n; ++i) &#123; boolean flag = false; for (int j = left; j &lt;= right; ++j) &#123; if (arr[i][j] == 1) &#123; flag = true; break; &#125; &#125; if (!flag) ++res[k]; &#125; &#125; return res; &#125;&#125;","categories":[{"name":"Contest","slug":"Contest","permalink":"https://leopol1d.github.io/categories/Contest/"},{"name":"LCP","slug":"Contest/LCP","permalink":"https://leopol1d.github.io/categories/Contest/LCP/"}],"tags":[{"name":"力扣杯","slug":"力扣杯","permalink":"https://leopol1d.github.io/tags/%E5%8A%9B%E6%89%A3%E6%9D%AF/"}]},{"title":"lcp351","slug":"lcp351","date":"2023-07-03T06:04:33.000Z","updated":"2023-08-01T08:28:53.260Z","comments":true,"path":"2023/07/03/lcp351/","link":"","permalink":"https://leopol1d.github.io/2023/07/03/lcp351/","excerpt":"","text":"美丽下标对的数目 123456789101112131415161718192021222324252627class Solution &#123; public int countBeautifulPairs(int[] nums) &#123; int res = 0; for (int i = 0; i &lt; nums.length; ++i) for (int j = i + 1; j &lt; nums.length; ++j) if (check(i, j, nums)) ++res; return res; &#125; private boolean check(int i, int j, int[] nums) &#123; int num1 = nums[i], num2 = nums[j]; char ch1 = String.valueOf(num1).charAt(0); String str = String.valueOf(num2); char ch2 = str.charAt(str.length() - 1); int l = Integer.parseInt(String.valueOf(ch1)), r = Integer.parseInt(String.valueOf(ch2)); int small = l &lt; r ? l : r; int great = l &gt; r ? l : r; if (small == 1) return true; for (int k = 2; k &lt;= small; ++k) &#123; if (small % k == 0 &amp;&amp; great % k == 0) return false; &#125; return true; &#125;&#125; 得到整数零需要执行的最少操作数 123456789101112131415161718class Solution &#123; public int makeTheIntegerZero(int num1, int num2) &#123; /** * 1. 从小到大枚举答案 * 2. 假设操作次数为 k * 则问题变为：x = num1 - k * num2 能不能是k个2^i之和 * 能的话就立即返回结果 * 3. 如果x.bitCount &lt;= k，那么一定可以是k个2^i之和 * 对于循环退出条件，那么如果num2 &lt; 0, 那么当 x &lt; k，再增大k只会让x越来越小，此时肯定要结束循环 * 若num2 &lt; 0，因为num2只能是-1 -2 -3...这样，也就是说若k + 1，则x 会增加 -num2，也就是说至少也会+1 * 则k永远无法追上x，此时也要结束循环 */ for (long k = 1; k &lt;= num1 - k * num2; k++) &#123; if (k &gt;= Long.bitCount(num1 - k * num2)) return (int)k; &#125; return -1; &#125;&#125; 将数组划分成若干好子数组的方式 123456789101112131415161718192021222324252627class Solution &#123; public int numberOfGoodSubarraySplits(int[] nums) &#123; // &#123;0,1,|0,0,1|,0,0,1,0&#125; // &#123;0,1,|0,0,1,0|,0,1,0&#125; // &#123;0,1,|0,0,1,0,0|,1,0&#125; // &#123;0,1,0,|0,1|,0,0,1,0&#125; // &#123;0,1,0,|0,1,0|,0,1,0&#125; // &#123;0,1,0,|0,1,0,0|,1,0&#125; // &#123;0,1,0,0,|1,|0,0,1,0&#125; // &#123;0,1,0,0,|1,0,|0,1,0&#125; // &#123;0,1,0,0,|1,0,0,|1,0&#125; final long MOD = (long) 1e9 + 7; List&lt;Integer&gt; list = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; nums.length; ++i) if (nums[i] == 1) list.add(i); int[] interval = list.stream().mapToInt(i -&gt; i).toArray(); if (interval.length == 0) return 0; long res = 1; for (int i = 1; i &lt; interval.length; ++i) res = (res * (interval[i] - interval[i - 1])) % MOD; return (int) res; &#125;&#125; 机器人碰撞 方法一：栈模拟 类似于735. 行星碰撞 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123; public List&lt;Integer&gt; survivedRobotsHealths(int[] positions, int[] healths, String directions) &#123; int n = positions.length; Map&lt;Integer, Integer&gt; posToIdx = new HashMap&lt;&gt;(), posToHealth = new HashMap&lt;&gt;(); Map&lt;Integer, Character&gt; posToDir = new HashMap&lt;&gt;(); for (int i = 0; i &lt; n; ++i) &#123; posToIdx.put(positions[i], i); posToHealth.put(positions[i], healths[i]); posToDir.put(positions[i], directions.charAt(i)); &#125; Arrays.sort(positions); Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for (int i = 0; i &lt; n; ++i) &#123; boolean alive = true; char dir = posToDir.get(positions[i]); while (alive &amp;&amp; !stack.isEmpty() &amp;&amp; dir == &#x27;L&#x27; &amp;&amp; posToDir.get(stack.peek()) == &#x27;R&#x27; ) &#123; int topPos = stack.peek(); int topHealth = posToHealth.get(topPos); if (posToHealth.get(positions[i]) &gt; topHealth) &#123; stack.pop(); posToHealth.put(positions[i], posToHealth.get(positions[i]) - 1); &#125; else if (posToHealth.get(positions[i]) &lt; topHealth) &#123; alive = false; posToHealth.put(topPos, posToHealth.get(topPos) - 1); &#125; else &#123; //== alive = false; stack.pop(); &#125; &#125; if (alive) stack.push(positions[i]); &#125; int[] newHealths = new int[n]; while (!stack.isEmpty()) &#123; int pos = stack.pop(); int index = posToIdx.get(pos), health = posToHealth.get(pos); newHealths[index] = health; &#125; List&lt;Integer&gt; survivor = new LinkedList&lt;&gt;(); for (int x : newHealths) if (x != 0) survivor.add(x); return survivor; &#125;&#125; ​","categories":[{"name":"Contest","slug":"Contest","permalink":"https://leopol1d.github.io/categories/Contest/"},{"name":"LCP","slug":"Contest/LCP","permalink":"https://leopol1d.github.io/categories/Contest/LCP/"}],"tags":[{"name":"力扣杯","slug":"力扣杯","permalink":"https://leopol1d.github.io/tags/%E5%8A%9B%E6%89%A3%E6%9D%AF/"}]},{"title":"lcp352","slug":"lcp352","date":"2023-07-02T09:50:45.000Z","updated":"2023-08-01T08:28:55.954Z","comments":true,"path":"2023/07/02/lcp352/","link":"","permalink":"https://leopol1d.github.io/2023/07/02/lcp352/","excerpt":"","text":"6909. 最长奇偶子数组 方法一：暴力枚举 123456789101112131415161718192021222324252627282930313233class Solution &#123; public int longestAlternatingSubarray(int[] nums, int threshhold) &#123; // dp int n = nums.length; int res = 0; for (int i = 0; i &lt; n; ++i) &#123; if (nums[i] % 2 != 0 || nums[i] &gt; threshhold) continue; int len = 1, pre = 0; res = Math.max(res, len); for (int j = i + 1; j &lt; n; ++j) &#123; if (pre == 0) &#123; if (nums[j] % 2 == 1 &amp;&amp; nums[j] &lt;= threshhold) &#123; ++len; pre = 1; res = Math.max(res, len); &#125; else &#123; break; &#125; &#125; else &#123; // pre == 1 if (nums[j] % 2 == 0 &amp;&amp; nums[j] &lt;= threshhold) &#123; ++len; pre = 0; res = Math.max(res, len); &#125; else &#123; break; &#125; &#125; &#125; &#125; return res; &#125;&#125; 方法二：一轮遍历 123456789101112131415161718class Solution &#123; public int longestAlternatingSubarray(int[] nums, int threshold) &#123; int res = 0; for (int i = 0; i &lt; nums.length; ++i) &#123; if (nums[i] % 2 == 0 &amp;&amp; nums[i] &lt;= threshold) &#123; int pre = nums[i] % 2, j = i + 1; for (; j &lt; nums.length; ++j) &#123; if (nums[j] % 2 != pre &amp;&amp; nums[j] &lt;= threshold) pre = nums[j] % 2; else break; &#125; res = Math.max(res, j - i); &#125; &#125; return res; &#125;&#125; 6916. 和等于目标值的质数对 方法一：埃氏筛 静态代码块: 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—&gt;非静态代码块—&gt;构造方法)。 该类不管创建多少对象，静态代码块只执行一次. 12345678910111213141516171819202122232425262728class Solution &#123; private final static int MAX = (int) 1e6; private final static boolean[] isPrime = new boolean[MAX + 1]; private final static int[] prime = new int[MAX]; static &#123; int index = 0; for (int i = 2; i &lt;= MAX; ++i) &#123; if (!isPrime[i]) &#123; prime[index++] = i; if (i &lt; MAX / i) for (int j = i * i; j &lt; MAX; j += i) isPrime[j] = true; &#125; &#125; &#125; public List&lt;List&lt;Integer&gt;&gt; findPrimePairs(int n) &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); for (int x : prime) &#123; int y = n - x; if (y &lt; x) break; if (!isPrime[y]) res.add(Arrays.asList(x, y)); &#125; return res; &#125;&#125; 204. 计数质数 埃氏筛 12345678910111213141516class Solution &#123; public int countPrimes(int n) &#123; boolean[] isPrime = new boolean[n]; Arrays.fill(isPrime, true); int res = 0; for (int i = 2; i &lt; n; ++i) &#123; if (isPrime[i]) &#123; ++res; if ((long) i * i &lt; n) for (int j = i * i; j &lt; n; j += i) isPrime[j] = false; &#125; &#125; return res; &#125;&#125; 6911. 不间断子数组 滑动窗口 map.lastKey() - map.firstKey()得到最大值与最小值的差 res += (long) i - j + 1十分巧妙，举例nums=[5, 4, 2, 4] i = 0， [5]， res += 1 = 1 i = 1，[5, 4], [4], res +=2 = 3 i = 2, [4, 2], [2] ,res += 2 = 5 i = 3, [4,2, 4], [4], [2,4], res += 3 = 8 123456789101112131415161718class Solution &#123; public long continuousSubarrays(int[] nums) &#123; TreeMap&lt;Integer, Integer&gt; map = new TreeMap&lt;&gt;(); int n = nums.length; long res = 0; for (int i = 0, j = 0; i &lt; n; ++i) &#123; map.put(nums[i], map.getOrDefault(nums[i], 0) + 1); while (j &lt;= i &amp;&amp; map.lastKey() - map.firstKey() &gt; 2) &#123; map.put(nums[j], map.getOrDefault(nums[j], 0) - 1); if (map.get(nums[j]) == 0) map.remove(nums[j]); ++j; &#125; res += (long) i - j + 1; &#125; return res; &#125;&#125; 1438. 绝对差不超过限制的最长连续子数组 1234567891011121314151617class Solution &#123; public int longestSubarray(int[] nums, int limit) &#123; TreeMap&lt;Integer, Integer&gt; map = new TreeMap&lt;&gt;(); int n = nums.length, res = 0; for (int i = 0, j = 0; i &lt; n; ++i) &#123; map.put(nums[i], map.getOrDefault(nums[i], 0) + 1); while (j &lt;= i &amp;&amp; map.lastKey() - map.firstKey() &gt; limit) &#123; map.put(nums[j], map.get(nums[j]) - 1); if (map.get(nums[j]) == 0) map.remove(nums[j]); ++j; &#125; res = Math.max(res, i - j + 1); &#125; return res; &#125;&#125; 6894. 所有子数组中不平衡数字之和 1234567891011121314151617181920212223class Solution &#123; public int sumImbalanceNumbers(int[] nums) &#123; int res = 0, n = nums.length; boolean[] visited = new boolean[n + 2]; for (int i = 0; i &lt; n; ++i) &#123; Arrays.fill(visited, false); int count = 0; visited[nums[i]] = true; for (int j = i + 1; j &lt; n; ++j) &#123; if (!visited[nums[j]]) &#123; ++count; if (visited[nums[j] - 1]) --count; if (visited[nums[j] + 1]) --count; visited[nums[j]] = true; &#125; res += count; &#125; &#125; return res; &#125;&#125;","categories":[{"name":"Contest","slug":"Contest","permalink":"https://leopol1d.github.io/categories/Contest/"},{"name":"LCP","slug":"Contest/LCP","permalink":"https://leopol1d.github.io/categories/Contest/LCP/"}],"tags":[{"name":"力扣杯","slug":"力扣杯","permalink":"https://leopol1d.github.io/tags/%E5%8A%9B%E6%89%A3%E6%9D%AF/"}]},{"title":"lcp346","slug":"lcp346","date":"2023-07-01T06:47:34.000Z","updated":"2023-08-01T08:28:41.579Z","comments":true,"path":"2023/07/01/lcp346/","link":"","permalink":"https://leopol1d.github.io/2023/07/01/lcp346/","excerpt":"","text":"2696. 删除子串后的字符串最小长度 方法一：暴力枚举 12345678910111213141516171819202122232425262728293031323334class Solution &#123; public int minLength(String s) &#123; int res = s.length(); int[] last = new int[s.length()]; int lastIndex = -1; for (int i = 1; i &lt; s.length(); ++i) &#123; char ch1 = s.charAt(i - 1), ch2 = s.charAt(i); if (ch1 == &#x27;A&#x27; || ch1 == &#x27;C&#x27;) &#123; if (ch2 != &#x27;B&#x27; &amp;&amp; ch2 != &#x27;D&#x27;) &#123; last[++lastIndex] = i - 1; &#125; else if ((ch1 == &#x27;A&#x27; &amp;&amp; ch2 == &#x27;B&#x27;) || (ch1 == &#x27;C&#x27; &amp;&amp; ch2 == &#x27;D&#x27;)) &#123; res -= 2; int step = 1; for (int r = i + 1; lastIndex &gt;= 0 &amp;&amp; r &lt; s.length(); ++r) &#123; char ch3 = s.charAt(last[lastIndex]), ch4 = s.charAt(r); if ((ch3 == &#x27;A&#x27; &amp;&amp; ch4 == &#x27;B&#x27;) || (ch3 == &#x27;C&#x27; &amp;&amp; ch4 == &#x27;D&#x27;)) &#123; res -= 2; ++step; --lastIndex; &#125; else &#123; i += step; break; &#125; &#125; &#125; &#125; else &#123; // ch1 != AC lastIndex = -1; &#125; &#125; return res; &#125;&#125; 方法二：栈 12345678910111213class Solution &#123; public int minLength(String s) &#123; Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); for (int i = 0; i &lt; s.length(); ++i) &#123; char ch = s.charAt(i); if (!stack.isEmpty() &amp;&amp; ((stack.peek() == &#x27;A&#x27; &amp;&amp; ch == &#x27;B&#x27;) || (stack.peek() == &#x27;C&#x27; &amp;&amp; ch == &#x27;D&#x27;))) stack.pop(); else stack.push(ch); &#125; return stack.size(); &#125;&#125; 2697. 字典序最小回文串 方法一：DP(超时) 1234567891011121314151617181920212223class Solution &#123; public String makeSmallestPalindrome(String s) &#123; int n = s.length(); String[][] dp = new String[n][n]; for (int i = 0; i &lt; n; ++i) &#123; char chI = s.charAt(i); for (int j = 0; j &lt;= i; ++j) &#123; char chJ = s.charAt(j); char small = chJ - chI &lt; 0 ? chJ : chI; if (i == j) dp[j][i] = String.valueOf(chI); else if (i - j == 1) dp[j][i] = String.valueOf(small) + small; else if (i - j == 2) dp[j][i] = String.valueOf(small) + s.charAt(j + 1) + small; else &#123; dp[j][i] = String.valueOf(small) + dp[j + 1][i - 1] + small; &#125; &#125; &#125; return dp[0][n - 1]; &#125;&#125; 方法二：贪心 1234567891011class Solution &#123; public String makeSmallestPalindrome(String s) &#123; char[] arr = s.toCharArray(); for (int i = 0, j = s.length() - 1; i &lt; j; ++i, --j) &#123; char small = arr[i] &lt; arr[j] ? arr[i] : arr[j]; arr[i] = small; arr[j] = small; &#125; return new String(arr); &#125;&#125; 求一个整数的惩罚数 方法一：回溯 123456789101112131415161718192021222324252627282930313233class Solution &#123; public int punishmentNumber(int n) &#123; int res = 0; for (int i = 1; i &lt;= n; ++i) &#123; if (check(i)) res += i * i; &#125; return res; &#125; private boolean check(int x) &#123; path.clear(); return dfs(x, String.valueOf(x * x), 0); &#125; Deque&lt;String&gt; path = new LinkedList&lt;&gt;(); private boolean dfs(int x, String str, int index) &#123; if (index == str.length()) &#123; int sum = 0; for (String s : path) sum += Integer.parseInt(s); return sum == x; &#125; for (int i = index; i &lt; str.length(); ++i) &#123; String sub = str.substring(index, i + 1); path.offerLast(sub); if (dfs(x, str, i + 1)) return true; path.pollLast(); &#125; return false; &#125;&#125; 修改图中的边权 方法一： 1","categories":[{"name":"Contest","slug":"Contest","permalink":"https://leopol1d.github.io/categories/Contest/"},{"name":"LCP","slug":"Contest/LCP","permalink":"https://leopol1d.github.io/categories/Contest/LCP/"}],"tags":[{"name":"力扣杯","slug":"力扣杯","permalink":"https://leopol1d.github.io/tags/%E5%8A%9B%E6%89%A3%E6%9D%AF/"}]},{"title":"","slug":"microsoft","date":"2023-06-28T07:33:03.000Z","updated":"2023-08-01T07:09:13.913Z","comments":true,"path":"2023/06/28/microsoft/","link":"","permalink":"https://leopol1d.github.io/2023/06/28/microsoft/","excerpt":"","text":"236. 二叉树的最近公共祖先使用DFS解决 124. 二叉树中的最大路径和 215. 数组中的第K个最大元素 297. 二叉树的序列化与反序列化 方法一：DFS 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Codec &#123; // Encodes a tree to a single string. public String serialize(TreeNode root) &#123; if (root == null) return &quot;#&quot;; String left = serialize(root.left); String right = serialize(root.right); return root.val + &quot;,&quot; + left + &quot;,&quot; + right; &#125; // Decodes your encoded data to tree. public TreeNode deserialize(String data) &#123; String[] nodes = data.split(&quot;,&quot;); return dfs(nodes); &#125; int i = 0; public TreeNode dfs(String[] nodes) &#123; String str = nodes[i++]; if (str.equals(&quot;#&quot;)) return null; TreeNode root = new TreeNode(Integer.valueOf(str)); root.left = dfs(nodes); root.right = dfs(nodes); return root; &#125;&#125;// Your Codec object will be instantiated and called as such:// Codec ser = new Codec();// Codec deser = new Codec();// TreeNode ans = deser.deserialize(ser.serialize(root)); 为什么左边的代码不行，因为如何nodes[i]是节点，i没有自增！ 206. 反转链表 3. 无重复字符的最长子串 方法一：滑动窗口 set 用HashSet判断重复，并将左区间滑动到没有重复元素为止 1234567891011121314151617181920class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int length = 0; Set&lt;Character&gt; set = new HashSet&lt;&gt;(); for (int i = 0, left = 0; i &lt; s.length(); ++i) &#123; char ch = s.charAt(i); if (set.contains(ch)) &#123; while (left &lt; i) &#123; set.remove(s.charAt(left++)); if (!set.contains(ch)) break; &#125; &#125; set.add(ch); length = Math.max(length, i - left + 1); &#125; return length; &#125;&#125; 方法二：滑动窗口 map 用HashMap存储遍历的字符以及其下标，当出现重复字符，将left赋值为Math.max(left, map.get(ch) + 1) 1234567891011121314class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int max = 0, left = 0, n = s.length(); Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; n; ++i) &#123; char ch = s.charAt(i); if (map.containsKey(ch)) left = Math.max(left, map.get(ch) + 1); map.put(ch, i); max = Math.max(max, i - left + 1); &#125; return max; &#125;&#125; 146. LRU 缓存 方法一：HashMap + ListNode 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283class LRUCache &#123; static class ListNode &#123; int key; int val; ListNode next, pre; public ListNode(int key, int val) &#123; this.key = key; this.val = val; &#125; &#125; ListNode head, tail; Map&lt;Integer, ListNode&gt; map; int capacity; public LRUCache(int capacity) &#123; head = new ListNode(-1, -1); tail = new ListNode(-1, -1); head.next = tail; tail.pre = head; map = new HashMap&lt;&gt;(); this.capacity = capacity; &#125; public int get(int key) &#123; if (!map.containsKey(key)) return -1; moveToTail(key); return map.get(key).val; &#125; public void put(int key, int value) &#123; if (map.containsKey(key)) &#123; moveToTail(key); map.get(key).val = value; &#125; else &#123; if (capacity == map.size()) // delete last one delete(-1, true); // insert new node in the previous of tail ListNode node = new ListNode(key, value); map.put(key, node); insertIntail(key); &#125; &#125; public void moveToTail(int key) &#123; delete(key, false); insertIntail(key); &#125; public void delete(int key, boolean isLast) &#123; if (isLast) &#123; ListNode toBeDelete = head.next; map.remove(toBeDelete.key); head.next = toBeDelete.next; toBeDelete.next.pre = head; &#125; else &#123; ListNode toBeDelete = map.get(key); // map.remove(toBeDelete.key); toBeDelete.pre.next = toBeDelete.next; toBeDelete.next.pre = toBeDelete.pre; &#125; &#125; private void insertIntail(int key) &#123; ListNode node = map.get(key); node.next = tail; tail.pre.next = node; node.pre = tail.pre; tail.pre = node; &#125; &#125;/** * Your LRUCache object will be instantiated and called as such: * LRUCache obj = new LRUCache(capacity); * int param_1 = obj.get(key); * obj.put(key,value); */ 450. 删除二叉搜索树中的节点 方法一：DFS 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public TreeNode deleteNode(TreeNode root, int key) &#123; if (root == null) return null; if (root.val &gt; key) root.left = deleteNode(root.left, key); else if (root.val &lt; key) root.right = deleteNode(root.right, key); else &#123; if (root.left == null &amp;&amp; root.right == null) return null; else if (root.left == null) return root.right; else if (root.right == null) return root.left; else &#123; TreeNode cur = root.right; while (cur.left != null) cur = cur.left; cur.left = root.left; return root.right; &#125; &#125; return root; &#125;&#125; 53. 最大子数组和 方法一：DP 123456789101112class Solution &#123; public int maxSubArray(int[] nums) &#123; int n = nums.length, res = nums[0]; int[] dp = new int[n]; dp[0] = nums[0]; for (int i = 1; i &lt; n; ++i) &#123; dp[i] = nums[i] + (dp[i - 1] &gt;= 0 ? dp[i - 1] : 0); res = Math.max(res, dp[i]); &#125; return res; &#125;&#125; 33. 搜索旋转排序数组 方法一：二分查找 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public int search(int[] nums, int target) &#123; // 首先找到逆序的第一个数的下标x，x~n-1是较小的子数组 int n = nums.length, targetIdx = -1; int left = 0, right = n - 1; while (left &lt;= right) &#123; int mid = (left + right) &gt;&gt; 1; if (nums[mid] &lt;= nums[n - 1]) right = mid - 1; else left = mid + 1; &#125; // left &gt; right，此时找到了逆序的第一个数的下标left // 接着根据target的值来二分，如果target &gt; nums[n - 1]，则在左边较大的子数组中二分查找，否在在右边较小的子数组中二分查找 if (target &gt; nums[n - 1]) targetIdx = bisearch(nums, 0, left - 1, target); else targetIdx = bisearch(nums, left, n - 1, target); return targetIdx; &#125; public int bisearch(int[] nums, int left, int right, int target) &#123; while (left &lt;= right) &#123; int mid = (left + right) &gt;&gt; 1; if (nums[mid] &lt; target) left = mid + 1; else if (nums[mid] == target) return mid; else right = mid - 1; &#125; return -1; &#125;&#125; 4. 寻找两个正序数组的中位数 题解 方法一：划分数组 123456789101112131415161718192021222324252627282930class Solution &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; if (nums1.length &gt; nums2.length) return findMedianSortedArrays(nums2, nums1); int m = nums1.length, n = nums2.length; int median1 = 0, median2 = 0; // 如果有m + n是偶数，median2是第二个中位数 int left = 0, right = m; // i == m时，表示nums1全被划分为前一部分 while (left &lt;= right) &#123; // 前一部分包含 nums1[0 .. i-1] 和 nums2[0 .. j-1] // 后一部分包含 nums1[i .. m-1] 和 nums2[j .. n-1] // 当m + n是偶数，规定前一部分和后一部分的长度相同 // 当m + n是奇数，规定前一部分的长度 == 后一部分的长度 + 1 // j = (m + n + 1 ) / 2 - i 可以很好地满足，不管m+n是奇数还是偶数 int i = (left + right) / 2, j = (m + n + 1) / 2 - i; int nums_i = i == m ? Integer.MAX_VALUE : nums1[i]; int nums_im1 = i == 0 ? Integer.MIN_VALUE : nums1[i - 1]; int nums_j = j == n ? Integer.MAX_VALUE : nums2[j]; int nums_jm1 = j == 0 ? Integer.MIN_VALUE : nums2[j - 1]; if (nums_im1 &lt;= nums_j) &#123; median1 = Math.max(nums_im1, nums_jm1); median2 = Math.min(nums_i, nums_j); left = i + 1; &#125; else &#123; right = i - 1; &#125; &#125; return (m + n) % 2 == 0 ? (median1 + median2) / 2.0 : median1; &#125;&#125; 22. 括号生成 方法一：回溯 12345678910111213141516171819202122232425262728class Solution &#123; public List&lt;String&gt; generateParenthesis(int n) &#123; this.n = n; dfs(0, n, n); return res; &#125; private void dfs(int index, int left, int right) &#123; if (index == 2 * n) &#123; res.add(sb.toString()); return; &#125; if (left &gt; 0) &#123; sb.append(&#x27;(&#x27;); dfs(index + 1, left - 1, right); sb.deleteCharAt(sb.length() - 1); &#125; if (right &gt; left) &#123; sb.append(&#x27;)&#x27;); dfs(index + 1, left, right - 1); sb.deleteCharAt(sb.length() - 1); &#125; &#125; List&lt;String&gt; res = new LinkedList&lt;&gt;(); StringBuilder sb = new StringBuilder(); int n;&#125; 560. 和为 K 的子数组 方法一：前缀和 + HashMap 题解 可以用这种方法做链接中的题 map.put(0, 1)是为了让第一组满足的子数组map.containsKey(pre - k) = 1 1234567891011121314 class Solution &#123; public int subarraySum(int[] nums, int k) &#123; int pre = 0, count = 0; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); map.put(0, 1); for (int i = 0; i &lt; nums.length; ++i) &#123; pre += nums[i]; if (map.containsKey(pre - k)) count += map.get(pre - k); map.put(pre, map.getOrDefault(pre, 0) + 1); &#125; return count; &#125;&#125; 103. 二叉树的锯齿形层序遍历 方法一：双队列 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123; if (root == null) return new LinkedList&lt;&gt;(); boolean nextRight = true; Deque&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(), temp = new LinkedList&lt;&gt;(); queue.offer(root); List&lt;List&lt;Integer&gt;&gt; res = new LinkedList(); while (!queue.isEmpty()) &#123; int size = queue.size(); List&lt;Integer&gt; list = new LinkedList(); for (int i = 0; i &lt; size; ++i) &#123; if (nextRight) &#123; TreeNode cur = queue.pollFirst(); list.add(cur.val); if (cur.left != null) temp.offerLast(cur.left); if (cur.right != null) temp.offerLast(cur.right); &#125; else &#123; TreeNode cur = queue.pollLast(); list.add(cur.val); if (cur.right != null) temp.offerFirst(cur.right); if (cur.left != null) temp.offerFirst(cur.left); &#125; &#125; queue = temp; temp = new LinkedList&lt;&gt;(); res.add(list); nextRight = !nextRight; &#125; return res; &#125;&#125; 151. 反转字符串中的单词 方法一：双端队列 用栈实现不是逆序的 1234567891011121314151617181920212223class Solution &#123; public String reverseWords(String s) &#123; // 去除首尾空格 Deque&lt;String&gt; queue = new LinkedList&lt;&gt;(); StringBuilder sb = new StringBuilder(); int left = 0, right = s.length() - 1; while (s.charAt(left) == &#x27; &#x27;) ++left; while (s.charAt(right) == &#x27; &#x27;) --right; while (left &lt;= right) &#123; char ch = s.charAt(left++); if (ch != &#x27; &#x27;) sb.append(ch); else if (ch == &#x27; &#x27; &amp;&amp; sb.length() &gt; 0) &#123; queue.offerFirst(sb.toString()); sb.setLength(0); &#125; &#125; queue.offerFirst(sb.toString()); return String.join(&quot; &quot;, queue); &#125;&#125; 25. K 个一组翻转链表 方法一：模拟 多debug 使用outOfBound判断最后一部分节点的数量是否少于k，如果少于k就break 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode reverseKGroup(ListNode head, int k) &#123; if (k == 1) return head; ListNode dummyHead = new ListNode(-1, head); ListNode pre = dummyHead, next = dummyHead, cur = head, start = dummyHead; while (cur != null &amp;&amp; cur.next != null) &#123; boolean outOfBound = false; for (int i = 0; i &lt; k - 1; ++i) &#123; if (cur.next == null) &#123; outOfBound = true; break; &#125; cur = cur.next; next = cur.next; &#125; if (outOfBound) break; cur.next = null; start = pre.next; pre.next = reverse(start); start.next = next; pre = start; cur = pre.next; &#125; return dummyHead.next; &#125; private ListNode reverse(ListNode cur) &#123; ListNode pre = null, next; while (cur != null) &#123; next = cur.next; cur.next = pre;; pre = cur; cur = next; &#125; return pre; &#125; &#125; 8. 字符串转换整数 (atoi) 方法一：模拟 判断是否溢出 其中Integer.MAX_VALUE / 10 == res &amp;&amp; val &gt; 7，如果是正数val &gt; 7溢出；如果是负数val &gt; 8才溢出，不过等于8时，结果恰好是Integer.MIN_VALUE [-2147483648,2147483647] 12if (Integer.MAX_VALUE / 10 &lt; res || (Integer.MAX_VALUE / 10 == res &amp;&amp; val &gt; 7)) return positive ? Integer.MAX_VALUE : Integer.MIN_VALUE; 代码 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123; public int myAtoi(String s) &#123; int left = 0, n = s.length(); if (n == 0) return 0; // 丢弃前导空格 while (left &lt; n) &#123; if (s.charAt(left) != &#x27; &#x27;) break; ++left; &#125; if (left == n) return 0; // 判断正负号 boolean positive = true; if (!isDigital(s.charAt(left))) &#123; positive = s.charAt(left) == &#x27;-&#x27; ? false : true; if (s.charAt(left) == &#x27;-&#x27;) positive = false; else if (s.charAt(left) != &#x27;+&#x27;) return 0; ++left; &#125; int res = 0; for (int i = left; i &lt; n; ++i) &#123; char ch = s.charAt(i); if (!isDigital(ch)) break; int val = ch - &#x27;0&#x27;; if (Integer.MAX_VALUE / 10 &lt; res || (Integer.MAX_VALUE / 10 == res &amp;&amp; val &gt; 7)) return positive ? Integer.MAX_VALUE : Integer.MIN_VALUE; res = res * 10 + val; &#125; return positive ? res : -res; &#125; private boolean isDigital(char ch) &#123; return ch == &#x27;0&#x27; || ch == &#x27;1&#x27; || ch == &#x27;2&#x27; || ch == &#x27;3&#x27; || ch == &#x27;4&#x27; || ch == &#x27;5&#x27; || ch == &#x27;6&#x27;|| ch == &#x27;7&#x27;|| ch == &#x27;8&#x27;|| ch == &#x27;9&#x27;; &#125;&#125; 56. 合并区间 方法一：射气球 1234567891011121314151617181920212223class Solution &#123; public int[][] merge(int[][] intervals) &#123; Arrays.sort(intervals, new Comparator&lt;int[]&gt;() &#123; @Override public int compare(int[] o1, int[] o2) &#123; return Integer.compare(o1[0], o2[0]); &#125; &#125;); List&lt;int[]&gt; list = new LinkedList&lt;&gt;(); int left = 0; for (int i = 1; i &lt; intervals.length; ++i) &#123; if (intervals[left][1] &gt;= intervals[i][0]) intervals[left][1] = Math.max(intervals[left][1], intervals[i][1]); else &#123; list.add(intervals[left]); left = i; &#125; &#125; intervals[left][1] = Math.max(intervals[left][1], intervals[intervals.length - 1][1]); list.add(intervals[left]); return list.toArray(new int[list.size()][]); &#125;&#125; 48. 旋转图像 方法一：模拟 别看题解 123456789101112131415class Solution &#123; public void rotate(int[][] matrix) &#123; int n = matrix.length; for (int i = 0; i &lt; n &gt;&gt; 1; ++i) &#123; int len = n - i * 2; for (int j = 0; j &lt; len - 1; ++j) &#123; int temp = matrix[i][i + j]; matrix[i][i + j] = matrix[n - i - j - 1][i]; matrix[n - i - j - 1][i] = matrix[n - i - 1][n - i - j - 1]; matrix[n - i - 1][n - i - j - 1] = matrix[i + j][n - i - 1]; matrix[i + j][n - i - 1] = temp; &#125; &#125; &#125;&#125; 15. 三数之和 方法一：排序 + 双指针 题解 123456789101112131415161718192021222324252627282930class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; int n = nums.length; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Arrays.sort(nums); for (int i = 0; i &lt; n; ++i) &#123; if (nums[i] &gt; 0) return res; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue; int left = i + 1, right = n - 1; while (left &lt; right) &#123; if (nums[i] + nums[left] + nums[right] == 0) &#123; res.add(Arrays.asList(nums[i], nums[left], nums[right])); while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) ++left; while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) --right; ++left; --right; &#125; else if (nums[i] + nums[left] + nums[right] &lt; 0) ++left; else --right; &#125; &#125; return res; &#125;&#125; 1. 两数之和 方法一：HashMap 12345678910111213141516class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int n = nums.length; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); int[] res = new int[2]; for (int i = 0; i &lt; n; ++i) &#123; if (map.containsKey(target - nums[i])) &#123; res[0] = i; res[1] = map.get(target - nums[i]); &#125; map.put(nums[i], i); &#125; return res; &#125;&#125; 5. 最长回文子串 方法一：DP 12345678910111213141516171819202122232425262728class Solution &#123; public String longestPalindrome(String s) &#123; int n = s.length(), max = 0; int[] maxIndex = new int[2]; int[][] dp = new int[n][n]; for (int i = 0; i &lt; n; ++i) &#123; for (int j = i; j &gt;= 0; --j) &#123; if (i - j + 1 == 1) dp[i][j] = 1; else if (i - j + 1 == 2) dp[i][j] = s.charAt(i) == s.charAt(j) ? 2 : 0; else if (i - j + 1 == 3) dp[i][j] = s.charAt(i) == s.charAt(j) ? 3 : 0; else &#123; if (s.charAt(i) != s.charAt(j)) dp[i][j] = 0; else dp[i][j] = dp[i - 1][j + 1] &gt; 0 ? dp[i - 1][j + 1] + 2 : 0; &#125; if (dp[i][j] &gt; max) &#123; max = dp[i][j]; maxIndex = new int[]&#123;j, i&#125;; &#125; &#125; &#125; return s.substring(maxIndex[0], maxIndex[1] + 1); &#125;&#125; 121. 买卖股票的最佳时机","categories":[],"tags":[]},{"title":"Package Problem","slug":"package-problem","date":"2023-06-26T02:52:41.000Z","updated":"2023-09-15T06:55:20.355Z","comments":true,"path":"2023/06/26/package-problem/","link":"","permalink":"https://leopol1d.github.io/2023/06/26/package-problem/","excerpt":"","text":"dp数组的初始化、状态转移方程、遍历顺序至关重要其中的关键是状态转移方程，初始化以及遍历顺序都由状态转移方程确定 01背包 01背包-二维dp数组(m行) 代码 12345678910111213141516171819202122232425262728293031323334353637383940package 背包;public class bag01_2d &#123; public static void main(String[] args) &#123; int[] weight = &#123;4, 1, 3&#125;; int[] value = &#123;30, 15, 20&#125;; int capacity = 4; int res = calcMaxValue(weight, value, capacity); System.out.println(&quot;res: &quot; + res); &#125; private static int calcMaxValue(int[] weight, int[] value, int capacity) &#123; int[][] dp = new int[weight.length][capacity + 1]; /* * dp[i][j]:容量为j的背包，在物品0~i中任选，能获得的最大价值 * 状态转移；if(j &gt;= weight[i]) dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]) 选物品i或不选物品i * else dp[i][j] = dp[i - 1][j] 不选物品i * 初始化：由状态转移可以看出，dp[i][j]依赖于dp[i - 1][j]，所以需要初始化第0行 * 第0行：选择物品0.如果j &gt; weight[0]，dp[0][j] = value[0] * 第0列：背包容量为0，什么都装不下，dp[i][0] = 0 * */ for (int j = 0; j &lt;= capacity; ++j) dp[0][j] = j &gt;= weight[0] ? value[0] : 0; for (int i = 1; i &lt; weight.length; ++i) &#123; for (int j = 1; j &lt;= capacity; ++j) &#123; if (j &gt;= weight[i]) dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); else dp[i][j] = dp[i - 1][j]; &#125; &#125; for (int i = 0; i &lt; weight.length; ++i) &#123; for (int j = 0; j &lt;= capacity; ++j) System.out.print(dp[i][j] + &quot;\\t&quot;); System.out.println(); &#125; System.out.println(); return dp[weight.length - 1][capacity]; &#125;&#125; 输出 123450 0 0 0 30 0 15 15 15 30 0 15 15 20 35 res: 35 01背包-二维dp数组(两行) 状态转移： 1234if(j &gt;= weight[i]) dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]) 选物品i或不选物品ielse dp[i][j] = dp[i - 1][j] 不选物品i 可以看出dp[i][j]只可能被dp[i - 1][j]和dp[i - 1][j - weight[i]]推导出，也就是说第i行只与第i - 1行关联，那么dp数组只需要用两行 与使用m行的代码相比，只需要将dp数组更改为2行，dp[i]与dp[i - 1]改为dp[i % 2]与dp[(i - 1) % 2] 初始化后(遍历完第0个物品后)的dp数组为 120 0 0 0 30 0 0 0 0 0 遍历完第1个物品后的dp数组为 120 0 0 0 30 0 15 15 15 30 遍历第2个物品时，只需要遍历第1个物品的dp数据，不需要遍历第0个物品的dp数据，所以把遍历第2个物品的dp数据覆盖在第0行 120 0 0 20 35 0 15 15 15 30 代码 1234567891011121314151617181920212223242526272829package 背包;public class bag01_2d &#123; public static void main(String[] args) &#123; int[] weight = &#123;4, 1, 3&#125;; int[] value = &#123;30, 15, 20&#125;; int capacity = 4; int res = calcMaxValue(weight, value, capacity); System.out.println(&quot;res: &quot; + res); &#125; private static int calcMaxValue(int[] weight, int[] value, int capacity) &#123; int[][] dp = new int[2][capacity + 1]; for (int j = 0; j &lt;= capacity; ++j) dp[0][j] = j &gt;= weight[0] ? value[0] : 0; for (int i = 1; i &lt; weight.length; ++i) &#123; for (int j = weight[i]; j &lt;= capacity; ++j) &#123; dp[i % 2][j] = Math.max(dp[(i - 1) % 2][j], dp[(i - 1) % 2][j - weight[i]] + value[i]); &#125; &#125; for (int i = 0; i &lt; 2; ++i) &#123; for (int j = 0; j &lt;= capacity; ++j) System.out.print(dp[i][j] + &quot;\\t&quot;); System.out.println(); &#125; System.out.println(); return dp[(weight.length - 1) % 2][capacity]; &#125;&#125; 输出 12340 0 0 20 35 0 15 15 15 30 res: 35 01背包-滚动数组(一维dp数组) 两行能搞定，一行也行！ 现在使用一维dp数组 1int[] dp = new int[capacity + 1]; 回顾一下使用二维dp数组是如何填表的 1234560 0 0 0 30 0 15 15 15 30 0 15 15 20 35 // int[] weight = &#123;4, 1, 3&#125;;// int[] value = &#123;30, 15, 20&#125;;// int capacity = 4; 直接看第二行最后一个元素35(此时i = 2, j = 4)，它是由dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);更新 dp[i - 1][j - weight[i]] = dp[1][1] = 15, value[i] = 20 35是由左上方的15加上value[2]得到的 所以使用一维滚动数组，在更新dp[4]的时候(相对于两维数组是要更新dp[2][4])， 需要上一行的dp[1](相对于二维dp数组是dp[1][1])， 那么j的遍历顺序一定要从后往前！否则(从前往后)，dp[1]是二维dp数组中dp[2][1]的数据 1for (int j = capacity; j &gt;= weight[i]; --j) 代码 初始化为0即可 12345678910111213141516171819202122232425package 背包;public class bag01 &#123; public static void main(String[] args) &#123; int[] weight = &#123;4, 1, 3&#125;; int[] value = &#123;30, 15, 20&#125;; int capacity = 4; int res = calcMaxValue(weight, value, capacity); System.out.println(res); &#125; private static int calcMaxValue(int[] weight, int[] value, int capacity) &#123; int[] dp = new int[capacity + 1]; for (int i = 0; i &lt; weight.length; ++i) for (int j = capacity; j &gt;= weight[i]; --j) dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]); for (int j = 0; j &lt;= capacity; j++)&#123; System.out.print(dp[j] + &quot; &quot;); &#125; return dp[capacity]; &#125;&#125; 输出 10 15 15 20 35 35 494. 目标和 方法一：记忆化搜索背包 123456789101112131415161718192021222324252627282930class Solution &#123; public int findTargetSumWays(int[] nums, int target) &#123; this.nums = nums; n = nums.length; for (int x : nums) target += x; if (target % 2 != 0 || target &lt; 0) return 0; target /= 2; dp = new int[n][target + 1]; for (int[] arr : dp) Arrays.fill(arr, -1); return dfs(0, target); &#125; private int dfs(int index, int target) &#123; if (index == n) return target == 0 ? 1 : 0; if (dp[index][target] != -1) return dp[index][target]; int choose = 0, pass = dfs(index + 1, target); if (target &gt;= nums[index]) choose = dfs(index + 1, target - nums[index]); return dp[index][target] = pass + choose; &#125; int[] nums; int n; int[][] dp;&#125; 方法二：01背包 1234567891011121314151617181920class Solution &#123; public int findTargetSumWays(int[] nums, int target) &#123; int n = nums.length; for (int x : nums) target += x; if (target % 2 != 0 || target &lt; 0) return 0; target /= 2; int[][] dp = new int[n + 1][target + 1]; dp[0][0] = 1; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt;= target; ++j) &#123; dp[i + 1][j] = dp[i][j]; if (j &gt;= nums[i]) dp[i + 1][j] += dp[i][j - nums[i]]; &#125; &#125; return dp[n][target]; &#125;&#125; 方法三：滚动数组 12345678910111213141516class Solution &#123; public int findTargetSumWays(int[] nums, int target) &#123; int n = nums.length; for (int x : nums) target += x; if (target % 2 != 0 || target &lt; 0) return 0; target /= 2; int[] dp = new int[target + 1]; dp[0] = 1; for (int i = 0; i &lt; n; ++i) for (int j = target; j &gt;= nums[i]; --j) dp[j] += dp[j - nums[i]]; return dp[target]; &#125;&#125; 322. 零钱兑换 方法一：记忆化搜索 12345678910111213141516171819202122232425class Solution &#123; public int coinChange(int[] coins, int amount) &#123; this.coins = coins; n = coins.length; dp = new int[n][amount + 1]; for (int[] arr : dp) Arrays.fill(arr, -1); int res = dfs(0, amount); return res == Integer.MAX_VALUE / 2 ? -1 : res; &#125; private int dfs(int index, int amount) &#123; if (index == n) return amount == 0 ? 0 : Integer.MAX_VALUE / 2; if (dp[index][amount] != -1) return dp[index][amount]; if (coins[index] &gt; amount) return dfs(index + 1, amount); return dp[index][amount] = Math.min(dfs(index + 1, amount), dfs(index, amount - coins[index]) + 1); &#125; int[] coins; int n; int[][] dp;&#125; 方法二：完全背包 1234567891011121314151617class Solution &#123; public int coinChange(int[] coins, int amount) &#123; int n = coins.length; int[][] dp = new int[n + 1][amount + 1]; for (int[] arr : dp) Arrays.fill(arr, Integer.MAX_VALUE &gt;&gt; 1); dp[0][0] = 0; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt;= amount; ++j) &#123; dp[i + 1][j] = dp[i][j]; if (coins[i] &lt;= j) dp[i + 1][j] = Math.min(dp[i][j], dp[i + 1][j - coins[i]] + 1); &#125; &#125; return dp[n][amount] == Integer.MAX_VALUE &gt;&gt; 1 ? -1 : dp[n][amount]; &#125;&#125; 方法三：滚动数组 12345678910111213class Solution &#123; public int coinChange(int[] coins, int amount) &#123; int n = coins.length; int[] dp = new int[amount + 1]; Arrays.fill(dp, Integer.MAX_VALUE &gt;&gt; 1); dp[0] = 0; for (int i = 0; i &lt; n; ++i) for (int j = 0; j &lt;= amount; ++j) if (j &gt;= coins[i]) dp[j] = Math.min(dp[j], dp[j - coins[i]] + 1); return dp[amount] == Integer.MAX_VALUE &gt;&gt; 1 ? -1 : dp[amount]; &#125;&#125; 2787. 将一个数字表示成幂的和的方案数 方法一：01背包 123456789101112131415161718class Solution &#123; public int numberOfWays(int n, int x) &#123; int mod = (int) 1e9 + 7; // 01背包， 从1^x, 2^x,...,n^x里选物品，恰好能装满容量为n的背包的方案数 int[][] dp = new int[n + 1][n + 1]; // 没有物品，恰好装满容量为0的背包的方案数：1,什么都不装 dp[0][0] = 1; for (int i = 1; i &lt;= n; ++i) &#123; int s = (int) Math.pow(i, x); for (int j = 0; j &lt;= n; ++j) &#123; dp[i][j] = dp[i - 1][j]; if (j &gt;= s) dp[i][j] = (dp[i][j] + dp[i - 1][j - s]) % mod; &#125; &#125; return dp[n][n]; &#125;&#125; 方法二：滚动数组 12345678910111213141516class Solution &#123; public int numberOfWays(int n, int x) &#123; int mod = (int) 1e9 + 7; // 01背包， 从1^x, 2^x,...,n^x里选物品，恰好能装满容量为n的背包的方案数 int[] dp = new int[n + 1]; // 没有物品，恰好装满容量为0的背包的方案数：1,什么都不装 dp[0] = 1; for (int i = 1; i &lt;= n; ++i) &#123; int s = (int) Math.pow(i, x); for (int j = n; j &gt;= s; --j) &#123; dp[j] = (dp[j] + dp[j - s]) % mod; &#125; &#125; return dp[n]; &#125;&#125; 方法三：静态处理 所有x,n在static语句块中处理好 1234567891011121314151617181920212223class Solution &#123; static int[][] dp; static &#123; int n = 300, x = 5; int mod = (int) 1e9 + 7; // 01背包， 从1^x, 2^x,...,n^x里选物品，恰好能装满容量为n的背包的方案数 dp = new int[x][n + 1]; // 没有物品，恰好装满容量为0的背包的方案数：1,什么都不装 for (int i = 0; i &lt; x; ++i) dp[i][0] = 1; for (int k = 1; k &lt;= x; ++k) &#123; for (int i = 1; i &lt;= n; ++i) &#123; int s = (int) Math.pow(i, k); for (int j = n; j &gt;= s; --j) &#123; dp[k - 1][j] = (dp[k - 1][j] + dp[k - 1][j - s]) % mod; &#125; &#125; &#125; &#125; public int numberOfWays(int n, int x) &#123; return dp[x - 1][n]; &#125;&#125; 879. 盈利计划 方法一：记忆化搜索(爆内存) 方案数用 +！！！ 1234567891011121314151617181920212223242526272829class Solution &#123; public int profitableSchemes(int n, int minProfit, int[] group, int[] profit) &#123; this.group = group; this.profit = profit; this.n = n; this.minProfit = minProfit; dp = new int[group.length][n + 1][10000]; for (int[][] a : dp) for (int[] b : a) Arrays.fill(b, -1); return dfs(0, n, 0); &#125; public int dfs(int index, int hc, int p) &#123; if (index == group.length) return p &gt;= minProfit ? 1 : 0; if (dp[index][hc][p] != -1) return dp[index][hc][p]; int x = group[index], y = profit[index]; if (hc &gt;= x) return dp[index][hc][p] = (dfs(index + 1, hc, p) + dfs(index + 1, hc - x, p + y)) % mod; return dp[index][hc][p] = dfs(index + 1, hc, p) % mod; &#125; int[] group, profit; int n, minProfit, mod = (int) 1e9 + 7; int[][][] dp; &#125; 方法二：10000改成sum 勉勉强强过 1234567891011121314151617181920212223242526272829303132class Solution &#123; public int profitableSchemes(int n, int minProfit, int[] group, int[] profit) &#123; this.group = group; this.profit = profit; this.n = n; this.minProfit = minProfit; int sum = 0; for (int x : profit) sum += x; dp = new int[group.length][n + 1][sum + 1]; for (int[][] a : dp) for (int[] b : a) Arrays.fill(b, -1); return dfs(0, n, 0); &#125; public int dfs(int index, int hc, int p) &#123; if (index == group.length) return p &gt;= minProfit ? 1 : 0; if (dp[index][hc][p] != -1) return dp[index][hc][p]; int x = group[index], y = profit[index]; if (hc &gt;= x) return dp[index][hc][p] = (dfs(index + 1, hc, p) + dfs(index + 1, hc - x, p + y)) % mod; return dp[index][hc][p] = dfs(index + 1, hc, p) % mod; &#125; int[] group, profit; int n, minProfit, mod = (int) 1e9 + 7; int[][][] dp; &#125; 方法三：01背包 题解 1234567891011121314151617181920212223class Solution &#123; public int profitableSchemes(int n, int minProfit, int[] group, int[] profit) &#123; int sum = 0, mod = (int) 1e9 + 7; for (int x : profit) sum += x; // 从group下标0~i中选任务，当前的最大可用人数是j，获得的利润至少为k的方案数 int[][][] dp = new int[group.length + 1][n + 1][minProfit + 1]; // 没有任务，没有人，可获得的利润大于等于0的方案数是1：什么都不选 for (int i = 0; i &lt;= n; ++i) dp[0][i][0] = 1; for (int i = 1; i &lt;= group.length; ++i) &#123; int x = group[i - 1], y = profit[i - 1]; for (int j = 0; j &lt;= n; ++j) &#123; for (int k = 0; k &lt;= minProfit; ++k) &#123; dp[i][j][k] = dp[i - 1][j][k]; if (j &gt;= x) dp[i][j][k] = (dp[i][j][k] + dp[i - 1][j - x][Math.max(0, k - y)]) % mod; &#125; &#125; &#125; return dp[group.length][n][minProfit]; &#125;&#125; 279. 完全平方数 方法一：记忆化搜索 12345678910111213141516171819202122232425262728293031323334class Solution &#123; static int[] nums = new int[10000]; static &#123; for (int i = 1; i &lt; nums.length; ++i) nums[i] = i * i; &#125; public int numSquares(int n) &#123; this.n = n; m = (int) Math.sqrt(n); for (int i = 1; i &lt;= n; ++i) nums[i] = i * i; dp = new int[m + 1][n + 1]; for (int[] arr : dp) Arrays.fill(arr, -1); return dfs(1, n); &#125; int n, m, inf = Integer.MAX_VALUE / 2; int[][] dp; public int dfs(int index, int sum) &#123; if (index == m + 1) return sum == 0 ? 0 : inf; if (dp[index][sum] != -1) return dp[index][sum]; int x = nums[index]; if (sum &gt;= x) return dp[index][sum] = Math.min(dfs(index, sum - x) + 1, dfs(index + 1, sum)); return dp[index][sum] = dfs(index + 1, sum); &#125; &#125; 方法二：完全背包 123456789101112131415161718class Solution &#123; public int numSquares(int n) &#123; int m = (int) Math.sqrt(n); int[] dp = new int[n + 1]; // dp[0] = 0 没有物品，容量为0，需要0个数 Arrays.fill(dp, 100010); dp[0] = 0; for (int i = 1; i &lt;= m; ++i) &#123; int x = i * i; for (int j = x; j &lt;= n; ++j) &#123; dp[j] = Math.min(dp[j], dp[j - x] + 1); &#125; &#125; return dp[n]; &#125;&#125;","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://leopol1d.github.io/categories/Algorithms/"},{"name":"Dynamic Programming","slug":"Algorithms/Dynamic-Programming","permalink":"https://leopol1d.github.io/categories/Algorithms/Dynamic-Programming/"}],"tags":[{"name":"动态规划,背包问题","slug":"动态规划-背包问题","permalink":"https://leopol1d.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"}]},{"title":"Sort","slug":"sort","date":"2023-06-12T07:52:25.000Z","updated":"2023-06-13T02:56:46.388Z","comments":true,"path":"2023/06/12/sort/","link":"","permalink":"https://leopol1d.github.io/2023/06/12/sort/","excerpt":"","text":"贪心是一种思想，使用贪心思想解决的问题，如果能被总结成具体某一类问题，那么就有具体的名字，比如单源最短路问题，最小生成树问题，拓扑排序问题，如果不能被总结出来，那它就叫贪心问题哈哈。贪心问题经常需要借助排序来实现。 快速排序 取一个随机值作为下标，与最后一个位置交换 small始终指向最后一个小于pivot的下标，初始为start - 1 从start开始遍历，不需要遍历最后一个数(特殊处理) 当nums[i] &lt; nums[end]，将small前移，并且交换i与small 退出循环后，将small前移，与最后一个位置的数(pivot)交换 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445package sort;import java.util.Random;public class test &#123; public int[] sortArray(int[] nums) &#123; quickSort(nums, 0, nums.length - 1); return nums; &#125; public void quickSort(int[] nums, int start, int end) &#123; if (start &lt; end) &#123; // 递归到子数组只有一个数字为止 int pivot = partition(nums, start, end); quickSort(nums, start, pivot - 1); quickSort(nums, pivot + 1, end); &#125; &#125; private int partition(int[] nums, int start, int end) &#123; int random = new Random().nextInt(end - start + 1) + start; // nextInt左闭右开 swap(nums, random, end); int small = start - 1; for (int i = start; i &lt; end; ++i) // end存放的是pivot，退出循环特殊处理 if (nums[i] &lt; nums[end]) swap(nums, ++small, i); swap(nums, end, ++small); return small; &#125; private void swap(int[] nums, int index1, int index2) &#123; if (index1 == index2) return; int temp = nums[index1]; nums[index1] = nums[index2]; nums[index2] = temp; &#125; public static void main(String[] args) &#123; test t = new test(); int[] arr = new int[]&#123;3,5,8,10,34,1,544,-13&#125;; t.sortArray(arr); for (int x : arr) System.out.print(x + &quot; &quot;); &#125;&#125; 计数排序计数排序是一种线性时间的整数排序算法。如果数组的长度为n，整数范围(数组中最大整数与最小整数的差值)为k对于k远小于n的场景(如对某公司所有员工的年龄排序)，那么计数排序的时间复杂度优于其他基于比较的排序算法(如归并排序、快速排序)， 三次遍历！ 遍历原始数组nums，得出最大值max与最小值min，并创建大小为max - min + 1的count数组 遍历nums数组，把对应整数num出现的次数记录在count数组的count[num - min]中 令num从min遍历到max，将num顺序填入nums中(每个num有count[num - min]个) 代码 123456789101112131415public int[] sortArray(int[] nums) &#123; int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE; for (int num : nums) &#123; min = Math.min(min, num); max = Math.max(max, num); &#125; int[] count = new int[max - min + 1]; for (int num : nums) ++count[num - min]; int i = 0; for (int num = min; num &lt;= max; ++num) while (count[num - min]-- &gt; 0) nums[i++] = num; return nums;&#125; 剑指 Offer II 074. 合并区间 方法一：射气球的思路 首先将数组按照左边界升序排序 当intervals[i][1] &gt;= intervals[j][0]，那么这两个元素一定是要合并的，因为是intervals数组是按照左边界升序排序的，那么合并区间[a, b]的a一定是intervals[i][0]，将intervals[i][1]赋值为intervals[i][1]与intervals[j][1]的最大值 当intervals[i][1] &lt; intervals[j][0]，那么这个两个区间是不重合的，先把上一个重合区间加入结果集，再把j赋值给i，进行下一轮循环 当j == intervals.length - 1时候， 如果intervals[i][1] &gt;= intervals[j][0]，那么会将intervals[i][1]取intervals[i][1]与intervals[j][1]的最大值 如果intervals[i][1] &lt; intervals[j][0]，那么会将之前的重合区间存入结果集，并将j赋值给i 所以出循环，只需要把intervals[i]加入结果集就好！ 1234567891011121314151617class Solution &#123; public int[][] merge(int[][] intervals) &#123; Arrays.sort(intervals, (o1, o2) -&gt; Integer.compare(o1[0], o2[0])); List&lt;int[]&gt; list = new LinkedList&lt;&gt;(); int i = 0; for (int j = 1; j &lt; intervals.length; ++j) &#123; if (intervals[i][1] &gt;= intervals[j][0]) intervals[i][1] = Math.max(intervals[i][1], intervals[j][1]); else &#123; list.add(new int[]&#123;intervals[i][0], intervals[i][1]&#125;); i = j; &#125; &#125; list.add(new int[]&#123;intervals[i][0], intervals[i][1]&#125;); return list.toArray(new int[list.size()][]); &#125;&#125; 剑指 Offer II 075. 数组相对排序 数据范围是[0, 1000]，创建大小为1001的count数组 统计arr1中出现整数的个数 按照arr2整数出现的顺序填arr1数组 从0到1000(升序)，把剩下的数组填入arr1数组 123456789101112131415class Solution &#123; public int[] relativeSortArray(int[] arr1, int[] arr2) &#123; int[] count = new int[1001]; for (int num : arr1) ++count[num]; int i = 0; for (int num : arr2) while (count[num]-- &gt; 0) arr1[i++] = num; for (int num = 0; num &lt;= 1000; ++num) while (count[num]-- &gt; 0) arr1[i++] = num; return arr1; &#125;&#125; 剑指 Offer II 076. 数组中的第 k 大的数字 快排找到下标为n-k的数x，左边的数都小于x，右边的数都大于x 12345678910111213141516171819202122232425262728293031323334class Solution &#123; public int findKthLargest(int[] nums, int k) &#123; int n = nums.length, target = n - k, start = 0, end = n - 1; int pivot = partition(nums, start, end); while (pivot != target) &#123; if (pivot &gt; target) end = pivot - 1; else start = pivot + 1; pivot = partition(nums, start, end); &#125; return nums[pivot]; &#125; private int partition(int[] nums, int start, int end) &#123; int random = new Random().nextInt(end - start + 1) + start; swap(nums, random, end); int small = start - 1; for (int i = start; i &lt; end; ++i) if (nums[i] &lt; nums[end]) swap(nums, ++small, i); swap(nums, ++small, end); return small; &#125; private void swap(int[] nums, int index1, int index2) &#123; if (index1 == index2) return; int temp = nums[index1]; nums[index1] = nums[index2]; nums[index2] = temp; &#125; &#125;","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://leopol1d.github.io/categories/Algorithms/"},{"name":"Sort","slug":"Algorithms/Sort","permalink":"https://leopol1d.github.io/categories/Algorithms/Sort/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://leopol1d.github.io/tags/%E6%8E%92%E5%BA%8F/"},{"name":"贪心","slug":"贪心","permalink":"https://leopol1d.github.io/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"Sliding Window","slug":"sliding-window","date":"2023-06-10T04:07:54.000Z","updated":"2023-10-06T07:59:22.331Z","comments":true,"path":"2023/06/10/sliding-window/","link":"","permalink":"https://leopol1d.github.io/2023/06/10/sliding-window/","excerpt":"","text":"滑动窗口主要解决满足某个条件的连续子串问题，因为我们枚举 区间、子数组、子串问题的时候时间复杂度是$O(n^2)$，使用滑窗可以将时间复杂度优化至$O(n)$。优质题解 3. 无重复字符的最长子串 left = Math.max(left , map.get(s.charAt(i))+1);十分tricky，举例 abba 当遍历到第二个a的时候，此时的left指向第二个b，right指向第二个a，字符出现重复，所以要更新left，往map里一查，之前出现的a下标比left还小，说明当前记录的最长不重复子串就不包含第一个a，所以left不变 然后不管出没出现重复字符，都要执行 map.put(s.charAt(i) , i);如果字符串是abbab，当遍历到最后一个b的时候，left赋值为第二个b 的下标 + 1 的位置，也就是a下标的位置；如果出现重复字符就不执行map.put(s.charAt(i) , i)，那么此时b在map里记录的下标是第一个b的下标 123456789101112131415161718192021222324252627282930313233public int lengthOfLongestSubstring(String s) &#123; HashMap&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); int maxLen = 0;//用于记录最大不重复子串的长度 int left = 0;//滑动窗口左指针 for (int i = 0; i &lt; s.length() ; i++) &#123; /** 1、首先，判断当前字符是否包含在map中，如果不包含，将该字符添加到map（字符，字符在数组下标）, 此时没有出现重复的字符，左指针不需要变化。此时不重复子串的长度为：i-left+1，与原来的maxLen比较，取最大值； 2、如果当前字符 ch 包含在 map中，此时有2类情况： 1）当前字符包含在当前有效的子段中，如：abca，当我们遍历到第二个a，当前有效最长子段是 abc，我们又遍历到a， 那么此时更新 left 为 map.get(a)+1=1，当前有效子段更新为 bca； 2）当前字符不包含在当前最长有效子段中，如：abba，我们先添加a,b进map，此时left=0，我们再添加b，发现map中包含b， 而且b包含在最长有效子段中，就是1）的情况，我们更新 left=map.get(b)+1=2，此时子段更新为 b，而且map中仍然包含a，map.get(a)=0； 随后，我们遍历到a，发现a包含在map中，且map.get(a)=0，如果我们像1）一样处理，就会发现 left=map.get(a)+1=1，实际上，left此时 应该不变，left始终为2，子段变成 ba才对。 为了处理以上2类情况，我们每次更新left，left=Math.max(left , map.get(ch)+1). 另外，更新left后，不管原来的 s.charAt(i) 是否在最长子段中，我们都要将 s.charAt(i) 的位置更新为当前的i， 因此此时新的 s.charAt(i) 已经进入到 当前最长的子段中！ */ if(map.containsKey(s.charAt(i))) &#123; left = Math.max(left , map.get(s.charAt(i))+1); &#125; //不管是否更新left，都要更新 s.charAt(i) 的位置！ map.put(s.charAt(i) , i); maxLen = Math.max(maxLen , i-left+1); &#125; return maxLen; &#125; 30. 串联所有单词的子串“ling mind rabo ofoo owin gdin gbar rwin g monkeypoundcake” [“fooo”,“barr”,“wing”,“ding”,“wing”] 187. 重复的DNA序列 方法一：暴搜(说是滑动窗口也行吧) 1234567891011121314class Solution &#123; public List&lt;String&gt; findRepeatedDnaSequences(String s) &#123; List&lt;String&gt; res = new LinkedList&lt;&gt;(); Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); for (int l = 0; l &lt;= s.length() - 10; ++l) &#123; String subStr = s.substring(l, l + 10); map.put(subStr, map.getOrDefault(subStr, 0) + 1); &#125; for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) if (entry.getValue() &gt; 1) res.add(entry.getKey()); return res; &#125;&#125; 一次循环也可 12345678910111213class Solution &#123; public List&lt;String&gt; findRepeatedDnaSequences(String s) &#123; List&lt;String&gt; res = new LinkedList&lt;&gt;(); Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); for (int l = 0; l &lt;= s.length() - 10; ++l) &#123; String subStr = s.substring(l, l + 10); map.put(subStr, map.getOrDefault(subStr, 0) + 1); if (map.getOrDefault(subStr, 0) == 2) res.add(subStr); &#125; return res; &#125;&#125; 76. 最小覆盖子串 方法一：滑动窗口(超时check部分) 12345678910111213141516171819202122232425262728293031class Solution &#123; public String minWindow(String s, String t) &#123; String res = &quot;&quot;; if (s.length() &lt; t.length()) return res; int minLen = 100000; int[] map = new int[256]; for (char ch : t.toCharArray()) ++map[ch - &#x27;A&#x27;]; for (int left = 0, i = 0; i &lt; s.length(); ++i) &#123; char ch = s.charAt(i); --map[ch - &#x27;A&#x27;]; while (i - left + 1 &gt;= t.length() &amp;&amp; check(map, t)) &#123; if (i - left + 1 &lt; minLen) &#123; res = s.substring(left, i + 1); minLen = i - left + 1; &#125; ++map[s.charAt(left) - &#x27;A&#x27;]; ++left; &#125; &#125; return res; &#125; private boolean check(int[] map, String t) &#123; for (char ch : t.toCharArray()) if (map[ch - &#x27;A&#x27;] &gt; 0) return false; return true; &#125;&#125; 把t提前转换好勉强能过，char[] arr = t.toCharArray(); 1234567891011121314151617181920212223242526272829303132class Solution &#123; public String minWindow(String s, String t) &#123; String res = &quot;&quot;; if (s.length() &lt; t.length()) return res; char[] arr = t.toCharArray(); int minLen = 100000; int[] map = new int[128]; for (char ch : arr) ++map[ch - &#x27;A&#x27;]; for (int left = 0, i = 0; i &lt; s.length(); ++i) &#123; char ch = s.charAt(i); --map[ch - &#x27;A&#x27;]; while (i - left + 1 &gt;= t.length() &amp;&amp; check(map, arr)) &#123; if (i - left + 1 &lt; minLen) &#123; res = s.substring(left, i + 1); minLen = i - left + 1; &#125; ++map[s.charAt(left) - &#x27;A&#x27;]; ++left; &#125; &#125; return res; &#125; private boolean check(int[] map, char[] arr) &#123; for (char ch : arr) if (map[ch - &#x27;A&#x27;] &gt; 0) return false; return true; &#125;&#125; 209. 长度最小的子数组 12345678910111213class Solution &#123; public int minSubArrayLen(int target, int[] nums) &#123; int sum = 0, minLen = 100001; for (int left = 0, right = 0; right &lt; nums.length; ++right) &#123; sum += nums[right]; while (sum &gt;= target) &#123; minLen = Math.min(minLen, right - left + 1); sum -= nums[left++]; &#125; &#125; return minLen == 100001 ? 0 : minLen; &#125;&#125; 567. 字符串的排列 方法一：滑动窗口 123456789101112131415161718192021222324class Solution &#123; public boolean checkInclusion(String s1, String s2) &#123; int[] map = new int[26]; for (char ch : s1.toCharArray()) ++map[ch - &#x27;a&#x27;]; for (int left = 0, right = 0; right &lt; s2.length(); ++right) &#123; --map[s2.charAt(right) - &#x27;a&#x27;]; if (right - left + 1 &gt;= s1.length()) &#123; if (check(map, s1)) return true; ++map[s2.charAt(left++) - &#x27;a&#x27;]; &#125; &#125; return false; &#125; private boolean check(int[] map, String s) &#123; for (char ch : s.toCharArray()) if (map[ch - &#x27;a&#x27;] != 0) return false; return true; &#125; &#125; 1208. 尽可能使字符串相等 方法一：滑动窗口 123456789101112class Solution &#123; public int equalSubstring(String s, String t, int maxCost) &#123; int maxLen = 0, cost = 0; for (int left = 0, i = 0; i &lt; s.length() &amp;&amp; i &lt; t.length(); ++i) &#123; cost += Math.abs(s.charAt(i) - t.charAt(i)); while (left &lt;= i &amp;&amp; cost &gt; maxCost) cost -= Math.abs(Math.abs(s.charAt(left) - t.charAt(left++))); maxLen = Math.max(maxLen, i - left + 1); &#125; return maxLen; &#125;&#125; 找出最长等值子数组 方法一：滑动窗口 同向双指针 将每个值的下标存到List中，例如对于nums = [1,3,2,3,1,3], k = 3 list[1]: [0, 4] list[2] : [4] list[3]: [1, 3, 5] 枚举每个list，即把元素替换成1或2或3，例如枚举list[3]: [1, 3, 5]，l = 0, r = 1时，nums数组有list.get® - list.get(0) + 1 = 3 - 1 + 1 = 3个数：[3，2，3]，这个子数组中有r - l + 1 = 1 - 0 + 1 = 2个3，所以需要删除3 - 2 = 1个数 当需要删除的数大于k时，将左端点右移，直到满足需要删除的元素小于等于k 12345678910111213141516171819class Solution &#123; public int longestEqualSubarray(List&lt;Integer&gt; nums, int k) &#123; int n = nums.size(); List&lt;Integer&gt;[] pos = new List[n + 1]; Arrays.setAll(pos, e -&gt; new ArrayList&lt;&gt;()); for (int i = 0; i &lt; n; ++i) pos[nums.get(i)].add(i); int res = 0; for (List&lt;Integer&gt; list : pos) &#123; int l = 0; for (int r = 0; r &lt; list.size(); ++r) &#123; while (list.get(r) - list.get(l) + 1 - (r - l + 1) &gt; k) ++l; res = Math.max(res, r - l + 1); &#125; &#125; return res; &#125;&#125; 713. 乘积小于 K 的子数组 方法一：滑动窗口 相向双指针 res += i - l + 1;把当前[l,r]的子数组都涵括了 如果[l,r]满足条件，那么[l + 1, r], [l + 2, r], … , [r, r]都满足，满足条件的个数为 r - l + 1 123456789101112class Solution &#123; public int numSubarrayProductLessThanK(int[] nums, int k) &#123; int n = nums.length ,res = 0, l = 0, prod = 1; for (int i = 0; i &lt; n; ++i) &#123; prod *= nums[i]; while (l &lt;= i &amp;&amp; prod &gt;= k) prod /= nums[l++]; res += i - l + 1; &#125; return res; &#125;&#125; 1004. 最大连续1的个数 III 方法一：滑动窗口(同向双指针) 12345678910111213class Solution &#123; public int longestOnes(int[] nums, int k) &#123; int n = nums.length, left = 0, res = 0, cnt0 = 0; for (int i = 0; i &lt; n; ++i) &#123; cnt0 += 1 - nums[i]; while (cnt0 &gt; k) &#123; cnt0 -= (nums[left++] == 0 ? 1 : 0); &#125; res = Math.max(res, i - left + 1); &#125; return res; &#125;&#125; 1234. 替换子串得到平衡字符串 方法一：滑动窗口(同向双指针) 将[l,r]的字符数量减去，如果满足QWERd的数量都小于n / 4，那么子串长度为r - l + 1 123456789101112131415161718192021222324class Solution &#123; public int balancedString(String s) &#123; int[] cnt = new int[&#x27;X&#x27;]; // &#x27;X&#x27; - &#x27;W&#x27; = 1 int n = s.length(), l = 0, res = Integer.MAX_VALUE, target = n / 4; for (int i = 0; i &lt; n; ++i) cnt[s.charAt(i)]++; if (check(cnt, target)) return 0; for (int i = 0; i &lt; n; ++i) &#123; char ch = s.charAt(i); --cnt[ch]; while (check(cnt, target)) &#123; ++cnt[s.charAt(l)]; res = Math.min(res, i - l + 1); ++l; &#125; &#125; return res; &#125; private boolean check(int[] cnt, int target) &#123; return cnt[&#x27;Q&#x27;] &lt;= target &amp;&amp; cnt[&#x27;W&#x27;] &lt;= target &amp;&amp; cnt[&#x27;E&#x27;] &lt;= target &amp;&amp; cnt[&#x27;R&#x27;] &lt;= target; &#125;&#125; 1658. 将 x 减到 0 的最小操作数 123456789101112131415161718class Solution &#123; public int minOperations(int[] nums, int x) &#123; int n = nums.length, res = -1, l = 0, sum = 0; for (int a : nums) sum += a; int target = sum - x, cur = 0; if (target &lt; 0) return -1; for (int i = 0; i &lt; n; ++i) &#123; cur += nums[i]; while (cur &gt; target) cur -= nums[l++]; if (cur == target) res = Math.max(res, i - l + 1); &#125; return res &lt; 0 ? -1 : n - res; &#125;&#125; 两个线段获得的最多奖品 方法一：同向双指针 12345678910111213class Solution &#123; public int maximizeWin(int[] pos, int k) &#123; int n = pos.length, res = 0, l = 0; int[] pre = new int[n + 1]; for (int i = 0; i &lt; n; ++i) &#123; while (pos[i] - pos[l] &gt; k) ++l; res = Math.max(res, pre[l] + i - l + 1); pre[i + 1] = Math.max(pre[i], i - l + 1); &#125; return res; &#125;&#125; 1456. 定长子串中元音的最大数目 方法一：滑动窗口(同向双指针) 123456789101112131415161718192021222324class Solution &#123; public int maxVowels(String s, int k) &#123; Set&lt;Character&gt; set = new HashSet&lt;&gt;(); set.add(&#x27;a&#x27;); set.add(&#x27;e&#x27;); set.add(&#x27;i&#x27;); set.add(&#x27;o&#x27;); set.add(&#x27;u&#x27;); int n = s.length(), l = 0, res = 0, cnt = 0; for (int i = 0; i &lt; n; ++i) &#123; char ch = s.charAt(i); if (set.contains(ch)) &#123; ++cnt; res = Math.max(res, cnt); &#125; if (i - l + 1 == k) &#123; if (set.contains(s.charAt(l))) --cnt; ++l; &#125; &#125; return res; &#125;&#125; 2269. 找到一个数字的 K 美丽值 方法一：滑动窗口(同向双指针) 1234567891011121314151617class Solution &#123; public int divisorSubstrings(int num, int k) &#123; String s = num + &quot;&quot;; int n = s.length(), cnt = 0, x = 0, mod = (int) Math.pow(10, k - 1); for (int i = 0; i &lt; k; ++i) x = x * 10 + (s.charAt(i) - &#x27;0&#x27;); for (int i = k; i &lt; n; ++i) &#123; if (x != 0 &amp;&amp; num % x == 0) ++cnt; x %= mod; x = x * 10 + (s.charAt(i) - &#x27;0&#x27;); &#125; if (x != 0 &amp;&amp; num % x == 0) ++cnt; return cnt; &#125;&#125; 方法二：子串处理 123456789101112class Solution &#123; public int divisorSubstrings(int num, int k) &#123; String s = String.valueOf(num); int n = s.length(), cnt = 0; for (int i = 0; i + k &lt;= n; ++i) &#123; int x = Integer.parseInt(s.substring(i, i + k)); if (x != 0 &amp;&amp; num % x == 0) ++cnt; &#125; return cnt; &#125;&#125; 1984. 学生分数的最小差值 方法一：排序 + 滑动窗口 123456789101112131415class Solution &#123; public int minimumDifference(int[] nums, int k) &#123; if (nums.length == 1 || k == 1) return 0; Arrays.sort(nums); int res = 1000001, n = nums.length, l = 0; for (int i = 0; i &lt; n; ++i) &#123; if (i - l + 1 == k) &#123; res = Math.min(res, nums[i] - nums[l]); ++l; &#125; &#125; return res; &#125;&#125; 643. 子数组最大平均数 I 方法一：滑动窗口 1234567891011121314class Solution &#123; public double findMaxAverage(int[] nums, int k) &#123; int n = nums.length, l = 0; double res = Integer.MIN_VALUE, sum = 0; for (int i = 0; i &lt; n; ++i) &#123; sum += nums[i]; if (i - l + 1 == k) &#123; res = Math.max(res, sum / k); sum -= nums[l++]; &#125; &#125; return res; &#125;&#125; 1343. 大小为 K 且平均值大于等于阈值的子数组数目 方法一：滑动窗口 1234567891011121314class Solution &#123; public int numOfSubarrays(int[] arr, int k, int threshold) &#123; int l = 0, cnt = 0, n = arr.length, sum = 0; for (int i = 0; i &lt; n; ++i) &#123; sum += arr[i]; if (i - l + 1 == k) &#123; if (sum / k &gt;= threshold) ++cnt; sum -= arr[l++]; &#125; &#125; return cnt; &#125;&#125; 2090. 半径为 k 的子数组平均值 方法一：滑动数组 12345678910111213141516class Solution &#123; public int[] getAverages(int[] nums, int k) &#123; int n = nums.length, l = 0; int[] avg = new int[n]; Arrays.fill(avg, -1); long sum = 0; for (int i = 0; i &lt; n; ++i) &#123; sum += nums[i]; if (i - l + 1 == 2 * k + 1) &#123; avg[i - k] = (int) (sum / (2 * k + 1)); sum -= nums[l++]; &#125; &#125; return avg; &#125;&#125; 2379. 得到 K 个黑块的最少涂色次数 方法一：滑动窗口 123456789101112131415class Solution &#123; public int minimumRecolors(String s, int k) &#123; int cnt = 0, res = 10000, l = 0, n = s.length(); for (int i = 0; i &lt; n; ++i) &#123; char ch = s.charAt(i); if (ch == &#x27;W&#x27;) ++cnt; if (i - l + 1 == k) &#123; res = Math.min(res, cnt); cnt -= (s.charAt(l++) == &#x27;W&#x27; ? 1 : 0); &#125; &#125; return res; &#125;&#125; 1052. 爱生气的书店老板 方法一：滑动窗口 1234567891011121314151617class Solution &#123; public int maxSatisfied(int[] customers, int[] grumpy, int k) &#123; int n = customers.length, l = 0, sum = 0, res = 0; for (int i = 0; i &lt; n; ++i) sum += grumpy[i] == 0 ? customers[i] : 0; for (int i = 0; i &lt; n; ++i) &#123; sum += grumpy[i] == 1 ? customers[i] : 0; if (i - l + 1 == k) &#123; res = Math.max(res, sum); if (grumpy[l] == 1) sum -= customers[l]; ++l; &#125; &#125; return res; &#125;&#125; 2841. 几乎唯一子数组的最大和 方法一：滑动窗口 12345678910111213141516171819202122class Solution &#123; public long maxSum(List&lt;Integer&gt; nums, int m, int k) &#123; int n = nums.size(), l = 0; long sum = 0, res = 0; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; n; ++i) &#123; int x = nums.get(i); sum += x; map.put(x, map.getOrDefault(x, 0) + 1); if (i - l + 1 == k) &#123; if (map.size() &gt;= m) res = Math.max(res, sum); int y = nums.get(l++); sum -= y; map.put(y, map.get(y) - 1); if (map.get(y) == 0) map.remove(y); &#125; &#125; return res; &#125;&#125; 2461. 长度为 K 子数组中的最大和 方法一：滑动窗口 1234567891011121314151617181920212223242526class Solution &#123; public long maximumSubarraySum(int[] nums, int k) &#123; int n = nums.length, cnt = 0, l = 0; long res = 0, s = 0; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; n; ++i) &#123; int x = nums[i]; s += x; if (!map.containsKey(x)) ++cnt; map.put(x, map.getOrDefault(x, 0) + 1); if (i - l + 1 == k) &#123; if (cnt == k) res = Math.max(res, s); int y = nums[l++]; s -= y; map.put(y, map.get(y) - 1); if (map.get(y) == 0) &#123; map.remove(y); --cnt; &#125; &#125; &#125; return res; &#125;&#125; 1423. 可获得的最大点数 方法一：逆向思维 + 滑动窗口 **正难则反：**从数组中长出长度为n - k，和最小的子数组 1234567891011121314class Solution &#123; public int maxScore(int[] nums, int k) &#123; int sum = 0, s = 0, l = 0, n = nums.length, res = Integer.MAX_VALUE; // n = 7 , k = 3 求长度位4的最小组数组 for (int i = 0; i &lt; n; ++i) &#123; sum += nums[i]; s += nums[i]; if (i - l + 1 == n - k) &#123; res = Math.min(res, s); s -= nums[l++]; &#125; &#125; return sum - (n - k == 0 ? 0 : res); &#125;&#125; 2134. 最少交换次数来组合所有的 1 II 方法一：逆向思维 统计1的个数k，以k为窗口，计算窗口内0的数量 12345678910111213141516class Solution &#123; public int minSwaps(int[] nums) &#123; int l = 0, k = 0, cnt = 0, n = nums.length, res = n; for (int x : nums) k += x == 1 ? 1 : 0; for (int i = 0; i &lt; k; ++i) cnt += nums[i]; int r = k; while (l &lt; n) &#123; res = Math.min(res, k - cnt); cnt -= nums[l++ % n]; cnt += nums[r++ % n]; &#125; return res; &#125; &#125;","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://leopol1d.github.io/categories/Algorithms/"},{"name":"Sliding Window","slug":"Algorithms/Sliding-Window","permalink":"https://leopol1d.github.io/categories/Algorithms/Sliding-Window/"}],"tags":[{"name":"滑动窗口","slug":"滑动窗口","permalink":"https://leopol1d.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"}]},{"title":"Trie","slug":"trie","date":"2023-06-06T08:38:03.000Z","updated":"2023-06-08T08:12:45.454Z","comments":true,"path":"2023/06/06/trie/","link":"","permalink":"https://leopol1d.github.io/2023/06/06/trie/","excerpt":"","text":"前缀树主要用于解决与字符串查找相关d 剑指 Offer II 062. 实现前缀树 方法一：前缀树 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Trie &#123; static class TrieNode &#123; private TrieNode[] children = new TrieNode[26]; private boolean isWord; &#125; /** Initialize your data structure here. */ private TrieNode root = new TrieNode(); /** Inserts a word into the trie. */ public void insert(String word) &#123; TrieNode node = root; for (char ch : word.toCharArray()) &#123; if (node.children[ch - &#x27;a&#x27;] == null) node.children[ch - &#x27;a&#x27;] = new TrieNode(); node = node.children[ch - &#x27;a&#x27;]; &#125; node.isWord = true; &#125; /** Returns if the word is in the trie. */ public boolean search(String word) &#123; TrieNode node = root; for (char ch : word.toCharArray()) &#123; if (node.children[ch - &#x27;a&#x27;] == null) return false; node = node.children[ch - &#x27;a&#x27;]; &#125; return node.isWord; &#125; /** Returns if there is any word in the trie that starts with the given prefix. */ public boolean startsWith(String prefix) &#123; TrieNode node = root; for (char ch : prefix.toCharArray()) &#123; if (node.children[ch - &#x27;a&#x27;] == null) return false; node = node.children[ch - &#x27;a&#x27;]; &#125; return true; &#125;&#125;/** * Your Trie object will be instantiated and called as such: * Trie obj = new Trie(); * obj.insert(word); * boolean param_2 = obj.search(word); * boolean param_3 = obj.startsWith(prefix); */ 剑指 Offer II 063. 替换单词 一刷： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123; static class TrieNode &#123; private TrieNode[] children; private boolean isWord; public TrieNode() &#123; children = new TrieNode[26]; &#125; &#125; public String replaceWords(List&lt;String&gt; dictionary, String sentence) &#123; TrieNode root = buildTrie(dictionary); String[] words = sentence.split(&quot; &quot;); StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; words.length; ++i) &#123; String prefix = findPrefix(root, words[i]); if (!prefix.isEmpty()) &#123; words[i] = prefix; &#125; &#125; return String.join(&quot; &quot;, words); &#125; private String findPrefix(TrieNode root, String word) &#123; TrieNode cur = root; StringBuilder sb = new StringBuilder(); for (char ch : word.toCharArray()) &#123; if (cur.children[ch - &#x27;a&#x27;] == null || cur.isWord) break; sb.append(ch); cur = cur.children[ch - &#x27;a&#x27;]; &#125; return cur.isWord == true ? sb.toString() : &quot;&quot;; &#125; private TrieNode buildTrie(List&lt;String&gt; dictionary) &#123; TrieNode root = new TrieNode(); for (String str : dictionary) &#123; TrieNode cur = root; for (char ch : str.toCharArray()) &#123; if (cur.children[ch - &#x27;a&#x27;] == null) cur.children[ch - &#x27;a&#x27;] = new TrieNode(); cur = cur.children[ch - &#x27;a&#x27;]; &#125; cur.isWord = true; &#125; return root; &#125;&#125; 二刷 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; static class TrieNode &#123; TrieNode[] children = new TrieNode[26]; boolean isWord; &#125; TrieNode root = new TrieNode(); private void buildDict(List&lt;String&gt; dictionary) &#123; for (String word : dictionary) &#123; TrieNode node = root; for (char ch : word.toCharArray()) &#123; if (node.children[ch - &#x27;a&#x27;] == null) node.children[ch - &#x27;a&#x27;] = new TrieNode(); node = node.children[ch - &#x27;a&#x27;]; &#125; node.isWord = true; &#125; &#125; public String replaceWords(List&lt;String&gt; dictionary, String sentence) &#123; buildDict(dictionary); String[] words = sentence.split(&quot; &quot;); StringBuilder res = new StringBuilder(), sb = new StringBuilder(); for (String word : words) &#123; TrieNode node = root; for (char ch : word.toCharArray()) &#123; if (node.children[ch - &#x27;a&#x27;] == null) break; sb.append(ch); node = node.children[ch - &#x27;a&#x27;]; if (node.isWord) &#123; sb.append(&quot; &quot;); res.append(sb); sb = new StringBuilder(); break; &#125; &#125; sb = new StringBuilder(); if (!node.isWord) res.append(word + &quot; &quot;); &#125; res.deleteCharAt(res.length() - 1); return res.toString(); &#125;&#125; 剑指 Offer II 064. 神奇的字典 方法一：前缀树 注意：一定要判断root.isWord，比如字典里有“hello”，search(“hhll”) 12if (root.isWord &amp;&amp; index == searchWord.length() &amp;&amp; diff == 1) return true; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class MagicDictionary &#123; static class TrieNode &#123; TrieNode[] children = new TrieNode[26]; boolean isWord; &#125; /** Initialize your data structure here. */ TrieNode root = new TrieNode(); public void buildDict(String[] dictionary) &#123; for (String word : dictionary) &#123; TrieNode node = root; for (char ch : word.toCharArray()) &#123; if (node.children[ch - &#x27;a&#x27;] == null) node.children[ch - &#x27;a&#x27;] = new TrieNode(); node = node.children[ch - &#x27;a&#x27;]; &#125; node.isWord = true; &#125; &#125; public boolean search(String searchWord) &#123; return dfs(root, searchWord, 0, 0); &#125; private boolean dfs(TrieNode root, String searchWord, int index, int diff) &#123; if (root == null || diff &gt; 1) return false; if (root.isWord &amp;&amp; index == searchWord.length() &amp;&amp; diff == 1) return true; if (index == searchWord.length()) return false; boolean found = false; for (int i = 0; i &lt; 26; ++i) &#123; if (found) break; int nextDiff = i == searchWord.charAt(index) - &#x27;a&#x27; ? diff : diff + 1; found = dfs(root.children[i], searchWord, index + 1, nextDiff); &#125; return found; &#125;&#125;/** * Your MagicDictionary object will be instantiated and called as such: * MagicDictionary obj = new MagicDictionary(); * obj.buildDict(dictionary); * boolean param_2 = obj.search(searchWord); */","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://leopol1d.github.io/categories/Algorithms/"},{"name":"Trie","slug":"Algorithms/Trie","permalink":"https://leopol1d.github.io/categories/Algorithms/Trie/"}],"tags":[{"name":"前缀树","slug":"前缀树","permalink":"https://leopol1d.github.io/tags/%E5%89%8D%E7%BC%80%E6%A0%91/"}]},{"title":"Binary Search","slug":"binary-search","date":"2023-06-06T01:05:05.000Z","updated":"2023-09-06T04:27:28.573Z","comments":true,"path":"2023/06/06/binary-search/","link":"","permalink":"https://leopol1d.github.io/2023/06/06/binary-search/","excerpt":"","text":"mid的计算方式1234int mid1 = right - ((right - left) &gt;&gt; 1);int mid2 = left + (right - left) / 2;当right = 5， left = 4时mid1 = 5, mid2 = 4 总结经验求大于(等于)target的最小值返回left思路：尽量执行right = mid - 1，当最后一次满足check(mid) &lt;= target并向左滑动右区间，之后只会向右滑动左区间，最后left = right + 1退出while循环，left就是最小的最大值12345678while (left &lt;= right) &#123; int mid = (left + right) &gt;&gt; 1; if (check(mid) &lt;= target) // mid大了 right = mid - 1; else left = mid + 1;&#125;return left;while的执行条件为left &lt;= rightif (check(mid) &lt;= m) // mid大了right = mid - 1;return left;只要nums[mid] &gt; target，令right = mid - 1，当遇到大于target的最小值时，也会让right = mid - 1，之后在while循环中都不满足nums[mid] &gt; target，只会执行left = mid + 1，直到left = right + 1退出while循环，此时的left便是大于target的最小值求小于target的最大值返回right 35. 搜索插入位置 求大于等于target的最小值 如果target在数组中，则会在while循环内被return 如果target不在数组中，while会遍历到left&gt;right结束循环 在left&gt;right的上一步一定是left == right，此时nums[mid]&lt;target，由于右边界是right，可以确定target一定小于nums[right + 1] (或者nums[right]已经是右边界了) 所以while退出循环时，left指向的位置是大于target的，插入在这个位置就好 123456789101112131415 class Solution &#123; public int searchInsert(int[] nums, int target) &#123; int left = 0, right = nums.length - 1; while (left &lt;= right) &#123; int mid = (left + right) &gt;&gt; 1; if (nums[mid] == target) return mid; else if (nums[mid] &gt; target) right = mid - 1; else left = mid + 1; &#125; return left; &#125;&#125; 剑指 Offer II 069. 山峰数组的顶部 123456789101112131415class Solution &#123; public int peakIndexInMountainArray(int[] arr) &#123; int left = 1, right = arr.length - 2; while (left &lt;= right) &#123; int mid = (left + right) &gt;&gt; 1; if (arr[mid] &gt; arr[mid - 1] &amp;&amp; arr[mid] &gt; arr[mid + 1]) return mid; else if (arr[mid] &gt; arr[mid - 1]) left = mid + 1; else right = mid - 1; &#125; return -1; &#125;&#125; 剑指 Offer II 070. 排序数组中只出现一次的数字 优质题解,这道题需要在纸上模拟 在单一元素x之前,成对出现的第一个元素下标一定是偶数 在单一元素x之后,成对出现的第一个元素下标一定是奇数 举例 12数组:1 1 2 2 3 4 4 5 5下标:0 1 2 3 4 5 6 7 8 单一元素x的值为3,下标为4 在x之前,成对出现的元素有1 1, 2 2,第一个1的下标为0,第一个2的下标为2,均为偶数 在x之后,成对出现的元素有4 4,5 5,第一个4的下标为5,第一个5的下标为7,均为奇数 因此可以根据mid下标的奇偶性来进行二分 如果mid的下标是偶数 如果mid + 1 &lt; n &amp;&amp; nums[mid] == nums[mid + 1],那么单一元素x一定在mid + 1后,令 left = mid + 2; 否则,当nums[mid] != nums[mid + 1]时,mid可能就是单一元素x,如果不是,那么x也肯定在mid前面,令right = mid 如果mid的下标是奇数 如果mid - 1 &gt;= 0 &amp;&amp; nums[mid] == nums[mid - 1],那么单一元素x一定在mid后面,令left = mid + 1 否则,当nums[mid] != nums[mid - 1]时,肯定是mid - 1或者mid - 1之前出现了x,令right = mid - 1 举例 12数组:1 2 2 4 4 下标:0 1 2 3 4 当left == right时,退出循环,此时left(right)下标对应的数就是x 12345678910111213141516171819202122class Solution &#123; public int singleNonDuplicate(int[] nums) &#123; int n = nums.length; int left = 0, right = n - 1; while (left &lt; right) &#123; int mid = (left + right) &gt;&gt; 1; if (mid % 2 == 0) &#123; if (mid + 1 &lt; n &amp;&amp; nums[mid] == nums[mid + 1]) left = mid + 2; else right = mid; &#125; else &#123; if (mid - 1 &gt;= 0 &amp;&amp; nums[mid] == nums[mid - 1]) left = mid + 1; else right = mid - 1; &#125; &#125; return nums[right]; &#125;&#125; 如果nums时未排序的，那么这就是另一类经典面试题 将数组中所有数字异或，最终的结果就是那个唯一只出现一次的数字 12345678class Solution &#123; public int singleNonDuplicate(int[] nums) &#123; int res = 0; for (int i = 0; i &lt; nums.length; ++i) res = res ^ nums[i]; return res; &#125;&#125; 剑指 Offer II 071. 按权重生成随机数 方法一: 前缀和 + 二分查找 剑指offer题解 123456789101112131415161718192021222324252627282930313233343536class Solution &#123; private int total; private int[] preSum; private int n; public Solution(int[] w) &#123; n = w.length; preSum = new int[n]; for (int i = 0; i &lt; n; ++i) &#123; total += w[i]; preSum[i] += total; &#125; &#125; public int pickIndex() &#123; Random random = new Random(); // 找到大于p的最小值的下标 int p = random.nextInt(total); int left = 0, right = n - 1; while (left &lt;= right) &#123; int mid = (left + right) &gt;&gt; 1; if (preSum[mid] == p) return mid + 1; else if (preSum[mid] &gt; p) right = mid - 1; else left = mid + 1; &#125; return left; &#125;&#125;/** * Your Solution object will be instantiated and called as such: * Solution obj = new Solution(w); * int param_1 = obj.pickIndex(); */ 剑指 Offer II 072. 求平方根 方法一：二分查找 求平方小于等于x的最大值 如果x取根号为整数，会在while循环被返回 如果x取根号不为整数，while循环不会return，结束时right = left - 1，$right^2 &lt; x$并且$left^2 &gt; x$， right就是所求答案 123456789101112131415 class Solution &#123; public int mySqrt(int x) &#123; int left = 1, right = x; while (left &lt;= right) &#123; int mid = right - (right - left &gt;&gt; 1); if (mid == x / mid) return mid; else if (mid &lt; x / mid) left = mid + 1; else right = mid - 1; &#125; return right; &#125;&#125; 方法二：二分查找另一种写法 12345678910111213141516class Solution &#123; public int mySqrt(int x) &#123; int left = 1, right = x; while (left &lt;= right) &#123; int mid = right - (right - left &gt;&gt; 1); if (mid &lt;= x / mid) &#123; if ((mid + 1) &gt; x / (mid + 1)) return mid; left = mid + 1; &#125; else right = mid - 1; &#125; return 0; &#125;&#125; 剑指 Offer II 073. 狒狒吃香蕉 方法一：二分查找 1234if (hours &lt;= h) &#123; // 吃香蕉速度太快了 res = mid; right = mid - 1;&#125; 只要hours &lt;= h，说明速度太快，降低速度，并且记录这次能满足hours = h的速度 之后总会进入else语句，最终left &gt; right退出循环 最后一次记录的res就是答案 123456789101112131415161718192021222324252627class Solution &#123; public int minEatingSpeed(int[] piles, int h) &#123; int n = 0; for (int pile : piles) n = Math.max(n, pile); int left = 1, right = n,res = -1; while (left &lt;= right) &#123; int mid = (left + right) &gt;&gt; 1; int hours = getHours(mid, piles); if (hours &lt;= h) &#123; // 吃香蕉速度太快了 res = mid; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; return res; &#125; private int getHours(int speed, int[] piles) &#123; int hours = 0; for (int pile : piles) hours += (pile + speed - 1) / speed; return hours; &#125;&#125; 方法二：二分查找另一种写法 与方法一类似，不过不需要用一个变量记录答案 最后一次满足在h小时内吃完香蕉后，right = mid - 1,这个mid就是答案 之后一直循环else，最后left = right + 1退出循环，这个left就是最后一次满足在h小时内吃完香蕉的su’du 12345678910111213141516171819202122232425class Solution &#123; public int minEatingSpeed(int[] piles, int h) &#123; int n = 0; for (int pile : piles) n = Math.max(n, pile); int left = 1, right = n; while (left &lt;= right) &#123; int mid = (left + right) &gt;&gt; 1; int hours = getHours(mid, piles); if (hours &lt;= h) &#123; // 吃香蕉速度太快了 right = mid - 1; &#125; else left = mid + 1; &#125; return left; &#125; private int getHours(int speed, int[] piles) &#123; int hours = 0; for (int pile : piles) hours += (pile + speed - 1) / speed; return hours; &#125;&#125; 278. 第一个错误的版本 和排序数组中只出现一次的数字类似 方法一：二分查找 如果isBadVersion(mid)为true，说明当前版本或者之前的版本出错，那么令right = mid - 1(即使是mid出错了)往前面搜。当遇到第一个出错的版本(我们不知道是不是第一个)，并且执行right = mid - 1，之后的while循环中只会执行else部分， 即left = mid + 1;最终left会等于right + 1并且退出while循环，这个left就是第一个出错的版本 12345678910111213141516/* The isBadVersion API is defined in the parent class VersionControl. boolean isBadVersion(int version); */public class Solution extends VersionControl &#123; public int firstBadVersion(int n) &#123; int left = 1, right = n; while (left &lt;= right) &#123; int mid = right - ((right - left) &gt;&gt; 1); if (isBadVersion(mid)) // 当前版本或者之前的版本出错 right = mid - 1; else left = mid + 1; &#125; return left; &#125;&#125; 162. 寻找峰值 方法一：两端添加负无穷 一定要return 0，解决只有一个数的用例 12345678910111213141516171819 class Solution &#123; public int findPeakElement(int[] arr) &#123; int n = arr.length, left = 1, right = n; int[] nums = new int[n + 2]; for (int i = 0; i &lt; n; ++i) nums[i + 1] = arr[i]; nums[0] = nums[n + 1] = Integer.MIN_VALUE; while (left &lt;= right) &#123; int mid = right - ((right - left) &gt;&gt; 1); if (nums[mid] &gt; nums[mid - 1] &amp;&amp; nums[mid] &gt; nums[mid + 1]) return mid - 1; if (nums[mid] &lt; nums[mid + 1]) left = mid + 1; else right = mid - 1; &#125; return 0; &#125;&#125; 方法二： int mid = left + (right - left) / 2; // mid要选较小的 12345678910111213class Solution &#123; public int findPeakElement(int[] nums) &#123; int n = nums.length, left = 0, right = n - 1; while (left &lt; right) &#123; int mid = left + (right - left) / 2; // mid要选较小的 if (mid + 1 &lt; n &amp;&amp; nums[mid] &gt; nums[mid + 1]) right = mid; else left = mid + 1; &#125; return left; &#125;&#125; 367. 有效的完全平方数 方法一：二分查找 123456789101112131415class Solution &#123; public boolean isPerfectSquare(int num) &#123; int left = 1, right = num; while (left &lt;= right) &#123; int mid = right - ((right - left) &gt;&gt; 1); if (mid == num / mid &amp;&amp; num % mid == 0) return true; if (mid &gt; num / mid) right = mid - 1; else left = mid + 1; &#125; return false; &#125;&#125; 744. 寻找比目标字母大的最小字母 求大于target的最小值 首先判断target是否大于letters中最后一个字符，如果大于，直接返回letters[0] 进入while循环，如果letters[mid] - ‘a’ &lt;= target - ‘a’，令left = mid + 1，最后一次执行这个else循环的letters[mid]就是答案 123456789101112131415class Solution &#123; public char nextGreatestLetter(char[] letters, char target) &#123; int left = 0, right = letters.length - 1; if (target - &#x27;a&#x27; &gt;= letters[right] - &#x27;a&#x27;) return letters[0]; while (left &lt;= right) &#123; int mid = (left + right) &gt;&gt; 1; if (letters[mid] - &#x27;a&#x27; &gt; target - &#x27;a&#x27;) right = mid - 1; else left = mid + 1; &#125; return letters[left]; &#125; &#125; 34. 在排序数组中查找元素的第一个和最后一个位置 方法一：二分查找 二分两次，第一次找大于等于target的最小值，第二次找小于等于target的最大值，从而找到target第一个以及最后一个位置 12345678910111213141516171819202122232425262728293031class Solution &#123; public int[] searchRange(int[] nums, int target) &#123; int[] res = new int[]&#123;-1, -1&#125;; if (nums.length == 0) return res; int resL = -1, resR = -1; int left = 0, right = nums.length - 1; while (left &lt;= right) &#123; int mid = (left + right) &gt;&gt; 1; if (nums[mid] &gt;= target) right = mid - 1; else left = mid + 1; &#125; if (left &gt;= 0 &amp;&amp; left &lt; nums.length) resL = nums[left] == target ? left : -1; left = 0; right = nums.length - 1; while (left &lt;= right) &#123; int mid = (left + right) &gt;&gt; 1; if (nums[mid] &gt; target) right = mid - 1; else left = mid + 1; &#125; if (right &gt;= 0 &amp;&amp; right &lt; nums.length) resR = nums[right] == target ? right : -1; res = new int[]&#123;resL, resR&#125;; return res; &#125;&#125; 410. 分割数组的最大值 优质题解 方法一：二分查找 不能写成getSplitNum(nums, mid) &gt;= k，以下这个例子 输入：nums = [7,2,5,10,8], m = 2 输出：18 解释：一共有四种方法将 nums 分割为 2 个子数组。其中最好的方式是将其分为 [7,2,5] 和 [10,8] 。因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。 如果写成getSplitNum(nums, mid) &gt;= k，当mid=21(答案是18),得到的getSplitNum(nums, mid) = 2 &gt;= k，会继续让mid往更大的方向搜 12345if (getSplitNum(nums, mid) &gt; k) left = mid + 1;else // 分割的数量太少，mid选大了 right = mid - 1; 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public int splitArray(int[] nums, int k) &#123; /* 1.如果把数组分割成n个子数组，那么n个子数组各自和的最大值为数组中的最大值 2.如果把数组分割成1个子数组，那么这个子数组的最大值为数组的和 把以上两种情况返回的最大值当作二分查找的左右边界 每次选择一个中间值mid用于分割数组，被分割的数组和必须小于等于mid，返回分割的子数组个数splitNum 目标是确定一个恰当的「子数组各自的和的最大值」，使得它对应的「子数组的分割数」恰好等于 m 如果splitNum &gt; k，说明mid小了，选更大的值可以让 * */ int left = 0, right = 0; for (int num: nums) &#123; if (left &lt; num) left = num; right += num; &#125; while (left &lt;= right) &#123; int mid = (left + right) &gt;&gt; 1; // 分割的数量太多，mid选小了 if (getSplitNum(nums, mid) &gt; k) left = mid + 1; else // 分割的数量太少，mid选大了 right = mid - 1; &#125; return left; &#125; private int getSplitNum(int[] nums, int maxSum) &#123; // [至少是一个分割] [当前区间的和] int splitNum = 1, curSum = 0; for (int num : nums) &#123; if (curSum + num &gt; maxSum) &#123; ++splitNum; curSum = 0; &#125; curSum += num; &#125; return splitNum; &#125;&#125; 二刷 123456789101112131415161718192021222324252627282930class Solution &#123; public int splitArray(int[] nums, int k) &#123; int l = 0, r = 0; for (int x : nums) &#123; r += x; l = Math.max(l, x); &#125; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; // k个桶，容量上限为mid，是否能容纳所有数组元素 if (check(nums, k, mid)) // 如果能容纳，mid上限选大了或者刚刚好 r = mid - 1; else l = mid + 1; &#125; return l; &#125; private boolean check(int[] nums, int k, int mid) &#123; int bucket = 1, sum = 0; for (int x : nums) &#123; if (sum + x &gt; mid) &#123; ++bucket; sum = 0; &#125; sum += x; &#125; return bucket &lt;= k; &#125;&#125; LCP 12. 小张刷题计划 和分割数组的最大值相比，加了一个条件，每个分割后的数组减去其中的最大值 getSpendDay函数，在每一个新的一天第一次要刷的题先不加入totalTime，先记录maxTime，最后少计入时长的那道题就是需要花费时间最长的题 12345678910111213141516171819202122232425262728293031class Solution &#123; public int minTime(int[] time, int m) &#123; int left = 0, right = 0; for (int t : time) right += t; while (left &lt;= right) &#123; int mid = (left + right) &gt;&gt; 1; if (getSpendDay(time, mid) &lt;= m) // mid大了 right = mid - 1; else left = mid + 1; &#125; return left; &#125; public int getSpendDay(int[] time, int limit) &#123; int totalTime = 0, maxTime = 0, day = 1; for (int t : time) &#123; int nextTime = Math.min(maxTime, t); if (totalTime + nextTime &lt;= limit) &#123; totalTime += nextTime; maxTime = Math.max(maxTime, t); &#125; else &#123; ++day; totalTime = 0; maxTime = t; &#125; &#125; return day; &#125;&#125; 1482. 制作 m 束花所需的最少天数 方法一：二分查找 求能满足条件的最小值 如果用以下代码 12345if (check(bloomDay, k, mid) &lt;= m) // 天数不够凑成m束花 left = mid + 1;else right = mid - 1;return right; 举例 输入：bloomDay = [1,10,3,10,2], m = 3, k = 1 输出：3 解释：让我们一起观察这三天的花开过程，x 表示花开，而 _ 表示花还未开。现在需要制作 3 束花，每束只需要 1 朵。 1 天后：[x, _, _, _, _] // 只能制作 1 束花 2 天后：[x, _, _, _, x] // 只能制作 2 束花 3 天后：[x, _, x, _, x] // 可以制作 3 束花，答案为 3 mid == 5，check(bloomDay, k, mid) == 3(m)，此时还左区间还要向右边滑动当然错了 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; public int minDays(int[] bloomDay, int m, int k) &#123; /** 摘m束花的最小等待天数:能满足条件的最小值 等待bloomDay数组中的最大元素天能摘n束花 等待bloomDay 0天摘0束花 在这两者之间二分 如果选取的天数能凑成小于m束花，则left = mid + 1 如果选取的天数能凑成大于m束花，则right = mid - 1 */ int n = bloomDay.length; if (n / m &lt; k) return -1; int left = 0, right = 0; for (int flower : bloomDay) right = Math.max(right, flower); while (left &lt;= right) &#123; int mid = (left + right) &gt;&gt; 1; if (check(bloomDay, k, mid) &lt; m) // 天数不够凑成m束花 left = mid + 1; else right = mid - 1; &#125; return left; &#125; private int check(int[] bloomDay, int k, int days) &#123; int bouquets = 0, curFlower = 0; for (int flower : bloomDay) &#123; if (flower &lt;= days) &#123; ++curFlower; if (curFlower == k) &#123; ++bouquets; curFlower = 0; &#125; &#125; else &#123; curFlower = 0; &#125; &#125; return bouquets; &#125; &#125; 1011. 在 D 天内送达包裹的能力 和分割数组的最大值一样 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public int shipWithinDays(int[] weights, int days) &#123; // 把weights数组分割为days份，求最大的被分割子数组和的最小值 // 当运载能力为数组中最大的元素时，最多n天运输完所有货物 // 当运载能力为数组的和时，一天能运输完所有货物 // 在这两者之间进行二分 int n = weights.length, left = 0, right = 0; for (int w : weights) &#123; left = Math.max(left, w); right += w; &#125; while (left &lt;= right) &#123; int mid = (left + right) &gt;&gt; 1; if (check(weights, mid) &lt;= days) // 运载能力太强了 right = mid - 1; else left = mid + 1; &#125; return left; &#125; private int check(int[] weights, int capacity) &#123; int total = 0, spendDay = 1; for (int w : weights) &#123; if (total + w &lt;= capacity) total += w; else &#123; ++spendDay; total = w; &#125; &#125; return spendDay; &#125; &#125; 1552. 两球之间的磁力 1234567891011121314151617181920212223242526272829303132class Solution &#123; public int maxDistance(int[] position, int m) &#123; /** 1.最小的最大值：尽量执行left = mid + 1,最后一次执行它后，之后都只会执行right = mid - 1 最后right = left - 1退出循环，此时的right就是最小的最大值 2.二分查找当前磁力(最小求间距)是否可以放得下m个球 3.如果放得下m个球，增大球间距 4.如果放不下m个球，减小球间距 */ Arrays.sort(position); int n = position.length, left = 1, right = position[n - 1] - position[0]; while (left &lt;= right) &#123; int mid = (left + right) &gt;&gt; 1; if (check(position, mid) &gt;= m) left = mid + 1; else right = mid - 1; &#125; return right; &#125; private int check(int[] position, int limit) &#123; int pre = position[0], count = 1; for (int i = 1; i &lt; position.length; ++i) &#123; if (position[i] - pre &gt;= limit) &#123; pre = position[i]; ++count; &#125; &#125; return count; &#125; &#125;","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://leopol1d.github.io/categories/Algorithms/"},{"name":"Binary Search","slug":"Algorithms/Binary-Search","permalink":"https://leopol1d.github.io/categories/Algorithms/Binary-Search/"}],"tags":[{"name":"二分查找","slug":"二分查找","permalink":"https://leopol1d.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"}]},{"title":"Maze Problem","slug":"maze-problem","date":"2023-06-05T07:50:35.000Z","updated":"2023-08-31T07:54:13.717Z","comments":true,"path":"2023/06/05/maze-problem/","link":"","permalink":"https://leopol1d.github.io/2023/06/05/maze-problem/","excerpt":"","text":"130. 被围绕的区域 ​ 方法一：DFS 从边界出发，把边界以及与边界连通的O标记为B` 遍历整个board，把B还原为O，把O(此时的O是被X包围的)改变为X 没有这句死循环，m == 1，( i += 0) if (m &lt;= 2 || n &lt;= 2) return; 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public void solve(char[][] board) &#123; m = board.length; n = board[0].length; if (m &lt;= 2 || n &lt;= 2) return; for (int i = 0; i &lt; m; i += m - 1) for (int j = 0; j &lt; n; ++j) if (board[i][j] == &#x27;O&#x27;) dfs(i, j, board); for (int j = 0; j &lt; n; j += n - 1) for (int i = 0; i &lt; m; ++i) if (board[i][j] == &#x27;O&#x27;) dfs(i, j, board); for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (board[i][j] == &#x27;B&#x27;) board[i][j] = &#x27;O&#x27;; else if (board[i][j] == &#x27;O&#x27;) board[i][j] = &#x27;X&#x27;; &#125; &#125; &#125; int[][] dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; int m, n; private void dfs(int i, int j, char[][] board) &#123; board[i][j] = &#x27;B&#x27;; // backtrack for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col) &amp;&amp; board[row][col] == &#x27;O&#x27;) dfs(row, col, board); &#125; &#125; private boolean isValid(int i, int j) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125; &#125; 方法二：BFS 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution &#123; public void solve(char[][] board) &#123; this.board = board; m = board.length; n = board[0].length; if (m &lt;= 2 || n &lt;= 2) return; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; m; i += m - 1) for (int j = 0; j &lt; n; ++j) if (board[i][j] == &#x27;O&#x27;) queue.offer(new int[]&#123;i, j&#125;); for (int j = 0; j &lt; n; j += n - 1) for (int i = 1; i &lt; m - 1; ++i) if (board[i][j] == &#x27;O&#x27;) queue.offer(new int[]&#123;i, j&#125;); while (!queue.isEmpty()) &#123; int[] node = queue.poll(); board[node[0]][node[1]] = &#x27;#&#x27;; for (int[] dir : dirs) &#123; int row = node[0] + dir[0], col = node[1] + dir[1]; if (isValid(row, col) &amp;&amp; board[row][col] == &#x27;O&#x27;) queue.offer(new int[]&#123;row, col&#125;); &#125; &#125; for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (board[i][j] == &#x27;#&#x27;) board[i][j] = &#x27;O&#x27;; else if (board[i][j] == &#x27;O&#x27;) board[i][j] = &#x27;X&#x27;; &#125; &#125; &#125; private void dfs(int i, int j) &#123; board[i][j] = &#x27;#&#x27;; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col) &amp;&amp; board[row][col] == &#x27;O&#x27;) &#123; dfs(row, col); &#125; &#125; &#125; private boolean isValid(int row, int col) &#123; return row &lt; m &amp;&amp; row &gt;= 0 &amp;&amp; col &lt; n &amp;&amp; col &gt;= 0; &#125; int[][] dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; int m, n; char[][] board;&#125; 方法三：并查集 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package 背包;import java.awt.image.VolatileImage;public class Solution &#123; public void solve(char[][] board) &#123; this.board = board; m = board.length; n = board[0].length; if (m &lt;= 2 || n &lt;= 2) return; init(m * n + 1); int dummy = m * n; for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (board[i][j] == &#x27;O&#x27;) &#123; if (i == 0 || i == m - 1 || j == 0 || j == n - 1) union(n * i + j, dummy); else &#123; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col) &amp;&amp; board[row][col] == &#x27;O&#x27;) union(row * n + col, i * n + j); &#125; &#125; &#125; &#125; &#125; for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (board[i][j] == &#x27;O&#x27; &amp;&amp; findParent(i * n + j) != dummy) board[i][j] = &#x27;X&#x27;; &#125; &#125; &#125; int[] parent; private boolean union(int i, int j) &#123; int rootI = findParent(i), rootJ = findParent(j); if (rootI != rootJ) &#123; parent[rootI] = rootJ; return true; &#125; return false; &#125; private int findParent(int i) &#123; if (i != parent[i]) parent[i] = findParent(parent[i]); return parent[i]; &#125; private void init(int n) &#123; parent = new int[n]; for (int i = 0; i &lt; n; ++i) parent[i] = i; &#125; private boolean isValid(int row, int col) &#123; return row &lt; m &amp;&amp; row &gt;= 0 &amp;&amp; col &lt; n &amp;&amp; col &gt;= 0; &#125; int[][] dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; int m, n; char[][] board; public static void main(String[] args) &#123; Solution solution = new Solution(); char[][] board = new char[][]&#123;&#123;&#x27;O&#x27;,&#x27;O&#x27;,&#x27;O&#x27;&#125;, &#123;&#x27;O&#x27;,&#x27;O&#x27;,&#x27;O&#x27;&#125;, &#123;&#x27;O&#x27;,&#x27;O&#x27;,&#x27;O&#x27;&#125;&#125;; solution.solve(board); System.out.println(board); &#125;&#125; 200. 岛屿数量 方法一：DFS 123456789101112131415161718192021222324252627282930313233class Solution &#123; public int numIslands(char[][] grid) &#123; m = grid.length; n = grid[0].length; for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (grid[i][j] == &#x27;1&#x27;) &#123; dfs(i, j, grid); ++res; &#125; &#125; &#125; return res; &#125; int res = 0, m, n; int[][] dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; private void dfs(int i, int j, char[][] grid) &#123; grid[i][j] = &#x27;2&#x27;; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col) &amp;&amp; grid[row][col] == &#x27;1&#x27;) dfs(row, col, grid); &#125; &#125; private boolean isValid(int i, int j) &#123; return i &gt;= 0 &amp;&amp; j &gt;=0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125; &#125; 方法二：BFS 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; public int numIslands(char[][] grid) &#123; m = grid.length; n = grid[0].length; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (grid[i][j] == &#x27;1&#x27;) &#123; bfs(queue, i, j, grid); ++res; &#125; &#125; &#125; return res; &#125; int res = 0, m, n; int[][] dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; private void bfs(Queue&lt;int[]&gt; queue, int i, int j, char[][] grid) &#123; queue.offer(new int[]&#123;i, j&#125;); while (!queue.isEmpty()) &#123; int[] node = queue.poll(); for (int[] dir : dirs) &#123; int row = node[0] + dir[0], col = node[1] + dir[1]; if (isValid(row, col) &amp;&amp; grid[row][col] == &#x27;1&#x27;) &#123; grid[row][col] = &#x27;2&#x27;; queue.offer(new int[]&#123;row, col&#125;); &#125; &#125; &#125; &#125; private boolean isValid(int i, int j) &#123; return i &gt;= 0 &amp;&amp; j &gt;=0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125; &#125; 329. 矩阵中的最长递增路径 方法一：DFS + 记忆化搜索 如果之前计算过dp[i][j]，直接返回dp[i][j] 计算从matrix[i][j]为起点的最长路径，并用max记录最大值 12if (isValid(row, col) &amp;&amp; matrix[row][col] &gt; matrix[i][j]) &#123; max = Math.max(max, dfs(row, col, matrix)); 返回上一个节点的时候需要加上1，因为当前节点也需要加上，并用dp[i][j]记录 1return dp[i][j] = max + 1; 1234567891011121314151617181920212223242526272829303132class Solution &#123; public int longestIncreasingPath(int[][] matrix) &#123; m = matrix.length; n = matrix[0].length; dp = new int[m][n]; for (int i = 0; i &lt; m; ++i) for (int j = 0; j &lt; n; ++j) res = Math.max(res, dfs(i, j, matrix)); return res; &#125; int res = 1, m, n; int[][] dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;, dp; private int dfs(int i, int j, int[][] matrix) &#123; if (dp[i][j] != 0) return dp[i][j]; int max = 0; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col) &amp;&amp; matrix[row][col] &gt; matrix[i][j]) &#123; max = Math.max(max, dfs(row, col, matrix)); &#125; &#125; return dp[i][j] = max + 1; &#125; private boolean isValid(int i, int j) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125; &#125; 二刷 12345678910111213141516171819202122232425262728293031323334class Solution &#123; public int longestIncreasingPath(int[][] matrix) &#123; m = matrix.length; n = matrix[0].length; this.matrix = matrix; dp = new int[m][n]; for (int i = 0; i &lt; m; ++i) for (int j = 0; j &lt; n; ++j) res = Math.max(res, dfs(i, j)); return res; &#125; int[][] matrix, dp, dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; int m, n, res = 0; private int dfs(int i, int j) &#123; if (dp[i][j] != 0) return dp[i][j]; int max = 1; for (int[] dir : dirs) &#123; int len = 1; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col) &amp;&amp; matrix[i][j] &lt; matrix[row][col]) len = dfs(row, col) + 1; max = Math.max(len, max); &#125; return dp[i][j] = max; &#125; private boolean isValid(int i, int j) &#123; return i &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; n; &#125; &#125; 417. 太平洋大西洋水流问题 三刷DFS 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; pacificAtlantic(int[][] heights) &#123; m = heights.length; n = heights[0].length; this.heights = heights; boolean[][] pacific = new boolean[m][n], atlantic = new boolean[m][n]; for (int j = 0; j &lt; n; ++j) &#123; dfs(0, j, pacific); dfs(m - 1, j, atlantic); &#125; for (int i = 0; i &lt; m; ++i) &#123; dfs(i, 0, pacific); dfs(i, n - 1, atlantic); &#125; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; m; ++i) for (int j = 0; j &lt; n; ++j) if (pacific[i][j] &amp;&amp; atlantic[i][j]) res.add(Arrays.asList(i, j)); return res; &#125; int[][] heights, dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; int m, n; private void dfs(int i, int j, boolean[][] ocean) &#123; ocean[i][j] = true; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col) &amp;&amp; !ocean[row][col] &amp;&amp; heights[row][col] &gt;= heights[i][j]) dfs(row, col, ocean); &#125; &#125; private boolean isValid(int i, int j) &#123; return i &gt;=0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125; &#125; 二刷DFS 把四条边先标记好，然后dfs 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; pacificAtlantic(int[][] heights) &#123; m = heights.length; n = heights[0].length; pacific = new boolean[m][n]; atlantic = new boolean[m][n]; for (int j = 0; j &lt; n; ++j) pacific[0][j] = true; for (int i = 0; i &lt; m; ++i) pacific[i][0] = true; for (int j = 0; j &lt; n; ++j) atlantic[m - 1][j] = true; for (int i = 0; i &lt; m; ++i) atlantic[i][n - 1] = true; for (int i = 0; i &lt; m; ++i) for (int j = 0; j &lt; n; ++j) if (pacific[i][j] || atlantic[i][j]) dfs(i, j, heights); for (int i = 0; i &lt; m; ++i) for (int j = 0; j &lt; n; ++j) if (pacific[i][j] &amp;&amp; atlantic[i][j]) res.add(Arrays.asList(i, j)); return res; &#125; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); boolean[][] pacific, atlantic; int m, n; int[][] dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; private void dfs(int i, int j, int[][]heights) &#123; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col) &amp;&amp; heights[row][col] &gt;= heights[i][j]) &#123; if (pacific[i][j] &amp;&amp; !pacific[row][col]) &#123; pacific[row][col] = true; dfs(row, col, heights); &#125; if (atlantic[i][j] &amp;&amp; !atlantic[row][col]) &#123; atlantic[row][col] = true; dfs(row, col, heights); &#125; &#125; &#125; &#125; private boolean isValid(int i, int j) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125; &#125; 463. 岛屿的周长 方法一：DFS 初始每个陆地的边长都为4，如果周围有一个相连的陆地，那么周长-1，如上图grid[1][1]，上下左右都有陆地，所以它拥有的边长为4 - 4 = 0 只要陆地i, j的邻居row, col不是水域，那么先将周长减一 如果grid[row][col] == 2，说明之前访问过，不需要继续dfs，但是需要讲周长减一 如果grid[row][col] == 1，周长需要减一并且需要dfs访问 1234if (isValid(row, col) &amp;&amp; grid[row][col] != 0) &#123; --length; if (grid[row][col] == 1) dfs(row, col, grid); 代码 123456789101112131415161718192021222324252627282930313233class Solution &#123; public int islandPerimeter(int[][] grid) &#123; m = grid.length; n = grid[0].length; for (int i = 0; i &lt; m; ++i) for (int j = 0; j &lt; n; ++j) if (grid[i][j] == 1) dfs(i, j, grid); return res; &#125; int res = 0, m, n; int[][] dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; private void dfs(int i, int j, int[][] grid) &#123; grid[i][j] = 2; int length = 4; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col) &amp;&amp; grid[row][col] != 0) &#123; --length; if (grid[row][col] == 1) dfs(row, col, grid); &#125; &#125; res += length; &#125; private boolean isValid(int i, int j) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125; &#125; 方法二：BFS 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public int islandPerimeter(int[][] grid) &#123; m = grid.length; n = grid[0].length; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; m; ++i) for (int j = 0; j &lt; n; ++j) if (grid[i][j] == 1) &#123; queue.offer(new int[]&#123;i, j&#125;); grid[i][j] = 2; bfs(i, j, grid, queue); return res; &#125; return -1; &#125; int res = 0, m, n; int[][] dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; private void bfs(int i, int j, int[][] grid, Queue&lt;int[]&gt; queue) &#123; while (!queue.isEmpty()) &#123; int[] node = queue.poll(); int length = 4; for (int[] dir : dirs) &#123; int row = node[0] + dir[0], col = node[1] + dir[1]; if (isValid(row, col) &amp;&amp; grid[row][col] != 0) &#123; --length; if (grid[row][col] == 1) &#123; grid[row][col] = 2; queue.offer(new int[]&#123;row, col&#125;); &#125; &#125; &#125; res += length; &#125; &#125; private boolean isValid(int i, int j) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125;&#125; 695. 岛屿的最大面积 方法一：DFS 1234567891011121314151617181920212223242526272829class Solution &#123; public int maxAreaOfIsland(int[][] grid) &#123; m = grid.length; n = grid[0].length; for (int i = 0; i &lt; m; ++i) for (int j = 0; j &lt; n; ++j) if (grid[i][j] == 1) res = Math.max(res, dfs(i, j, grid)); return res; &#125; int m, n, res = 0; int[][] dirs = new int[][]&#123;&#123;0, -1&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;, &#123;1, 0&#125;&#125;; private int dfs(int i, int j, int[][] grid) &#123; int length = 1; grid[i][j] = 2; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col) &amp;&amp; grid[row][col] == 1) length += dfs(row, col, grid); &#125; return length; &#125; private boolean isValid(int i, int j) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125;&#125; 方法二：并查集 注意 只有当grid[i][j] == 1时才判断 如果row,col不超过边界，且grid[row][col]是陆地(1或者2)，且没有被访问过(如果访问过， 那么grid[i][j]与grid[row][col]的parent一致)，则将grid[i][j]赋值2(1表示没有被访问的陆地，2表示被访问过的陆地) 如果row,col不超过边界，且grid[row][col]是陆地(1或者2)，但是被访问过(此时也会绑定grid[i][j]与grid[row][col]的parent)，不执行 12345678 if (grid[i][j] == 1) &#123; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; // 1.不超过边界 2.是陆地 3.没有被访问过 if (isValid(row, col) &amp;&amp; grid[row][col] != 0 &amp;&amp; union(i * n + j, row * n + col)) grid[i][j] = 2; &#125;&#125; 遍历所有陆地，将每块陆地的祖先存入map，值为子孙的数量，那么含有最大子孙的数量就是岛屿最大数量 map进行put操作时，key为findParent(i * n + j)，因为在之前进行union的过程(parent[parentOfI] = parentOfJ)，直接将i的祖先的祖先赋值为j的祖先，但是此时i的祖先还没有同步，所以这里是进行一个祖先同步的操作 1234567Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();for (int i = 0; i &lt; m; ++i) for (int j = 0; j &lt; n; ++j) if (grid[i][j] != 0) &#123; map.put(findParent(i * n + j), map.getOrDefault(parent[i * n + j], 0) + 1); res = Math.max(res, map.get(parent[i * n + j])); &#125; 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution &#123; public int maxAreaOfIsland(int[][] grid) &#123; m = grid.length; n = grid[0].length; init(m, n); for (int i = 0; i &lt; m; ++i) for (int j = 0; j &lt; n; ++j) if (grid[i][j] == 1) &#123; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; // 1.不超过边界 2.是陆地 3.没有被访问过 if (isValid(row, col) &amp;&amp; grid[row][col] != 0 &amp;&amp; union(i * n + j, row * n + col)) grid[i][j] = 2; &#125; &#125; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; m; ++i) for (int j = 0; j &lt; n; ++j) if (grid[i][j] != 0) &#123; map.put(findParent(i * n + j), map.getOrDefault(parent[i * n + j], 0) + 1); res = Math.max(res, map.get(parent[i * n + j])); &#125; return res; &#125; int m, n, res = 0; int[][] dirs = new int[][]&#123;&#123;0, -1&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;, &#123;1, 0&#125;&#125;; int[] parent; private void init(int m, int n) &#123; parent = new int[m * n]; for (int i = 0; i &lt; m * n; ++i) parent[i] = i; &#125; private int findParent(int i) &#123; return i == parent[i] ? parent[i] : (parent[i] = findParent(parent[i])); &#125; private boolean union(int i, int j) &#123; int parentOfI = findParent(i), parentOfJ = findParent(j); if (parentOfI != parentOfJ) &#123; parent[parentOfI] = parentOfJ; return true; &#125; return false; &#125; private boolean isValid(int i, int j) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125;&#125; 二刷并查集 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution &#123; public int maxAreaOfIsland(int[][] grid) &#123; this.grid = grid; m = grid.length; n = grid[0].length; init(m * n); for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (grid[i][j] == 1) &#123; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col) &amp;&amp; grid[row][col] == 1) union(i * n + j, row * n + col); &#125; &#125; &#125; &#125; int res = 0; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; m; ++i) for (int j = 0; j &lt; n; ++j) if (grid[i][j] != 0) &#123; map.put(findParent(i * n + j), map.getOrDefault(parent[i * n + j], 0) + 1); res = Math.max(res, map.get(parent[i * n + j])); &#125; return res; &#125; private boolean isValid(int i, int j) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125; int m, n; int[][] grid, dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; int[] parent; private boolean union(int i, int j) &#123; int rootI = findParent(i), rootJ = findParent(j); if (rootI != rootJ) &#123; parent[rootI] = rootJ; return true; &#125; return false; &#125; private int findParent(int i) &#123; if (i != parent[i]) parent[i] = findParent(parent[i]); return parent[i]; &#125; private void init(int n) &#123; parent = new int[n]; for (int i = 0; i &lt; n; ++i) parent[i] = i; &#125;&#125; 733. 图像渲染 方法一：BFS 二刷 1234567891011121314151617181920212223242526272829303132class Solution &#123; public int[][] floodFill(int[][] image, int sr, int sc, int color) &#123; m = image.length; n = image[0].length; int targetColor = image[sr][sc]; image[sr][sc] = color; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); queue.offer(new int[]&#123;sr, sc&#125;); boolean[][] visited = new boolean[m][n]; visited[sr][sc] = true; while (!queue.isEmpty()) &#123; int[] node = queue.poll(); for (int[] dir : dirs) &#123; int row = node[0] + dir[0], col = node[1] + dir[1]; if (isValid(row,col) &amp;&amp; !visited[row][col] &amp;&amp; image[row][col] == targetColor) &#123; visited[row][col] = true; queue.offer(new int[]&#123;row, col&#125;); image[row][col] = color; &#125; &#125; &#125; return image; &#125; int[][] dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; int m, n; private boolean isValid(int i, int j) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125; &#125; 一刷 小心死循环，curColor很关键 12345678910111213141516171819202122232425262728293031class Solution &#123; public int[][] floodFill(int[][] image, int sr, int sc, int color) &#123; int curColor = image[sr][sc]; if (color == curColor) return image; m = image.length; n = image[0].length; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); queue.offer(new int[]&#123;sr, sc&#125;); image[sr][sc] = color; while (!queue.isEmpty()) &#123; int[] node = queue.poll(); for (int[] dir : dirs) &#123; int row = node[0] + dir[0], col = node[1] + dir[1]; if (isValid(row, col) &amp;&amp; image[row][col] == curColor) &#123; queue.offer(new int[]&#123;row, col&#125;); image[row][col] = color; &#125; &#125; &#125; return image; &#125; int m, n; int[][] dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; private boolean isValid(int i, int j) &#123; return i &gt;=0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125; &#125; 方法二：DFS 1234567891011121314151617181920212223242526272829class Solution &#123; public int[][] floodFill(int[][] image, int sr, int sc, int color) &#123; int curColor = image[sr][sc]; if (color == curColor) return image; m = image.length; n = image[0].length; image[sr][sc] = color; dfs(sr, sc, color, curColor, image); return image; &#125; int m, n; int[][] dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; private void dfs(int i, int j, int color, int curColor, int[][] image) &#123; image[i][j] = color; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col) &amp;&amp; image[row][col] == curColor) dfs(row, col, color, curColor, image); &#125; &#125; private boolean isValid(int i, int j) &#123; return i &gt;=0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125; &#125; 1020. 飞地的数量 方法一：DFS 同太平洋大西洋水流问题，从边缘进入dfs 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public int numEnclaves(int[][] grid) &#123; m = grid.length; n = grid[0].length; if (m &lt;= 2 || n &lt;= 2) return 0; for (int i = 0; i &lt; m; i += m - 1) for (int j = 0; j &lt; n; ++j) if (grid[i][j] == 1) dfs(i, j, grid); for (int j = 0; j &lt; n; j += n - 1) for (int i = 1; i &lt; m - 1; ++i) if (grid[i][j] == 1) dfs(i, j, grid); for (int i = 1; i &lt; m; ++i) for (int j = 1; j &lt; n; ++j) if (grid[i][j] == 1) ++res; return res; &#125; int res = 0, m, n; int[][] dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; private void dfs(int i, int j, int[][] grid) &#123; grid[i][j] = 0; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col) &amp;&amp; grid[row][col] == 1) dfs(row, col, grid); &#125; &#125; private boolean isValid(int i, int j) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125;&#125; 方法二：BFS 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123; public int numEnclaves(int[][] grid) &#123; m = grid.length; n = grid[0].length; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); for (int j = 0; j &lt; n; ++j) if (grid[0][j] == 1) queue.offer(new int[]&#123;0, j&#125;); for (int i = 1; i &lt; m; ++i) if (grid[i][0] == 1) queue.offer(new int[]&#123;i, 0&#125;); for (int i = 1; i &lt; m; ++i) if (grid[i][n - 1] == 1) queue.offer(new int[]&#123;i, n - 1&#125;); for (int j = 1; j &lt; n - 1; ++j) if (grid[m - 1][j] == 1) queue.offer(new int[]&#123;m - 1, j&#125;); while(!queue.isEmpty()) &#123; int[] node = queue.poll(); for (int[] dir : dirs) &#123; int row = node[0] + dir[0], col = node[1] + dir[1]; if (isValid(row, col) &amp;&amp; grid[row][col] == 1) &#123; grid[row][col] = 0; queue.offer(new int[]&#123;row, col&#125;); &#125; &#125; &#125; int res = 0; for (int i = 1; i &lt; m - 1; ++i) &#123; for (int j = 1; j &lt; n - 1; ++j) &#123; if (grid[i][j] == 1) ++res; &#125; &#125; return res; &#125; int[][] dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; int m, n; private boolean isValid(int i, int j) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125; &#125; 1559. 二维网格图中探测环 方法三：并查集 题解 遍历矩阵，只检查左边和上面，可以保证每一条边的两个节点只会被合并一次 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123; public boolean containsCycle(char[][] grid) &#123; m = grid.length; n = grid[0].length; init(m * n); for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row,col) &amp;&amp; grid[i][j] == grid[row][col]) &#123; if (!union(i * n + j, row * n + col)) return true; &#125; &#125; &#125; &#125; return false; &#125; int[] parent; private boolean union(int i, int j) &#123; int rootI = findParent(i), rootJ = findParent(j); if (rootI != rootJ) &#123; parent[rootI] = rootJ; return true; &#125; return false; &#125; private int findParent(int i) &#123; if (i != parent[i]) parent[i] = findParent(parent[i]); return parent[i]; &#125; private void init(int n) &#123; parent = new int[n]; for (int i = 0; i &lt; n; ++i) parent[i] = i; &#125; int[][] dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;0, -1&#125;&#125;; int m, n; private boolean isValid(int i, int j) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125;&#125; 方法一：BFS 每次从队列中取出一个节点时，记录当前队列大小size，初始化neigbors = 0 在上下左右四个方向遍历，如果相邻节点没有越界且与当前字符相同，++neighbors，如果没访问过，加入队列，visited赋值true **遍历完四个方向后，如果neigbors - 1== queue.size() - size，(-1是减去上一次访问过，并将当前节点入队的节点)，说明新入队的邻居之前都没有访问过 ** 如果neigbors - 1 &gt; queue.size() - size，说明遍历到了已经访问过的jie’dian，那么可以形成环 举例 从下标(0, 0)开始BFS遍历，有两条路径，一条向右出发(记为路径A)，一条向下出发(记为路径B)，这里默认先遍历右边再遍历下面 当遍历了5步后，如下图 (路径A)此时下标为(2, 3)的节点往下遍历，将右下角编号为(3, 3)的节点赋值true，如下图 (路径B)现在下标为(3, 2)的节点往右遍历，邻居neighbors = 2，但是queue.size() - size = 0(队列没有新入队节点)，说明路径A已经遍历过这个节点了 ，那么路径B可以按照路径A返回起点，所以可以形成环 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123; public boolean containsCycle(char[][] grid) &#123; m = grid.length; n = grid[0].length; visited = new boolean[m][n]; for (int i = 0; i &lt; m; ++i) for (int j = 0; j &lt; n; ++j) if (!visited[i][j] &amp;&amp; bfs(i, j, grid)) return true; return false; &#125; private boolean bfs(int i, int j, char[][] grid) &#123; queue.offer(new int[]&#123;i, j&#125;); visited[i][j] = true; while (!queue.isEmpty()) &#123; int[] node = queue.poll(); int neibors = 0, size = queue.size(); for (int[] dir : dirs) &#123; int row = node[0] + dir[0], col = node[1] + dir[1]; if (isValid(row, col) &amp;&amp; grid[row][col] == grid[node[0]][node[1]]) &#123; ++neibors; if (!visited[row][col]) &#123; queue.offer(new int[]&#123;row, col&#125;); visited[row][col] = true; &#125; &#125; &#125; if (neibors - 1 &gt; queue.size() - size) return true; &#125; return false; &#125; int m, n; boolean[][] visited; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); int[][] dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; private boolean isValid(int i, int j) &#123; return i &gt;=0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125;&#125; 方法二：DFS 通过preI,preJ记录上一个已访问节点 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public boolean containsCycle(char[][] grid) &#123; m = grid.length; n = grid[0].length; visited = new boolean[m][n]; for (int i = 0; i &lt; m; ++i) for (int j = 0; j &lt; n; ++j) if (!visited[i][j] &amp;&amp; dfs(i, j, grid, -1, -1)) return true; return false; &#125; private boolean dfs(int i, int j, char[][] grid, int preI, int preJ) &#123; if (visited[i][j]) return true; visited[i][j] = true; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col) &amp;&amp; grid[row][col] == grid[i][j]) &#123; if (row == preI &amp;&amp; col == preJ) continue; if (dfs(row, col, grid, i, j)) return true; &#125; &#125; return false; &#125; int m, n; boolean[][] visited; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); int[][] dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; private boolean isValid(int i, int j) &#123; return i &gt;=0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125;&#125; 785. 判断二分图 方法一：BFS colors[next] == 1 - color说明访问过，而且颜色与当前颜色不同，不用加入队列 1234567891011121314151617181920212223242526class Solution &#123; public boolean isBipartite(int[][] graph) &#123; int n = graph.length; int[] colors = new int[n]; Arrays.fill(colors, -1); Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; n; ++i) &#123; if (colors[i] == -1) &#123; colors[i] = 0; queue.offer(i); while (!queue.isEmpty()) &#123; int node = queue.poll(), color = colors[node]; for (int next : graph[node]) &#123; if (colors[next] == -1) &#123; colors[next] = 1 - color; queue.offer(next); &#125; else if (colors[next] == color) return false; &#125; &#125; &#125; &#125; return true; &#125;&#125; 方法二：DFS 123456789101112131415161718192021222324252627282930class Solution &#123; public boolean isBipartite(int[][] graph) &#123; int n = graph.length; int[] colors = new int[n]; Arrays.fill(colors, -1); for (int i = 0; i &lt; n; ++i) &#123; if (colors[i] == -1) &#123; if (!dfs(graph, colors, i, 0)) return false; &#125; &#125; return true; &#125; private boolean dfs(int[][] graph, int[] colors, int i, int color) &#123; colors[i] = color; for (int next : graph[i]) &#123; if (colors[next] == -1) &#123; if (!dfs(graph, colors, next, 1 - color)) return false; &#125; else &#123; if (colors[next] == color) return false; &#125; &#125; return true; &#125; &#125; 方法三：并查集 每个顶点i的邻居应该是在同一个集合里，如果i与邻居在一个集合，则不是二分图 遍历每一个顶点i，判断i与邻居是否在一个集合中，如果是则不是二分图返回false；如果顶点i不与邻居在同一个集合，那么将邻居合并到同一个集合 123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public boolean isBipartite(int[][] graph) &#123; int n = graph.length; init(n); for (int i = 0; i &lt; n; ++i) &#123; for (int next : graph[i]) &#123; if (findParent(i) == findParent(next)) return false; union(graph[i][0], next); &#125; &#125; return true; &#125; int[] parent; private boolean union(int i, int j) &#123; int rootI = findParent(i), rootJ = findParent(j); if (rootI != rootJ) &#123; parent[rootI] = rootJ; return true; &#125; return false; &#125; private int findParent(int i) &#123; if (i != parent[i]) parent[i] = findParent(parent[i]); return parent[i]; &#125; private void init(int n) &#123; parent = new int[n]; for (int i = 0; i &lt; n; ++i) parent[i] = i; &#125;&#125; 剑指 Offer II 110. 所有路径 方法一：回溯 123456789101112131415161718192021222324252627class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; allPathsSourceTarget(int[][] graph) &#123; n = graph.length; this.graph = graph; path.offer(0); dfs(0); return res; &#125; private void dfs(int index) &#123; if (index == n - 1) &#123; res.add(new LinkedList&lt;&gt;(path)); return; &#125; for (int next : graph[index]) &#123; path.offerLast(next); dfs(next); path.pollLast(); &#125; &#125; int n; int[][] graph; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;();&#125; 剑指 Offer II 111. 计算除法 方法一：DFS 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123; public double[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, double[] values, List&lt;List&lt;String&gt;&gt; queries) &#123; Map&lt;String, Map&lt;String, Double&gt;&gt; graph = new HashMap&lt;&gt;(); for (int i = 0; i &lt; equations.size(); ++i) &#123; String num1 = equations.get(i).get(0), num2 = equations.get(i).get(1); graph.putIfAbsent(num1, new HashMap&lt;&gt;()); graph.putIfAbsent(num2, new HashMap&lt;&gt;()); graph.get(num1).put(num2, values[i]); graph.get(num2).put(num1, 1 / values[i]); &#125; double[] res = new double[queries.size()]; for (int i = 0; i &lt; queries.size(); ++i) &#123; String num1 = queries.get(i).get(0), num2 = queries.get(i).get(1); if (!graph.containsKey(num1) || !graph.containsKey(num2)) res[i] = -1.0; else if (num1.equals(num2)) // 字符在图中且两个字符相等 res[i] = 1.0; else if (graph.get(num1).containsKey(num2)) res[i] = graph.get(num1).get(num2); else &#123; visited.clear(); res[i] = dfs(num1, num2, graph); &#125; &#125; return res; &#125; Set&lt;String&gt; visited = new HashSet&lt;&gt;(); private double dfs(String num1, String num2, Map&lt;String, Map&lt;String, Double&gt;&gt; graph) &#123; if (num1.equals(num2)) return 1.0; visited.add(num1); Map&lt;String, Double&gt; nexts = graph.get(num1); for (String next : nexts.keySet()) &#123; if (visited.contains(next)) continue; double val = dfs(next, num2, graph); if (val &gt; 0) return val * nexts.get(next); &#125; visited.remove(num1); return -1.0; &#125;&#125; 二进制矩阵中翻转最多一次使路径不连通 方法一：两次DFS 12345678910111213141516171819202122232425262728class Solution &#123; public boolean isPossibleToCutPath(int[][] grid) &#123; m = grid.length; n = grid[0].length; this.grid = grid; return !dfs(0, 0) || !dfs(0, 0); &#125; private boolean dfs(int i, int j) &#123; if (i == m - 1 &amp;&amp; j == n - 1) return true; grid[i][j] = 0; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col) &amp;&amp; grid[row][col] == 1 &amp;&amp; dfs(row, col)) return true; &#125; return false; &#125; int m, n; int[][] dirs = new int[][]&#123;&#123;1, 0&#125;, &#123;0, 1&#125;&#125;, grid; private boolean isValid(int i, int j) &#123; return i &lt; m &amp;&amp; j &lt; n; &#125;&#125;","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://leopol1d.github.io/categories/Algorithms/"},{"name":"Graph","slug":"Algorithms/Graph","permalink":"https://leopol1d.github.io/categories/Algorithms/Graph/"}],"tags":[{"name":"图","slug":"图","permalink":"https://leopol1d.github.io/tags/%E5%9B%BE/"},{"name":"迷宫问题","slug":"迷宫问题","permalink":"https://leopol1d.github.io/tags/%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98/"}]},{"title":"Monotonic Stack","slug":"monotonic-stack","date":"2023-06-02T01:41:22.000Z","updated":"2023-10-07T07:47:10.061Z","comments":true,"path":"2023/06/02/monotonic-stack/","link":"","permalink":"https://leopol1d.github.io/2023/06/02/monotonic-stack/","excerpt":"","text":"求某个区间的最大(小)值，可以使用单调队列单调栈的作用：存放之前遍历过的元素i，当比nums[i]更大(小)的元素出现时，计算结果，并将i弹出 239. 滑动窗口最大值 维护一个单调递减的双端队列，队列大小为[0, k]，队列存储数组下标，从而更好判断滑动窗口区间 存储答案的队列res大小为n - k + 1 遍历数组nums 当队列不为空且当前元素大于队尾元素在nums中对应的值时，将队尾元素弹出，从而保持队列的单调递减性 12while (!queue.isEmpty() &amp;&amp; nums[i] &gt; nums[queue.peekLast()]) queue.pollLast(); 完成步骤4后，将当前元素nums[i]加入队列 当队首元素等于i - k，说明已经遍历过k轮，滑动窗口的左边界已经超过队首元素了，弹出队首元素 12if (queue.peekFirst() == i - k) queue.pollFirst(); 只有当i &gt;= k - 1时，才记录结果res 1234567891011121314151617class Solution &#123; public int[] maxSlidingWindow(int[] nums, int k) &#123; int n = nums.length; int[] res = new int[n - k + 1]; Deque&lt;Integer&gt; queue = new LinkedList(); for (int i = 0; i &lt; n; ++i) &#123; while (!queue.isEmpty() &amp;&amp; nums[i] &gt; nums[queue.peekLast()]) queue.pollLast(); queue.offerLast(i); if (queue.peekFirst() == i - k) queue.pollFirst(); if (i &gt;= k - 1) res[i - k + 1] = nums[queue.peekFirst()]; &#125; return res; &#125;&#125; 单调栈是一种基于栈的数据结构，所谓的单调就是满足单调递增（单调递减）的栈。主要用于解决 下一个更大的元素问题，也就是找到下一个更大的元素。单调栈的意义：用 O(n) 复杂度的一重遍历找到每个元素前后最近的更小/大元素位置 739. 每日温度 方法一：单调栈 创建一个栈，存储元素下标 遍历数组元素 当栈不为空且数组元素值 &gt; 栈顶元素对应数组的值 弹出栈顶元素并用变量i - topIndex;接收 topIndex的下一个更大值的距离为i - topIndex; 将i压栈 遍历完for循环，如果栈不为空，说明栈里的元素不存在比它更大的元素 123456789101112131415class Solution &#123; public int[] dailyTemperatures(int[] temperatures) &#123; int n = temperatures.length; int[] res = new int[n]; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for (int i = 0; i &lt; n; ++i) &#123; while (!stack.isEmpty() &amp;&amp; temperatures[i] &gt; temperatures[stack.peek()]) &#123; int topIndex = stack.pop(); res[topIndex] = i - topIndex; &#125; stack.push(i); &#125; return res; &#125;&#125; 496. 下一个更大元素 I 方法一：单调栈 + HashMap res[i] = map.getOrDefault(nums1[i], -1);假设nums1[i]在nums2中的下标为j，如果map查不到nums1[i]，说明nums2[j]在j之后没有比nums2[j]更大的元素 123456789101112131415161718class Solution &#123; public int[] nextGreaterElement(int[] nums1, int[] nums2) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums2.length; ++i) &#123; while (!stack.isEmpty() &amp;&amp; nums2[i] &gt; nums2[stack.peek()]) &#123; int topIndex = stack.pop(); map.put(nums2[topIndex], nums2[i]); &#125; stack.push(i); &#125; int[] res = new int[nums1.length]; for (int i = 0; i &lt; nums1.length; ++i) &#123; res[i] = map.getOrDefault(nums1[i], -1); &#125; return res; &#125;&#125; 503. 下一个更大元素 II 方法一：单调栈 初始res数组为-1很重要！默认所有元素都没有更大的下一个元素 1Arrays.fill(res, -1); 循环数组遍历两次，即使第一轮遍历已经被赋值，第二轮也只会赋相同的值，不影响 12345678910111213141516class Solution &#123; public int[] nextGreaterElements(int[] nums) &#123; int n = nums.length; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); int[] res = new int[n]; Arrays.fill(res, -1); for (int i = 0; i &lt; 2 * n; ++i) &#123; while (!stack.isEmpty() &amp;&amp; nums[i % n] &gt; nums[stack.peek()]) &#123; int topIndex = stack.pop(); res[topIndex] = nums[i % n]; &#125; stack.push(i % n); &#125; return res; &#125;&#125; 316. 去除重复字母 方法一：单调栈 遇到一个新字符 如果比栈顶小 并且在新字符后面还有和栈顶一样的 就把栈顶的字符抛弃了 12345678910111213141516171819202122232425class Solution &#123; public String removeDuplicateLetters(String s) &#123; int[] count = new int[26]; for (int i = 0; i &lt; s.length(); ++i) ++count[s.charAt(i) - &#x27;a&#x27;]; boolean[] visited = new boolean[26]; Deque&lt;Integer&gt; stack = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; s.length(); ++i) &#123; char ch = s.charAt(i); --count[ch - &#x27;a&#x27;]; if (visited[ch - &#x27;a&#x27;]) continue; while(!stack.isEmpty() &amp;&amp; s.charAt(stack.peek()) &gt; ch &amp;&amp; count[s.charAt(stack.peek()) - &#x27;a&#x27;] &gt; 0) &#123; visited[s.charAt(stack.peek()) - &#x27;a&#x27;] = false; stack.pop(); &#125; visited[ch - &#x27;a&#x27;] = true; stack.push(i); &#125; StringBuilder sb = new StringBuilder(); while (!stack.isEmpty()) sb.append(s.charAt(stack.pollLast())); return sb.toString(); &#125;&#125; 84. 柱状图中最大的矩形 方法一：单调栈 思路 对于一个高度，如果能得到向左和向右的边界 那么就能对每个高度求一次面积 遍历所有高度，即可得出最大面积 使用单调栈，在出栈操作时得到前后边界并计算面积 注意边界问题 12Arrays.fill(rights, n);Arrays.fill(left, -1); 123456789101112131415161718192021222324252627282930class Solution &#123; public int largestRectangleArea(int[] heights) &#123; int n = heights.length; int[] rights = new int[n]; Arrays.fill(rights, n); Deque&lt;Integer&gt; stack = new LinkedList(); for (int i = 0 ; i &lt; n ; i++)&#123; while (!stack.isEmpty() &amp;&amp; heights[stack.getLast()] &gt; heights[i]) &#123; int top = stack.pollLast(); rights[top] = i; &#125; stack.addLast(i); &#125; int[] left = new int[n]; Arrays.fill(left, -1); stack.clear(); for (int i = n - 1 ; i &gt;= 0 ; i--) &#123; while (!stack.isEmpty() &amp;&amp; heights[stack.getLast()] &gt; heights[i]) &#123; int top = stack.pollLast(); left[top] = i; &#125; stack.addLast(i); &#125; int res = 0; for (int i = 0 ; i &lt; n ; i++) &#123; res = Math.max(res, (rights[i] - left[i] - 1) * heights[i]); &#125; return res; &#125;&#125; 42. 接雨水 方法一：单调栈 优质题解 12345678910111213141516171819class Solution &#123; public int trap(int[] height) &#123; int n = height.length, index = 0, res = 0; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); while (index &lt; n) &#123; while (!stack.isEmpty() &amp;&amp; height[index] &gt; height[stack.peek()]) &#123; int topIndex = stack.pop(); int h = height[topIndex]; if (stack.isEmpty()) break; int min = Math.min(height[index], height[stack.peek()]); int width = index - stack.peek() - 1; res += (min - h) * width; &#125; stack.push(index++); &#125; return res; &#125;&#125; 394. 字符串解码 (普通栈模拟) 方法一：双栈模拟 创建两个栈：1.ns(num stack)存放数字，2.is(index stack)存放StringBuilder的下标，下面会详细解释两个栈的用法。 遍历字符串s的每个字符ch，有四种情况： 数字：压入数字栈ns中 字符：放入StringBuilder中 左括号[：将StringBuilder的长度压入下标栈is中 右括号]：将数字，也就是重复次数从数字栈ns中取出来，记作t。从下标栈is中取出要复制子串的初始位置index， 将子串sb.substring(index, sb.toString())复制t - 1次(stringbuilder中已经有一份数据了，所以是t-1) 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public String decodeString(String s) &#123; int n = s.length(); Stack&lt;Integer&gt; ns = new Stack&lt;&gt;(), is = new Stack&lt;&gt;(); // numStack, indexStack StringBuilder sb = new StringBuilder(); boolean preIsNum = false; for (int i = 0; i &lt; n; ++i) &#123; char ch = s.charAt(i); if (ch - &#x27;0&#x27; &gt;= 0 &amp;&amp; ch - &#x27;0&#x27; &lt;= 9) &#123; if (preIsNum) &#123; int pre = ns.pop(); ns.push(pre * 10 + ch - &#x27;0&#x27;); &#125; else ns.push(ch - &#x27;0&#x27;); preIsNum = true; &#125; else &#123; preIsNum = false; if (ch == &#x27;[&#x27;) is.add(sb.length()); else if (ch == &#x27;]&#x27;) &#123; int index = is.pop(), t = ns.pop(); String temp = sb.substring(index, sb.length()); for (int j = 0; j &lt; t - 1; ++j) &#123; sb.append(temp); &#125; &#125; else sb.append(ch); &#125; &#125; return sb.toString(); &#125;&#125; 901. 股票价格跨度 方法一：单调栈 123456789101112131415161718192021222324252627class StockSpanner &#123; Stack&lt;Integer&gt; stack; List&lt;Integer&gt; nums, count; public StockSpanner() &#123; stack = new Stack(); nums = new ArrayList(); count = new ArrayList(); &#125; public int next(int price) &#123; int cnt = 1; while (!stack.isEmpty() &amp;&amp; price &gt;= nums.get(stack.peek())) cnt += count.get(stack.pop()); nums.add(price); count.add(cnt); stack.push(nums.size() - 1); return cnt; &#125;&#125;/** * Your StockSpanner object will be instantiated and called as such: * StockSpanner obj = new StockSpanner(); * int param_1 = obj.next(price); */","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://leopol1d.github.io/categories/Algorithms/"},{"name":"Queue && Stack","slug":"Algorithms/Queue-Stack","permalink":"https://leopol1d.github.io/categories/Algorithms/Queue-Stack/"}],"tags":[{"name":"单调栈","slug":"单调栈","permalink":"https://leopol1d.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"name":"单调队列","slug":"单调队列","permalink":"https://leopol1d.github.io/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"}]},{"title":"Shortest Path Problem","slug":"shortest-path-problem","date":"2023-05-31T01:21:07.000Z","updated":"2023-09-16T07:30:31.175Z","comments":true,"path":"2023/05/31/shortest-path-problem/","link":"","permalink":"https://leopol1d.github.io/2023/05/31/shortest-path-problem/","excerpt":"","text":"迪杰斯特拉 解析 开一个dis数组，记录从给定点x到其他点的最短距离，初始化为max，；开一个visited数组，记录顶点是否被访问过 将x的dis初始为0 开始遍历，首先找到未被访问且距离x最短的顶点y，将y的visited赋值true 更新的dis中顶点z的距离：未被访问且 z与x的距离大于 x到y + y到z的距离 743. 网络延迟时间 方法一：迪杰斯特拉 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123;final int inf = Integer.MAX_VALUE / 2; public int networkDelayTime(int[][] times, int n, int k) &#123; int[][] graph = new int[n + 1][n + 1]; for (int[] g : graph) Arrays.fill(g, inf); for (int[] time : times) &#123; int from = time[0], to = time[1], weight = time[2]; graph[from][to] = weight; &#125; int[] dist = dijkstra(graph, n, k); int res = 0; for (int x : dist) &#123; if (x == inf) return -1; res = Math.max(res, x); &#125; for (int d : dist) System.out.print(d + &quot;, &quot;); System.out.println(); return res; &#125; public int[] dijkstra(int[][] graph, int n, int from) &#123; int[] dist = new int[n + 1]; for (int i = 1; i &lt;= n; ++i) if (i != from) dist[i] = inf; // 不要把visited[from]初始为true，dist[from] = 0，会在下面的for循环中被第一个选到 boolean[] visited = new boolean[n + 1]; for (int i = 0; i &lt; n; ++i) &#123; // 每遍历一次将一个顶点visit赋值true，需要遍历n次 int minIndex = -1, minDist = inf; for (int j = 1; j &lt;= n; ++j) &#123; if (!visited[j] &amp;&amp; dist[j] &lt; minDist) &#123; minIndex = j; minDist = dist[j]; &#125; &#125; if (minIndex == -1) // 如果有节点非连通，则返回 return dist; visited[minIndex] = true; for (int j = 1; j &lt;= n; ++j) if (!visited[j] &amp;&amp; dist[j] &gt; graph[minIndex][j] + minDist) dist[j] = graph[minIndex][j] + minDist; &#125; return dist; &#125;&#125; 方法二：堆优化dijkstra 我们还可以使用一个小根堆来寻找「未确定节点」中与起点距离最近的点 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123; final int inf = Integer.MAX_VALUE / 2; public int networkDelayTime(int[][] times, int n, int k) &#123; int[][] graph = new int[n + 1][n + 1]; for (int[] g : graph) Arrays.fill(g, inf); for (int[] time : times) &#123; int from = time[0], to = time[1], weight = time[2]; graph[from][to] = weight; &#125; int[] dist = dijkstra(graph, n, k); int res = 0; for (int x : dist) &#123; if (x == inf) return -1; res = Math.max(res, x); &#125; return res; &#125; public int[] dijkstra(int[][] graph, int n, int from) &#123; int[] dist = new int[n + 1]; for (int i = 1; i &lt;= n; ++i) if (i != from) dist[i] = inf; boolean[] visited = new boolean[n + 1]; PriorityQueue&lt;int[]&gt; queue = new PriorityQueue&lt;&gt;(((o1, o2) -&gt; o1[1] - o2[1])); queue.offer(new int[]&#123;from, 0&#125;); while (!queue.isEmpty()) &#123; int[] arr = queue.poll(); int node = arr[0], disToFrom = arr[1]; if (visited[node]) continue; visited[node] = true; for (int i = 1; i &lt;= n; ++i) &#123; // graph[node][i] &lt; inf表示node与i有边 if (graph[node][i] &lt; inf &amp;&amp; dist[i] &gt; disToFrom + graph[node][i]) &#123; dist[i] = disToFrom + graph[node][i]; queue.offer(new int[]&#123;i, dist[i]&#125;); &#125; &#125; &#125; return dist; &#125;&#125; 322. 零钱兑换 方法一：BFS 12345678910111213141516171819202122class Solution &#123; public int coinChange(int[] coins, int amount) &#123; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); // 第一个元素表示已经凑成的钱(距离)，第二个元素表示使用的硬币数(步数) queue.offer(new int[]&#123;0 , 0&#125;); boolean[] visited = new boolean[amount + 1]; visited[0] = true; while (!queue.isEmpty()) &#123; int[] node = queue.poll(); int sum = node[0], num = node[1]; if (sum == amount) return num; for (int coin : coins) &#123; if (coin &gt; amount - sum || visited[sum + coin]) continue; queue.offer(new int[]&#123;sum + coin, num + 1&#125;); visited[sum + coin] = true; &#125; &#125; return -1; &#125;&#125; 45. 跳跃游戏 II 方法一：BFS 123456789101112131415161718192021class Solution &#123; public int jump(int[] nums) &#123; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); queue.offer(new int[]&#123;0, 0&#125;); boolean[] visited = new boolean[nums.length]; visited[0]= true; while (!queue.isEmpty()) &#123; int[] node = queue.poll(); int pos = node[0], step = node[1]; if (pos == nums.length - 1) return step; for (int i = 1; i &lt;= nums[pos]; ++i) &#123; if (pos + i &gt;= nums.length || visited[pos + i]) continue; queue.offer(new int[]&#123;pos + i, step + 1&#125;); visited[pos + i] = true; &#125; &#125; return -1; &#125;&#125; 542. 01 矩阵 方法一：BFS queue三元组，分别为横坐标i，纵坐标j，mat[i][j]距离0的距离 将所有0加入队列，并标记visited BFS搜索 123456789101112131415161718192021222324252627282930313233class Solution &#123; public int[][] updateMatrix(int[][] mat) &#123; int m = mat.length, n = mat[0].length; int[][] res = new int[m][n]; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); boolean[][] visited = new boolean[m][n]; for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (mat[i][j] == 0) &#123; queue.offer(new int[]&#123;i, j, 0&#125;); // x, y, distance visited[i][j] = true; &#125; &#125; &#125; while (!queue.isEmpty()) &#123; int[] node = queue.poll(); int i = node[0], j = node[1], dist = node[2]; for (int[] dir :dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col, m, n) &amp;&amp; !visited[row][col]) &#123; res[row][col] = dist + 1; queue.offer(new int[]&#123;row, col, dist + 1&#125;); visited[row][col] = true; &#125; &#125; &#125; return res; &#125; int[][] dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; private boolean isValid(int i, int j, int m, int n) &#123; return i &gt;= 0 &amp;&amp; j &gt;=0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125;&#125; 773. 滑动谜题 1334. 阈值距离内邻居最少的城市 不能用BFS做，这是求多源最短路径 方法一：弗洛伊德 dp[i][j]表示i到j的最短距离 枚举所有中间节点k，如果i经过中间节点k再到达j比i直接到达j更短，那么将dp[i][j]赋值为dp[i][k] + dp[k][j] 1234567891011121314151617181920212223242526272829303132class Solution &#123; public int findTheCity(int n, int[][] edges, int distanceThreshold) &#123; int[][] dp = buildGraph(n, edges); for (int k = 0; k &lt; n; ++k) for (int i = 0; i &lt; n; ++i) for (int j = 0; j &lt; n; ++j) dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k][j]); int minNum = 100000, minIndex = -1; for (int i = 0; i &lt; n; ++i) &#123; int neighborsNum = 0; for (int j = 0; j &lt; n; ++j) if (i!= j &amp;&amp; dp[i][j] &lt;= distanceThreshold) ++neighborsNum; if (neighborsNum &lt;= minNum) &#123; minNum = neighborsNum; minIndex = i; &#125; &#125; return minIndex; &#125; private int[][] buildGraph(int n, int[][] edges) &#123; int[][] graph = new int[n][n]; for (int[] row : graph) Arrays.fill(row, 100000); for (int[] edge : edges) &#123; int from = edge[0], to = edge[1], weight = edge[2]; graph[from][to] = graph[to][from] = weight; &#125; return graph; &#125;&#125; 剑指 Offer II 107. 矩阵中的距离 方法一：BFS BFS可以确保从0到非0元素的最短路径 123456789101112131415161718192021222324252627282930class Solution &#123; public int[][] updateMatrix(int[][] mat) &#123; m = mat.length; n = mat[0].length; int[][] dist = new int[m][n]; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; m; ++i) for (int j = 0; j &lt; n; ++j) if (mat[i][j] == 0) queue.offer(new int[]&#123;i, j&#125;); int[][] dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; while (!queue.isEmpty()) &#123; int[] node = queue.poll(); for (int[] dir : dirs) &#123; int row = node[0] + dir[0], col = node[1] + dir[1]; if (isValid(row, col) &amp;&amp; mat[row][col] != 0 &amp;&amp; dist[row][col] == 0) &#123; dist[row][col] = dist[node[0]][node[1]] + 1; queue.offer(new int[]&#123;row, col&#125;); &#125; &#125; &#125; return dist; &#125; int m, n; private boolean isValid(int i, int j) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125; &#125; 剑指 Offer II 108. 单词演变 方法一：单向BFS 不能使用queue2.clear()，因为queue1是指向queue2内存空间的 12345 if (queue1.isEmpty()) &#123; ++length; queue1 = queue2; queue2 = new LinkedList&lt;&gt;();&#125; 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123; public int ladderLength(String beginWord, String endWord, List&lt;String&gt; wordList) &#123; Set&lt;String&gt; set = new HashSet&lt;&gt;(wordList); Queue&lt;String&gt; queue1 = new LinkedList&lt;&gt;(), queue2 = new LinkedList&lt;&gt;(); queue1.offer(beginWord); int length = 1; while (!queue1.isEmpty()) &#123; String node = queue1.poll(); if (node.equals(endWord)) return length; List&lt;String&gt; neibors = getNeibors(node); for (String next : neibors) &#123; if (set.contains(next)) &#123; queue2.offer(next); // 通过bfs最先遍历到的节点，距离初始节点的距离一定是最短的 set.remove(next); &#125; &#125; if (queue1.isEmpty()) &#123; ++length; queue1 = queue2; queue2 = new LinkedList&lt;&gt;(); &#125; &#125; return 0; &#125; private List&lt;String&gt; getNeibors(String node) &#123; List&lt;String&gt; neibors = new LinkedList&lt;&gt;(); char[] chs = node.toCharArray(); for (int i = 0; i &lt; chs.length; ++i) &#123; char ch = chs[i]; for (char j = &#x27;a&#x27;; j &lt;= &#x27;z&#x27;; ++j) &#123; if (ch != j) &#123; chs[i] = j; neibors.add(new String(chs)); &#125; &#125; chs[i] = ch; &#125; return neibors; &#125;&#125; 方法二：双向BFS 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution &#123; public int ladderLength(String beginWord, String endWord, List&lt;String&gt; wordList) &#123; Set&lt;String&gt; notVisited = new HashSet&lt;&gt;(wordList); if (!notVisited.contains(endWord)) return 0; Set&lt;String&gt; set1 = new HashSet&lt;&gt;(), set2 = new HashSet&lt;&gt;(); set1.add(beginWord); set2.add(endWord); notVisited.remove(endWord); int length = 2; while (!set1.isEmpty() &amp;&amp; !set2.isEmpty()) &#123; if (set1.size() &gt; set2.size()) &#123; Set&lt;String&gt; temp = set1; set1 = set2; set2 = temp; &#125; Set&lt;String&gt; set3 = new HashSet&lt;&gt;(); for (String word : set1) &#123; List&lt;String&gt; neibors = getNeibors(word); for (String next : neibors) &#123; if (set2.contains(next)) return length; if (notVisited.contains(next)) &#123; set3.add(next); notVisited.remove(next); &#125; &#125; &#125; ++length; set1 = set3; set3 = new HashSet&lt;&gt;(); &#125; return 0; &#125; private List&lt;String&gt; getNeibors(String node) &#123; List&lt;String&gt; neibors = new LinkedList&lt;&gt;(); char[] chs = node.toCharArray(); for (int i = 0; i &lt; chs.length; ++i) &#123; char ch = chs[i]; for (char j = &#x27;a&#x27;; j &lt;= &#x27;z&#x27;; ++j) &#123; if (ch != j) &#123; chs[i] = j; neibors.add(new String(chs)); &#125; &#125; chs[i] = ch; &#125; return neibors; &#125;&#125; 剑指 Offer II 109. 开密码锁 方法一：单向BFS 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class Solution &#123; public int openLock(String[] deadends, String target) &#123; Set&lt;String&gt; notAchievable = new HashSet&lt;&gt;(Arrays.asList(deadends)); if (notAchievable.contains(&quot;0000&quot;)) return -1; Queue&lt;String&gt; queue1 = new LinkedList&lt;&gt;(), queue2 = new LinkedList&lt;&gt;(); queue1.offer(&quot;0000&quot;); Set&lt;String&gt; visited = new HashSet&lt;&gt;(); int length = 0; while (!queue1.isEmpty()) &#123; String node = queue1.poll(); if (node.equals(target)) return length; List&lt;String&gt; neibors = getNeibors(node, notAchievable); for (String next : neibors) &#123; if (visited.contains(next)) continue; visited.add(next); queue2.offer(next); &#125; if (queue1.isEmpty()) &#123; ++length; queue1 = queue2; queue2 = new LinkedList&lt;&gt;(); &#125; &#125; return -1; &#125; private List&lt;String&gt; getNeibors(String node, Set&lt;String&gt; notAchievable) &#123; List&lt;String&gt; neibors = new LinkedList&lt;&gt;(); char[] chs = node.toCharArray(); String pre, next; for (int i = 0; i &lt; 4; ++i) &#123; char ch = chs[i]; if (ch == &#x27;0&#x27;) &#123; chs[i] = &#x27;1&#x27;; next = new String(chs); if (!notAchievable.contains(next)) neibors.add(next); chs[i] = &#x27;9&#x27;; pre = new String(chs); if (!notAchievable.contains(pre)) neibors.add(new String(chs)); &#125; else if (ch == &#x27;9&#x27;) &#123; chs[i] = &#x27;0&#x27;; next = new String(chs); if (!notAchievable.contains(next)) neibors.add(next); chs[i] = &#x27;8&#x27;; pre = new String(chs); if (!notAchievable.contains(pre)) neibors.add(pre); &#125; else &#123; chs[i] = (char) (ch + 1); next = new String(chs); if (!notAchievable.contains(next)) neibors.add(next); chs[i] = (char) (ch - 1); pre = new String(chs); if (!notAchievable.contains(pre)) neibors.add(pre); &#125; chs[i] = ch; &#125; return neibors; &#125;&#125; 6951. 找出最安全路径 方法一：多源BFS 二分做右端点的初始 1int l = 0, r = Math.min(dist[0][0], dist[n - 1][n - 1]); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class Solution &#123; public int maximumSafenessFactor(List&lt;List&lt;Integer&gt;&gt; g) &#123; n = g.size(); grid = new int[n][n]; for (int i = 0; i &lt; n; ++i) for (int j = 0; j &lt; n; ++j) grid[i][j] = g.get(i).get(j); int[][] dist = new int[n][n]; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); for (int[] arr : dist) Arrays.fill(arr, -1); for (int i = 0; i &lt; n; ++i) for (int j = 0; j &lt; n; ++j) if (grid[i][j] == 1) &#123; queue.offer(new int[]&#123;i, j&#125;); dist[i][j] = 0; &#125; while (!queue.isEmpty()) &#123; int[] node = queue.poll(); for (int[] dir : dirs) &#123; int row = node[0] + dir[0], col = node[1] + dir[1]; if (isValid(row, col) &amp;&amp; dist[row][col] == -1) &#123; dist[row][col] = dist[node[0]][node[1]] + 1; queue.offer(new int[]&#123;row, col&#125;); &#125; &#125; &#125; int l = 0, r = Math.min(dist[0][0], dist[n - 1][n - 1]); while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if (check(mid, dist)) l = mid + 1; else r = mid - 1; &#125; return r; &#125; private boolean check(int limit, int[][] dist) &#123; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); boolean[][] visited = new boolean[n][n]; queue.offer(new int[]&#123;0, 0&#125;); visited[0][0] = true; while (!queue.isEmpty()) &#123; int[] node = queue.poll(); for (int[] dir : dirs) &#123; int row = node[0] + dir[0], col = node[1] + dir[1]; if (isValid(row, col) &amp;&amp; !visited[row][col] &amp;&amp; dist[row][col] &gt;= limit) &#123; visited[row][col] = true; queue.offer(new int[]&#123;row, col&#125;); &#125; &#125; &#125; return visited[n - 1][n - 1]; &#125; private boolean isValid(int i, int j) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; n &amp;&amp; j &lt; n; &#125; int[][] grid, dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; int n;&#125; 在check中判断初始位置，r = 2 * n - 1 (大一点也没关系) 12if (dist[0][0] &lt; limit) return false; 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class Solution &#123; public int maximumSafenessFactor(List&lt;List&lt;Integer&gt;&gt; g) &#123; n = g.size(); grid = new int[n][n]; for (int i = 0; i &lt; n; ++i) for (int j = 0; j &lt; n; ++j) grid[i][j] = g.get(i).get(j); int[][] dist = new int[n][n]; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); for (int[] arr : dist) Arrays.fill(arr, -1); for (int i = 0; i &lt; n; ++i) for (int j = 0; j &lt; n; ++j) if (grid[i][j] == 1) &#123; queue.offer(new int[]&#123;i, j&#125;); dist[i][j] = 0; &#125; while (!queue.isEmpty()) &#123; int[] node = queue.poll(); for (int[] dir : dirs) &#123; int row = node[0] + dir[0], col = node[1] + dir[1]; if (isValid(row, col) &amp;&amp; dist[row][col] == -1) &#123; dist[row][col] = dist[node[0]][node[1]] + 1; queue.offer(new int[]&#123;row, col&#125;); &#125; &#125; &#125; int l = 0, r = 2 * n; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if (check(mid, dist)) l = mid + 1; else r = mid - 1; &#125; return r; &#125; private boolean check(int limit, int[][] dist) &#123; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); boolean[][] visited = new boolean[n][n]; if (dist[0][0] &lt; limit) return false; queue.offer(new int[]&#123;0, 0&#125;); visited[0][0] = true; while (!queue.isEmpty()) &#123; int[] node = queue.poll(); for (int[] dir : dirs) &#123; int row = node[0] + dir[0], col = node[1] + dir[1]; if (isValid(row, col) &amp;&amp; !visited[row][col] &amp;&amp; dist[row][col] &gt;= limit) &#123; visited[row][col] = true; queue.offer(new int[]&#123;row, col&#125;); &#125; &#125; &#125; return visited[n - 1][n - 1]; &#125; private boolean isValid(int i, int j) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; n &amp;&amp; j &lt; n; &#125; int[][] grid, dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; int n;&#125; check使用DFS 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class Solution &#123; public int maximumSafenessFactor(List&lt;List&lt;Integer&gt;&gt; g) &#123; n = g.size(); grid = new int[n][n]; dist = new int[n][n]; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; grid[i][j] = g.get(i).get(j); dist[i][j] = -1; if (grid[i][j] == 1) &#123; dist[i][j] = 0; queue.offer(new int[]&#123;i, j&#125;); &#125; &#125; &#125; // bfs while (!queue.isEmpty()) &#123; int[] node = queue.poll(); for (int[] dir : dirs) &#123; int row = node[0] + dir[0], col = node[1] + dir[1]; if (isValid(row, col) &amp;&amp; dist[row][col] == -1) &#123; queue.offer(new int[]&#123;row, col&#125;); dist[row][col] = dist[node[0]][node[1]] + 1; &#125; &#125; &#125; int l = 0, r = (n - 1) &lt;&lt; 1; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if (check(mid)) l = mid + 1; else r = mid - 1; &#125; return r; &#125; private boolean check(int minDist) &#123; if (dist[0][0] &lt; minDist) return false; boolean[][] visited = new boolean[n][n]; return dfs(0, 0, minDist, visited); &#125; private boolean dfs(int i, int j, int minDist, boolean[][] visited) &#123; if (i == n -1 &amp;&amp; j == n - 1) return true; visited[i][j] = true; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col) &amp;&amp; !visited[row][col] &amp;&amp; dist[row][col] &gt;= minDist) &#123; if (dfs(row, col, minDist, visited)) return true; &#125; &#125; return false; &#125; private boolean isValid(int i, int j) &#123; return i &gt;=0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; n &amp;&amp; j &lt; n; &#125; int[][] grid, dist, dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; int n;&#125; int[][] visited数组，visited数组只需要创建一次 要初始化为-1，因为会考虑到limit == 0的情况 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class Solution &#123; public int maximumSafenessFactor(List&lt;List&lt;Integer&gt;&gt; g) &#123; n = g.size(); grid = new int[n][n]; dist = new int[n][n]; visited = new int[n][n]; for (int[] arr : visited) Arrays.fill(arr, -1); Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; grid[i][j] = g.get(i).get(j); dist[i][j] = -1; if (grid[i][j] == 1) &#123; queue.offer(new int[]&#123;i, j&#125;); dist[i][j] = 0; &#125; &#125; &#125; // 多源BFS while (!queue.isEmpty()) &#123; int[] node = queue.poll(); int i = node[0], j = node[1]; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col) &amp;&amp; dist[row][col] == -1) &#123; dist[row][col] = dist[i][j] + 1; queue.offer(new int[]&#123;row, col&#125;); &#125; &#125; &#125; int l = 0, r = 2 * (n - 1); while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if (check(mid)) l = mid + 1; else r = mid - 1; &#125; return r; &#125; private boolean check(int limit) &#123; if (dist[0][0] &lt; limit) return false; return dfs(0, 0, limit); &#125; private boolean dfs(int i, int j, int limit) &#123; if (i == n - 1 &amp;&amp; j == n - 1) return true; visited[i][j] = limit; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row,col) &amp;&amp; visited[row][col] != limit &amp;&amp; dist[row][col] &gt;= limit &amp;&amp; dfs(row, col, limit)) &#123; return true; &#125; &#125; return false; &#125; int[][] grid, dist, dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; int n; int[][] visited; private boolean isValid(int i, int j) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; n &amp;&amp; j &lt; n; &#125;&#125; 方法二：多源BFS + 并查集 关于从dists.size() - 2开始枚举：最后一步是空集，所以最大的距离为 dists.size() - 2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384class Solution &#123; public int maximumSafenessFactor(List&lt;List&lt;Integer&gt;&gt; g) &#123; n = g.size(); grid = new int[n][n]; int[][] dist = new int[n][n]; for (int[] arr : dist) Arrays.fill(arr, -1); List&lt;int[]&gt; queue = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; grid[i][j] = g.get(i).get(j); if (grid[i][j] == 1) &#123; dist[i][j] = 0; queue.add(new int[]&#123;i, j&#125;); &#125; &#125; &#125; // 多源BFS List&lt;List&lt;int[]&gt;&gt; dists = new ArrayList&lt;&gt;(); dists.add(queue); List&lt;int[]&gt; temp = new LinkedList&lt;&gt;(); while (!queue.isEmpty()) &#123; temp = queue; queue = new LinkedList&lt;&gt;(); for (int[] node : temp) &#123; for (int[] dir : dirs) &#123; int row = node[0] + dir[0], col = node[1] + dir[1]; if (isValid(row, col) &amp;&amp; dist[row][col] == -1) &#123; // 没有被访问过 queue.add(new int[]&#123;row, col&#125;); dist[row][col] = dists.size(); &#125; &#125; &#125; // 最后一步是空集，所以最大的距离为 dists.size() - 2 dists.add(queue); &#125; // 初始化并查集 init(n * n); for (int i = dists.size() - 2; i &gt; 0; --i) &#123; List&lt;int[]&gt; q = dists.get(i); for (int[] node : q) &#123; for (int[] dir : dirs) &#123; int row = node[0] + dir[0], col = node[1] + dir[1]; if (isValid(row, col) &amp;&amp; dist[row][col] &gt;= i) union(node[0] * n + node[1],row * n + col); &#125; &#125; if (findParent(0) == findParent(n * n - 1)) return i; &#125; return 0; &#125; private boolean isValid(int i, int j) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; n &amp;&amp; j &lt; n; &#125; int[][] grid, dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; int n; int[] parent; private boolean union(int i, int j) &#123; int rootI = findParent(i), rootJ = findParent(j); if (rootI != rootJ) &#123; parent[rootI] = rootJ; return true; &#125; return false; &#125; private int findParent(int i) &#123; if (i != parent[i]) parent[i] = findParent(parent[i]); return parent[i]; &#125; private void init(int n) &#123; parent = new int[n]; for (int i = 0; i &lt; n; ++i) parent[i] = i; &#125;&#125; 补充题 1631. 最小体力消耗路径 方法一：多源BFS + 二分 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; public int minimumEffortPath(int[][] heights) &#123; this.heights = heights; m = heights.length; n = heights[0].length; visited = new boolean[m][n]; int l = 0, r = (int) 1e6; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if (check(mid)) r = mid - 1; else l = mid + 1; &#125; return l; &#125; private boolean check(int limit) &#123; visited = new boolean[m][n]; return dfs(0, 0, limit); &#125; private boolean dfs(int i, int j, int limit) &#123; if (i == m - 1 &amp;&amp; j == n - 1) return true; visited[i][j] = true; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col) &amp;&amp; !visited[row][col] &amp;&amp; Math.abs(heights[i][j] - heights[row][col]) &lt;= limit) if (dfs(row, col, limit)) return true; &#125; return false; &#125; int[][] heights, dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; int m, n; boolean[][] visited; private boolean isValid(int i, int j) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125;&#125; 方法二：并查集 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Solution &#123; public int minimumEffortPath(int[][] heights) &#123; this.heights = heights; m = heights.length; n = heights[0].length; visited = new boolean[m][n]; List&lt;int[]&gt; edges = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; int id = i * n + j; if (i &gt; 0) edges.add(new int[]&#123;id - n, id, Math.abs(heights[i][j] - heights[i - 1][j])&#125;); if (j &gt; 0) edges.add(new int[]&#123;id - 1, id, Math.abs(heights[i][j] - heights[i][j - 1])&#125;); &#125; &#125; Collections.sort(edges, (o1, o2) -&gt; o1[2] - o2[2]); // 初始化并查集 init(m * n); for (int[] edge : edges) &#123; int from = edge[0], to = edge[1], weight = edge[2]; union(from, to); if (findParent(0) == findParent(m * n - 1)) return weight; &#125; return 0; &#125; int[] parent; private boolean union(int i, int j) &#123; int rootI = findParent(i), rootJ = findParent(j); if (rootI != rootJ) &#123; parent[rootI] = rootJ; return true; &#125; return false; &#125; private int findParent(int i) &#123; if (i != parent[i]) parent[i] = findParent(parent[i]); return parent[i]; &#125; private void init(int n) &#123; parent = new int[n]; for (int i = 0; i &lt; n; ++i) parent[i] = i; &#125; int[][] heights, dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; int m, n; boolean[][] visited; private boolean isValid(int i, int j) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125;&#125; 在网格图中访问一个格子的最少时间 二刷 dijkstra 无需visited数组 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; public int minimumTime(int[][] grid) &#123; int m = grid.length, n = grid[0].length; if (grid[1][0] &gt; 1 &amp;&amp; grid[0][1] &gt; 1) return -1; int[][] dist = new int[m][n]; for (int[] arr : dist) Arrays.fill(arr, Integer.MAX_VALUE &gt;&gt; 1); dist[0][0] = 0; boolean[][] visited = new boolean[m][n]; PriorityQueue&lt;int[]&gt; q = new PriorityQueue&lt;&gt;((o1, o2) -&gt; o1[2] - o2[2]); q.offer(new int[]&#123;0, 0, 0&#125;); while (true) &#123; int[] node = q.poll(); int i = node[0], j = node[1], d = node[2]; if (i == m - 1 &amp;&amp; j == n - 1) return d; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col, m, n)) &#123; int nd = Math.max(d, grid[row][col]); nd += (nd + row + col) % 2; if (nd &lt; dist[row][col]) &#123; dist[row][col] = nd; q.offer(new int[]&#123;row, col, nd&#125;); &#125; &#125; &#125; &#125; &#125; public boolean isValid(int i, int j, int m, int n) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125; int[][] dirs = new int[][]&#123;&#123;1,0&#125;, &#123;-1,0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;; &#125; 方法一：堆优化的dijkstra dist[i][j]与 i + j 同奇偶 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123; public int minimumTime(int[][] grid) &#123; this.grid = grid; m = grid.length; n = grid[0].length; if (grid[0][1] &gt; 1 &amp;&amp; grid[1][0] &gt; 1) return -1; int[][] dist = new int[m][n]; int inf = Integer.MAX_VALUE &gt;&gt; 1; for (int[] arr : dist) Arrays.fill(arr, inf); dist[0][0] = 0; boolean[][] visited = new boolean[m][n]; PriorityQueue&lt;int[]&gt; queue = new PriorityQueue&lt;&gt;(((o1, o2) -&gt; o1[0] - o2[0])); queue.offer(new int[]&#123;0, 0, 0&#125;); while (!queue.isEmpty()) &#123; int[] arr = queue.poll(); int d = arr[0], i = arr[1], j = arr[2]; if (i == m - 1 &amp;&amp; j == n - 1) return d; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col)) &#123; int nd = Math.max(d + 1, grid[row][col]); nd += (nd - row - col) % 2; if (nd &lt; dist[row][col]) &#123; dist[row][col] = nd; queue.offer(new int[]&#123;nd, row, col&#125;); &#125; &#125; &#125; &#125; return dist[m - 1][n - 1]; &#125; int[][] grid, dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; int m, n; private boolean isValid(int i, int j) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125;&#125; 方法二：二分+ BFS 双数组 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution &#123; public int minimumTime(int[][] grid) &#123; this.grid = grid; m = grid.length; n = grid[0].length; if (grid[0][1] &gt; 1 &amp;&amp; grid[1][0] &gt; 1) return -1; int left = Math.max(m + n - 2, grid[m - 1][n - 1]), right = (int) 1e5 + m + n; while (left &lt;= right) &#123; int mid = (left + right) &gt;&gt; 1; if (check(mid)) right = mid - 1; else left = mid + 1; &#125; return left + (left + m + n) % 2; // 答案要与 m + n - 2同奇偶 &#125; private boolean check(int limit) &#123; boolean[][] visited = new boolean[m][n]; visited[m - 1][n - 1] = true; List&lt;int[]&gt; queue = new ArrayList&lt;&gt;(); int t = limit - 1; queue.add(new int[]&#123;m - 1, n - 1&#125;); while (!queue.isEmpty()) &#123; List&lt;int[]&gt; temp = queue; queue = new ArrayList&lt;&gt;(); for (int[] arr : temp) &#123; int i = arr[0], j = arr[1]; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col) &amp;&amp; !visited[row][col] &amp;&amp; grid[row][col] &lt;= t) &#123; if (row == 0 &amp;&amp; col == 0) return true; visited[row][col] = true; queue.add(new int[]&#123;row, col&#125;); &#125; &#125; &#125; --t; &#125; return false; &#125; int[][] grid, dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; int m, n; private boolean isValid(int i, int j) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125;&#125; Queue q.offer(new int[]{m - 1, n - 1, limit - 1});表示终点在limit时访问过，邻居的grid值要小于limit - 1 从limit - 1开始 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; public int minimumTime(int[][] grid) &#123; int m = grid.length, n = grid[0].length; if (grid[1][0] &gt; 1 &amp;&amp; grid[0][1] &gt; 1) return -1; int l = Math.max(m + n - 2, grid[m - 1][n - 1]), r = (int) 1e5; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if (check(mid, grid, m, n)) r = mid - 1; else l = mid + 1; &#125; return l + (l + m + n - 2) % 2; // 答案需要和重点坐标[m - 1, n - 1]之和同奇偶 &#125; public boolean check(int limit, int[][] grid, int m, int n) &#123; boolean[][] visited = new boolean[m][n]; Queue&lt;int[]&gt; q = new LinkedList&lt;&gt;(); q.offer(new int[]&#123;m - 1, n - 1, limit - 1&#125;); visited[m - 1][n - 1] = true; while (!q.isEmpty()) &#123; int[] node = q.poll(); int i = node[0], j = node[1], t = node[2]; if (i == 0 &amp;&amp; j == 0) return true; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col, m, n) &amp;&amp; !visited[row][col] &amp;&amp; t &gt;= grid[row][col]) &#123; q.offer(new int[]&#123;row, col, t - 1&#125;); visited[row][col] = true; &#125; &#125; &#125; return false; &#125; public boolean isValid(int i, int j, int m, int n) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125; int[][] dirs = new int[][]&#123;&#123;1,0&#125;, &#123;-1,0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;; &#125;","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://leopol1d.github.io/categories/Algorithms/"},{"name":"Graph","slug":"Algorithms/Graph","permalink":"https://leopol1d.github.io/categories/Algorithms/Graph/"}],"tags":[{"name":"图","slug":"图","permalink":"https://leopol1d.github.io/tags/%E5%9B%BE/"},{"name":"最短路","slug":"最短路","permalink":"https://leopol1d.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"}]},{"title":"Minimum Spanning Tree","slug":"minimum-spanning-tree","date":"2023-05-30T07:23:03.000Z","updated":"2023-06-05T01:18:34.602Z","comments":true,"path":"2023/05/30/minimum-spanning-tree/","link":"","permalink":"https://leopol1d.github.io/2023/05/30/minimum-spanning-tree/","excerpt":"","text":"1584. 连接所有点的最小费用 方法一：Kruskal算法 依次选择权值最小的边 如果要加入的边会使得图形成环，则跳过 使用并查集来判断是否会形成环 如果两个顶点不在同一个子图中，连接边不会形成环 如果两个顶点在同一个子图中，连接边会形成环 恰好可以用union解决 比如有三个顶点，1，2，3那么所有的边为(1,2),(1,3),(2,3) 1int[][] edges = new int[n * (n - 1) / 2][3]; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123; public int minCostConnectPoints(int[][] points) &#123; int n = points.length; // edge[0]:顶点1，edge[1]:顶点2，edge[2]:权值(举例) int[][] edges = new int[n * (n - 1) / 2][3]; int index = 0; for (int i = 0; i &lt; n; ++i) for (int j = i + 1; j &lt; n; ++j) edges[index++] = new int[]&#123;i, j, Math.abs(points[i][0] - points[j][0]) + Math.abs(points[i][1] - points[j][1])&#125;; return kruskal(edges, n); &#125; private int kruskal(int[][] edges, int n) &#123; int res = 0; init(n); Arrays.sort(edges, (o1, o2) -&gt; Integer.compare(o1[2], o2[2])); for (int[] edge : edges) &#123; int node1 = edge[0], node2 = edge[1]; if (union(node1, node2)) &#123; // node1与node2不在同一个子图中，加入这条边不会形成环 res += edge[2]; &#125; &#125; return res; &#125; int[] parent; private boolean union(int i, int j) &#123; int rootI = findParent(i), rootJ = findParent(j); if (rootI != rootJ) &#123; parent[rootI] = rootJ; return true; &#125; return false; &#125; private int findParent(int i) &#123; if (i != parent[i]) parent[i] = findParent(parent[i]); return parent[i]; &#125; private void init(int n) &#123; parent = new int[n]; for (int i = 0; i &lt; n; ++i) parent[i] = i; &#125;&#125; 面试用：节点多，边少的时候用 稠密图 方法二：Prim算法 误区：以下是prim，prim需要更新的是已选顶点集距离未选顶点的最短距离 123for (int j = 0; j &lt; n; ++j) if (!visited[j] &amp;&amp; dist[j] &gt; graph[minIndex][j]) dist[j] = graph[minIndex][j]; 以下是dijkstra 123for (int j = 1; j &lt;= n; ++j) if (!visited[j] &amp;&amp; dist[j] &gt; graph[minIndex][j] + minDist) dist[j] = graph[minIndex][j] + minDist; 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public int minCostConnectPoints(int[][] points) &#123; int n = points.length, index = 0; int[][] graph = new int[n][n]; for (int i = 0; i &lt; n; ++i) for (int j = i + 1; j &lt; n; ++j) graph[i][j] = graph[j][i] = getMDistance(points[i], points[j]); return prim(graph, n); &#125; private int prim(int[][] graph, int n) &#123; int res = 0, inf = Integer.MAX_VALUE &gt;&gt; 1; // 已选顶点集距离未选顶点的距离 int[] dist = new int[n]; boolean[] visited = new boolean[n]; for (int i = 1; i &lt; n; ++i) dist[i] = inf; for (int i = 0; i &lt; n; ++i) &#123; int minIndex = -1, minDist = inf; for (int j = 0; j &lt; n; ++j) &#123; if (!visited[j] &amp;&amp; dist[j] &lt; minDist) &#123; minDist = dist[j]; minIndex = j; &#125; &#125; visited[minIndex] = true; res += minDist; for (int j = 0; j &lt; n; ++j) if (!visited[j] &amp;&amp; dist[j] &gt; graph[minIndex][j]) dist[j] = graph[minIndex][j]; &#125; return res; &#125; public int getMDistance(int[] d1, int[] d2) &#123; return Math.abs(d1[0] - d2[0]) + Math.abs(d1[1] - d2[1]); &#125;&#125;","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://leopol1d.github.io/categories/Algorithms/"},{"name":"Graph","slug":"Algorithms/Graph","permalink":"https://leopol1d.github.io/categories/Algorithms/Graph/"}],"tags":[{"name":"图","slug":"图","permalink":"https://leopol1d.github.io/tags/%E5%9B%BE/"},{"name":"最小生成树","slug":"最小生成树","permalink":"https://leopol1d.github.io/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"}]},{"title":"Union Find","slug":"union-find","date":"2023-05-29T09:51:43.000Z","updated":"2023-07-17T06:51:09.012Z","comments":true,"path":"2023/05/29/union-find/","link":"","permalink":"https://leopol1d.github.io/2023/05/29/union-find/","excerpt":"","text":"并查集是一种高效的数据结构，用于解决 连通问题、成环问题等。 模板 123456789101112131415161718192021int[] parent; private boolean union(int i, int j) &#123; int rootI = findParent(i), rootJ = findParent(j); if (rootI != rootJ) &#123; parent[rootI] = rootJ; return true; &#125; return false; &#125; private int findParent(int i) &#123; if (i != parent[i]) parent[i] = findParent(parent[i]); return parent[i]; &#125; private void init(int n) &#123; parent = new int[n]; for (int i = 0; i &lt; n; ++i) parent[i] = i; &#125; 547. 省份数量 方法一：BFS 1234567891011121314151617181920212223242526272829class Solution &#123; boolean[] visited; public int findCircleNum(int[][] isConnected) &#123; int n = isConnected.length, res = 0; visited = new boolean[n]; for (int i = 0; i &lt; n; ++i) &#123; if (!visited[i]) &#123; bfs(i, isConnected, n); ++res; &#125; &#125; return res; &#125; private void bfs(int i, int[][] isConnected, int n) &#123; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); queue.offer(i); visited[i] = true; while (!queue.isEmpty()) &#123; int node = queue.poll(); for (int j = 0; j &lt; n; ++j) &#123; if (isConnected[node][j] == 1 &amp;&amp; !visited[j]) &#123; visited[j] = true; queue.offer(j); &#125; &#125; &#125; &#125;&#125; 方法二：DFS 1234567891011121314151617181920212223class Solution &#123; boolean[] visited; public int findCircleNum(int[][] isConnected) &#123; int n = isConnected.length, res = 0; visited = new boolean[n]; for (int i = 0; i &lt; n; ++i) &#123; if (!visited[i]) &#123; dfs(i, isConnected, n); ++res; &#125; &#125; return res; &#125; private void dfs(int index, int[][] isConnected, int n) &#123; visited[index] = true; for (int i = 0; i &lt; n; ++i) &#123; if (isConnected[index][i] == 1 &amp;&amp; !visited[i]) &#123; dfs(i, isConnected, n); &#125; &#125; &#125;&#125; 方法三：并查集 12345678910111213141516171819202122232425262728public int findCircleNum(int[][] isConnected) &#123; int n = isConnected.length, res = n; parent = new int[n]; for (int i = 0; i &lt; n; ++i) parent[i] = i; for (int i = 0; i &lt; n; ++i) &#123; for (int j = i + 1; j &lt; n; ++j) &#123; if (isConnected[i][j] == 1 &amp;&amp; union(i, j)) --res; &#125; &#125; return res;&#125;int[] parent;private boolean union(int i, int j) &#123; int rootI = findParent(i), rootJ = findParent(j); if (rootI != rootJ) &#123; parent[rootI] = rootJ; return true; &#125; return false;&#125;private int findParent(int i) &#123; if (i != parent[i]) parent[i] = findParent(parent[i]); return parent[i];&#125; 684. 冗余连接 方法一：并查集 初始化为森林，依次连接节点之间的边 如果连接边之前，节点不在同一个子集，那么合并 如果连接边之前，节点已经在同一个子集了，那么一定会形成环，这条边就是最后的冗余连接 123456789101112131415161718192021222324252627282930313233class Solution &#123; public int[] findRedundantConnection(int[][] edges) &#123; int n = edges.length; init(n + 1); for (int[] edge : edges) &#123; if (!union(edge[0], edge[1])) &#123; return edge; &#125; &#125; return new int[0]; &#125; int[] parent; private boolean union(int i, int j) &#123; int rootI = findParent(i), rootJ = findParent(j); if (rootI != rootJ) &#123; parent[rootI] = rootJ; return true; &#125; return false; &#125; private int findParent(int i) &#123; if (i != parent[i]) parent[i] = findParent(parent[i]); return parent[i]; &#125; private void init(int n) &#123; parent = new int[n]; for (int i = 0; i &lt; n; ++i) parent[i] = i; &#125;&#125; 1319. 连通网络的操作次数 方法一：并查集 找到连通分量 123for (int i = 0 ; i &lt; n ; i++) if (parent[i] == i) require++; 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123; public int makeConnected(int n, int[][] connections) &#123; init(n); int redundancy = 0; for (int[] connection : connections) &#123; if (!union(connection[0], connection[1])) &#123; // 已连通 ++redundancy; &#125; &#125; // 找到连通分量数，n个连通分量需要用n-1条边连接 int require = -1; for (int i = 0 ; i &lt; n ; i++) if (parent[i] == i) require++; if (require &lt;= redundancy) return require; return -1; &#125; int[] parent; private boolean union(int i, int j) &#123; int rootI = findParent(i), rootJ = findParent(j); if (rootI != rootJ) &#123; parent[rootI] = rootJ; return true; &#125; return false; &#125; private int findParent(int i) &#123; if (i != parent[i]) parent[i] = findParent(parent[i]); return parent[i]; &#125; private void init(int n) &#123; parent = new int[n]; for (int i = 0; i &lt; n; ++i) parent[i] = i; &#125;&#125; 面试题 16.19. 水域大小 方法一：DFS 12345678910111213141516171819202122232425262728293031323334class Solution &#123; int[][] dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;, &#123;-1, -1&#125;, &#123;-1, 1&#125;, &#123;1, -1&#125;, &#123;1, 1&#125;&#125;; boolean[][] visited; public int[] pondSizes(int[][] land) &#123; int m = land.length, n = land[0].length; visited = new boolean[m][n]; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (!visited[i][j] &amp;&amp; land[i][j] == 0) list.add(dfs(land, m, n, i, j)); &#125; &#125; int[] res = list.stream().mapToInt(i-&gt;i).toArray(); Arrays.sort(res); return res; &#125; private int dfs(int[][] land, int m, int n, int i, int j) &#123; visited[i][j] = true; int length = 1; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(m, n, row, col) &amp;&amp; !visited[row][col] &amp;&amp; land[row][col] == 0) &#123; length += dfs(land, m, n, row, col); &#125; &#125; return length; &#125; private boolean isValid(int m, int n, int i, int j) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125;&#125; 方法二：并查集 使用哈希表count记录池塘的大小 初始化，额外将count赋值1 123456private void init(int n) &#123; parent = new int[n]; for (int i = 0; i &lt; n; ++i) &#123; parent[i] = i; count.put(i, 1); &#125; 如果land[i][j] != 0，那么必然不会是池塘，将count值赋-1 12if (land[i][j] != 0) count.put(i * n + j, -1); 遍历依次合并，合并时将新parent的count加上被合并的count，并将被合并的parent的count赋值-1(便于收集结果) 12345678910private boolean union(int i, int j) &#123; int rootI = findParent(i), rootJ = findParent(j); if (rootI != rootJ) &#123; parent[rootI] = rootJ; count.put(rootJ, count.get(rootI) + count.get(rootJ)); count.put(rootI, -1); return true; &#125; return false;&#125; 收集结果 123for (int val : count.values()) if (val != -1) list.add(val); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class Solution &#123; Map&lt;Integer, Integer&gt; count = new HashMap&lt;&gt;(); public int[] pondSizes(int[][] land) &#123; int[][] dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;, &#123;-1, -1&#125;, &#123;-1, 1&#125;, &#123;1, -1&#125;, &#123;1, 1&#125;&#125;; int m = land.length, n = land[0].length; init(m * n); for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (land[i][j] != 0) count.put(i * n + j, -1); if (land[i][j] == 0) &#123; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(m, n, row, col) &amp;&amp; land[row][col] == 0) &#123; union(i * n + j, row * n + col); &#125; &#125; &#125; &#125; &#125;// for (Map.Entry&lt;Integer, Integer&gt; entry : count.entrySet()) &#123;// System.out.println(&quot;key: &quot; + entry.getKey() + &quot;, value: &quot; + entry.getValue());// &#125; List&lt;Integer&gt; list = new LinkedList&lt;&gt;(); for (int val : count.values()) if (val != -1) list.add(val); int[] res = list.stream().mapToInt(i-&gt;i).toArray(); Arrays.sort(res); return res; &#125; private boolean isValid(int m, int n, int i, int j) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125; int[] parent; private boolean union(int i, int j) &#123; int rootI = findParent(i), rootJ = findParent(j); if (rootI != rootJ) &#123; parent[rootI] = rootJ; count.put(rootJ, count.get(rootI) + count.get(rootJ)); count.put(rootI, -1); return true; &#125; return false; &#125; private int findParent(int i) &#123; if (i != parent[i]) parent[i] = findParent(parent[i]); return parent[i]; &#125; private void init(int n) &#123; parent = new int[n]; for (int i = 0; i &lt; n; ++i) &#123; parent[i] = i; count.put(i, 1); &#125; &#125;&#125; 721. 账户合并 方法一：并查集 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Solution &#123; Map&lt;String, Integer&gt; emailToId = new HashMap&lt;&gt;(); Map&lt;Integer, List&lt;String&gt;&gt; idToEmail = new HashMap&lt;&gt;(); public List&lt;List&lt;String&gt;&gt; accountsMerge(List&lt;List&lt;String&gt;&gt; accounts) &#123; int n = accounts.size(); init(n); for (int i = 0; i &lt; n; ++i) &#123; int size = accounts.get(i).size(); for (int j = 1; j &lt; size; ++j) &#123; String email = accounts.get(i).get(j); if (!emailToId.containsKey(email)) &#123; emailToId.put(email, i); &#125; else &#123; union(i, emailToId.get(email)); &#125; &#125; &#125; for (String email : emailToId.keySet()) &#123; int rootId = findParent(emailToId.get(email)); List&lt;String&gt; emails = idToEmail.getOrDefault(rootId, new LinkedList&lt;&gt;()); emails.add(email); idToEmail.put(rootId, emails); &#125; // 加入name List&lt;List&lt;String&gt;&gt; res = new LinkedList&lt;&gt;(); for (Map.Entry&lt;Integer, List&lt;String&gt;&gt; entry : idToEmail.entrySet()) &#123; int id = entry.getKey(); String name = accounts.get(id).get(0); List&lt;String&gt; row = new LinkedList&lt;&gt;(); row.add(name); List&lt;String&gt; emails = entry.getValue(); Collections.sort(emails); row.addAll(emails); res.add(row); &#125; return res; &#125; int[] parent; private boolean union(int i, int j) &#123; int rootI = findParent(i), rootJ = findParent(j); if (rootI != rootJ) &#123; parent[rootI] = rootJ; return true; &#125; return false; &#125; private int findParent(int i) &#123; if (i != parent[i]) parent[i] = findParent(parent[i]); return parent[i]; &#125; private void init(int n) &#123; parent = new int[n]; for (int i = 0; i &lt; n; ++i) parent[i] = i; &#125;&#125; 剑指 Offer II 119. 最长连续序列 方法一：并查集 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123; public int longestConsecutive(int[] nums) &#123; init(nums); Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int x : nums) set.add(x); for (int x : nums) &#123; if (set.contains(x - 1)) &#123; union(x, x - 1); &#125; if (set.contains(x + 1)) &#123; union(x, x + 1); &#125; &#125; int res = 0; for (int cnt : count.values()) res = Math.max(res, cnt); return res; &#125; private void init(int[] nums) &#123; for (int i = 0; i &lt; nums.length; ++i) &#123; parent.put(nums[i], nums[i]); count.put(nums[i], 1); &#125; &#125; private int findParent(int num) &#123; if (num != parent.get(num)) parent.put(num, findParent(parent.get(num))); return parent.get(num); &#125; private boolean union(int i, int j) &#123; int rootI = findParent(i), rootJ = findParent(j); if (rootI != rootJ) &#123; count.put(rootI, count.get(rootI) + count.get(rootJ)); parent.put(rootJ, rootI); return true; &#125; return false; &#125; Map&lt;Integer, Integer&gt; parent = new HashMap&lt;&gt;(), count = new HashMap&lt;&gt;();&#125;","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://leopol1d.github.io/categories/Algorithms/"},{"name":"Graph","slug":"Algorithms/Graph","permalink":"https://leopol1d.github.io/categories/Algorithms/Graph/"}],"tags":[{"name":"图","slug":"图","permalink":"https://leopol1d.github.io/tags/%E5%9B%BE/"},{"name":"并查集","slug":"并查集","permalink":"https://leopol1d.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"}]},{"title":"Topological Sort","slug":"topological-sort","date":"2023-05-29T02:05:49.000Z","updated":"2023-10-04T07:41:06.739Z","comments":true,"path":"2023/05/29/topological-sort/","link":"","permalink":"https://leopol1d.github.io/2023/05/29/topological-sort/","excerpt":"","text":"模板 首先通过Map创建图graph，graph的key是节点，graph的value是节点key后继的集合；一般如下定义 1Map&lt;Character, Set&lt;Character&gt;&gt; graph = new HashMap&lt;&gt;(); 创建一个节点映射其入度的Map；一般如下定义 1Map&lt;Character, Integer&gt; inDegrees = new HashMap&lt;&gt;(); 初始化graph的节点，把每个节点都加入图中；初始化inDegrees 123456for (String word : words) &#123; for (char ch : word.toCharArray()) &#123; graph.putIfAbsent(ch, new HashSet&lt;&gt;()); inDegrees.putIfAbsent(ch, 0); &#125;&#125; 初始化graph的边，同时计算入度 12345678910111213for (int i = 1; i &lt; words.length; ++i) &#123; String word1 = words[i - 1], word2 = words[i]; for (int j = 0; j &lt; word1.length() &amp;&amp; j &lt; word2.length(); ++j) &#123; char ch1 = word1.charAt(j), ch2 = word2.charAt(j); if (ch1 != ch2) &#123; if (!graph.get(ch1).contains(ch2)) &#123; graph.get(ch1).add(ch2); inDegrees.put(ch2, inDegrees.get(ch2) + 1); &#125; break; &#125; &#125;&#125; 创建队列，并把入度为0的节点加入队列 1234Queue&lt;Character&gt; queue = new LinkedList&lt;&gt;();for (char key : inDegrees.keySet()) if (inDegrees.get(key) == 0) queue.offer(key); 创建一个记录结果的容器，每次从queue中取出一个节点，把该节点加入结果集，并将该节点后继的入度减一，如果该节点后继的入度为0，则加入队列 12345678910StringBuilder sb = new StringBuilder(); while (!queue.isEmpty()) &#123; char node = queue.poll(); sb.append(node); for (char next : graph.get(node)) &#123; inDegrees.put(next, inDegrees.get(next) - 1); if (inDegrees.get(next) == 0) queue.offer(next); &#125; &#125; 如果结果集包含所有节点，则是有向无环图 207. 课程表 方法一：拓扑排序 123456789101112131415161718192021222324252627class Solution &#123; public boolean canFinish(int numCourses, int[][] prerequisites) &#123; // key表示先修的课程，value表示list中的课程需要先修key Map&lt;Integer, List&lt;Integer&gt;&gt; graph = new HashMap&lt;&gt;(); for (int i = 0; i &lt; numCourses; ++i) graph.put(i, new LinkedList&lt;&gt;()); int[] inDegrees = new int[numCourses]; for (int[] arr : prerequisites) &#123; graph.get(arr[1]).add(arr[0]); ++inDegrees[arr[0]]; &#125; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; numCourses; ++i) if (inDegrees[i] == 0) queue.offer(i); List&lt;Integer&gt; order = new ArrayList&lt;&gt;(); while (!queue.isEmpty()) &#123; int node = queue.poll(); order.add(node); for (int next : graph.get(node)) &#123; if (--inDegrees[next] == 0) queue.offer(next); &#125; &#125; return order.size() == numCourses ? true : false; &#125;&#125; 210. 课程表 II 方法一：拓扑排序 1234567891011121314151617181920212223242526class Solution &#123; public int[] findOrder(int numCourses, int[][] prerequisites) &#123; Map&lt;Integer, List&lt;Integer&gt;&gt; graph = new HashMap&lt;&gt;(); for (int i = 0; i &lt; numCourses; ++i) graph.put(i, new LinkedList&lt;&gt;()); int[] inDegrees = new int[numCourses]; for (int[] arr : prerequisites) &#123; graph.get(arr[1]).add(arr[0]); ++inDegrees[arr[0]]; &#125; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; numCourses; ++i) if (inDegrees[i] == 0) queue.offer(i); List&lt;Integer&gt; order = new ArrayList&lt;&gt;(); while (!queue.isEmpty()) &#123; int node = queue.poll(); order.add(node); for (int next : graph.get(node)) &#123; if (--inDegrees[next] == 0) queue.offer(next); &#125; &#125; return order.size() == numCourses ? order.stream().mapToInt(i-&gt;i).toArray() : new int[0]; &#125;&#125; 剑指 Offer II 114. 外星文字典 方法一：拓扑排序 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123; public String alienOrder(String[] words) &#123; Map&lt;Character, Set&lt;Character&gt;&gt; graph = new HashMap&lt;&gt;(); Map&lt;Character, Integer&gt; inDegrees = new HashMap&lt;&gt;(); for (String word : words) &#123; for (char ch : word.toCharArray()) &#123; graph.putIfAbsent(ch, new HashSet&lt;&gt;()); inDegrees.putIfAbsent(ch, 0); &#125; &#125; for (int i = 1; i &lt; words.length; ++i) &#123; String word1 = words[i - 1], word2 = words[i]; if (word1.startsWith(word2) &amp;&amp; !word1.equals(word2)) return &quot;&quot;; for (int j = 0; j &lt; word1.length() &amp;&amp; j &lt; word2.length(); ++j) &#123; char ch1 = word1.charAt(j), ch2 = word2.charAt(j); if (ch1 != ch2) &#123; if (!graph.get(ch1).contains(ch2)) &#123; graph.get(ch1).add(ch2); inDegrees.put(ch2, inDegrees.get(ch2) + 1); &#125; break; &#125; &#125; &#125; Queue&lt;Character&gt; queue = new LinkedList&lt;&gt;(); for (char key : inDegrees.keySet()) if (inDegrees.get(key) == 0) queue.offer(key); StringBuilder sb = new StringBuilder(); while (!queue.isEmpty()) &#123; char node = queue.poll(); sb.append(node); for (char next : graph.get(node)) &#123; inDegrees.put(next, inDegrees.get(next) - 1); if (inDegrees.get(next) == 0) queue.offer(next); &#125; &#125; return sb.length() == inDegrees.size() ? sb.toString() : &quot;&quot;; &#125;&#125; 剑指 Offer II 115. 重建序列 方法一：拓扑排序 判断有向图的拓扑排序序列是否唯一 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public boolean sequenceReconstruction(int[] nums, int[][] sequences) &#123; Map&lt;Integer, Set&lt;Integer&gt;&gt; graph = new HashMap&lt;&gt;(); Map&lt;Integer, Integer&gt; inDegrees = new HashMap&lt;&gt;(); for (int[] seq : sequences) &#123; for (int i = 0; i &lt; seq.length; ++i) &#123; graph.putIfAbsent(seq[i], new HashSet&lt;&gt;()); inDegrees.putIfAbsent(seq[i], 0); &#125; &#125; for (int[] seq : sequences) &#123; for (int i = 1; i &lt; seq.length; ++i) &#123; int num1 = seq[i - 1], num2 = seq[i]; if (!graph.get(num1).contains(num2)) &#123; graph.get(num1).add(num2); inDegrees.put(num2, inDegrees.get(num2) + 1); &#125; &#125; &#125; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); for (int node : inDegrees.keySet()) if (inDegrees.get(node) == 0) queue.offer(node); List&lt;Integer&gt; order = new LinkedList&lt;&gt;(); while (queue.size() == 1) &#123; int node = queue.poll(); order.add(node); for (int next : graph.get(node)) &#123; inDegrees.put(next, inDegrees.get(next) - 1); if (inDegrees.get(next) == 0) queue.offer(next); &#125; &#125; int[] res = order.stream().mapToInt(i-&gt;i).toArray(); return Arrays.equals(res, nums); &#125;&#125; 二刷 返回queue.isEmpty();就好，如下例，节点1和3的入度都为0，queue.size()为二，不进入while(queue.size() == 1)，此时queue中有1和3，不为空，所以返回false 12345输入：nums = [1,2,3], sequences = [[1,2]]输出：false解释：最短可能的超序列为 [1,2]。序列 [1,2] 是它的子序列：[1,2]。因为 nums 不是最短的超序列，所以返回false。 代码 123456789101112131415161718192021222324252627282930class Solution &#123; public boolean sequenceReconstruction(int[] nums, int[][] sequences) &#123; int n = nums.length; Map&lt;Integer, List&lt;Integer&gt;&gt; graph = new HashMap&lt;&gt;(); Map&lt;Integer, Integer&gt; inDegrees = new HashMap&lt;&gt;(); for (int i = 0; i &lt; n; ++i) &#123; graph.putIfAbsent(nums[i], new LinkedList&lt;&gt;()); inDegrees.putIfAbsent(nums[i], 0); &#125; for (int[] sequence : sequences) &#123; for (int i = 1; i &lt; sequence.length; ++i) &#123; graph.get(sequence[i - 1]).add(sequence[i]); inDegrees.put(sequence[i], inDegrees.get(sequence[i]) + 1); &#125; &#125; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); for (int key : inDegrees.keySet()) if (inDegrees.get(key) == 0) queue.offer(key); while (queue.size() == 1) &#123; int node = queue.poll(); for (int next : graph.get(node)) &#123; inDegrees.put(next, inDegrees.get(next) - 1); if (inDegrees.get(next) == 0) queue.offer(next); &#125; &#125; return queue.isEmpty(); &#125;&#125; 三刷 inDegrees换成数组 12345678910111213141516171819202122232425262728class Solution &#123; public boolean sequenceReconstruction(int[] nums, int[][] sequences) &#123; int n = nums.length; Map&lt;Integer, List&lt;Integer&gt;&gt; graph = new HashMap&lt;&gt;(); int[] inDegrees = new int[n + 1]; for (int i = 0; i &lt; n; ++i) graph.putIfAbsent(nums[i], new LinkedList&lt;&gt;()); for (int[] sequence : sequences) &#123; for (int i = 1; i &lt; sequence.length; ++i) &#123; graph.get(sequence[i - 1]).add(sequence[i]); ++inDegrees[sequence[i]]; &#125; &#125; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); for (int i = 1; i &lt;= n; ++i) if (inDegrees[i] == 0) queue.offer(i); while (queue.size() == 1) &#123; int node = queue.poll(); for (int next : graph.get(node)) &#123; --inDegrees[next]; if (inDegrees[next] == 0) queue.offer(next); &#125; &#125; return queue.isEmpty(); &#125;&#125; 310. 最小高度树 方法一：拓扑排序 此题的思路是：找到所有边缘上的节点，然后一层一层删除，直到队列为空，那队列中最后的值就是答案了。比如样例1：边缘的节点为0，2，3，删除后就只剩下1了。不难发现，边缘的节点就是度数为1的节点。 定义graph时为空，需要初始化每一个List 1List&lt;Integer&gt;[] graph = new List[n]; 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public List&lt;Integer&gt; findMinHeightTrees(int n, int[][] edges) &#123; if (n == 1) return Arrays.asList(0); List&lt;Integer&gt;[] graph = new List[n]; for (int i = 0; i &lt; n; ++i) graph[i] = new ArrayList&lt;&gt;(); int[] degree = new int[n]; for (int[] edge : edges) &#123; int node1 = edge[0], node2 = edge[1]; graph[node1].add(node2); graph[node2].add(node1); ++degree[node1]; ++degree[node2]; &#125; Queue&lt;Integer&gt; queue = new ArrayDeque&lt;&gt;(); for (int i = 0; i &lt; n; ++i) if (degree[i] == 1) queue.offer(i); List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); while (!queue.isEmpty()) &#123; res = new ArrayList&lt;&gt;(); int size = queue.size(); for (int i = 0; i &lt; size; ++i) &#123; int node = queue.poll(); res.add(node); for (int next : graph[node]) &#123; if (--degree[next] == 1) queue.offer(next); &#125; &#125; &#125; return res; &#125;&#125; 二刷 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public List&lt;Integer&gt; findMinHeightTrees(int n, int[][] edges) &#123; if (n == 1) return Arrays.asList(0); List&lt;Integer&gt; res = new LinkedList&lt;&gt;(); Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); Map&lt;Integer, List&lt;Integer&gt;&gt; graph = new HashMap&lt;&gt;(); int[] degrees = new int[n]; for (int i = 0; i &lt; n; ++i) graph.put(i, new LinkedList&lt;&gt;()); for (int[] edge : edges) &#123; int from = edge[0], to = edge[1]; graph.get(from).add(to); graph.get(to).add(from); degrees[from]++; degrees[to]++; &#125; for (int i = 0; i &lt; n; i++) if (degrees[i] == 1) queue.offer(i); while (!queue.isEmpty()) &#123; res.clear(); int size = queue.size(); for (int i = 0; i &lt; size; i++) &#123; int node = queue.poll(); res.add(node); for (int next : graph.get(node)) &#123; if (--degrees[next] == 1) queue.offer(next); &#125; &#125; &#125; return res; &#125;&#125; 802. 找到最终的安全状态 方法一：拓扑排序 找到所有不进入环的节点 求反向图，拓扑排序 入度为0的节点符合要求 12345678910111213141516171819202122232425262728293031class Solution &#123; public List&lt;Integer&gt; eventualSafeNodes(int[][] graph) &#123; int n = graph.length; List&lt;Integer&gt;[] adj = new List[n]; int[] indegrees = new int[n]; for (int i = 0; i &lt; n; ++i) &#123; adj[i] = new ArrayList&lt;&gt;(); &#125; for (int i = 0; i &lt; graph.length; ++i) &#123; for (int j = 0; j &lt; graph[i].length; ++j) &#123; adj[graph[i][j]].add(i); &#125; indegrees[i] = graph[i].length; &#125; Queue&lt;Integer&gt; queue = new ArrayDeque&lt;&gt;(); for (int i = 0; i &lt; n; ++i) if (indegrees[i] == 0) queue.offer(i); while (!queue.isEmpty()) &#123; int node = queue.poll(); for (int next : adj[node]) if (--indegrees[next] == 0) queue.offer(next); &#125; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n; ++i) if (indegrees[i] == 0) res.add(i); return res; &#125;&#125; 二刷 12345678910111213141516171819202122232425262728293031class Solution &#123; public List&lt;Integer&gt; eventualSafeNodes(int[][] g) &#123; Map&lt;Integer, List&lt;Integer&gt;&gt; graph = new HashMap&lt;&gt;(); int n = g.length; int[] outDegrees = new int[n]; for (int i = 0; i &lt; n; ++i) graph.put(i, new ArrayList&lt;&gt;()); for (int i = 0; i &lt; g.length; ++i) &#123; for (int j = 0; j &lt; g[i].length; ++j) &#123; graph.get(g[i][j]).add(i); outDegrees[i]++; &#125; &#125; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; n; ++i) if (outDegrees[i] == 0) queue.offer(i); while(!queue.isEmpty()) &#123; int node = queue.poll(); for (int next : graph.get(node)) &#123; if (--outDegrees[next] == 0) queue.offer(next); &#125; &#125; List&lt;Integer&gt; res = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; n; i++) if (outDegrees[i] == 0) res.add(i); return res; &#125;&#125; 2603. 收集树中金币 方法一：两次拓扑排序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123; public int collectTheCoins(int[] coins, int[][] edges) &#123; int n = edges.length + 1; List&lt;Integer&gt;[] g = new List[n]; Arrays.setAll(g, e -&gt; new ArrayList&lt;&gt;()); int[] degree = new int[n]; for (int[] edge : edges) &#123; int from = edge[0], to = edge[1]; g[from].add(to); g[to].add(from); ++degree[from]; ++degree[to]; &#125; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; n; ++i) if (degree[i] == 1 &amp;&amp; coins[i] == 0) queue.offer(i); while (!queue.isEmpty()) &#123; int node = queue.poll(); for (int next : g[node]) if (--degree[next] == 1 &amp;&amp; coins[next] == 0) queue.offer(next); &#125; for (int i = 0; i &lt; n; ++i) if (degree[i] == 1 &amp;&amp; coins[i] == 1) queue.offer(i); int[] times = new int[n]; int t = 1; while (!queue.isEmpty()) &#123; int size= queue.size(); for (int i = 0; i &lt; size; ++i) &#123; int node = queue.poll(); for (int next : g[node]) &#123; if (--degree[next] == 1) &#123; queue.offer(next); times[next] = t; &#125; &#125; &#125; ++t; &#125; int res = 0; for (int[] edge : edges) if (times[edge[0]] &gt;= 2 &amp;&amp; times[edge[1]] &gt;= 2) res += 2; return res; &#125;&#125; 2876. 有向图访问计数 方法一：拓扑排序 + 反向图 注意内向基环图可以包含多个环！！！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123; public int[] countVisitedNodes(List&lt;Integer&gt; g) &#123; int n = g.size(); int[] degree = new int[n]; List&lt;Integer&gt;[] rg = new List[n]; Arrays.setAll(rg, e -&gt; new ArrayList&lt;&gt;()); for (int i = 0; i &lt; n; ++i) &#123; int from = i, to = g.get(i); degree[to]++; rg[to].add(from); &#125; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; n; ++i) if (degree[i] == 0) queue.offer(i); while (!queue.isEmpty()) &#123; int node = queue.poll(); int next = g.get(node); if (--degree[next] == 0) queue.offer(next); &#125; int[] res = new int[n]; for (int i = 0; i &lt; n; ++i) &#123; if (degree[i] &lt;= 0) continue; List&lt;Integer&gt; ring = new ArrayList&lt;&gt;(); int j = i; while (true) &#123; ring.add(j); degree[j] = -1; j = g.get(j); if (j == i) break; &#125; for (int x : ring) dfs(x, ring.size(), rg, res, degree); &#125; return res; &#125; private void dfs(int x, int size, List&lt;Integer&gt;[] rg, int[] res, int[] degree) &#123; res[x] = size; for (int next : rg[x]) &#123; if (degree[next] == 0) dfs(next, size + 1, rg, res, degree); &#125; &#125;&#125; 2360. 图中的最长环 方法一：拓扑排序 + 基环树 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public int longestCycle(int[] g) &#123; int n = g.length; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); int[] degree = new int[n]; for (int i = 0; i &lt; n; ++i) &#123; if (g[i] != -1) degree[g[i]]++; &#125; for (int i = 0; i &lt; n; ++i) if (degree[i] == 0) queue.offer(i); while (!queue.isEmpty()) &#123; int node = queue.poll(); int next = g[node]; if (next == -1) continue; if (--degree[next] == 0) queue.offer(next); &#125; int res = -1; for (int i = 0; i &lt; n; ++i) &#123; if (degree[i]&lt;= 0) continue; degree[i] = -1; List&lt;Integer&gt; ring = new ArrayList&lt;&gt;(); ring.add(i); int next = g[i]; while (true) &#123; if (next == i) break; degree[next] = -1; ring.add(next); next = g[next]; &#125; if (ring.size() &gt; 0) res = Math.max(res, ring.size()); &#125; return res; &#125;&#125;","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://leopol1d.github.io/categories/Algorithms/"},{"name":"Graph","slug":"Algorithms/Graph","permalink":"https://leopol1d.github.io/categories/Algorithms/Graph/"}],"tags":[{"name":"图","slug":"图","permalink":"https://leopol1d.github.io/tags/%E5%9B%BE/"},{"name":"拓扑排序","slug":"拓扑排序","permalink":"https://leopol1d.github.io/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"}]},{"title":"Dynamic Programming","slug":"dynamic-programming","date":"2023-05-27T02:11:44.000Z","updated":"2023-09-20T07:40:14.447Z","comments":true,"path":"2023/05/27/dynamic-programming/","link":"","permalink":"https://leopol1d.github.io/2023/05/27/dynamic-programming/","excerpt":"","text":"自底向上的动态规划 509. 斐波那契数 方法一：暴搜 1234567891011class Solution &#123; public int fib(int n) &#123; return dfs(n); &#125; private int dfs(int index) &#123; if (index == 0 || index == 1) return index; return dfs(index - 1) + dfs(index - 2); &#125;&#125; 方法二：记忆化搜索 12345678910111213141516class Solution &#123; public int fib(int n) &#123; dp = new int[n + 1]; return dfs(n); &#125; int[] dp; private int dfs(int index) &#123; if (index == 0 || index == 1) return index; if (dp[index] != 0) return dp[index]; return dp[index] = dfs(index - 1) + dfs(index - 2); &#125;&#125; 方法三：DP 1234567891011class Solution &#123; public int fib(int n) &#123; if (n == 0 || n == 1) return n; int[] dp = new int[n + 1]; dp[1] = 1; for (int i = 2; i &lt;= n; ++i) dp[i] = dp[i - 2] + dp[i - 1]; return dp[n]; &#125;&#125; 方法四：DP + 滚动数组 1234567891011class Solution &#123; public int fib(int n) &#123; if (n == 0 || n == 1) return n; int[] dp = new int[3]; dp[1] = 1; for (int i = 2; i &lt;= n; ++i) dp[i % 3] = dp[(i - 2) % 3] + dp[(i - 1) % 3]; return dp[n % 3]; &#125;&#125; 198. 打家劫舍 方法一：暴搜 12345678910class Solution &#123; public int rob(int[] nums) &#123; return dfs(nums, nums.length - 1); &#125; private int dfs(int[] nums, int index) &#123; if (index == 0 || index &lt; 0) return index == 0 ? nums[0] : 0; return Math.max(dfs(nums, index - 2) + nums[index], dfs(nums, index - 1)); &#125;&#125; 方法二：记忆化搜索 123456789101112131415class Solution &#123; int[] dp; public int rob(int[] nums) &#123; dp = new int[nums.length]; Arrays.fill(dp, -1); return dfs(nums, nums.length - 1); &#125; private int dfs(int[] nums, int index) &#123; if (index == 0 || index &lt; 0) return index == 0 ? nums[0] : 0; if (dp[index] != -1) return dp[index]; return dp[index] = Math.max(dfs(nums, index - 2) + nums[index], dfs(nums, index - 1)); &#125;&#125; 方法三：DP 12345678910111213141516class Solution &#123; public int rob(int[] nums) &#123; // dp[i]：经过第i个房间能获得的最大价值 if (nums.length == 1) return nums[0]; if (nums.length == 2) return Math.max(nums[0], nums[1]); int[] dp = new int[nums.length]; dp[0] = nums[0]; dp[1] = Math.max(nums[0], nums[1]); for (int i = 2; i &lt; nums.length; ++i) &#123; dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]); &#125; return dp[nums.length - 1]; &#125;&#125; 方法四：DP + 滚动数组 12345678910111213141516class Solution &#123; public int rob(int[] nums) &#123; // dp[i]：经过第i个房间能获得的最大价值 if (nums.length == 1) return nums[0]; if (nums.length == 2) return Math.max(nums[0], nums[1]); int[] dp = new int[3]; dp[0] = nums[0]; dp[1] = Math.max(nums[0], nums[1]); for (int i = 2; i &lt; nums.length; ++i) &#123; dp[i % 3] = Math.max(dp[(i - 1) % 3], dp[(i - 2) % 3] + nums[i]); &#125; return dp[(nums.length - 1) % 3]; &#125;&#125; 64. 最小路径和 方法一：回溯 回溯一 123456789101112131415161718class Solution &#123; public int minPathSum(int[][] grid) &#123; dfs(grid, 0, 0, 0); return res; &#125; int res = 8000000; private void dfs(int[][] grid, int i, int j, int sum) &#123; if (i == grid.length || j == grid[0].length) return; sum += grid[i][j]; if (i == grid.length - 1 &amp;&amp; j == grid[0].length - 1) &#123; res = Math.min(res, sum); return; &#125; dfs(grid, i + 1, j, sum); dfs(grid, i, j + 1, sum); &#125;&#125; 回溯二 1234567891011121314151617class Solution &#123; public int minPathSum(int[][] grid) &#123; dfs(grid, 0, 0, 0); return res; &#125; int res = 8000000; private int dfs(int[][] grid, int i, int j, int sum) &#123; if (i == grid.length || j == grid[0].length) return 0; sum += grid[i][j]; if (i == grid.length - 1 &amp;&amp; j == grid[0].length - 1) &#123; res = Math.min(res, sum); return sum; &#125; return dfs(grid, i + 1, j, sum) + dfs(grid, i, j + 1, sum); &#125;&#125; 方法二：记忆化搜索 12345678910111213141516171819class Solution &#123; public int minPathSum(int[][] grid) &#123; dp = new int[grid.length][grid[0].length]; for (int[] arr : dp) Arrays.fill(arr, -1); return dfs(grid, 0, 0); &#125; int[][] dp; private int dfs(int[][] grid, int i, int j) &#123; if (i == grid.length || j == grid[0].length) return 8000000; if (dp[i][j] != -1) return dp[i][j]; if (i == grid.length - 1 &amp;&amp; j == grid[0].length - 1) &#123; return grid[i][j]; &#125; return dp[i][j] = grid[i][j] + Math.min(dfs(grid, i + 1, j), dfs(grid, i, j + 1)); &#125;&#125; 方法三：DP 12345678910111213141516171819class Solution &#123; public int minPathSum(int[][] grid) &#123; // dp[i][j]:走到grid[i][j]的最小路径 // 状态转移：dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] // 初始化：第0行和第0列 int[][] dp = new int[grid.length][grid[0].length]; dp[0][0] = grid[0][0]; for (int i = 1; i &lt; grid.length; ++i) dp[i][0] += dp[i - 1][0] + grid[i][0]; for (int j = 1; j &lt; grid[0].length; ++j) dp[0][j] += dp[0][j - 1] + grid[0][j]; for (int i = 1; i &lt; grid.length; ++i) &#123; for (int j = 1; j &lt; grid[0].length; ++j) &#123; dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]; &#125; &#125; return dp[grid.length - 1][grid[0].length - 1]; &#125;&#125; 62. 不同路径 方法一：回溯 123456789101112class Solution &#123; public int uniquePaths(int m, int n) &#123; return dfs(m, n, 1, 1); &#125; private int dfs(int m, int n, int i, int j) &#123; if (i == m + 1 || j == n + 1) return 0; if (i == m &amp;&amp; j == n) return 1; return dfs(m, n, i + 1, j) + dfs(m, n, i, j + 1); &#125;&#125; 方法二：记忆化搜索 12345678910111213141516class Solution &#123; public int uniquePaths(int m, int n) &#123; dp = new int[m + 1][n + 1]; return dfs(m, n, 1, 1); &#125; int[][] dp; private int dfs(int m, int n, int i, int j) &#123; if (i == m + 1 || j == n + 1) return 0; if (i == m &amp;&amp; j == n) return 1; if (dp[i][j] != 0) return dp[i][j]; return dp[i][j] = dfs(m, n, i + 1, j) + dfs(m, n, i, j + 1); &#125;&#125; 方法三：组合数学 res = res * i / j不能写成*=，因为可能i / j不为整数 12345678class Solution &#123; public int uniquePaths(int m, int n) &#123; long res = 1; for (int i = n, j = 1; j &lt; m; ++i, ++j) res = res * i / j; return (int) res; &#125;&#125; 方法四：DP 第0行第0列赋值1，反正后面都会被覆盖，干脆全赋值1 12for (int[] arr : dp) Arrays.fill(arr, 1); 123456789101112131415class Solution &#123; public int uniquePaths(int m, int n) &#123; if (m == 1 || n == 1) return 1; int[][] dp = new int[m][n]; for (int[] arr : dp) Arrays.fill(arr, 1); for (int i = 1; i &lt; m; ++i) &#123; for (int j = 1; j &lt; n; ++j) &#123; dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; &#125; &#125; return dp[m - 1][n - 1]; &#125;&#125; 方法五：DP + 滚动数组(两行) 边界都是1，所以可以滚动，不同路径那题不行 123456789101112131415class Solution &#123; public int uniquePaths(int m, int n) &#123; if (m == 1 || n == 1) return 1; int[][] dp = new int[2][n]; for (int[] arr : dp) Arrays.fill(arr, 1); for (int i = 1; i &lt; m; ++i) &#123; for (int j = 1; j &lt; n; ++j) &#123; dp[i % 2][j] = dp[(i - 1) % 2][j] + dp[i % 2][j - 1]; &#125; &#125; return dp[(m - 1) % 2][n - 1]; &#125;&#125; 方法五：DP + 滚动数组(一行) 这里把数组全部初始化为1，是为了模拟第0行 1234567891011121314class Solution &#123; public int uniquePaths(int m, int n) &#123; if (m == 1 || n == 1) return 1; int[] dp = new int[n]; Arrays.fill(dp, 1); for (int i = 1; i &lt; m; ++i) &#123; for (int j = 1; j &lt; n; ++j) &#123; dp[j] += + dp[j - 1]; &#125; &#125; return dp[n - 1]; &#125;&#125; 63. 不同路径 II 方法一：回溯 1234567891011121314class Solution &#123; public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123; int m = obstacleGrid.length, n = obstacleGrid[0].length; return dfs(obstacleGrid, m, n, 0, 0); &#125; private int dfs(int[][] obstacleGrid, int m, int n, int i, int j) &#123; if (i == m || j == n || obstacleGrid[i][j] == 1) return 0; if (i == m - 1 &amp;&amp; j == n - 1) return 1; return dfs(obstacleGrid, m, n, i + 1, j) + dfs(obstacleGrid, m, n, i, j + 1); &#125;&#125; 方法二：记忆化搜索 12345678910111213141516171819class Solution &#123; public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123; int m = obstacleGrid.length, n = obstacleGrid[0].length; dp = new int[m][n]; for (int[] arr : dp) Arrays.fill(arr, -1); return dfs(obstacleGrid, m, n, 0, 0); &#125; int[][] dp; private int dfs(int[][] obstacleGrid, int m, int n, int i, int j) &#123; if (i == m || j == n || obstacleGrid[i][j] == 1) return 0; if (i == m - 1 &amp;&amp; j == n - 1) return 1; if (dp[i][j] != -1) return dp[i][j]; return dp[i][j] = dfs(obstacleGrid, m, n, i + 1, j) + dfs(obstacleGrid, m, n, i, j + 1); &#125;&#125; 方法三：DP 123456789101112131415161718192021222324class Solution &#123; public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123; int m = obstacleGrid.length, n = obstacleGrid[0].length; int[][] dp = new int[m][n]; for (int i = 0; i &lt; m; ++i) &#123; if (obstacleGrid[i][0] == 1) break; dp[i][0] = 1; &#125; for (int j = 0; j &lt; n; ++j) &#123; if (obstacleGrid[0][j] == 1) break; dp[0][j] = 1; &#125; for (int i = 1; i &lt; m; ++i) &#123; for (int j = 1; j &lt; n; ++j) &#123; if (obstacleGrid[i][j] == 1) continue; dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; &#125; &#125; return dp[m - 1][n - 1]; &#125;&#125; 方法五：DP + 滚动数组 123456789101112131415161718class Solution &#123; public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123; int m = obstacleGrid.length, n = obstacleGrid[0].length; int[] dp = new int[n]; dp[0] = obstacleGrid[0][0] == 1 ? 0 : 1; for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (obstacleGrid[i][j] == 1) &#123; dp[j] = 0; continue; &#125; if (j &gt;= 1 &amp;&amp; obstacleGrid[i][j - 1] == 0) dp[j] += dp[j - 1]; &#125; &#125; return dp[n - 1]; &#125;&#125; 980. 不同路径 III 方法一：回溯 先放错误版本，debug1个多小时 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123; public int uniquePathsIII(int[][] grid) &#123; this.grid = grid; m = grid.length; n = grid[0].length; int[] oriIndex = null; int left = 0; for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (grid[i][j] == 0) ++left; else if (grid[i][j] == 1) oriIndex = new int[]&#123;i, j&#125;; &#125; &#125; return dfs(oriIndex[0], oriIndex[1], left + 1); &#125; private int dfs(int i, int j, int left) &#123; if (grid[i][j] == 2) return left == 0 ? 1 : 0; int res = 0; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col) &amp;&amp; grid[row][col] != -1) &#123; int temp1 = grid[row][col]; grid[row][col] = -1; res += dfs(row, col, left - 1); grid[row][col] = temp1; &#125; &#125; return res; &#125; private boolean isValid(int i, int j) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125; int[][] grid, dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;;; int m, n;&#125; 在错误版本中，是将邻居grid[row][col] = -1;置为以访问状态，那么从i ，j递归到 row, col又可以递归回i,j所以left的次数一定是错的 回溯正确版本 将i,j置为以访问状态 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public int uniquePathsIII(int[][] grid) &#123; this.grid = grid; m = grid.length; n = grid[0].length; int[] oriIndex = null; int left = 0; for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (grid[i][j] == 0) ++left; else if (grid[i][j] == 1) oriIndex = new int[]&#123;i, j&#125;; &#125; &#125; return dfs(oriIndex[0], oriIndex[1], left + 1); &#125; private int dfs(int i, int j, int left) &#123; if (grid[i][j] == 2) return left == 0 ? 1 : 0; int res = 0, temp = grid[i][j]; grid[i][j] = -1; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col) &amp;&amp; (grid[row][col] == 0 || grid[row][col] == 2)) &#123; res += dfs(row, col, left - 1); &#125; &#125; grid[i][j] = temp; return res; &#125; private boolean isValid(int i, int j) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125; int[][] grid, dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;;; int m, n;&#125; 118. 杨辉三角 方法一：DP 最后一行的长度是2n - 1 123456789101112131415161718class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); int[][] dp = new int[numRows][numRows * 2 + 1]; dp[0][dp[0].length / 2] = 1; res.add(new LinkedList&lt;&gt;(Arrays.asList(1))); for (int i = 1; i &lt; numRows; ++i) &#123; List&lt;Integer&gt; list = new LinkedList&lt;&gt;(); for (int j = 0; j &lt; dp[0].length; ++j) &#123; dp[i][j] = (j &lt; dp[0].length - 1 ? dp[i - 1][j + 1] : 0) + (j &gt;= 1 ? dp[i - 1][j - 1] : 0); if (dp[i][j] != 0) list.add(dp[i][j]); &#125; res.add(list); &#125; return res; &#125;&#125; 方法二：DP 第一列与最后一列是1 1234567891011121314151617181920212223242526class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123; /* 1 1 1 1 2 1 1 3 3 1 */ List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); List&lt;Integer&gt; row = new LinkedList&lt;&gt;(); // 第一行 row.add(1); res.add(row); for (int i = 2; i &lt;= numRows; ++i) &#123; row = new LinkedList&lt;&gt;(); // 第一列 row.add(1); for (int j = 1; j &lt; i - 1; ++j) row.add(res.get(i - 2).get(j - 1) + res.get(i - 2).get(j)); // 最后一列 row.add(1); res.add(row); // 在res中的下标为i - 1 &#125; return res; &#125;&#125; 120. 三角形最小路径和 二刷回溯 123456789101112131415161718class Solution &#123; public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123; /* 2 3 4 6 5 7 4 1 8 3 */ return dfs(triangle, 0, 0); &#125; private int dfs(List&lt;List&lt;Integer&gt;&gt; triangle, int i, int j) &#123; if (i == triangle.size()) return 0; return triangle.get(i).get(j) + Math.min(dfs(triangle, i + 1, j), dfs(triangle, i + 1, j + 1)); &#125;&#125; 二刷记忆化搜索 123456789101112131415161718192021222324class Solution &#123; public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123; /* 2 3 4 6 5 7 4 1 8 3 */ dp = new int[triangle.size()][triangle.size()]; for (int[] arr : dp) Arrays.fill(arr, 10001); return dfs(triangle, 0, 0); &#125; int[][] dp; private int dfs(List&lt;List&lt;Integer&gt;&gt; triangle, int i, int j) &#123; if (i == triangle.size()) return 0; if (dp[i][j] != 10001) return dp[i][j]; return dp[i][j] = triangle.get(i).get(j) + Math.min(dfs(triangle, i + 1, j), dfs(triangle, i + 1, j + 1)); &#125;&#125; 二刷DP dp数组多创建一列，把dp数组初始化为10001，处理第一列没有左上方元素与最后一列没有正上方元素的特殊情况 1int[][] dp = new int[triangle.size()][triangle.size() + 1]; 代码 1234567891011121314151617181920212223242526class Solution &#123; public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123; /* 2 3 4 6 5 7 4 1 8 3 */ if (triangle.size() == 1) return triangle.get(0).get(0); // dp[i][j]：到达i，j的最短距离 int[][] dp = new int[triangle.size()][triangle.size() + 1]; int min = 10001; for (int[] arr : dp) Arrays.fill(arr, 10001); dp[0][1] = triangle.get(0).get(0); for (int i = 1; i &lt; triangle.size(); ++i) &#123; for (int j = 0; j &lt; triangle.get(i).size(); ++j) &#123; dp[i][j + 1] = Math.min(dp[i - 1][j], dp[i - 1][j + 1]) + triangle.get(i).get(j); if (i == triangle.size() - 1) min = Math.min(min, dp[i][j + 1]); &#125; &#125; return min; &#125;&#125; 从最后一行开始遍历 12345678910111213141516171819class Solution &#123; public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123; /* 2 3 4 6 5 7 4 1 8 3 */ // dp[i][j]：到达i，j的最短距离 int n = triangle.size(); int[][] dp = new int[n + 1][n + 1]; for (int i = n - 1; i &gt;= 0; --i) &#123; for (int j = 0; j &lt;= i; ++j) &#123; dp[i][j] = Math.min(dp[i + 1][j], dp[i + 1][j + 1]) + triangle.get(i).get(j); &#125; &#125; return dp[0][0]; &#125;&#125; 方法一：回溯 1234567891011121314151617181920class Solution &#123; public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123; int n = triangle.size(); int[][] list = new int[n][n]; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; i + 1; ++j) &#123; list[i][j] = triangle.get(i).get(j); &#125; &#125; return dfs(list, n, 0, 0); &#125; private int dfs(int[][] list, int n, int i, int j) &#123; if (j &gt; i) return 0; if (i == n - 1) return list[i][j]; return Math.min(dfs(list, n, i + 1, j), dfs(list, n, i + 1, j + 1)) + list[i][j]; &#125;&#125; 方法二：记忆化搜索一 12345678910111213141516171819202122232425class Solution &#123; public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123; int n = triangle.size(); int[][] list = new int[n][n]; dp = new int[n][n]; for (int[] arr : dp) Arrays.fill(arr, Integer.MAX_VALUE); for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; i + 1; ++j) &#123; list[i][j] = triangle.get(i).get(j); &#125; &#125; return dfs(list, n, 0, 0); &#125; int[][] dp; private int dfs(int[][] list, int n, int i, int j) &#123; if (j &gt; i) return 0; if (i == n - 1) return list[i][j]; if (dp[i][j] != Integer.MAX_VALUE) return dp[i][j]; return dp[i][j] = Math.min(dfs(list, n, i + 1, j), dfs(list, n, i + 1, j + 1)) + list[i][j]; &#125;&#125; 优化记忆化搜索 只改动了base case i == n-1就直接返回，会使最后一次dp信息漏掉，如果最后一行很长，那么会多进入dfs很多次 注意最后一行 12345678910111213141516171819202122232425class Solution &#123; public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123; int n = triangle.size(); int[][] list = new int[n][n]; dp = new int[n][n]; for (int[] arr : dp) Arrays.fill(arr, Integer.MAX_VALUE); for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; i + 1; ++j) &#123; list[i][j] = triangle.get(i).get(j); &#125; &#125; return dfs(list, n, 0, 0); &#125; int[][] dp; private int dfs(int[][] list, int n, int i, int j) &#123; if (j &gt; i) return 0; if (i == n) return 0; if (dp[i][j] != Integer.MAX_VALUE) return dp[i][j]; return dp[i][j] = Math.min(dfs(list, n, i + 1, j), dfs(list, n, i + 1, j + 1)) + list[i][j]; &#125;&#125; 方法三：DP 1234567891011121314151617181920212223class Solution &#123; public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123; int n = triangle.size(); int[][] dp = new int[n][n]; for (int[] arr : dp) Arrays.fill(arr, Integer.MAX_VALUE); int res = Integer.MAX_VALUE; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; i + 1; ++j) &#123; int pre = 0; if (i &gt;= 1) &#123; pre = dp[i - 1][j]; if (j &gt;= 1) pre = Math.min(pre, dp[i - 1][j - 1]); &#125; dp[i][j] = triangle.get(i).get(j) + pre; if (i == n - 1) res = Math.min(res, dp[i][j]); &#125; &#125; return res; &#125;&#125; 方法四：DP + 滚动数组 和01背包类似，第二次for循环要倒序遍历；如果正序遍历那么pre = dp[j]拿到的是第i行的数据，我们需要的是第i-1行的数据 12345678910111213141516171819202122class Solution &#123; public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123; int n = triangle.size(); int[] dp = new int[n]; Arrays.fill(dp, 1000000); int res = Integer.MAX_VALUE; for (int i = 0; i &lt; n; ++i) &#123; for (int j = i; j &gt;= 0; --j) &#123; int pre = 0; if (i &gt;= 1) &#123; pre = dp[j]; if (j &gt;= 1) pre = Math.min(pre, dp[j - 1]); &#125; dp[j] = triangle.get(i).get(j) + pre; if (i == n - 1) res = Math.min(res, dp[j]); &#125; &#125; return res; &#125;&#125; 279. 完全平方数 完全背包问题 方法一：DP 1234567891011121314151617181920class Solution &#123; public int numSquares(int n) &#123; int m = (int) Math.sqrt(n); int[] nums = new int[m]; for (int i = 0; i &lt; m; ++i) &#123; nums[i] = (i + 1) * (i + 1); &#125; // dp[j]:容量为j的背包最少需要多少个数字填满 // dp[0] = 0 int[] dp = new int[n + 1]; for (int i = 1; i &lt; dp.length; ++i) dp[i] = 10001; for (int i = 0; i &lt; nums.length; ++i) &#123; for (int j = nums[i]; j &lt;= n; ++j) &#123; dp[j] = Math.min(dp[j], dp[j - nums[i]] + 1); &#125; &#125; return dp[n]; &#125;&#125; 377. 组合总和 Ⅳ 思路： 排列问题 爬楼梯问题 方法一：DP 1234567891011121314151617class Solution &#123; public int combinationSum4(int[] nums, int target) &#123; // dp[i]:组成i的排列种数 // dp[i] += dp[i - nums[j]] // dp[0] = 1，后面状态根据1往上加 int[] dp = new int[target + 1]; dp[0] = 1; for (int i = 1; i &lt;= target; ++i) &#123; for (int j = 0; j &lt; nums.length; ++j) &#123; if (i &gt;= nums[j]) &#123; dp[i] += dp[i - nums[j]]; &#125; &#125; &#125; return dp[target]; &#125;&#125; 如果要求返回所有排列数，如下 12345678910111213141516171819202122232425262728293031package 背包;import java.util.*;public class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum4(int[] nums, int target) &#123; backtracking(nums, target, 0); return res; &#125; private void backtracking(int[] nums, int target, int index) &#123; if (target == 0) &#123; res.add(new LinkedList&lt;&gt;(path)); return; &#125; for (int i = index; i &lt; nums.length; ++i) &#123; if (target &lt; nums[i]) break; path.offerLast(nums[i]); backtracking(nums, target - nums[i], index); path.pollLast(); &#125; &#125; public static void main(String[] args) &#123; Solution solution = new Solution(); System.out.println(solution.combinationSum4(new int[]&#123;1, 2, 3&#125;, 4)); &#125;&#125; 300. 最长递增子序列 方法一：DP 1234567891011121314151617class Solution &#123; public int lengthOfLIS(int[] nums) &#123; // dp[j]: 以下标j结尾的最长递增子序列的长度 int res = 1; int[] dp = new int[nums.length]; Arrays.fill(dp, 1); for (int i = 0; i &lt; nums.length; ++i) &#123; for (int j = i + 1; j &lt; nums.length; ++j) &#123; if (nums[j] &gt; nums[i]) &#123; dp[j] = Math.max(dp[j], dp[i] + 1); &#125; res = Math.max(res, dp[j]); &#125; &#125; return res; &#125;&#125; 二刷DP：从前往后 12345678910111213141516171819class Solution &#123; public int lengthOfLIS(int[] nums) &#123; if (nums.length == 1) return 1; // dp[i]：下标为i前的子数组的最长递增子序列的长度 int[] dp = new int[nums.length]; Arrays.fill(dp, 1); int res = 1; for (int i = 1; i &lt; nums.length; ++i) &#123; for (int j = 0; j &lt; i; ++j) &#123; if (nums[j] &lt; nums[i]) &#123; dp[i] = Math.max(dp[i], dp[j] + 1); res = Math.max(res, dp[i]); &#125; &#125; &#125; return res; &#125;&#125; 方法二：贪心 + 二分 674. 最长连续递增序列 方法一：暴力 12345678910111213141516171819class Solution &#123; public int findLengthOfLCIS(int[] nums) &#123; // dp[j]: 以下标j为结尾的子数组的长度 int res = 1; for (int i = 0; i &lt; nums.length; ++i) &#123; int length = 1; for (int j = i + 1; j &lt; nums.length; ++j) &#123; if (nums[j] &gt; nums[j - 1]) &#123; ++length; res = Math.max(res, length); &#125; else &#123; length = 1; &#125; &#125; &#125; return res; &#125;&#125; 方法二：DP 1234567891011121314151617class Solution &#123; public int findLengthOfLCIS(int[] nums) &#123; // dp[j]: 以下标j为结尾的最长连续递增序列的长度 // dp[j] = dp[j - 1] + 1 // dp[:] = 1 int[] dp = new int[nums.length]; Arrays.fill(dp, 1); int res = 1; for (int i = 1; i &lt; nums.length; ++i) &#123; if (nums[i] &gt; nums[i - 1]) &#123; dp[i] = dp[i - 1] + 1; res = Math.max(res, dp[i]); &#125; &#125; return res; &#125;&#125; 方法三：DP + 滚动数组 如果nums[i] &lt;= nums[i-1]，记得dp[i % 2] = 1; 1234567891011121314151617181920class Solution &#123; public int findLengthOfLCIS(int[] nums) &#123; // dp[j]: 以下标j为结尾的最长连续递增序列的长度 // dp[j] = dp[j - 1] + 1 // dp[:] = 1 int[] dp = new int[2]; Arrays.fill(dp, 1); int res = 1; for (int i = 1; i &lt; nums.length; ++i) &#123; if (nums[i] &gt; nums[i - 1]) &#123; dp[i % 2] = dp[(i - 1) % 2] + 1; res = Math.max(res, dp[i % 2]); &#125; else &#123; dp[i % 2] = 1; &#125; &#125; return res; &#125;&#125; 718. 最长重复子数组 动动脑子吧你 方法一：暴力 时间复杂度：$O(m^2n)$ 空间复杂度：$O(1)$ 123456789101112131415161718class Solution &#123; public int findLength(int[] nums1, int[] nums2) &#123; int res = 0; for (int i = 0; i &lt; nums1.length; ++i) &#123; for (int j = 0; j &lt; nums2.length; ++j) &#123; int count1 = i, count2 = j; int counter = 0; while (count1 &lt; nums1.length &amp;&amp; count2 &lt; nums2.length &amp;&amp; nums1[count1] == nums2[count2]) &#123; ++counter; ++count1; ++count2; &#125; res = Math.max(res, counter); &#125; &#125; return res; &#125;&#125; 方法二：DP dp[i][j]:以nums1[i - 1]结尾与以nums2[j - 1]结尾时的最长重复子数组 状态转移公式：当nums1[i - 1] == nums2[j - 1]时，dp[i][j] = dp[i - 1][j - 1] + 1 初始化：m为nums1的长度，n为nums2的长度，初始化(m + 1) * (n + 1)的二维数组，第一行第一列初始化为0，因为任一数组为空，就不会有重复子数组 注意事项：输出结果是dp数组中的最大值，因为最长的重复子数组不一定是在两数组的结尾处，可以在循环内比较 时间复杂度：$O(mn)$ 空间复杂度：$O(mn)$ 12345678910111213141516class Solution &#123; public int findLength(int[] nums1, int[] nums2) &#123; int m = nums1.length, n = nums2.length; int[][] dp = new int[m + 1][n + 1]; int result = 0; for (int i = 1; i &lt;= m; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; if (nums1[i - 1] == nums2[j - 1]) &#123; dp[i][j] = dp[i - 1][j - 1] + 1; result = Math.max(result, dp[i][j]); &#125; &#125; &#125; return result; &#125;&#125; 滚动数组缩减空间复杂度 dp数组为第二个数组的长度加一 不相等时要把dp[j]赋0，不然之后会出错 此时遍历第二个数组的时候，就要从后向前遍历，这样避免重复覆盖。 比如nums1 = [1, 2, 3, 1],nums2 = [1,6,8,1,3,1,2,3] i = 1时候，dp数组为[1,0,0,1,0,1,0,0] i = 2时候，dp数组为[0,0,0,0,0,0,1,0] i = 3时候，dp数组为[0,0,0,0,1,0,0,2] i=3时，如果第二层for循环j从前往后遍历，那么dp倒数第二个位置会因为3!=2，被赋0，进而导致dp最后一个位置是1而不是2 123456789101112131415161718class Solution &#123; public int findLength(int[] nums1, int[] nums2) &#123; int[] dp = new int[nums2.length + 1]; int res = 0; for (int i = 1; i &lt;= nums1.length; ++i) &#123; for (int j = nums2.length; j &gt; 0; --j) &#123; if (nums1[i - 1] == nums2[j - 1]) &#123; dp[j] = dp[j - 1] + 1; &#125; else &#123; dp[j] = 0; &#125; res = Math.max(res, dp[j]); &#125; &#125; return res; &#125;&#125; 1143. 最长公共子序列 方法三：滚动数组(一行) 用pre记录左上角的值 计算当前值之前，先用temp保存dp[j + 1]，计算完dp[j + 1]，将temp赋值给pre 123456789101112131415161718192021class Solution &#123; public int longestCommonSubsequence(String s, String t) &#123; int m = s.length(), n = t.length(); // dp[i][j]: s[:i]与t[:j]的最长公共子序列长度 // if s[i] == t[j]: dp[i][j] = 1 + dp[i - 1][j - 1] // else dp[i][j] = max(dp[i][j - 1], dp[i - 1][j]) int[] dp = new int[n + 1]; for (int i = 0; i &lt; m; ++i) &#123; int pre = 0; for (int j = 0; j &lt; n; ++j) &#123; int temp = dp[j + 1]; if (s.charAt(i) == t.charAt(j)) dp[j + 1] = pre + 1; else dp[j + 1] = Math.max(dp[j], dp[j + 1]); pre = temp; &#125; &#125; return dp[n]; &#125;&#125; 方法一：DP 1234567891011121314151617class Solution &#123; public int longestCommonSubsequence(String text1, String text2) &#123; // dp[i][j]: text1以i为结尾，text2以j为结尾的最长公共子序列长度 // text[i - 1] == text[j - 1]:dp[i][j] = dp[i - 1][j - 1] + 1 // text[i - 1] != text[j - 1]:dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) int[][] dp = new int[text1.length() + 1][text2.length() + 1]; for (int i = 1; i &lt;= text1.length(); ++i) &#123; for (int j = 1; j &lt;= text2.length(); ++j) &#123; if (text1.charAt(i - 1) == text2.charAt(j - 1)) dp[i][j] = dp[i - 1][j - 1] + 1; else dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]); &#125; &#125; return dp[text1.length()][text2.length()]; &#125;&#125; 方法二：DP + 滚动数组(两行) 12345678910111213141516171819class Solution &#123; public int longestCommonSubsequence(String text1, String text2) &#123; // dp[i][j]: text1以i为结尾，text2以j为结尾的最长公共子序列长度 // text[i - 1] == text[j - 1]:dp[i][j] = dp[i - 1][j - 1] + 1 // text[i - 1] != text[j - 1]:dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) int[][] dp = new int[2][text2.length() + 1]; for (int i = 1; i &lt;= text1.length(); ++i) &#123; for (int j = 1; j &lt;= text2.length(); ++j) &#123; if (text1.charAt(i - 1) == text2.charAt(j - 1)) &#123; dp[i % 2][j] = dp[(i - 1) % 2][j - 1] + 1; &#125; else &#123; dp[i % 2][j] = Math.max(dp[i % 2][j - 1], dp[(i - 1) % 2][j]); &#125; &#125; &#125; return dp[text1.length() % 2][text2.length()]; &#125;&#125; 583. 两个字符串的删除操作 方法一：最长公共子序列 代码和最长公共子序列一模一样，只是返回值不同 找出最长公共子序列长度为x，然后用word1的长度 + word2的长度 - x 1234567891011121314151617181920class Solution &#123; public int minDistance(String text1, String text2) &#123; // dp[i][j]: text1以i为结尾，text2以j为结尾的最长公共子序列长度 // text[i - 1] == text[j - 1]:dp[i][j] = dp[i - 1][j - 1] + 1 // text[i - 1] != text[j - 1]:dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) int[][] dp = new int[2][text2.length() + 1]; for (int i = 1; i &lt;= text1.length(); ++i) &#123; for (int j = 1; j &lt;= text2.length(); ++j) &#123; if (text1.charAt(i - 1) == text2.charAt(j - 1)) &#123; dp[i % 2][j] = dp[(i - 1) % 2][j - 1] + 1; &#125; else &#123; dp[i % 2][j] = Math.max(dp[i % 2][j - 1], dp[(i - 1) % 2][j]); &#125; &#125; &#125; // return dp[text1.length() % 2][text2.length()]; return text1.length() + text2.length() - dp[text1.length() % 2][text2.length()] * 2; &#125;&#125; 方法二：DP dp[i][j]：使得以i为结尾的子串sub1与以j为结尾的子串sub2相同所需的最少删除次数 m为word1的长度，n为word2的长度，创建大小为(m + 1) * (n + 1)大小的dp数组，首先需要初始化第0行与第0列，初始化第0行表示使为空字符串的sub1与长度为j的子串sub2相同所需的最少删除次数，举例word1 = “sea”，word2 = “eeat”，空字符串与空字符串：0，空字符串与“e”：1，空字符串与“ee”：2，空字符串与“eea”：3，空字符串与“eeat”：4。 初始化第0列类似。以下为初始化dp数组 0 1 2 3 4 1 0 0 0 0 2 0 0 0 0 3 0 0 0 0 状态转移方程： 如果两个字符i、j相同，那么所需删除的次数和没加入这两个字符所需要的次数一致 12if (word1.charAt(i - 1) == word2.charAt(j - 1)) dp[i][j] = dp[i - 1][j - 1]; 如果两个字符i、j不同，所需删除的次数为如下 1dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + 1; 12345678910111213141516171819class Solution &#123; public int minDistance(String word1, String word2) &#123; int m = word1.length(), n = word2.length(); int[][] dp = new int[m + 1][n + 1]; for (int j = 0; j &lt;= n; ++j) dp[0][j] = j; for (int i = 0; i &lt;= m; ++i) dp[i][0] = i; for (int i = 1; i &lt;= m; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; if (word1.charAt(i - 1) == word2.charAt(j - 1)) dp[i][j] = dp[i - 1][j - 1]; else dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + 1; &#125; &#125; return dp[m][n]; &#125;&#125; 72. 编辑距离 优质题解 方法一：DP 1234567891011121314151617181920class Solution &#123; public int minDistance(String word1, String word2) &#123; int m = word1.length(), n = word2.length(); int[][] dp = new int[m + 1][n + 1]; for (int i = 1; i &lt;= m; ++i) dp[i][0] = dp[i - 1][0] + 1; for (int j = 1; j &lt;= n; ++j) dp[0][j] = dp[0][j - 1] + 1; for (int i = 1; i &lt;= m; ++i) &#123; char ch1 = word1.charAt(i - 1); for (int j = 1; j &lt;= n; ++j) &#123; if (ch1 != word2.charAt(j - 1)) dp[i][j] = Math.min(Math.min(dp[i - 1][j - 1], dp[i - 1][j]), dp[i][j - 1]) + 1; else dp[i][j] = dp[i - 1][j - 1]; &#125; &#125; return dp[m][n]; &#125;&#125; 二刷DP 当 word1[i] == word2[j]，dp[i][j] = dp[i-1][j-1]； 当 word1[i] != word2[j]，dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1 其中，dp[i-1][j-1] 表示替换操作，dp[i-1][j] 表示删除操作，dp[i][j-1] 表示插入操作。 12345678910111213141516171819class Solution &#123; public int minDistance(String word1, String word2) &#123; int m = word1.length(), n = word2.length(); int[][] dp = new int[m + 1][n + 1]; for (int j = 1; j &lt;= n; ++j) dp[0][j] = j; for (int i = 1; i &lt;= m; ++i) dp[i][0] = i; for (int i = 1; i &lt;= m; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; if (word1.charAt(i - 1) == word2.charAt(j - 1)) dp[i][j] = dp[i - 1][j - 1]; else dp[i][j] = Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1; &#125; &#125; return dp[m][n]; &#125;&#125; 647. 回文子串 优质题解 二刷看的题解 状态：dp[i][j] 表示字符串s在[i,j]区间的子串是否是一个回文串。状态转移方程：当 s[i] == s[j] &amp;&amp; (j - i &lt; 2 || dp[i + 1][j - 1]) 时，dp[i][j]=true，否则为false 这个状态转移方程是什么意思呢？ 当只有一个字符时，比如 a 自然是一个回文串。当有两个字符时，如果是相等的，比如 aa，也是一个回文串。当有三个及以上字符时，比如 ababa 这个字符记作串 1，把两边的 a 去掉，也就是 bab 记作串 2，可以看出只要串2是一个回文串，那么左右各多了一个 a 的串 1 必定也是回文串。所以当 s[i]==s[j] 时，自然要看 dp[i+1][j-1] 是不是一个回文串。 1234567891011121314class Solution &#123; public int countSubstrings(String s) &#123; // dp[i][j]: s[i:j]的回文子串个数 int n = s.length(), res = 0; boolean[][] dp = new boolean[n][n]; for (int j = 0; j &lt; n; ++j) for (int i = 0; i &lt;= j; ++i) if (s.charAt(i) == s.charAt(j) &amp;&amp; (j - i &lt;= 1 || dp[i + 1][j - 1])) &#123; dp[i][j] = true; ++res; &#125; return res; &#125;&#125; 换一种遍历顺序 1234567891011121314class Solution &#123; public int countSubstrings(String s) &#123; // dp[i][j]: s[i:j]的回文子串个数 int n = s.length(), res = 0; boolean[][] dp = new boolean[n][n]; for (int i = n - 1; i &gt;= 0; --i) for (int j = i; j &lt; n; ++j) if (s.charAt(i) == s.charAt(j) &amp;&amp; (j - i &lt;= 1 || dp[i + 1][j - 1])) &#123; dp[i][j] = true; ++res; &#125; return res; &#125;&#125; 方法一：DP 1234567891011121314151617181920class Solution &#123; public int countSubstrings(String s) &#123; int n = s.length(), res = 0; boolean[][] dp = new boolean[n][n]; for (int j = 0; j &lt; n; ++j) &#123; for (int i = j; i &gt;= 0; --i) &#123; if (i == j) dp[i][j] = true; else if (i + 1 == j) dp[i][j] = s.charAt(i) == s.charAt(j) ? true : false; else &#123; dp[i][j] = s.charAt(i) == s.charAt(j) &amp;&amp; dp[i + 1][j - 1]; &#125; if (dp[i][j]) ++res; &#125; &#125; return res; &#125;&#125; 5. 最长回文子串 方法一：DP dp[i][j] = ch1 == ch2 &amp;&amp; (dp[i + 1][j - 1] || j - i + 1 &lt;= 2) 从最后一行开始遍历，从左往右、从右往左都可以 12345678910111213141516171819202122class Solution &#123; public String longestPalindrome(String s) &#123; // dp[i][j] = ch1 == ch2 &amp;&amp; (dp[i + 1][j - 1] || j - i + 1 &lt;= 2) // dp[i][j]: s[i:j]是否是回文串 int n = s.length(),l = 0, r = 0, maxLen = 0; boolean[][] dp = new boolean[n][n]; for (int i = n - 1; i &gt;= 0; --i) &#123; // for (int j = n - 1; j &gt;= i; --j) 也可以 for (int j = i; j &lt; n; ++j) &#123; if (s.charAt(i) == s.charAt(j) &amp;&amp; (j - i + 1 &lt;= 2 || dp[i + 1][j - 1])) &#123; dp[i][j] = true; if (j - i + 1 &gt; maxLen) &#123; maxLen = j - i + 1; l = i; r = j; &#125; &#125; &#125; &#125; return s.substring(l, r + 1); &#125;&#125; 516. 最长回文子序列 方法一：DP 12345678910111213141516171819202122232425class Solution &#123; public int longestPalindromeSubseq(String s) &#123;// dp[i][j]: 字符串从下标i到j的最长回文子序列// dp[i][j]:// s[i] == s[j]: d[i + 1][j - 1]// s[i] != s[j]: max(dp[i + 1][j], dp[i][j - 1]) int n = s.length(); int[][] dp = new int[n][n]; for (int j = 0; j &lt; n; ++j) &#123; for (int i = j; i &gt;= 0; --i) &#123; if (i == j) dp[i][j] = 1; else if (i + 1 == j) dp[i][j] = s.charAt(i) == s.charAt(j) ? 2 : 1; else &#123; if (s.charAt(i) == s.charAt(j)) dp[i][j] = dp[i + 1][j - 1] + 2; else dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]); &#125; &#125; &#125; return dp[0][n - 1]; &#125;&#125; 二刷 dp[i][j - 1] dp[i][j] dp[i + 1][j - 1] dp[i + 1][j] 从下往上，从左往右遍历 else if (s.charAt(i) == s.charAt(j))一定要else if不能是if。如果是if会越界(i = n - 1时, dp[i + 1][j - 1]越界) 1234567891011121314151617class Solution &#123; public int longestPalindromeSubseq(String s) &#123; int n = s.length(); int[][] dp = new int[n][n]; for (int i = n - 1; i &gt;= 0; --i) &#123; for (int j = i; j &lt; n; ++j) &#123; if (i == j) dp[i][j] = 1; else if (s.charAt(i) == s.charAt(j)) dp[i][j] = dp[i + 1][j - 1] + 2; else dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]); &#125; &#125; return dp[0][n - 1]; &#125;&#125; 剑指 Offer II 092. 翻转字符 注意：(ch == ‘1’ ? 0 : 1)的括号 方法一：DP 1234567891011121314151617181920class Solution &#123; public int minFlipsMonoIncr(String s) &#123; // dp[i][0]: 经过若干转换使得子串s[:i]有序且最后一位是0的最少翻转次数 // dp[i][1]：经过若干转换使得子串s[:i]有序且最后一位是1的最少翻转次数 /* 状态转移：dp[i][0] = dp[i - 1][0] + s[i] == 0 ? 0 : 1; dp[i][1] = Math.min(dp[i - 1][0], dp[i - 1][1]) + s[i] == 1 ? 0 : 1; 初始化：dp[0][0] = s[0] == 0 ? 0 : 1; dp[0][1] = s[0] == 1 ? 0 : 1; */ int[][] dp = new int[s.length()][2]; dp[0][0] = s.charAt(0) == &#x27;0&#x27; ? 0 : 1; dp[0][1] = s.charAt(0) == &#x27;1&#x27; ? 0 : 1; for (int i = 1; i &lt; s.length(); ++i) &#123; char ch = s.charAt(i); dp[i][0] = dp[i - 1][0] + (ch == &#x27;0&#x27; ? 0 : 1); dp[i][1] = Math.min(dp[i - 1][0], dp[i - 1][1]) + (ch == &#x27;1&#x27; ? 0 : 1); &#125; return Math.min(dp[s.length() - 1][0], dp[s.length() - 1][1]); &#125;&#125; 剑指 Offer II 093. 最长斐波那契数列 方法一：DP 12345678910111213141516171819class Solution &#123; public int lenLongestFibSubseq(int[] arr) &#123; int n = arr.length; int[][] dp = new int[n][n]; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); int res = 0; for (int i = 0; i &lt; n; ++i) map.put(arr[i], i); for (int i = 2; i &lt; n; ++i) &#123; for (int j = i - 1; j &gt;= 0; --j) &#123; int k = map.getOrDefault(arr[i] - arr[j], -1); if (k &gt;= 0 &amp;&amp; k &lt; j) dp[j][i] = Math.max(dp[k][j] + 1, 3); res = Math.max(res, dp[j][i]); &#125; &#125; return res; &#125;&#125; 分割回文串 II 123456789101112131415161718192021222324252627282930class Solution &#123; public int minCut(String s) &#123; int n = s.length(); /** i &lt; j &amp;&amp; s[i] == s[j], dp[i][j] = dp[i + 1][j - 1] */ boolean[][] dp = new boolean[n][n]; for (int i = n - 1; i &gt;= 0; --i) for (int j = i; j &lt; n; ++j) if (s.charAt(i) == s.charAt(j) &amp;&amp; (j - i &lt;= 1 || dp[i + 1][j - 1])) dp[i][j] = true; /** if (dp[0][n - 1]) return 0; if (dp[i][j]) */ int[] memo = new int[n]; for (int i = 0; i &lt; n; ++i) &#123; if (dp[0][i]) memo[i] = 0; else &#123; memo[i] = i; for (int j = 1; j &lt;= i; ++j) &#123; if (dp[j][i]) memo[i] = Math.min(memo[i], memo[j - 1] + 1); &#125; &#125; &#125; return memo[n - 1]; &#125;&#125; 剑指 Offer II 096. 字符串交织 初始化出错了，debug半天 1234for (int i = 1; i &lt;= n &amp;&amp; s2.charAt(i - 1) == s3.charAt(i - 1); ++i) // 不符合提前终止for循环 dp[0][i] = true;for (int i = 1; i &lt;= m &amp;&amp; s1.charAt(i - 1) == s3.charAt(i - 1); ++i) dp[i][0] = true; 代码 12345678910111213141516171819class Solution &#123; public boolean isInterleave(String s1, String s2, String s3) &#123; int m = s1.length(), n = s2.length(), t = s3.length(); if (t != m + n) return false; // dp[i][j] = (s1[i] == s3[i + j] &amp;&amp; dp[i - 1][j]) || (s2[j] == s3[i + j] &amp;&amp; dp[i][j - 1]) boolean[][] dp = new boolean[m + 1][n + 1]; dp[0][0] = true; for (int i = 1; i &lt;= n &amp;&amp; s2.charAt(i - 1) == s3.charAt(i - 1); ++i) dp[0][i] = true; for (int i = 1; i &lt;= m &amp;&amp; s1.charAt(i - 1) == s3.charAt(i - 1); ++i) dp[i][0] = true; for (int i = 1; i &lt;= m; ++i) for (int j = 1; j &lt;= n; ++j) if ((s1.charAt(i - 1) == s3.charAt(i + j - 1) &amp;&amp; dp[i - 1][j]) || (s2.charAt(j - 1) == s3.charAt(i + j - 1) &amp;&amp; dp[i][j - 1])) dp[i][j] = true; return dp[m][n]; &#125;&#125; 115. 不同的子序列 二刷记忆化搜索 12345678910111213141516171819202122232425262728293031class Solution &#123; public int numDistinct(String s, String t) &#123; m = s.length(); n = t.length(); this.s = s; this.t = t; dp = new int[m][n]; for (int[] arr : dp) Arrays.fill(arr, -1); return dfs(0, 0); &#125; public int dfs(int i, int j) &#123; // t被匹配返回1 if (j == n) return 1; // s到最后也没能匹配到t的最后一个字符，返回0 if (i == m) return 0; if (dp[i][j] != -1) return dp[i][j]; // 匹配：选：i，j往下递归；不选：i往下递归 if (s.charAt(i) == t.charAt(j)) return dp[i][j] = dfs(i + 1, j + 1) + dfs(i + 1, j); return dp[i][j] = dfs(i + 1, j); &#125; int m, n; String s, t; int[][] dp;&#125; 方法三：滚动数组 12345678910111213141516class Solution &#123; public int numDistinct(String s, String t) &#123; int m = s.length(), n = t.length(); // s[:i]中t[:j]出现的次数 int[] dp = new int[n + 1]; // s,t为空串，匹配 dp[0] = 1; for (int i = 1; i &lt;= m; ++i) &#123; for (int j = n; j &gt;= 1; --j) &#123; if (s.charAt(i - 1) == t.charAt(j - 1)) dp[j] += dp[j - 1]; &#125; &#125; return dp[n]; &#125;&#125; 方法一：DP 注意初始化 123456789101112131415161718192021222324class Solution &#123; public int numDistinct(String s, String t) &#123; /** s = &quot;bagg&quot;, t = &quot;bag&quot; 对于bag的最后一个&#x27;g&#x27;，可以使用它，或者不使用它 */ int m = s.length(), n = t.length(); if (m &lt; n) return 0; int[][] dp = new int[m + 1][n + 1]; dp[0][0] = 1; for (int i = 1;i &lt;= m; ++i) dp[i][0] = 1; for (int i = 1; i &lt;= m; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; if (s.charAt(i - 1) == t.charAt(j - 1)) dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]; else dp[i][j] = dp[i - 1][j]; &#125; &#125; return dp[m][n]; &#125;&#125; 方法二：记忆化搜索 优质题解 1234567891011121314151617181920212223242526class Solution &#123; public int numDistinct(String s, String t) &#123; m = s.length(); n = t.length(); dp = new int[m][n]; for (int[] arr : dp) Arrays.fill(arr, -1); return dfs(s, t, m - 1, n - 1); &#125; int m, n; int[][] dp; private int dfs(String s, String t, int i, int j) &#123; if (j &lt; 0) // base case 当j指针越界，此时t为空串，s不管是不是空串，匹配方式数都是1 return 1; if (i &lt; 0) // base case i指针越界，此时s为空串，t不是，s怎么也匹配不了t，方式数0 return 0; if (dp[i][j] != -1) return dp[i][j]; if (s.charAt(i) == t.charAt(j)) return dp[i][j] = dfs(s, t, i - 1, j - 1) + dfs(s, t, i - 1, j); else return dp[i][j] = dfs(s, t, i - 1, j); &#125;&#125; 392. 判断子序列 方法一：DP 1234567891011121314151617class Solution &#123; public boolean isSubsequence(String s, String t) &#123; /** dp[i][j]:s[:i]是否是t[:j]的子序列 dp[i][j] = dp[i][j - 1] || dp[i - 1][j - 1] &amp;&amp; s[i] == t[j] 初始化：s为空，都是t的子串 */ int m = s.length(), n = t.length(); boolean[][] dp = new boolean[m + 1][n + 1]; for (int j = 0; j &lt;= n; ++j) dp[0][j] = true; for (int i = 1; i &lt;= m; ++i) for (int j = 1; j &lt;= n; ++j) dp[i][j] = dp[i][j - 1] || dp[i - 1][j - 1] &amp;&amp; s.charAt(i - 1) == t.charAt(j - 1); return dp[m][n]; &#125;&#125; 销售利润最大化 方法一：线性DP 相似题目 2008. 出租车的最大盈利（和本题几乎一样） 1235. 规划兼职工作（数据范围更大的情况，我的题解） 1751. 最多可以参加的会议数目 II（区间个数限制） 2054. 两个最好的不重叠活动 12345678910111213141516171819class Solution &#123; public int maximizeTheProfit(int n, List&lt;List&lt;Integer&gt;&gt; offers) &#123; List&lt;int[]&gt;[] list = new List[n]; Arrays.setAll(list, e -&gt; new ArrayList&lt;&gt;()); for (List&lt;Integer&gt; offer : offers) &#123; int start = offer.get(0), end = offer.get(1), val = offer.get(2); list[end].add(new int[]&#123;start, val&#125;); &#125; int[] dp = new int[n + 1]; for (int i = 1; i &lt;= n; ++i) &#123; dp[i] = dp[i - 1]; for (int[] arr : list[i - 1]) &#123; int start = arr[0], val = arr[1]; dp[i] = Math.max(dp[i], dp[start] + val); &#125; &#125; return dp[n]; &#125;&#125; 方法二：二分 + DP 12345678910111213141516171819202122232425class Solution &#123; public int maximizeTheProfit(int n, List&lt;List&lt;Integer&gt;&gt; offers) &#123; Collections.sort(offers, (o1, o2) -&gt; o1.get(1) - o2.get(1)); // 处理标号为0~i的房子能获得的最大利润 int[] dp = new int[offers.size() + 1]; for (int i = 0; i &lt; offers.size(); ++i) &#123; dp[i + 1] = dp[i]; int j = bisearch(offers, i, offers.get(i).get(0)); dp[i + 1] = Math.max(dp[i + 1], (j &gt;= -1 ? dp[j + 1] : 0) + offers.get(i).get(2)); &#125; return dp[offers.size()]; &#125; private int bisearch(List&lt;List&lt;Integer&gt;&gt; offers, int r, int start) &#123; int l = 0; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if (offers.get(mid).get(1) &lt; start) l = mid + 1; else r = mid - 1; &#125; return r; &#125;&#125; 2008. 出租车的最大盈利 方法一：线性DP 12345678910111213141516171819class Solution &#123; public long maxTaxiEarnings(int n, int[][] rides) &#123; List&lt;int[]&gt;[] list = new List[n + 1]; Arrays.setAll(list, o -&gt; new ArrayList&lt;&gt;()); for (int[] ride : rides) &#123; int from = ride[0], to = ride[1], tips = ride[2]; list[to].add(new int[]&#123;from, to - from + tips&#125;); &#125; long[] dp = new long[n + 1]; for (int i = 1; i &lt;= n; ++i) &#123; dp[i] = dp[i - 1]; for (int[] arr : list[i]) &#123; int start = arr[0], val = arr[1]; dp[i] = Math.max(dp[i], dp[start] + val); &#125; &#125; return dp[n]; &#125;&#125; 1235. 规划兼职工作 数据量$10^9$，如果用上述方法存储，会爆内存 方法一：二分 + DP 将jobs按照结束时间排序，dp[i]：处理前i分工作(做或者不做)能获得的最大利润，dp[0]没有意义(防止溢出) 对于第i份兼职，可以不做dp[i] = dp[i - 1]，或者做dp[i] = dp[j + 1] + prof，其中j是满足jobs[j][1] &lt;= jobs[i][0]的最大下标(dp数组是非递减的)，可以使用二分来找到j 1234567891011121314151617181920212223242526272829303132class Solution &#123; public int jobScheduling(int[] startTime, int[] endTime, int[] profit) &#123; int n = startTime.length; int[][] jobs = new int[n][3]; for (int i = 0; i &lt; n; ++i) &#123; jobs[i][0] = startTime[i]; jobs[i][1] = endTime[i]; jobs[i][2] = profit[i]; &#125; Arrays.sort(jobs, (o1, o2) -&gt; o1[1] - o2[1]); int[] dp = new int[n + 1]; for (int i = 1; i &lt;= n; ++i) &#123; dp[i] = dp[i - 1]; int start = jobs[i - 1][0], end = jobs[i - 1][1], p = jobs[i - 1][2]; int j = bisearch(jobs, i, start); // 右边界是i，找到最大的下标j，jobs[j][1] &lt;= start dp[i] = Math.max(dp[i], dp[j + 1] + p); // dp数组下标都往后移一位 &#125; return dp[n]; &#125; private int bisearch(int[][] jobs, int r, int start) &#123; int l = 0; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if (jobs[mid][1] &lt;= start) l = mid + 1; else r = mid - 1; &#125; return r; &#125;&#125; 1751. 最多可以参加的会议数目 II 数量限制 方法一：二分 + 二维DP 1234567891011121314151617181920212223242526class Solution &#123; public int maxValue(int[][] events, int k) &#123; Arrays.sort(events, (o1, o2) -&gt; o1[1] - o2[1]); int n = events.length; int[][] dp = new int[n + 1][k + 1]; for (int i = 0; i &lt; n; ++i) &#123; int p = bisearch(events, i, events[i][0]); for (int j = 1; j &lt;= k; ++j) &#123; dp[i + 1][j] = Math.max(dp[i][j], dp[p + 1][j - 1] + events[i][2]); &#125; &#125; return dp[n][k]; &#125; private int bisearch(int[][] events, int r, int start) &#123; int l = 0; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if (events[mid][1] &lt; start) l = mid + 1; else r = mid - 1; &#125; return r; &#125;&#125; 2054. 两个最好的不重叠活动 方法一：二分查找 + 线性dp 1234567891011121314151617181920212223242526class Solution &#123; public int maxTwoEvents(int[][] events) &#123; int n = events.length; Arrays.sort(events, (o1, o2) -&gt; o1[1] - o2[1]); int[][] dp = new int[n + 1][3]; for (int i = 0; i &lt; n; ++i) &#123; int p = bisearch(events, i, events[i][0]); for (int j = 1; j &lt;= 2; ++j) &#123; dp[i + 1][j] = Math.max(dp[i][j], dp[p + 1][j - 1] + events[i][2]); &#125; &#125; return dp[n][2]; &#125; private int bisearch(int[][] events, int r, int start) &#123; int l = 0; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if (events[mid][1] &lt; start) l = mid + 1; else r = mid - 1; &#125; return r; &#125;&#125; 剑指 Offer 47. 礼物的最大价值 方法一：记忆化搜索 12345678910111213141516171819202122232425262728293031323334class Solution &#123; public int maxValue(int[][] grid) &#123; this.grid = grid; m = grid.length; n = grid[0].length; dp = new int[m][n]; for (int[] arr : dp) Arrays.fill(arr, -1); return dfs(0, 0); &#125; private int dfs(int i, int j) &#123; if (i == m &amp;&amp; j == n) return 0; if (dp[i][j] != -1) return dp[i][j]; int res = grid[i][j], max = 0; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col)) &#123; max = Math.max(max, dfs(row, col)); &#125; &#125; res += max; return dp[i][j] = res; &#125; private boolean isValid(int i, int j) &#123; return i &lt; m &amp;&amp; j &lt; n; &#125; int[][] grid, dirs = new int[][]&#123;&#123;1, 0&#125;, &#123;0, 1&#125;&#125;, dp; int m, n;&#125; 方法二：简化写法 1234567891011121314151617181920212223242526class Solution &#123; public int maxValue(int[][] grid) &#123; this.grid = grid; m = grid.length; n = grid[0].length; dp = new int[m][n]; for (int[] arr : dp) Arrays.fill(arr, -1); return dfs(0, 0); &#125; private int dfs(int i, int j) &#123; if (i &gt;= m || j &gt;= n) return 0; if (dp[i][j] != -1) return dp[i][j]; return dp[i][j] = Math.max(dfs(i + 1, j), dfs(i, j + 1)) + grid[i][j]; &#125; private boolean isValid(int i, int j) &#123; return i &lt; m &amp;&amp; j &lt; n; &#125; int[][] grid, dp; int m, n;&#125; 方法三：DP 123456789101112131415class Solution &#123; public int maxValue(int[][] grid) &#123; this.grid = grid; m = grid.length; n = grid[0].length; dp = new int[m + 1][n + 1]; for (int i = 0; i &lt; m; ++i) for (int j = 0; j &lt; n; ++j) dp[i + 1][j + 1] = Math.max(dp[i][j + 1], dp[i + 1][j]) + grid[i][j]; return dp[m][n]; &#125; int[][] grid, dp; int m, n;&#125; 方法四：DP + 滚动数组 12345678910class Solution &#123; public int maxValue(int[][] grid) &#123; int m = grid.length, n = grid[0].length; int[] dp = new int[n + 1]; for (int i = 0; i &lt; m; ++i) for (int j =0; j &lt; n; ++j) dp[j + 1] = grid[i][j] + Math.max(dp[j + 1], dp[j]); return dp[n]; &#125;&#125; 931. 下降路径最小和 方法一：记忆化搜索 注意初始化dp数组 12345678910111213141516171819202122232425262728class Solution &#123; public int minFallingPathSum(int[][] matrix) &#123; this.matrix = matrix; n = matrix.length; int res = Integer.MAX_VALUE; dp = new int[n][n]; for (int[] arr : dp) Arrays.fill(arr, Integer.MAX_VALUE); for (int i = 0; i &lt; n; ++i) &#123; res = Math.min(res, dfs(0, i)); &#125; return res; &#125; private int dfs(int i, int j) &#123; if (i == n) return 0; if (dp[i][j] != Integer.MAX_VALUE) return dp[i][j]; int l = j &gt; 0 ? dfs(i + 1, j - 1) : Integer.MAX_VALUE; int d = dfs(i + 1, j); int r = j &lt; n - 1 ? dfs(i + 1, j + 1) : Integer.MAX_VALUE; return dp[i][j] = Math.min(l, Math.min(d, r)) + matrix[i][j]; &#125; int[][] matrix, dp; int n;&#125; 方法二：简化写法 123456789101112131415161718192021222324252627class Solution &#123; public int minFallingPathSum(int[][] matrix) &#123; this.matrix = matrix; n = matrix.length; int res = Integer.MAX_VALUE; dp = new int[n][n]; for (int[] arr : dp) Arrays.fill(arr, Integer.MAX_VALUE); for (int i = 0; i &lt; n; ++i) &#123; res = Math.min(res, dfs(0, i)); &#125; return res; &#125; private int dfs(int i, int j) &#123; if (i == n) return 0; if (j &lt; 0 || j == n) return Integer.MAX_VALUE; if (dp[i][j] != Integer.MAX_VALUE) return dp[i][j]; return dp[i][j] = Math.min(dfs(i + 1, j - 1), Math.min(dfs(i + 1, j), dfs(i + 1, j + 1))) + matrix[i][j]; &#125; int[][] matrix, dp; int n;&#125; 方法三：DP 1234567891011121314151617class Solution &#123; public int minFallingPathSum(int[][] matrix) &#123; int n = matrix.length; int[][] dp = new int[n + 1][n + 2]; for (int i = 0; i &lt;= n; ++i) &#123; dp[i][0] = Integer.MAX_VALUE; dp[i][n + 1] = Integer.MAX_VALUE; &#125; for (int i = 0; i &lt; n; ++i) for (int j = 0; j &lt; n; ++j) dp[i + 1][j + 1] = matrix[i][j] + Math.min(dp[i][j], Math.min(dp[i][j + 1], dp[i][j + 2])); int res = Integer.MAX_VALUE; for (int j = 1; j &lt;= n; ++j) res = Math.min(res, dp[n][j]); return res; &#125;&#125; 方法四：滚动数组 用pre记录左上角的数 12345678910111213141516171819202122class Solution &#123; public int minFallingPathSum(int[][] matrix) &#123; int n = matrix.length; int[] dp = new int[n + 2]; dp[0] = Integer.MAX_VALUE; dp[n + 1] = Integer.MAX_VALUE; for (int i = 0; i &lt; n; ++i) dp[i + 1] = matrix[0][i]; for (int i = 1; i &lt; n; ++i) &#123; int pre = dp[0]; for (int j = 0; j &lt; n; ++j) &#123; int temp = pre; pre = dp[j + 1]; dp[j + 1] = matrix[i][j] + Math.min(temp, Math.min(pre, dp[j + 2])); &#125; &#125; int res = Integer.MAX_VALUE; for (int j = 1; j &lt;= n; ++j) res = Math.min(res, dp[j]); return res; &#125;&#125; 1262. 可被三整除的最大和 方法一：记忆化搜索 12345678910111213141516171819202122class Solution &#123; public int maxSumDivThree(int[] nums) &#123; this.nums= nums; n = nums.length; dp = new int[n][3]; for (int[] arr : dp) Arrays.fill(arr, -1); return dfs(0, 0); &#125; private int dfs(int index, int sum) &#123; if (index == n) return sum == 0 ? 0 : Integer.MIN_VALUE; if (dp[index][sum] != -1) return dp[index][sum]; return dp[index][sum] = Math.max(dfs(index + 1, sum), dfs(index + 1, (sum + nums[index]) % 3) + nums[index]); &#125; int[] nums; int n; int[][] dp;&#125; 918. 环形子数组的最大和 12345678910111213class Solution &#123;public int maxSubarraySumCircular(int[] A) &#123; int total = 0, maxSum = A[0], curMax = 0, minSum = A[0], curMin = 0; for (int a : A) &#123; curMax = Math.max(curMax + a, a); maxSum = Math.max(maxSum, curMax); curMin = Math.min(curMin + a, a); minSum = Math.min(minSum, curMin); total += a; &#125; return minSum != total ? Math.max(maxSum, total - minSum) : maxSum;&#125;&#125; 1186. 删除一次得到子数组最大和 方法四：二刷 12345678910111213141516171819202122232425262728293031323334class Solution &#123; public int maximumSum(int[] arr) &#123; nums = arr; n = arr.length; dp = new int[n][2][2]; for (int[][] a : dp) for (int[] b : a) Arrays.fill(b, -10001); return dfs(0, 1, false); &#125; private int dfs(int index, int key, boolean chosen) &#123; if (index == n) return chosen ? 0 : Integer.MIN_VALUE; if (dp[index][key][chosen ? 1 : 0] != -10001) return dp[index][key][chosen ? 1 : 0]; int pass; if (chosen) pass = 0; else pass = dfs(index + 1, key, false); int choose = dfs(index + 1, key, true) + nums[index], delete = Integer.MIN_VALUE; if (key == 1) delete = dfs(index + 1, 0, chosen); int max = Math.max(Math.max(pass, choose), delete); res = Math.max(res, max); return dp[index][key][chosen ? 1 : 0] = max; &#125; int[] nums; int n; int res = Integer.MIN_VALUE; int[][][] dp;&#125; 方法一：记忆化搜索 由于至少要选一个元素，不能是空数组，所以复杂特别多 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123; public int maximumSum(int[] arr) &#123; nums = arr; n = nums.length; dp = new int[n][2][2]; for (int[][] x : dp) for (int[] y : x) Arrays.fill(y, Integer.MIN_VALUE); return dfs(0, 1, false, false); &#125; // 选x或者不选 // 如果选，之后的数可以选择删或者不删 // 至少要选一个 // PASS有两种情况：1.前面没选pass；2.选了，后面都pass private int dfs(int index, int key, boolean hasChosen, boolean stop) &#123; if (stop) return 0; if (index == n) return hasChosen ? 0 : Integer.MIN_VALUE; if (dp[index][key][hasChosen ? 1 : 0] != Integer.MIN_VALUE) return dp[index][key][hasChosen ? 1 : 0]; int pass = Integer.MIN_VALUE, delete = Integer.MIN_VALUE, choose = Integer.MIN_VALUE; int chooseStop = Integer.MIN_VALUE, deleteStop = Integer.MIN_VALUE; if (!hasChosen) pass = dfs(index + 1, key, hasChosen, false); choose = dfs(index + 1, key, true, false) + nums[index]; chooseStop = dfs(index + 1, key, true, true) + nums[index]; if (hasChosen &amp;&amp; key &gt;= 1) &#123; delete = dfs(index + 1, 0, true, false); deleteStop = dfs(index + 1, 0, true, true); &#125; int temp = Math.max(pass, Math.max(choose, delete)); temp = Math.max(temp, Math.max(chooseStop, deleteStop)); res = Math.max(res, temp); return dp[index][key][hasChosen ? 1 : 0] = temp; &#125; int[][][] dp; int[] nums; int n, res = Integer.MIN_VALUE;&#125; 方法二：记忆化搜索 123456789101112131415161718192021222324252627class Solution &#123; public int maximumSum(int[] arr) &#123; nums = arr; n = arr.length; dp = new int[n][2]; for (int[] x : dp) Arrays.fill(x, Integer.MIN_VALUE); int res = Integer.MIN_VALUE; for (int i = 0; i &lt; n; ++i) res = Math.max(res, Math.max(dfs(i, 0), dfs(i, 1))); return res; &#125; private int dfs(int i, int j) &#123; if (i == n) return Integer.MIN_VALUE &gt;&gt; 1; if (dp[i][j] != Integer.MIN_VALUE) return dp[i][j]; if (j == 0) return dp[i][j] = Math.max(dfs(i + 1, 0), 0) + nums[i]; return dp[i][j] = Math.max(dfs(i + 1, 1) + nums[i], dfs(i + 1, 0)); &#125; int[][] dp; int[] nums; int n, res = Integer.MIN_VALUE;&#125; 方法三：1:1转换DP 12345678910111213class Solution &#123; public int maximumSum(int[] nums) &#123; int n = nums.length, res = Integer.MIN_VALUE; int[][] dp = new int[n + 1][2]; Arrays.fill(dp[0], Integer.MIN_VALUE &gt;&gt; 1); // if (i == n) return Integer.MIN_VALUE &gt;&gt; 1; for (int i = 0; i &lt; n; ++i) &#123; dp[i + 1][0] = Math.max(dp[i][0], 0) + nums[i]; dp[i + 1][1] = Math.max(dp[i][1] + nums[i], dp[i][0]); res = Math.max(res, Math.max(dp[i + 1][0], dp[i + 1][1])); &#125; return res; &#125;&#125;","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://leopol1d.github.io/categories/Algorithms/"},{"name":"Dynamic Programming","slug":"Algorithms/Dynamic-Programming","permalink":"https://leopol1d.github.io/categories/Algorithms/Dynamic-Programming/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://leopol1d.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"Memorization Search","slug":"memorization-searcch","date":"2023-05-24T02:32:30.724Z","updated":"2023-10-09T11:28:23.227Z","comments":true,"path":"2023/05/24/memorization-searcch/","link":"","permalink":"https://leopol1d.github.io/2023/05/24/memorization-searcch/","excerpt":"","text":"自顶向下的动态规划——记忆化搜索 记忆化搜索好解决不常见状态转移方程的dp问题 198. 打家劫舍 方法一：DP 1234567891011121314151617class Solution &#123; public int rob(int[] nums) &#123; // 1.dp[j]: 到达标号为j的房屋可获得的最大价值 // 2.状态转移：dp[j] = max(dp[j - 1], dp[j - 2] + nums[j]) // 3.初始化：dp[0] = nums[0], dp[1] = max(nums[0], nums[1]) // 4.遍历顺序：从前往后 int[] dp = new int[nums.length]; dp[0] = nums[0]; if (nums.length == 1) return nums[0]; dp[1] = Math.max(nums[0], nums[1]); for (int i = 2; i &lt; nums.length; ++i) &#123; dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]); &#125; return dp[nums.length - 1]; &#125;&#125; 方法二：DP + 滚动数组 由状态转移方程可以看出，dp[i]由前面两个状态得出，所以dp数组的长度只需要为3 1234567891011121314151617class Solution &#123; public int rob(int[] nums) &#123; // 1.dp[j]: 到达标号为j的房屋可获得的最大价值 // 2.状态转移：dp[j] = max(dp[j - 1], dp[j - 2] + nums[j]) // 3.初始化：dp[0] = nums[0], dp[1] = max(nums[0], nums[1]) // 4.遍历顺序：从前往后 if (nums.length == 1) return nums[0]; int[] dp = new int[3]; dp[0] = nums[0]; dp[1] = Math.max(nums[0], nums[1]); for (int i = 2; i &lt; nums.length; ++i) &#123; dp[i % 3] = Math.max(dp[(i - 1) % 3], dp[(i - 2) % 3] + nums[i]); &#125; return dp[(nums.length - 1) % 3]; &#125;&#125; 方法三：记忆化搜索 自顶向下，举个例子nums=[1,2,3,1] 返回的答案为dfs(3, nums) 要求，需要知道dfs(3-1,nums)与dfs(3-2,nums)+nums[3]，然后取最大值 求dfs(2,nums)，需要知道dfs(2-1,nums)与dfs(2-2,nums)+nums[2]，然后取最大值 … 1234567891011121314151617181920public class Solution &#123; int[] dp; public int rob(int[] nums) &#123; dp = new int[nums.length]; Arrays.fill(dp, -1); return dfs(nums.length - 1, nums); &#125; private int dfs(int index, int[] nums) &#123; if (index &lt; 0) return 0; if (dp[index] != -1) return dp[index];// int dont = dfs(index - 1, nums);// int steal = dfs(index - 2, nums) + nums[index];// return dp[index] = Math.max(dont, steal); return dp[index] = Math.max(dfs(index - 1, nums), dfs(index - 2, nums) + nums[index]); &#125;&#125; 二刷记忆化搜索 1234567891011121314151617class Solution &#123; public int rob(int[] nums) &#123; dp = new int[nums.length]; Arrays.fill(dp, -1); return dfs(nums, 0); &#125; int[] dp; private int dfs(int[] nums, int index) &#123; if (index &gt;= nums.length) return 0; if (dp[index] != -1) return dp[index]; return dp[index] = Math.max(dfs(nums, index + 1), dfs(nums, index + 2) + nums[index]); &#125;&#125; 方法四：回溯 1234567891011class Solution &#123; public int rob(int[] nums) &#123; return dfs(nums, 0); &#125; private int dfs(int[] nums, int index) &#123; if (index &gt;= nums.length) return 0; return Math.max(dfs(nums, index + 1), dfs(nums, index + 2) + nums[index]); &#125;&#125; 213. 打家劫舍 II 方法一：DP 12345678910111213141516171819class Solution &#123; public int rob(int[] nums) &#123; if (nums.length == 1) return nums[0]; if (nums.length == 2) return Math.max(nums[0], nums[1]); return Math.max(process(nums, 0, nums.length - 1), process(nums, 1, nums.length)); &#125; private int process(int[] nums, int start, int end) &#123; int[] dp = new int[end - start]; dp[0] = nums[start]; dp[1] = Math.max(nums[start], nums[start + 1]); for (int i = 2; i &lt; end - start; ++i) &#123; dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i + start]); &#125; return dp[end - start - 1]; &#125;&#125; 方法二：DP + 滚动数组 12345678910111213141516171819class Solution &#123; public int rob(int[] nums) &#123; if (nums.length == 1) return nums[0]; if (nums.length == 2) return Math.max(nums[0], nums[1]); return Math.max(process(nums, 0, nums.length - 1), process(nums, 1, nums.length)); &#125; private int process(int[] nums, int start, int end) &#123; int[] dp = new int[3]; dp[0] = nums[start]; dp[1] = Math.max(nums[start], nums[start + 1]); for (int i = 2; i &lt; end - start; ++i) &#123; dp[i % 3] = Math.max(dp[(i - 1) % 3], dp[(i - 2) % 3] + nums[i + start]); &#125; return dp[(end - start - 1) % 3]; &#125;&#125; 方法三：记忆化搜索 1234567891011121314151617181920212223class Solution &#123; int[] dp; public int rob(int[] nums) &#123; if (nums.length == 1) return nums[0]; if (nums.length == 2) return Math.max(nums[0], nums[1]); dp = new int[nums.length]; Arrays.fill(dp, -1); int res1 = dfs(nums, 0, nums.length - 2); Arrays.fill(dp, -1); int res2 = dfs(nums, 1, nums.length - 1); return Math.max(res1, res2); &#125; private int dfs(int[] nums, int start, int index) &#123; if (index &lt; start) return 0; if (dp[index] != -1) return dp[index]; return dp[index] = Math.max(dfs(nums, start, index - 1), dfs(nums, start, index - 2) + nums[index]); &#125;&#125; 二刷记忆化搜索 12345678910111213141516171819202122class Solution &#123; public int rob(int[] nums) &#123; if (nums.length == 1) return nums[0]; this.nums = nums; dp = new int[nums.length]; Arrays.fill(dp, -1); int res1 = dfs(0, nums.length - 1); Arrays.fill(dp, -1); return Math.max(res1, dfs(1, nums.length)); &#125; int[] dp, nums; private int dfs(int start, int end) &#123; if (start &gt;= end) return 0; if (dp[start] != -1) return dp[start]; return dp[start] = Math.max(dfs(start + 1, end), dfs(start + 2, end) + nums[start]); &#125;&#125; 337. 打家劫舍 III 方法一：DP 1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; // steal: 偷当前节点能获得的最大金额 // pass: 不偷当前节点能获得的最大金额 // steal(cur) = cur.val + pass(cur.left) + pass(cur.right) // pass(cur) = max(steal(cur.left), pass(steal.right)) + max(steal(cur.right), pass(steal.right)) Map&lt;TreeNode, Integer&gt; steal = new HashMap&lt;&gt;(); Map&lt;TreeNode, Integer&gt; pass = new HashMap&lt;&gt;(); public int rob(TreeNode root) &#123; dfs(root); return Math.max(steal.getOrDefault(root, 0), pass.getOrDefault(root, 0)); &#125; public void dfs(TreeNode root) &#123; if (root == null) return; dfs(root.left); dfs(root.right); steal.put(root, root.val + pass.getOrDefault(root.left, 0) + pass.getOrDefault(root.right, 0)); pass.put(root, Math.max(steal.getOrDefault(root.left, 0), pass.getOrDefault(root.left, 0)) + Math.max(steal.getOrDefault(root.right, 0), pass.getOrDefault(root.right, 0))); &#125;&#125; 方法二：乱写的的dfs 1234567891011121314151617181920212223242526272829class Solution &#123; // steal: 偷当前节点能获得的最大金额 // pass: 不偷当前节点能获得的最大金额 // steal(cur) = cur.val + pass(cur.left) + pass(cur.right) // pass(cur) = max(steal(cur.left), pass(steal.right)) + max(steal(cur.right), pass(steal.right)) Map&lt;TreeNode, Integer&gt; steal = new HashMap&lt;&gt;(); Map&lt;TreeNode, Integer&gt; pass = new HashMap&lt;&gt;(); public int rob(TreeNode root) &#123; int steal = dfs(root, 0); int pass = dfs(root, 1); return Math.max(steal, pass); &#125; public int dfs(TreeNode root, int flag) &#123; if (root == null) return 0; if (flag == 1 &amp;&amp; pass.get(root) != null) &#123; return pass.get(root); &#125; else if (flag == 0 &amp;&amp; steal.get(root) != null) &#123; return steal.get(root); &#125; steal.put(root, root.val + pass.getOrDefault(root.left, dfs(root.left, 1)) + pass.getOrDefault(root.right, dfs(root.right, 1))); pass.put(root, Math.max(steal.getOrDefault(root.left, dfs(root.left, 0)), pass.getOrDefault(root.left, dfs(root.left, 1))) + Math.max(steal.getOrDefault(root.right, dfs(root.right, 0)), pass.getOrDefault(root.right, dfs(root.right, 1)))); if (flag == 0) return steal.getOrDefault(root, 0); else return pass.getOrDefault(root, 0); &#125;&#125; 方法三：记忆化搜索 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public int rob(TreeNode root) &#123; return dfs(root); &#125; Map&lt;TreeNode, Integer&gt; map = new HashMap&lt;&gt;(); public int dfs(TreeNode root) &#123; if (root == null) return 0; if (map.containsKey(root)) return map.get(root); int left = 0, right = 0; if (root.left != null) left = dfs(root.left.left) + dfs(root.left.right); if (root.right != null) right = dfs(root.right.left) + dfs(root.right.right); int steal = root.val + left + right; int pass = dfs(root.left) + dfs(root.right); int max = Math.max(steal, pass); map.put(root, max); return max; &#125;&#125; 494. 目标和 方法一：01背包 12345678910111213141516171819class Solution &#123; public int findTargetSumWays(int[] nums, int target) &#123; int sum = Arrays.stream(nums).sum(); int diff = sum - target; if (diff % 2 == 1 || diff &lt; 0) return 0; target = diff / 2; // dp[j]:装满容量为j的方法数 // dp[0] = 1,装满容量为0的背包有一种 int[] dp = new int[target + 1]; dp[0] = 1; for (int i = 0; i &lt; nums.length; ++i) &#123; for (int j = target; j &gt;= nums[i]; --j) &#123; dp[j] += dp[j - nums[i]]; &#125; &#125; return dp[target]; &#125;&#125; 方法二：回溯 使用sum，对sum作加操作，相当于对target作减操作 1234567891011121314151617class Solution &#123; int res = 0; public int findTargetSumWays(int[] nums, int target) &#123; backtracking(nums, target, 0); return res; &#125; private void backtracking(int[] nums, int target, int start) &#123; if (start == nums.length) &#123; if (target == 0) ++res; return; &#125; backtracking(nums, target + nums[start], start + 1); backtracking(nums, target - nums[start], start + 1); &#125;&#125; 方法三：回溯的另一种写法 123456789101112class Solution &#123; public int findTargetSumWays(int[] nums, int target) &#123; return dfs(nums, target, 0, 0); &#125; private int dfs(int[] nums, int target, int start, int sum) &#123; if (start == nums.length) &#123; return target == sum ? 1 : 0; &#125; return dfs(nums, target, start + 1, sum - nums[start]) + dfs(nums, target, start + 1, sum + nums[start]); &#125;&#125; 更加精简的回溯 1234567891011class Solution &#123; public int findTargetSumWays(int[] nums, int target) &#123; return dfs(nums, target, 0); &#125; private int dfs(int[] nums, int target, int index) &#123; if (index == nums.length) return target == 0 ? 1 : 0; return dfs(nums, target - nums[index], index + 1) + dfs(nums, target + nums[index], index + 1); &#125;&#125; 方法四：记忆化搜索 相比回溯，使用数组记录已经计算过的结果，return前先赋值给数组memo 每次遍历时，首先检查memo中是否已经有结果(已经计算过了)，有结果直接返回结果 123456789101112131415161718class Solution &#123; int[][] memo; public int findTargetSumWays(int[] nums, int target) &#123; memo = new int[nums.length][2001]; for (int[] m : memo) Arrays.fill(m, -1); return dfs(nums, target, nums.length - 1, 0); &#125; private int dfs(int[] nums, int target, int start, int sum) &#123; if (start &lt; 0) &#123; return target == sum ? 1 : 0; &#125; if (memo[start][sum + 1000] != -1) return memo[start][sum + 1000]; return memo[start][sum + 1000] = dfs(nums, target, start - 1, sum - nums[start]) + dfs(nums, target, start - 1, sum + nums[start]); &#125;&#125; 二刷记忆化搜索 需要多开辟一点数组空间 123456789101112131415161718class Solution &#123; public int findTargetSumWays(int[] nums, int target) &#123; dp = new int[3001][nums.length + 1]; for (int[] arr : dp) Arrays.fill(arr, -1); return dfs(nums, target, 0); &#125; int[][] dp; private int dfs(int[] nums, int target, int index) &#123; if (index == nums.length) return target == 0 ? 1 : 0; if (dp[target + 1000][index] != -1) return dp[target + 1000][index]; return dp[target + 1000][index] = dfs(nums, target - nums[index], index + 1) + dfs(nums, target + nums[index], index + 1); &#125;&#125; 64. 最小路径和 方法一：回溯超时 12345678910111213141516171819202122232425class Solution &#123; int[][] dirs = new int[][]&#123; &#123;1, 0&#125;, &#123;0, 1&#125;&#125;; int res = Integer.MAX_VALUE; public int minPathSum(int[][] grid) &#123; int m = grid.length, n = grid[0].length; dfs(grid, m, n, 0, 0, grid[m - 1][n - 1]); // 最后一次答案没有计算，所以在遍历前加上 return res; &#125; private void dfs(int[][] grid, int m, int n, int i, int j, int sum) &#123; if(i == m - 1 &amp;&amp; j == n - 1) &#123; res = Math.min(res, sum); return; &#125; sum += grid[i][j]; if (isValid(i + 1, j, m, n)) dfs(grid, m, n, i + 1, j, sum); if (isValid(i, j + 1, m, n)) dfs(grid, m, n, i, j + 1, sum); &#125; private boolean isValid(int row, int col, int m, int n) &#123; return row &gt;= 0 &amp;&amp; col &gt;= 0 &amp;&amp; row &lt; m &amp;&amp; col &lt; n; &#125;&#125; 方法二：记忆化搜索 1234567891011121314151617181920212223242526class Solution &#123; int res = Integer.MAX_VALUE; int dp[][]; public int minPathSum(int[][] grid) &#123; int m = grid.length, n = grid[0].length; // dp[i][j]:grid[i][j]到右下角的最小距离 dp = new int[m][n]; for (int[] arr : dp) Arrays.fill(arr, -1); return dfs(grid, m - 1, n - 1); &#125; private int dfs(int[][] grid, int i, int j) &#123; if (i == 0 &amp;&amp; j == 0) return grid[0][0]; if (i &lt; 0 || j &lt; 0) return 8000000; if (dp[i][j] != -1) return dp[i][j]; return dp[i][j] = grid[i][j] + Math.min(dfs(grid, i - 1, j), dfs(grid, i, j - 1)); &#125; private boolean isValid(int row, int col) &#123; return row &gt;= 0 &amp;&amp; col &gt;= 0; &#125;&#125; 二刷记忆化搜索 12345678910111213141516171819202122232425262728class Solution &#123; public int minPathSum(int[][] grid) &#123; dp = new int[grid.length][grid[0].length]; for (int[] arr : dp) Arrays.fill(arr, -1); return dfs(grid, 0, 0); &#125; int[][] dirs = new int[][]&#123;&#123;1, 0&#125;, &#123;0, 1&#125;&#125;; int[][] dp; private int dfs(int[][] grid, int i, int j) &#123; if (i == grid.length - 1 &amp;&amp; j == grid[0].length - 1) return grid[i][j]; if (dp[i][j] != -1) return dp[i][j]; int res = 40000; for (int[] dir : dirs) &#123; int sum = grid[i][j]; int row = i + dir[0], col = j + dir[1]; if (row &lt; grid.length &amp;&amp; col &lt; grid[0].length) &#123; sum += dfs(grid, row, col); dp[i][j] = res = Math.min(res, sum); &#125; &#125; return res; &#125;&#125; 62. 不同路径 方法一：记忆化搜索 12345678910111213141516171819class Solution &#123; int[][] dp; public int uniquePaths(int m, int n) &#123; dp = new int[m + 1][n + 1]; for (int[] arr : dp) Arrays.fill(arr, -1); return dfs(m, n); &#125; private int dfs(int i, int j) &#123; if (i == 1 &amp;&amp; j == 1) return 1; if (i &lt; 1 || j &lt; 1) return 0; if (dp[i][j] != -1) return dp[i][j]; return dp[i][j] = dfs(i - 1, j) + dfs(i, j - 1); &#125;&#125; 二刷记忆化搜索 123456789101112131415161718class Solution &#123; public int uniquePaths(int m, int n) &#123; dp = new int[m + 1][n + 1]; return dfs(1, 1, m, n); &#125; int[][] dp; private int dfs(int i, int j, int m, int n) &#123; if (i == m &amp;&amp; j == n) return 1; if (i &gt; m || j &gt; n) return 0; if (dp[i][j] != 0) return dp[i][j]; return dp[i][j] = dfs(i + 1, j, m, n) + dfs(i, j + 1, m, n); &#125;&#125; 63. 不同路径 II 方法一：记忆化搜索 obstacleGrid[i][j] == 1的判断要在if (i == 0 &amp;&amp; j == 0)上面，不然会报如下错 1234567891011121314151617181920class Solution &#123; int[][] dp; public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123; int m = obstacleGrid.length, n = obstacleGrid[0].length; dp = new int[m][n]; for (int[] arr : dp) Arrays.fill(arr, -1); return dfs(obstacleGrid, m - 1, n - 1); &#125; private int dfs(int[][] obstacleGrid, int i, int j) &#123; if (i &lt; 0 || j &lt; 0 || obstacleGrid[i][j] == 1) return 0; if (i == 0 &amp;&amp; j == 0) return 1; if (dp[i][j] != -1) return dp[i][j]; return dp[i][j] = dfs(obstacleGrid,i - 1, j) + dfs(obstacleGrid, i, j - 1); &#125;&#125; 二刷记忆化搜索 1234567891011121314151617181920class Solution &#123; public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123; m = obstacleGrid.length; n = obstacleGrid[0].length; dp = new int[m][n]; return dfs(obstacleGrid, 0, 0); &#125; int[][] dp; int m, n; private int dfs(int[][] obstacleGrid, int i, int j) &#123; if (i == m || j == n || obstacleGrid[i][j] == 1) return 0; if (i == m - 1 &amp;&amp; j == n - 1) return 1; if (dp[i][j] != 0) return dp[i][j]; return dp[i][j] = dfs(obstacleGrid, i + 1, j) + dfs(obstacleGrid, i, j + 1); &#125;&#125; 139. 单词拆分 方法一：DP 1234567891011121314151617181920class Solution &#123; // dp[i]:前i个字符是否能被字典中的单词拼接出 // 状态转移：dp[i] = dp[j] &amp;&amp; set.contains(s.substring(j, i)) (j &lt; i) boolean[] dp; Set&lt;String&gt; set; public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123; dp = new boolean[s.length() + 1]; set = new HashSet&lt;&gt;(wordDict); dp[0] = true; for (int i = 1; i &lt;= s.length(); ++i) &#123; for (int j = 0; j &lt; i; ++j) &#123; if (dp[j] &amp;&amp; set.contains(s.substring(j, i))) &#123; dp[i] = true; break; &#125; &#125; &#125; return dp[s.length()]; &#125;&#125; 方法二：回溯(超时) 123456789101112131415161718class Solution &#123; Set&lt;String&gt; set; public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123; set = new HashSet&lt;&gt;(wordDict); return dfs(s, 0); &#125; private boolean dfs(String s, int index) &#123; if (index == s.length()) return true; for (int i = index; i &lt; s.length(); ++i) &#123; String str = s.substring(index, i + 1); if (set.contains(str) &amp;&amp; dfs(s, i + 1)) return true; &#125; return false; &#125;&#125; 方法二：记忆化搜索 dp[i]：从下标i到结尾，是否拼接出单词 1234567891011121314151617181920212223242526class Solution &#123; Set&lt;String&gt; set; int[] dp; public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123; set = new HashSet&lt;&gt;(wordDict); dp = new int[s.length() + 1]; Arrays.fill(dp, -1); return dfs(s, 0); &#125; private boolean dfs(String s, int index) &#123; if (index == s.length())//能走到这，说明之前的字符串全能被单词拼接 return true; if (dp[index] != -1) return dp[index] == 0 ? false : true; for (int i = index; i &lt; s.length(); ++i) &#123; String str = s.substring(index, i + 1); if (set.contains(str)) &#123; dp[i + 1] = dfs(s, i + 1) ? 1 : 0; if (dp[i + 1] == 1) return true; // 找到一个答案就返回true &#125; &#125; return false; &#125;&#125; 397. 整数替换 方法一：记忆化搜索 1234567891011121314151617181920212223class Solution &#123; Map&lt;Long, Integer&gt; map = new HashMap&lt;&gt;(); public int integerReplacement(int n) &#123; return dfs(n); &#125; private int dfs(long n) &#123; if (n == 1) return 0; if (map.containsKey(n)) return map.get(n); int count = 0; if (n % 2 == 0) &#123; count = dfs(n &gt;&gt; 1) + 1; &#125; else &#123; count = Math.min(dfs(n + 1), dfs(n - 1)) + 1; &#125; map.put(n, count); return count; &#125;&#125; 55. 跳跃游戏 方法一：记忆化搜索 12345678910111213141516171819202122class Solution &#123; int[] dp; public boolean canJump(int[] nums) &#123; dp = new int[nums.length]; return dfs(nums, 0); &#125; private boolean dfs(int[] nums, int index) &#123; if (index &gt;= nums.length - 1) return true; if (dp[index] != 0) return dp[index] == 1; for (int i = 1; i &lt;= nums[index]; ++i) &#123; if (dfs(nums, index + i)) &#123; dp[index] = 1; return true; &#125; &#125; dp[index] = -1; return false; &#125;&#125; 方法二：贪心 1234567891011121314class Solution &#123; public boolean canJump(int[] nums) &#123; int n = nums.length; int rightmost = 0; for (int i = 0; i &lt; n; ++i) &#123; if (i &lt;= rightmost) &#123; rightmost = Math.max(rightmost, i + nums[i]); if (rightmost &gt;= n - 1) return true; &#125; &#125; return false; &#125;&#125; 方法三：回溯(超时) 123456789101112131415class Solution &#123; public boolean canJump(int[] nums) &#123; return dfs(nums, 0); &#125; private boolean dfs(int[] nums, int index) &#123; if (index &gt;= nums.length - 1) return true; for (int i = 1; i &lt;= nums[index]; ++i) if (dfs(nums, index + i)) return true; return false; &#125; &#125; 二刷记忆化搜索 1234567891011121314151617181920212223class Solution &#123; int[] dp; public boolean canJump(int[] nums) &#123; dp = new int[nums.length]; return dfs(nums, 0); &#125; private boolean dfs(int[] nums, int index) &#123; if (index &gt;= nums.length - 1) return true; if (dp[index] != 0) return dp[index] == 1; for (int i = 1; i &lt;= nums[index]; ++i) &#123; dp[index] = dfs(nums, index + i) == true ? 1 : -1; if (dp[index] == 1) return true; &#125; return false; &#125; &#125; 45. 跳跃游戏 II 123456789101112131415161718192021222324class Solution &#123; public int jump(int[] nums) &#123; dp = new int[nums.length]; return dfs(nums, 0); &#125; int[] dp; int res = 10001; private int dfs(int[] nums, int index) &#123; if (index &gt;= nums.length - 1) &#123; return 0; &#125; if (dp[index] != 0) return dp[index]; int min = 10001; for (int i = 1; i &lt;= nums[index]; ++i) &#123; min = Math.min(min, dfs(nums, index + i) + 1); &#125; return dp[index] = min; &#125; &#125; 方法二：贪心 322. 零钱兑换 方法一：记忆化搜索 12345678910111213141516171819202122232425class Solution &#123; public int coinChange(int[] coins, int amount) &#123; dp = new int[amount + 1]; Arrays.fill(dp, -1); int res = dfs(coins, amount); return res == 10001 ? -1 : res; &#125; int[] dp; private int dfs(int[] coins, int amount) &#123; if (amount == 0) return 0; if (dp[amount] != -1) return dp[amount]; int min = 10001; for (int i = 0; i &lt; coins.length; ++i) &#123; if (amount - coins[i] &lt; 0) continue; min = Math.min(min, dfs(coins, amount - coins[i]) + 1); &#125; return dp[amount] = min; &#125; &#125; 方法二：完全背包 518. 零钱兑换 II 方法一：完全背包 方法二：回溯(超时) 12345678910111213141516171819202122class Solution &#123; public int change(int amount, int[] coins) &#123; Arrays.sort(coins); dfs(amount, coins, 0); return res; &#125; int res = 0; public void dfs(int amount, int[] coins, int index) &#123; if (amount == 0) &#123; ++res; return; &#125; for (int i = index; i &lt; coins.length; ++i) &#123; if (amount &lt; coins[i]) break; dfs(amount - coins[i], coins, i); &#125; &#125; &#125; 回溯另一种写法 123456789101112131415161718public int change(int amount, int[] coins) &#123; Arrays.sort(coins); return dfs(amount, coins, 0);&#125;public int dfs(int amount, int[] coins, int index) &#123; if (amount == 0) &#123; return 1; &#125; int count = 0; for (int i = index; i &lt; coins.length; ++i) &#123; if (amount &lt; coins[i]) break; count += dfs(amount - coins[i], coins, i); &#125; return count;&#125; 方法三：记忆化搜索需要用二位数组存储当前amount，与遍历到的下标 1234567891011121314151617181920212223242526class Solution &#123; public int change(int amount, int[] coins) &#123; dp = new int[amount + 1][coins.length]; for (int[] arr : dp) Arrays.fill(arr, -1); Arrays.sort(coins); return dfs(amount, coins, 0); &#125; int[][] dp; public int dfs(int amount, int[] coins, int index) &#123; if (amount == 0) &#123; return 1; &#125; if (dp[amount][index] != -1) return dp[amount][index]; int count = 0; for (int i = index; i &lt; coins.length; ++i) &#123; if (amount &lt; coins[i]) break; count += dfs(amount - coins[i], coins, i); &#125; return dp[amount][index] = count; &#125;&#125; 343. 整数拆分 方法一：记忆化搜索 123456789101112131415161718192021222324class Solution &#123; int[] dp; public int integerBreak(int n) &#123; // dp[i]:将i拆分成若干正整数，将他们相乘的最大值 // dp[1] = 1; dp[2] = 1 dp = new int[n + 1]; dp[1] = 1; int res = dfs(n); return res; &#125; private int dfs(int n) &#123; if (n == 2) return 1; if (dp[n] != 0) return dp[n]; int max = 0; for (int i = 1; i &lt;= n - 1; ++i) &#123; int k = n - i; max = Math.max(max, Math.max(k * dfs(i), k * i)); &#125; return dp[n] = max; &#125;&#125; res = Math.max(res, Math.max(i * (n - i), dfs(n - i) * i));这一句后面为什么不是dfs(n - i) * dfs(i) 比如 如果dfs(i) * dfs(k)，那么6和2会被拆分成3， 3，1 121. 买卖股票的最佳时机 方法一：贪心 123456789101112class Solution &#123; public int maxProfit(int[] prices) &#123; int minStock = 10000, maxProfit = 0; for (int price : prices) &#123; if (price &lt; minStock) &#123; minStock = price; &#125; maxProfit = Math.max(maxProfit, price - minStock); &#125; return maxProfit; &#125;&#125; 方法二：回溯 12345678910111213141516public int maxProfit(int[] prices) &#123; this.prices = prices; return dfs(0, 0);&#125;int[] prices;private int dfs(int index, int state) &#123; if (index == prices.length || state == 2) return 0; if (state == 0) // 不操作 买入 return Math.max(dfs(index + 1, state), dfs(index + 1, state + 1) - prices[index]); // 不操作 卖出 return Math.max(dfs(index + 1, state), dfs(index + 1, state + 1) + prices[index]);&#125; 如果摸不着头脑救去debug吧！ debug版本 1234567891011121314151617181920public int maxProfit(int[] prices) &#123; this.prices = prices; return dfs(0, 0);&#125;int[] prices;private int dfs(int index, int state) &#123; if (index == prices.length || state == 2) return 0; if (state == 0) &#123; int keep0 = dfs(index + 1, state); int buy = dfs(index + 1, state + 1) - prices[index]; return Math.max(keep0, buy); &#125; else &#123; int keep1 = dfs(index + 1, state); int sell = dfs(index + 1, state + 1) + prices[index]; return Math.max(keep1, sell); &#125;&#125; 方法三：记忆化搜索 123456789101112131415161718192021222324class Solution &#123; public int maxProfit(int[] prices) &#123; this.prices = prices; dp = new int[2][prices.length]; for (int[] arr : dp) Arrays.fill(arr, -1); return dfs(0, 0); &#125; int[] prices; int[][] dp; private int dfs(int index, int state) &#123; if (index == prices.length || state == 2) return 0; if (dp[state][index] != -1) return dp[state][index]; if (state == 0) // 不操作 买入 return dp[state][index] = Math.max(dfs(index + 1, 0), dfs(index + 1, 1) - prices[index]); // 不操作 卖出 return dp[state][index] = Math.max(dfs(index + 1, 1), dfs(index + 1, 2) + prices[index]); &#125;&#125; 122. 买卖股票的最佳时机 II 记忆化搜索 123456789101112131415161718192021222324class Solution &#123; public int maxProfit(int[] prices) &#123; this.prices = prices; dp = new int[2][prices.length]; for (int[] arr : dp) Arrays.fill(arr, -1); return dfs(0, 0); &#125; int[] prices; int[][] dp; private int dfs(int index, int state) &#123; if (index == prices.length) return 0; if (dp[state][index] != -1) return dp[state][index]; if (state == 0) // 不操作 买入 return dp[state][index] = Math.max(dfs(index + 1, 0), dfs(index + 1, 1) - prices[index]); // 不操作 卖出 return dp[state][index] = Math.max(dfs(index + 1, 1), dfs(index + 1, 0) + prices[index]); &#125;&#125; 123. 买卖股票的最佳时机 III 记忆化搜索 123456789101112131415161718class Solution &#123; public int maxProfit(int[] prices) &#123; dp = new int[prices.length][4]; for (int[] arr : dp) Arrays.fill(arr, -1); return dfs(prices, 0, 0); &#125; int[][] dp; private int dfs(int[] prices, int index, int state) &#123; if (index == prices.length || state == 4) return 0; if (dp[index][state] != -1) return dp[index][state]; if (state == 0 || state == 2) // 不操作，买入 return dp[index][state] = Math.max(dfs(prices, index + 1, state), dfs(prices, index + 1, state + 1) - prices[index]); return dp[index][state] = Math.max(dfs(prices, index + 1, state), dfs(prices, index + 1, state + 1) + prices[index]); &#125;&#125; 188. 买卖股票的最佳时机 IV 记忆化搜索 1234567891011121314151617181920class Solution &#123; public int maxProfit(int k, int[] prices) &#123; dp = new int[prices.length][2 * k]; this.k = k; for (int[] arr : dp) Arrays.fill(arr, -1); return dfs(prices, 0, 0); &#125; int[][] dp; int k; private int dfs(int[] prices, int index, int state) &#123; if (index == prices.length || state == 2 * k) return 0; if (dp[index][state] != -1) return dp[index][state]; if (state % 2 == 0) // 不操作，买入 return dp[index][state] = Math.max(dfs(prices, index + 1, state), dfs(prices, index + 1, state + 1) - prices[index]); return dp[index][state] = Math.max(dfs(prices, index + 1, state), dfs(prices, index + 1, state + 1) + prices[index]); &#125;&#125; 714. 买卖股票的最佳时机含手续费 记忆化搜索 卖的时候 - fee 或者 买的时候 - fee都可以 1234567891011121314151617181920class Solution &#123; public int maxProfit(int[] prices, int fee) &#123; dp = new int[prices.length][2]; this.fee = fee; for (int[] arr : dp) Arrays.fill(arr, -1); return dfs(prices, 0, 0); &#125; int[][] dp; int fee; private int dfs(int[] prices, int index, int state) &#123; if (index == prices.length) return 0; if (dp[index][state] != -1) return dp[index][state]; if (state == 0) // 不操作，买入 return dp[index][state] = Math.max(dfs(prices, index + 1, 0), dfs(prices, index + 1, 1) - prices[index]); return dp[index][state] = Math.max(dfs(prices, index + 1, 1), dfs(prices, index + 1, 0) + prices[index] - fee); &#125;&#125; 309. 最佳买卖股票时机含冷冻期 记忆化搜索 卖出:index + 2 base case : index &gt;= prices.length 123456789101112131415161718class Solution &#123; public int maxProfit(int[] prices) &#123; dp = new int[prices.length][2]; for (int[] arr : dp) Arrays.fill(arr, -1); return dfs(prices, 0, 0); &#125; int[][] dp; private int dfs(int[] prices, int index, int state) &#123; if (index &gt;= prices.length) return 0; if (dp[index][state] != -1) return dp[index][state]; if (state == 0) // 不操作，买入 return dp[index][state] = Math.max(dfs(prices, index + 1, 0), dfs(prices, index + 1, 1) - prices[index]); return dp[index][state] = Math.max(dfs(prices, index + 1, 1), dfs(prices, index + 2, 0) + prices[index]); &#125;&#125; 获得分数的方法数 方法一：记忆化搜索(分组背包) 1234567891011121314151617181920212223242526class Solution &#123; static final int MOD = (int) 1e9 + 7; int n ; int[][] types, dp; public int waysToReachTarget(int target, int[][] types) &#123; this.types = types; n = types.length; dp = new int[n][1002]; for (int[] arr : dp) Arrays.fill(arr, -1); return dfs(0, target); &#125; private int dfs(int index, int target) &#123; if (index == n) return target == 0 ? 1 : 0; if (dp[index][target] != -1) return dp[index][target]; int res = 0, count = types[index][0], marks = types[index][1]; for (int i = 0; i &lt;= Math.min(target / marks, count); ++i) res = (res + (dfs(index + 1, target - i * marks) % MOD)) % MOD; return dp[index][target] = res; &#125;&#125; 1981. 最小化目标值与所选元素的差 方法一：记忆化搜索 题解 12345678910111213141516171819202122232425262728293031class Solution &#123; public int minimizeTheDifference(int[][] mat, int target) &#123; m = mat.length; n = mat[0].length; this.target = target; this.mat = mat; dp = new boolean[80][5000]; dfs(0, 0); return res; &#125; private void dfs(int i, int sum) &#123; if (i == m) &#123; res = Math.min(res, Math.abs(sum - target)); return; &#125; if (sum - target &gt; res || dp[i][sum]) return; dp[i][sum] = true; for (int j = 0; j &lt; n; ++j) &#123; dfs(i + 1, sum + mat[i][j]); &#125; &#125; int m, n, res = Integer.MAX_VALUE; int[][] mat; boolean[][] dp; int target;&#125; 访问数组中的位置使分数最大 139. 单词拆分 方法一：记忆化搜索 12345678910111213141516171819202122232425262728293031class Solution &#123; public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123; this.s = s; n = s.length(); set = new HashSet&lt;&gt;(wordDict); dp = new int[n]; Arrays.fill(dp, -1); return dfs(0); &#125; private boolean dfs(int index) &#123; if (index == n) return true; if (dp[index] != -1) return dp[index] == 1 ? true : false; for (int i = index; i &lt; n; ++i) &#123; String sub = s.substring(index, i + 1); if (set.contains(sub)) &#123; dp[index] = dfs(i + 1) ? 1 : 0; if (dp[index] == 1) return true; &#125; &#125; return false; &#125; int n; String s; Set&lt;String&gt; set; int[] dp;&#125; 300. 最长递增子序列2 方法一：记忆化搜索(选或不选) 注意额外处理第一个位置 1234567891011121314151617181920212223242526272829class Solution &#123; public int lengthOfLIS(int[] nums) &#123; n = nums.length; this.nums = new int[n + 1]; this.nums[0] = -10001; for (int i = 0; i &lt; n; ++i) this.nums[i + 1] = nums[i]; dp = new int[n + 1][n]; for (int[] arr : dp) Arrays.fill(arr, -1); return dfs(1, 0); &#125; public int dfs(int index, int pre) &#123; if (index == n + 1) return 0; if (dp[index][pre] != -1) return dp[index][pre]; int x = nums[index]; if (index == 0 || x &gt; nums[pre]) return dp[index][pre] = Math.max(dfs(index + 1, index) + 1, dfs(index + 1, pre)); return dp[index][pre] = dfs(index + 1, pre); &#125; int[][] dp; int[] nums; int n; &#125; 方法二：记忆化搜索(枚举选哪个) dp不用重复初始化，因为记忆化的是增量 12345678910111213141516171819202122232425262728class Solution &#123; public int lengthOfLIS(int[] nums) &#123; n = nums.length; this.nums = nums; dp = new int[n]; int res = 1; for (int i = 0; i &lt; n; ++i) &#123; res = Math.max(res, dfs(i)); &#125; return res; &#125; public int dfs(int index) &#123; if (dp[index] != 0) return dp[index]; int res = 1; for (int i = index + 1; i &lt; n; ++i) &#123; if (nums[i] &gt; nums[index]) res = Math.max(res, dfs(i) + 1); &#125; return dp[index] = res; &#125; int[] dp; int[] nums; int n; &#125; 方法三：DP 12345678910111213141516class Solution &#123; public int lengthOfLIS(int[] nums) &#123; int n = nums.length, res = 1; // 以i为结尾，最长递增子序列的长度 int[] dp = new int[n]; Arrays.fill(dp, 1); for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; i; ++j) &#123; if (nums[i] &gt; nums[j]) dp[i] = Math.max(dp[i], dp[j] + 1); &#125; res = Math.max(res, dp[i]); &#125; return res; &#125;&#125; 416. 分割等和子集 方法一：记忆化搜索 12345678910111213141516171819202122232425262728293031class Solution &#123; public boolean canPartition(int[] nums) &#123; int target = 0, n = nums.length; for (int x : nums) target += x; if (target % 2 == 1) return false; target /= 2; dp = new int[n][target + 1]; for (int[] arr : dp) Arrays.fill(arr, -1); return dfs(0, nums, target); &#125; int[][] dp; public boolean dfs(int index, int[] nums, int target) &#123; if (index == nums.length) return target == 0 ? true : false; if (dp[index][target] != -1) return dp[index][target] == 1 ? true : false; boolean choose = false, pass = false; int x = nums[index]; if (target - x &gt;= 0) &#123; choose = dfs(index + 1, nums, target - x); &#125; pass = dfs(index + 1, nums , target); dp[index][target] = (choose || pass) ? 1 : 0; return dp[index][target] == 1 ? true : false; &#125;&#125; 115. 不同的子序列 二刷记忆化搜索 12345678910111213141516171819202122232425262728293031class Solution &#123; public int numDistinct(String s, String t) &#123; m = s.length(); n = t.length(); this.s = s; this.t = t; dp = new int[m][n]; for (int[] arr : dp) Arrays.fill(arr, -1); return dfs(0, 0); &#125; public int dfs(int i, int j) &#123; // t被匹配返回1 if (j == n) return 1; // s到最后也没能匹配到t的最后一个字符，返回0 if (i == m) return 0; if (dp[i][j] != -1) return dp[i][j]; // 匹配：选：i，j往下递归；不选：i往下递归 if (s.charAt(i) == t.charAt(j)) return dp[i][j] = dfs(i + 1, j + 1) + dfs(i + 1, j); return dp[i][j] = dfs(i + 1, j); &#125; int m, n; String s, t; int[][] dp;&#125; 方法三：滚动数组 12345678910111213141516class Solution &#123; public int numDistinct(String s, String t) &#123; int m = s.length(), n = t.length(); // s[:i]中t[:j]出现的次数 int[] dp = new int[n + 1]; // s,t为空串，匹配 dp[0] = 1; for (int i = 1; i &lt;= m; ++i) &#123; for (int j = n; j &gt;= 1; --j) &#123; if (s.charAt(i - 1) == t.charAt(j - 1)) dp[j] += dp[j - 1]; &#125; &#125; return dp[n]; &#125;&#125; 方法一：DP 注意初始化 123456789101112131415161718192021222324class Solution &#123; public int numDistinct(String s, String t) &#123; /** s = &quot;bagg&quot;, t = &quot;bag&quot; 对于bag的最后一个&#x27;g&#x27;，可以使用它，或者不使用它 */ int m = s.length(), n = t.length(); if (m &lt; n) return 0; int[][] dp = new int[m + 1][n + 1]; dp[0][0] = 1; for (int i = 1;i &lt;= m; ++i) dp[i][0] = 1; for (int i = 1; i &lt;= m; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; if (s.charAt(i - 1) == t.charAt(j - 1)) dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]; else dp[i][j] = dp[i - 1][j]; &#125; &#125; return dp[m][n]; &#125;&#125; 方法二：记忆化搜索 优质题解 1234567891011121314151617181920212223242526class Solution &#123; public int numDistinct(String s, String t) &#123; m = s.length(); n = t.length(); dp = new int[m][n]; for (int[] arr : dp) Arrays.fill(arr, -1); return dfs(s, t, m - 1, n - 1); &#125; int m, n; int[][] dp; private int dfs(String s, String t, int i, int j) &#123; if (j &lt; 0) // base case 当j指针越界，此时t为空串，s不管是不是空串，匹配方式数都是1 return 1; if (i &lt; 0) // base case i指针越界，此时s为空串，t不是，s怎么也匹配不了t，方式数0 return 0; if (dp[i][j] != -1) return dp[i][j]; if (s.charAt(i) == t.charAt(j)) return dp[i][j] = dfs(s, t, i - 1, j - 1) + dfs(s, t, i - 1, j); else return dp[i][j] = dfs(s, t, i - 1, j); &#125;&#125; 2896. 执行操作使两个字符串相等 方法一：记忆化搜索 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public int minOperations(String s1, String s2, int x) &#123; n = s1.length(); int cnt1 = 0, cnt2 = 0; for (int i = 0; i &lt; n; ++i) &#123; if (s1.charAt(i) == &#x27;1&#x27;) ++cnt1; if (s2.charAt(i) == &#x27;1&#x27;) ++cnt2; &#125; if (cnt1 % 2 != cnt2 % 2) return -1; this.s1 = s1; this.s2 = s2; this.x = x; dp = new int[n][n + 1][2]; for (int[][] a : dp) for (int[] b : a) Arrays.fill(b, -1); return dfs(0, 0, false); &#125; public int dfs(int index, int key, boolean reverse) &#123; if (index &gt;= n) return key == 0 &amp;&amp; !reverse ? 0 : inf; if (dp[index][key][reverse ? 1 : 0] != -1) return dp[index][key][reverse ? 1 : 0]; char ch1 = s1.charAt(index), ch2 = s2.charAt(index); if ((ch1 == ch2) == !reverse) return dp[index][key][reverse ? 1 : 0] = dfs(index + 1, key, false); int res = Math.min(dfs(index + 1, key + 1, false) + x, dfs(index + 1, key, true) + 1); if (key &gt; 0) res = Math.min(res, dfs(index + 1, key - 1, false)); return dp[index][key][reverse ? 1 : 0] = res; &#125; String s1, s2; int x, inf = Integer.MAX_VALUE &gt;&gt; 1, n; int[][][] dp; &#125; 2897. 对数组执行操作使平方和最大 方法一：位运算 123456789101112131415161718192021222324public class Solution &#123; public int maxSum(List&lt;Integer&gt; nums, int k) &#123; final long MOD = 1_000_000_007; int[] cnt = new int[30]; for (int x : nums) &#123; for (int i = 0; i &lt; 30; i++) &#123; cnt[i] += (x &gt;&gt; i) &amp; 1; &#125; &#125; long ans = 0; while (k-- &gt; 0) &#123; int x = 0; for (int i = 0; i &lt; 30; i++) &#123; if (cnt[i] &gt; 0) &#123; cnt[i]--; x |= 1 &lt;&lt; i; &#125; &#125; ans = (ans + (long) x * x) % MOD; &#125; return (int) ans; &#125;&#125;","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://leopol1d.github.io/categories/Algorithms/"},{"name":"Memorization Search","slug":"Algorithms/Memorization-Search","permalink":"https://leopol1d.github.io/categories/Algorithms/Memorization-Search/"}],"tags":[{"name":"记忆化搜索","slug":"记忆化搜索","permalink":"https://leopol1d.github.io/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"}]},{"title":"Backtracking","slug":"backtracking","date":"2023-05-20T05:46:51.857Z","updated":"2023-09-27T09:31:07.610Z","comments":true,"path":"2023/05/20/backtracking/","link":"","permalink":"https://leopol1d.github.io/2023/05/20/backtracking/","excerpt":"","text":"Backtracking 93. 复原 IP 地址 解题思路：加“.”分割字符串 注意：isValid()中，如果得到的子串str为空，说明字符串s已经有三个“.”分割，并且最后一个点在最后一个位置，比如101.0.23.， s = s.substring(0, i + 1) + “.” + s.substring(i + 1);得到字符串s = 101.0.23. ++pointNum; 进入下一轮backtracking(s, i + 2, pointNum); i + 2为.后面一位9 此时pointNum == 3，判断ip是否合法if (isValid(s, start, s.length() - 1)) String str = s.substring(start, end + 1); 此时start为9，end + 1为9，String.subString左闭右开，所以得到的str为空 这种情况返回false 123456789101112131415161718192021222324252627282930313233343536class Solution &#123; List&lt;String&gt; res = new LinkedList&lt;&gt;(); public List&lt;String&gt; restoreIpAddresses(String s) &#123; if (s.length() &gt; 12) return res; backtracking(s, 0, 0); return res; &#125; private void backtracking(String s, int start, int pointNum) &#123; if (pointNum == 3) &#123; if (isValid(s, start, s.length() - 1)) res.add(s); return; &#125; for (int i = start; i &lt; s.length(); ++i) &#123; if (isValid(s, start, i)) &#123; s = s.substring(0, i + 1) + &quot;.&quot; + s.substring(i + 1); ++pointNum; backtracking(s, i + 2, pointNum); --pointNum; s = s.substring(0, i + 1) + s.substring(i + 2); // 删除&quot;.&quot; &#125; else break; &#125; &#125; private boolean isValid(String s, int start, int end) &#123; String str = s.substring(start, end + 1); if (str.isEmpty()) return false; return Integer.valueOf(str) &lt;= 255 &amp;&amp; (str.equals(&quot;0&quot;) ||str.charAt(0) != &#x27;0&#x27;); &#125;&#125; 方法二：回溯(StringBuilder) 需要注意很多细节 isValid 首先需要判断字符串是否为空; Integer.valueOf(s) &lt;= 255的前提是以下else需要break，不然会超出整型最大值 1234567891011for (int i = start; i &lt; s.length(); ++i) &#123; String str = s.substring(start, i + 1); if (isValid(str)) &#123; path.append(str); path.append(&quot;.&quot;); backtracking(s, i + 1, split + 1); deleteSub(); &#125; else break;&#125; 要么为0要么第一个字符不为0，s.equals(“0”) || s.charAt(0) != ‘0’ 删除函数 一般会做两次path.append操作，先append子串，再append .，所以删除操作先把.删除了，再删除上一个.之前的子串 12345private void deleteSub() &#123; path.deleteCharAt(path.length() - 1); while (path.length() != 0 &amp;&amp; path.charAt(path.length() - 1) != &#x27;.&#x27;) path.deleteCharAt(path.length() - 1);&#125; 注意base case，如果剩余子串满足条件，那么会将子串append到path中，再加到res中，所以在此之后需要回溯一次，将新加入的子串删掉 123456789if (split == 3) &#123; String str = s.substring(start); if (isValid(str)) &#123; path.append(str); res.add(path.toString()); deleteSub(); &#125; return;&#125; 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123; List&lt;String&gt; res = new LinkedList&lt;&gt;(); StringBuilder path = new StringBuilder(); public List&lt;String&gt; restoreIpAddresses(String s) &#123; if (s.length() &gt; 12) return res; backtracking(s, 0, 0); return res; &#125; private void backtracking(String s, int start, int split) &#123; if (split == 3) &#123; String str = s.substring(start); if (isValid(str)) &#123; path.append(str); res.add(path.toString()); deleteSub(); &#125; return; &#125; for (int i = start; i &lt; s.length(); ++i) &#123; String str = s.substring(start, i + 1); if (isValid(str)) &#123; path.append(str); path.append(&quot;.&quot;); backtracking(s, i + 1, split + 1); deleteSub(); &#125; else break; &#125; &#125; private void deleteSub() &#123; path.deleteCharAt(path.length() - 1); while (path.length() != 0 &amp;&amp; path.charAt(path.length() - 1) != &#x27;.&#x27;) path.deleteCharAt(path.length() - 1); &#125; private boolean isValid(String s) &#123; if (s.isEmpty()) return false; return Integer.valueOf(s) &lt;= 255 &amp;&amp; (s.equals(&quot;0&quot;) || s.charAt(0) != &#x27;0&#x27;); &#125;&#125; 方法三：StringBuilder + 剪枝 在方法二的基础上加入剪枝 s.length() - start表示未被选择的子串的长度，记为x吧，举例说明 如果split = 0，表示还没有进行分割，如果x &gt; 12，一定不能满足条件，return； 如果split = 1，表示分割了一段，如果x &gt; 9，一定不能满足条件，return； 12if (s.length() - start &gt; 3 * (4 - split)) return; 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123; List&lt;String&gt; res = new LinkedList&lt;&gt;(); StringBuilder path = new StringBuilder(); public List&lt;String&gt; restoreIpAddresses(String s) &#123; backtracking(s, 0, 0); return res; &#125; private void backtracking(String s, int start, int split) &#123; if (split == 3) &#123; String str = s.substring(start); if (isValid(str)) &#123; path.append(str); res.add(path.toString()); deleteSub(); &#125; return; &#125; if (s.length() - start &gt; 3 * (4 - split)) return; for (int i = start; i &lt; s.length(); ++i) &#123; String str = s.substring(start, i + 1); if (isValid(str)) &#123; path.append(str); path.append(&quot;.&quot;); backtracking(s, i + 1, split + 1); deleteSub(); &#125; else break; &#125; &#125; private void deleteSub() &#123; path.deleteCharAt(path.length() - 1); while (path.length() != 0 &amp;&amp; path.charAt(path.length() - 1) != &#x27;.&#x27;) path.deleteCharAt(path.length() - 1); &#125; private boolean isValid(String s) &#123; if (s.isEmpty()) return false; return Integer.valueOf(s) &lt;= 255 &amp;&amp; (s.equals(&quot;0&quot;) || s.charAt(0) != &#x27;0&#x27;); &#125;&#125; 131. 分割回文串 方法一：回溯 二刷 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; List&lt;List&lt;String&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;String&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;String&gt;&gt; partition(String s) &#123; backtracking(s, 0); return res; &#125; private void backtracking(String s, int start) &#123; if (start == s.length()) &#123; res.add(new LinkedList&lt;&gt;(path)); return; &#125; for (int i = start; i &lt; s.length(); ++i) &#123; String split = s.substring(start, i + 1); if (isValid(split)) &#123; path.add(split); backtracking(s, i + 1); path.pollLast(); &#125; &#125; &#125; private boolean isValid(String split) &#123; int start = 0, end = split.length() - 1; while (start &lt; end) &#123; if (split.charAt(start++) != split.charAt(end--)) return false; &#125; return true; &#125;&#125; 方法二：回溯 + DP预处理 使用动态规划得到所有子串是否是回文 状态：dp[i][j] 表示字符串s在[i,j]区间的子串是否是一个回文串。状态转移方程：当 s[i] == s[j] &amp;&amp; (j - i &lt; 2 || dp[i + 1][j - 1]) 时，dp[i][j]=true，否则为false 这个状态转移方程是什么意思呢？ 当只有一个字符时，比如 a 自然是一个回文串。当有两个字符时，如果是相等的，比如 aa，也是一个回文串。当有三个及以上字符时，比如 ababa 这个字符记作串 1，把两边的 a 去掉，也就是 bab 记作串 2，可以看出只要串2是一个回文串，那么左右各多了一个 a 的串 1 必定也是回文串。所以当 s[i]==s[j] 时，自然要看 dp[i+1][j-1] 是不是一个回文串。 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; public List&lt;List&lt;String&gt;&gt; partition(String s) &#123; n = s.length(); this.s = s; dp = new boolean[n][n]; // dp[i][j] = ch1 == ch2 &amp;&amp; (j - i + 1 &lt;= 2) || dp[i + 1][j - 1] for (int i = n - 1; i &gt;= 0; --i) &#123; for (int j = i; j &lt; n; ++j) &#123; if (s.charAt(i) == s.charAt(j) &amp;&amp; (j - i + 1 &lt;= 2 || dp[i + 1][j - 1])) dp[i][j] = true; &#125; &#125; dfs(0); return res; &#125; public void dfs(int index) &#123; if (index == n) &#123; res.add(new LinkedList(path)); return; &#125; for (int i = index; i &lt; n; ++i) &#123; String sub = s.substring(index, i + 1); if (dp[index][i]) &#123; path.add(sub); dfs(i + 1); path.pollLast(); &#125; &#125; &#125; boolean[][] dp; List&lt;List&lt;String&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;String&gt; path = new LinkedList&lt;&gt;(); // StringBuilder sb = new StringBuilder(); int n; String s; &#125; 剑指 Offer II 085. 生成匹配的括号 1234567891011121314151617181920class Solution &#123; List&lt;String&gt; res = new LinkedList&lt;&gt;(); public List&lt;String&gt; generateParenthesis(int n) &#123; backtracking(n, n, &quot;&quot;); return res; &#125; private void backtracking(int leftNum, int rightNum, String parenthesis) &#123; if (leftNum == 0 &amp;&amp; rightNum == 0) &#123; res.add(parenthesis); return; &#125; if (leftNum &gt; 0) &#123; backtracking(leftNum - 1, rightNum, parenthesis + &quot;(&quot;); &#125; if (leftNum &lt; rightNum) &#123; backtracking(leftNum, rightNum - 1, parenthesis + &quot;)&quot;); &#125; &#125;&#125; 方法二：StringBuilder 12345678910111213141516171819202122232425class Solution &#123; List&lt;String&gt; res = new LinkedList&lt;&gt;(); StringBuilder path = new StringBuilder(); public List&lt;String&gt; generateParenthesis(int n) &#123; backtracking(n, n); return res; &#125; private void backtracking(int left, int right) &#123; if (left == 0 &amp;&amp; right == 0) &#123; res.add(path.toString()); return; &#125; if (left &gt; 0) &#123; path.append(&quot;(&quot;); backtracking(left - 1, right); path.deleteCharAt(path.length() - 1); &#125; if (left &lt; right) &#123; path.append(&quot;)&quot;); backtracking(left, right - 1); path.deleteCharAt(path.length() - 1); &#125; &#125;&#125; 77. 组合 方法一： 剪枝： 当前最多用n - i + 1 当前还需要加入k - path.size()个数组 n - i + 1 &gt;= k - path.size 1234567891011121314151617181920class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; backtracking(n, k, 1); return res; &#125; private void backtracking(int n, int k, int start) &#123; if (path.size() == k) &#123; res.add(new LinkedList&lt;&gt;(path)); return; &#125; for (int i = start; i &lt;= n - (k - path.size()) + 1; ++i) &#123; path.add(i); backtracking(n, k, i + 1); path.pollLast(); &#125; &#125;&#125; 方法二： 123456789101112131415161718192021222324class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; // 防止底层扩容 Deque&lt;Integer&gt; path = new ArrayDeque&lt;&gt;(k); backtracking(path, n, k, 1); return res; &#125; private void backtracking(Deque&lt;Integer&gt; path, int n, int k, int start) &#123; if (k == 0) &#123; res.add(new LinkedList&lt;&gt;(path)); return; &#125; // 若n=3，k=2,即从[1,2,3]中选两个数，如果当前什么都没选(k=2)，n - k + 1= 2， // 说明至少要从2开始，才能满足选两个数这个要求 int bound = n - k + 1; if (start &gt; bound) return; backtracking(path, n, k, start + 1); path.addLast(start); backtracking(path, n, k - 1, start + 1); path.removeLast(); &#125;&#125; 两种方法的树形结构（求子集为例子） 216. 组合总和 III 方法一： 注意：backtracking(k - 1, n - i, i + 1);k - 1，别写成–k!!! 1234567891011121314151617181920public class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) &#123; backtracking(k, n, 1); return res; &#125; private void backtracking(int k, int n, int start) &#123; if (k == 0) &#123; if (n == 0) res.add(new LinkedList&lt;&gt;(path)); return; &#125; for (int i = start; i &lt;= 9 - (k - path.size()) + 1; ++i) &#123; path.offerLast(i); backtracking(k - 1, n - i, i + 1); path.pollLast(); &#125; &#125; 方法二： 1234567891011121314151617181920212223public class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) &#123; backtracking(k, n, 1); return res; &#125; private void backtracking(int k, int n, int start) &#123; if (k == 0) &#123; if (n == 0) res.add(new LinkedList&lt;&gt;(path)); return; &#125; int bound = 9 - k + 1; if (start &gt; bound) return; backtracking(k, n, start + 1); path.offerLast(start); backtracking(k - 1, n - start, start + 1); path.pollLast(); &#125;&#125; 39. 组合总和 无重复元素，每个元素可以无限次选取 方法一： 剪枝： 12if (target &lt; candidates[i]) break; 可重复选取，所以backtracking传入的是当前下标i 1backtracking(candidates, target - candidates[i], i); 剪枝的条件是把数组排序 1Arrays.sort(candidates); 123456789101112131415161718192021222324List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;();Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;();public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; Arrays.sort(candidates); backtracking(candidates, target, 0); return res;&#125;private void backtracking(int[] candidates, int target, int start) &#123; if (target &lt; 0) return; if (target == 0) &#123; res.add(new LinkedList&lt;&gt;(path)); return; &#125; for (int i = start; i &lt; candidates.length; ++i) &#123; if (target &lt; candidates[i]) break; path.offerLast(candidates[i]); backtracking(candidates, target - candidates[i], i); path.pollLast(); &#125;&#125; 方法二： 1234567891011121314151617181920212223class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; Arrays.sort(candidates); backtracking(candidates, target, 0); return res; &#125; private void backtracking(int[] candidates, int target, int start) &#123; if (target &lt; 0 || start == candidates.length) return; if (target == 0) &#123; res.add(new LinkedList&lt;&gt;(path)); return; &#125; backtracking(candidates, target, start + 1); path.offerLast(candidates[start]); backtracking(candidates, target - candidates[start], start); path.pollLast(); &#125;&#125; 40. 组合总和 II 数组内有重复元素，每个元素只能使用一次，解集不能包含重复组合 方法一： 剪枝 12if (candidates[i] &gt; target) break; 去重 12if (i &gt; start &amp;&amp; candidates[i] == candidates[i - 1]) continue; 1234567891011121314151617181920212223242526class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; Arrays.sort(candidates); backtracking(candidates, target, 0); return res; &#125; private void backtracking(int[] candidates, int target, int start) &#123; if (target == 0) &#123; res.add(new LinkedList&lt;&gt;(path)); return; &#125; for (int i = start; i &lt; candidates.length; ++i) &#123; if (candidates[i] &gt; target) break; if (i &gt; start &amp;&amp; candidates[i] == candidates[i - 1]) continue; path.offerLast(candidates[i]); backtracking(candidates, target - candidates[i], i + 1); path.pollLast(); &#125; &#125;&#125; 78. 子集 1234567891011121314151617181920class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; backtracking(nums, 0); return res; &#125; private void backtracking(int[] nums, int start) &#123; if (start == nums.length) &#123; res.add(new LinkedList&lt;&gt;(path)); return; &#125; backtracking(nums, start + 1); path.offerLast(nums[start]); backtracking(nums, start + 1); path.pollLast(); &#125;&#125; 491. 递增子序列 方法一：顺序DFS 注意： HashSet的位置！！！每进入一层递归，就会在for循环前创建一个HashSet，这样可以保证树层去重，并且树枝不会去重 peekLast()! 不是peek() 1234567891011121314151617181920212223class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; findSubsequences(int[] nums) &#123; backtracking(nums, 0); return res; &#125; public void backtracking(int[] nums, int start) &#123; if (path.size() &gt;= 2) res.add(new LinkedList(path)); Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int i = start; i &lt; nums.length; ++i) &#123; if ((!path.isEmpty() &amp;&amp; nums[i] &lt; path.peekLast())) continue; if (set.contains(nums[i])) continue; set.add(nums[i]); path.add(nums[i]); backtracking(nums, i + 1); path.pollLast(); &#125; &#125;&#125; 46. 全排列 把树形结构画出来就懂了 for (int i = 0; i &lt; nums.length; ++i) { if (used[i]) continue;与 for (int i = 0; i &lt; nums.length &amp;&amp; !used[i]; ++i) 的区别 这两个循环的区别在于循环终止条件的判断逻辑。 第一个循环： 12345for (int i = 0; i &lt; nums.length; ++i) &#123; if (used[i]) continue; // 其他代码逻辑&#125; 这个循环会遍历数组 nums 的所有元素，但在每次迭代中，如果当前元素已经被标记为 used[i]，则会使用 continue 跳过后续的代码逻辑，直接进入下一次迭代。 第二个循环： 123for (int i = 0; i &lt; nums.length &amp;&amp; !used[i]; ++i) &#123; // 其他代码逻辑&#125; 这个循环同样会遍历数组 nums 的所有元素，但在每次迭代中，会先检查终止条件 i &lt; nums.length &amp;&amp; !used[i]。只有当两个条件都满足时，才会执行循环体中的代码逻辑。如果其中任何一个条件不满足，循环就会终止。 12345678910111213141516171819202122232425262728class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path; boolean[] used; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; // 防止底层扩容 path = new ArrayDeque&lt;&gt;(nums.length); used = new boolean[nums.length]; backtracking(nums, 0); return res; &#125; private void backtracking(int[] nums, int start) &#123; if (path.size() == nums.length) &#123; res.add(new ArrayList&lt;&gt;(path)); return; &#125; for (int i = 0; i &lt; nums.length; ++i) &#123; if (used[i]) continue; path.offerLast(nums[i]); used[i] = true; backtracking(nums, i + 1); used[i] = false; path.pollLast(); &#125; &#125;&#125; 47. 全排列 II 为了去重，需要先将数组排序 树层去重，树枝不需要去重 上一个相同的数如果used[i - 1] == false，那么说明已经被遍历过，并且将used数组赋值回false，这个时候就不需要遍历当前nums[i]了；如果used[i - 1] == true，那么说明是在同一路径上 12if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !used[i - 1]) continue; 12345678910111213141516171819202122232425262728293031class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path; boolean[] used; public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; // 防止底层扩容 path = new ArrayDeque&lt;&gt;(nums.length); used = new boolean[nums.length]; Arrays.sort(nums); backtracking(nums, 0); return res; &#125; private void backtracking(int[] nums, int start) &#123; if (path.size() == nums.length) &#123; res.add(new ArrayList&lt;&gt;(path)); return; &#125; for (int i = 0; i &lt; nums.length; ++i) &#123; if (used[i]) continue; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !used[i - 1]) continue; path.offerLast(nums[i]); used[i] = true; backtracking(nums, i + 1); used[i] = false; path.pollLast(); &#125; &#125;&#125; 698. 划分为k个相等的子集二刷没做出，三刷ac 优质题解 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); int[] bucket; public boolean canPartitionKSubsets(int[] nums, int k) &#123; int sum = Arrays.stream(nums).sum(); if (sum % k != 0) return false; int target = sum / k; bucket = new int[k]; Arrays.sort(nums); int l = 0, r = nums.length - 1; while (l &lt; r) &#123; int temp = nums[l]; nums[l] = nums[r]; nums[r] = temp; ++l; --r; &#125; return backtracking(nums, k, target, 0); &#125; private boolean backtracking(int[] nums, int k, int target, int index) &#123; if (index == nums.length) return true; for (int i = 0; i &lt; k; ++i) &#123; if (i &gt; 0 &amp;&amp; bucket[i - 1] == bucket[i]) continue; if (nums[index] + bucket[i] &gt; target) continue; bucket[i] += nums[index]; if (backtracking(nums, k, target, index + 1)) return true; bucket[i] -= nums[index]; &#125; return false; &#125;&#125; 51. N 皇后 方法一：回溯 可以通过(c == colum[i] || r + c == i + colum[i] || r - c == i - colum[i])来判断是否同列，同对角线 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution &#123; public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; this.n = n; colum = new int[n]; // 第i行选择的列号 dfs(0); return res; &#125; public void dfs(int index) &#123; if (index == n) &#123; // index是行 res.add(build()); return; &#125; for (int i = 0; i &lt; n; ++i) &#123; // i是列 if (isValid(index, i)) &#123; colum[index] = i; dfs(index + 1); &#125; &#125; &#125; public boolean isValid(int r, int c) &#123; for (int i = 0; i &lt; r; ++i) &#123; if (c == colum[i] || r + c == i + colum[i] || r - c == i - colum[i]) return false; &#125; return true; &#125; public List&lt;String&gt; build() &#123; List&lt;String&gt; s = new ArrayList&lt;&gt;(); StringBuilder sb = new StringBuilder(); for (int x : colum) &#123; for (int i = 0; i &lt; x; ++i) sb.append(&#x27;.&#x27;); sb.append(&#x27;Q&#x27;); for (int i = 0; i &lt; n - x - 1; ++i) sb.append(&#x27;.&#x27;); s.add(sb.toString()); sb = new StringBuilder(); &#125; return s; &#125; List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); Deque&lt;String&gt; path = new LinkedList&lt;&gt;(); int[] colum; int n; &#125; 473. 火柴拼正方形 与698. 划分为k个相等的子集一道题 方法一：回溯 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); int[] bucket = new int[4]; public boolean makesquare(int[] matchsticks) &#123; int sum = Arrays.stream(matchsticks).sum(); if (sum % 4 != 0) return false; int target = sum / 4, l = 0, r = matchsticks.length - 1; Arrays.sort(matchsticks); while (l &lt; r) &#123; int temp = matchsticks[l]; matchsticks[l] = matchsticks[r]; matchsticks[r] = temp; ++l; --r; &#125; return backtracking(matchsticks, 0, target); &#125; private boolean backtracking(int[] matchsticks, int index, int target) &#123; if (index == matchsticks.length) return true; for (int i = 0; i &lt; 4; ++i) &#123; if (i &gt; 0 &amp;&amp; bucket[i - 1] == bucket[i]) continue; if (matchsticks[index] + bucket[i] &gt; target) continue; bucket[i] += matchsticks[index]; if (backtracking(matchsticks, index + 1, target)) return true; bucket[i] -= matchsticks[index]; &#125; return false; &#125;&#125; 2305. 公平分发饼干参考题解 这一题和分割数组的最大值的区别是，这里的cookies不需要连续取！！！！！ 方法一：回溯 12345678910111213141516171819202122232425262728class Solution &#123; int res = Integer.MAX_VALUE; int[] bucket; public int distributeCookies(int[] cookies, int k) &#123; Arrays.sort(cookies); bucket = new int[k]; backtracking(cookies, k, 0); return res; &#125; private void backtracking(int[] cookies, int k, int index) &#123; if (index == cookies.length) &#123; int curAns = Integer.MIN_VALUE; for (int count : bucket)&#123; curAns = Math.max(curAns, count); &#125; res = Math.min(res, curAns); return; &#125; for (int i = 0; i &lt; k; ++i) &#123; if (i &gt; 0 &amp;&amp; bucket[i - 1] == bucket[i]) continue; bucket[i] += cookies[index]; backtracking(cookies, k, index + 1); bucket[i] -= cookies[index]; &#125; &#125;&#125; 方法二：回溯 + 二分 求最小的最大值 用k个框(bucket)装一个数组，所有框统一尺寸，要求框的最小尺寸 left是数组的最大元素，right是数组元素之和，如果把框的尺寸设为left，那么大概率不能容纳所有数组元素： left = mid + 1；如果把框的尺寸设为right，肯定能装下数组所有元素：right = mid - 1 只要check(cookies, mid, k)为true，说明mid刚刚好或者选大了，框的上界可以进一步缩小， 当最后一次满足check(cookies, mid, k)为true并向左滑动右区间，之后只会向右滑动左区间， 最后left = right + 1退出while循环，left就是最小的最大值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123; int[] bucket; public int distributeCookies(int[] cookies, int k) &#123; bucket = new int[k]; Arrays.sort(cookies); int l = 0, r = cookies.length - 1, sum = 0; while (l &lt; r) &#123; int temp = cookies[l]; cookies[l] = cookies[r]; cookies[r] = temp; sum += temp + cookies[l]; ++l; --r; &#125; if (cookies.length % 2 != 0) sum += cookies[cookies.length / 2]; l = cookies[0]; // 数组最大值 r = sum; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if (check(cookies, mid, k)) // mid刚刚好或者选大了，bucket的上界可以进一步缩小 r = mid - 1; else l = mid + 1; &#125; return l; &#125; private boolean check(int[] cookies, int mid, int k) &#123; bucket = new int[k]; return backtracking(cookies, mid, k, 0); &#125; private boolean backtracking(int[] cookies, int limit, int k, int index) &#123; if (index == cookies.length) return true; // 如果能遍历到这一步，说明所有元素都被装入桶中;如果有元素不能放入任意一个桶中，会走完for循环，return false for (int i = 0; i &lt; k; ++i) &#123; if (i &gt; 0 &amp;&amp; bucket[i - 1] == bucket[i]) // 如果两个桶已装容量一致，那么把当前饼干放在哪个桶效果都一样 continue; if (bucket[i] + cookies[index] &gt; limit) continue; bucket[i] += cookies[index]; if (backtracking(cookies, limit, k, index + 1)) return true; // 如果有一种选择已经满足了，return true bucket[i] -= cookies[index]; &#125; return false; &#125;&#125; 1723. 完成所有工作的最短时间 与2305. 公平分发饼干一模一样 方法一：二分 + 回溯这里的二分和之前做的二分不太一样要求最小的最大值，我们用二分去测试，如果允许每个bucket的最大值为mid，是否能用k个bucket容纳下jobs的所有元素l取jobs中最大的元素，r取jobs的和sum，比如每个bucket的最大值为sum，那么一个bucket就能容纳下jobs的所有元素，那么肯定是要取更小的bucket的最大值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123; int[] bucket; public int minimumTimeRequired(int[] jobs, int k) &#123; bucket = new int[k]; Arrays.sort(jobs); int l = 0, r = jobs.length - 1; while (l &lt; r) &#123; int temp = jobs[l]; jobs[l] = jobs[r]; jobs[r] = temp; ++l; --r; &#125; l = jobs[0]; r = Arrays.stream(jobs).sum(); while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if (check(jobs, mid, k)) // mid刚好或者选大了 r = mid - 1; else l = mid + 1; &#125; return l; &#125; private boolean check(int[] jobs, int limit, int k) &#123; bucket = new int[k]; return backtracking(jobs, limit, k, 0); &#125; private boolean backtracking(int[] jobs, int limit, int k, int index) &#123; if (index == jobs.length) return true; for (int i = 0; i &lt; k; ++i) &#123; if (i &gt; 0 &amp;&amp; bucket[i - 1] == bucket[i]) continue; if (jobs[index] + bucket[i] &gt; limit) continue; bucket[i] += jobs[index]; if (backtracking(jobs, limit, k, index + 1)) return true; bucket[i] -= jobs[index]; &#125; return false; &#125;&#125; 优化求sum部分 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution &#123; int[] bucket; public int minimumTimeRequired(int[] jobs, int k) &#123; bucket = new int[k]; Arrays.sort(jobs); int l = 0, r = jobs.length - 1, sum = 0; while (l &lt; r) &#123; int temp = jobs[l]; jobs[l] = jobs[r]; jobs[r] = temp; sum += temp + jobs[l]; ++l; --r; &#125; if (jobs.length % 2 != 0) sum += jobs[jobs.length / 2]; l = jobs[0]; // 数组最大值 r = sum; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if (check(jobs, mid, k)) // mid刚好或者选大了 r = mid - 1; else l = mid + 1; &#125; return l; &#125; private boolean check(int[] jobs, int limit, int k) &#123; bucket = new int[k]; return backtracking(jobs, limit, k, 0); &#125; private boolean backtracking(int[] jobs, int limit, int k, int index) &#123; if (index == jobs.length) return true; for (int i = 0; i &lt; k; ++i) &#123; if (i &gt; 0 &amp;&amp; bucket[i - 1] == bucket[i]) continue; if (jobs[index] + bucket[i] &gt; limit) continue; bucket[i] += jobs[index]; if (backtracking(jobs, limit, k, index + 1)) return true; bucket[i] -= jobs[index]; &#125; return false; &#125;&#125; 二刷 省略check，每次在dfs前重新初始化bucket数组 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public int minimumTimeRequired(int[] jobs, int k) &#123; bucket = new int[k]; Arrays.sort(jobs); int l = 0, r = jobs.length - 1, sum = 0; while (l &lt; r) &#123; int temp = jobs[l]; jobs[l] = jobs[r]; jobs[r] = temp; sum += temp + jobs[l]; ++l; --r; &#125; if (jobs.length % 2 == 1) sum += jobs[jobs.length / 2]; l = jobs[0]; r = sum; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if (dfs(jobs, k, mid, 0)) r = mid - 1; else l = mid + 1; &#125; return l;&#125;int[] bucket;private boolean dfs(int[] jobs, int k, int target, int index) &#123; if (index == jobs.length) &#123; bucket = new int[k]; return true; &#125; for (int i = 0; i &lt; k; ++i) &#123; if (i &gt; 0 &amp;&amp; bucket[i - 1] == bucket[i]) continue; if (bucket[i] + jobs[index] &gt; target) continue; bucket[i] += jobs[index]; if (dfs(jobs, k, target,index + 1)) return true; bucket[i] -= jobs[index]; &#125; return false;&#125;","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://leopol1d.github.io/categories/Algorithms/"},{"name":"backtracking","slug":"Algorithms/backtracking","permalink":"https://leopol1d.github.io/categories/Algorithms/backtracking/"}],"tags":[{"name":"回溯","slug":"回溯","permalink":"https://leopol1d.github.io/tags/%E5%9B%9E%E6%BA%AF/"}]},{"title":"Algorithms","slug":"Algorithms","date":"2023-04-07T08:06:11.000Z","updated":"2023-05-29T10:23:55.658Z","comments":true,"path":"2023/04/07/Algorithms/","link":"","permalink":"https://leopol1d.github.io/2023/04/07/Algorithms/","excerpt":"","text":"LeetCode Solutions Dynamic Programming debug 1234567private static void printDp(int[] dp, int i) &#123; System.out.print(i + &quot;: &quot;); for (int maxValue : dp)&#123; System.out.print(maxValue + &quot; &quot;); &#125; System.out.println();&#125; 509. 斐波那契数 方法一：DP 123456789101112class Solution &#123; public int fib(int n) &#123; if (n == 0) return 0; int[] dp = new int[n + 1]; dp[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; dp[i] = dp[i - 2] + dp[i - 1]; &#125; return dp[n]; &#125;&#125; 方法二：DP + 滚动数组 123456789101112class Solution &#123; public int fib(int n) &#123; if (n == 0) return 0; int[] dp = new int[3]; dp[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; dp[i % 3] = dp[(i - 2) % 3] + dp[(i - 1) % 3]; &#125; return dp[n % 3]; &#125;&#125; 70. 爬楼梯 方法一：DP + 滚动数组 123456789101112131415class Solution &#123; public int climbStairs(int n) &#123; // 1.dp[i]:爬上第i层楼梯的方法数 // 2.状态转移方程：dp[i] = dp[i - 1] + dp[i - 2] // 3.初始化：爬上第0层楼梯的方法数是1，dp[0] = 1,如果是0，那么dp[2] = 1！ // 爬上第一层楼梯的方法数是1,dp[1] = 1 int[] dp = new int[3]; dp[0] = 1; dp[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; dp[i % 3] = dp[(i - 1) % 3] + dp[(i - 2) % 3]; &#125; return dp[n % 3]; &#125;&#125; 746. 使用最小花费爬楼梯 注意：最后一个阶梯之后才是楼顶 方法一：DP + 滚动数组 123456789101112131415class Solution &#123; public int minCostClimbingStairs(int[] cost) &#123; // dp[i]:爬到第i层的最小花费 // 状态转移方程：dp[i] = min(dp[i - 2] + cost[i - 2], dp[i - 1] + cost[i - 1]) // 初始化：dp[0] = 0, dp[1] = 0 int n = cost.length; int[] dp = new int[3]; dp[0] = 0; dp[1] = 0; for (int i = 2; i &lt;= n; ++i) &#123; dp[i % 3] = Math.min(dp[(i - 2) % 3] + cost[i - 2], dp[(i - 1) % 3] + cost[i - 1]); &#125; return dp[n % 3]; &#125;&#125; 剑指Offer 95 最优子结构：求最长公共子序列，求问题最优解，适合使用dp解决。 重叠子问题：求第一个字符串中位置0~$i$构成的子序列与第二个字符串中0~$j$构成的子序列的最大公共子序列$f(i,j)$，需要多次使用$f(i-1, j-1), f(i-1,j),f(i,j-1)$，拥有重叠子问题 状态转移方程： $$ f(i,j) = \\begin{cases} f(i-1,j-1)+1, &amp; ch[i]==ch[j] \\ max(f(i-1,j),f(i,j-1)), &amp; else \\ \\end{cases} $$ 边界条件：dp[0][:] == 0, dp[:][] == 0 令两个字符串长度分别为$m,n$， 时间复杂度：双重for循环，$O(mn)$ 空间复杂度：需要建立大小为(m+1)(n+1)的数组，因此空间复杂度为$O(mn)$ 1234567891011121314151617class Solution &#123; public int longestCommonSubsequence(String text1, String text2) &#123; int m = text1.length(), n = text2.length(); int[][] dp = new int[m + 1][n + 1]; for (int i = 1; i &lt;= m; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; if (text1.charAt(i - 1) == text2.charAt(j - 1)) &#123; dp[i][j] = dp[i - 1][j - 1] + 1; &#125; else &#123; dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]); &#125; &#125; &#125; return dp[m][n]; &#125;&#125; 如何优化空间复杂度？ 剑指Offer 101 分割等和子集 分析：只要在数组中找到任意数等于数组累加和的一半，该数组就是等和子集，可抽象为经典0-1背包问题。 dp[i][j]:从编号0-i的物品中任选物品(可以都不选)，容量为j的背包能否正好装满 递归公式:dp[i][j] = dp[i-1][j] || j &gt;= num[i] : dp[i-1][j-nums[i]] : false 初始化: 当j==0时，即背包容量为0，不管有多少物品，只要什么都不选就能使背包总重量为0，所以f(i,0)=true 当i==0 &amp;&amp; j!= 0时，即物品数量为0，怎样都不能放满容量大于0的背包，所以f(0,i)=false 遍历顺序：先遍历物品再嵌套从头到尾遍历容量 打印dp数组验证与手写稿是否一致 空间复杂度优化：由于求第i行dp数组只需要用到第i-1行dp数组的信息，所以可以使用一维滑动dp数组代替二维dp数组。 剑指Offer 1049 最后一块石头的重量 II 从 stones数组中选择，凑成总和不超过 $sum/2$ 的最大价值 1234567891011121314class Solution &#123; public int lastStoneWeightII(int[] stones) &#123; int sum = Arrays.stream(stones).sum(); int target = sum / 2; // dp[j]:容量为j的背包能装下不超过target的最大价值 int[] dp = new int[target + 1]; for (int i = 0; i &lt; stones.length; ++i) &#123; for (int j = target; j &gt;= stones[i]; --j) &#123; dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]); &#125; &#125; return sum - dp[target] * 2; &#125;&#125; 一和零 背包问题中，weight里的数据不一定要升序！比如weights=[4,1,3] 方法一：DP 12345678910111213141516171819202122232425class Solution &#123; public int findMaxForm(String[] strs, int m, int n) &#123; // dp[i][j]:最多有i个0，j个1，最多能选的字符数量 int[][][] dp = new int[strs.length + 1][m + 1][n + 1]; for (int k = 1; k &lt;= strs.length; ++k) &#123; String str = strs[k - 1]; int num0 = 0, num1 = 0; for (int x = 0; x &lt; str.length(); ++x) &#123; if (str.charAt(x) == &#x27;0&#x27;) ++num0; else ++num1; &#125; for (int i = 0; i &lt;= m; ++i) &#123; for (int j = 0; j &lt;= n; ++j) &#123; if (i &lt; num0 || j &lt; num1) dp[k][i][j] = dp[k - 1][i][j]; else dp[k][i][j] = Math.max(dp[k - 1][i][j], dp[k - 1][i - num0][j - num1] + 1); &#125; &#125; &#125; return dp[strs.length][m][n]; &#125;&#125; 方法二：DP+滚动数组 12345678910111213141516171819202122class Solution &#123; public int findMaxForm(String[] strs, int m, int n) &#123; // dp[i][j]:最多有i个0，j个1，最多能选的字符数量 int[][] dp = new int[m + 1][n + 1]; for (int k = 1; k &lt;= strs.length; ++k) &#123; String str = strs[k - 1]; int num0 = 0, num1 = 0; for (int x = 0; x &lt; str.length(); ++x) &#123; if (str.charAt(x) == &#x27;0&#x27;) ++num0; else ++num1; &#125; for (int i = m; i &gt;= num0; --i) &#123; for (int j = n; j &gt;= num1; --j) &#123; dp[i][j] = Math.max(dp[i][j], dp[i - num0][j - num1] + 1); &#125; &#125; &#125; return dp[m][n]; &#125;&#125; 518. 零钱兑换 II ​ 经典完全背包问题，解题步骤如下： dp[j]：背包容量为j时，放满背包的组合方法数 状态转移公式：dp[j] = dp[j] + dp[j - coins[i]] 初始化dp[0]：背包容量为0时，有一种方法放满背包（什么都不放） 遍历顺序：求组合数，先便利物品，再遍历容量 遍历dp数组 关于组合和排列的理解：先遍历物品后遍历背包是这样，比如，外层循环固定coins[1]，在内层循环遍历背包时，随着背包不断增加，coins[1]可以重复被添加进来，而由于外层循环固定了，因此coins[2]只能在下一次外层循环添加进不同大小的背包中，这么看的话，coins[i + 1]只能在coins[i]之后了；如果先遍历背包后遍历物品，那么外层循环先固定背包大小j，然后在大小为j的背包中循环遍历添加物品，然后在下次外层循环背包大小变为j+1，此时仍要执行内层循环遍历添加物品，也就会出现在上一轮外层循环中添加coins[2]的基础上还能再添加coins[1]的情况，那么就有了coins[1]在coins[2]之后的情况了(逆序)。 如果求组合数就是外层for循环遍历物品，内层for遍历背包。 如果求排列数就是外层for遍历背包，内层for循环遍历物品。 377. 组合总和 Ⅳ 先举个例子，nums = [1, 2, 3]，target = 35. 假设用1，2，3拼凑出35的总组合个数为y。我们可以考虑三种情况： （1）有效组合的末尾数字为1，这类组合的个数为 x1。我们把所有该类组合的末尾1去掉，那么不难发现，我们找到了一个子问题，x1即为在[1，2，3]中凑出35 - 1 = 34的总组合个数。因为我如果得到了和为34的所有组合，我只要在所有组合的最后面，拼接一个1，就得到了和为35且最后一个数字为1的组合个数了。 （2）有效组合的末尾数字为2，这类组合的个数为 x2。我们把所有该类组合的末尾2去掉，那么不难发现，我们找到了一个子问题，x2即为在[1，2，3]中凑出35 - 2 = 33的总组合个数。因为我如果得到了和为33的所有组合，我只要在所有组合的最后面，拼接一个2，就得到了和为35且最后一个数字为2的组合个数了。 （3）有效组合的末尾数字为3，这类组合的个数为 x3。我们把所有该类组合的末尾3去掉，那么不难发现，我们找到了一个子问题，x3即为在[1，2，3]中凑出35 - 3 = 32的总组合个数。因为我如果得到了和为32的所有组合，我只要在所有组合的最后面，拼接一个3，就得到了和为35且最后一个数字为3的组合个数了。 这样就简单了，y = x1 + x2 + x3。而x1，x2，x3又可以用同样的办法从子问题得到。状态转移方程get！ 全排列问题，转化为完全背包问题 dp[j]：在背包容量为j时，放满背包的排列数 状态转移公式：dp[j] = dp[j] + dp[j - nums[i]] 初始化dp[0]：在背包容量为0时，放满背包的排列数量为1（什么都不放） 遍历顺序，排列问题，先遍历背包容量(物品可以逆序放入dp[j - nums[i]])，再遍历物品 打印dp数组 70. 爬楼梯 完全背包 + 全排列问题，可以重复选择放入物品1与物品2，求放满容量为n的背包的排列数 dp[j]：在背包容量为j时，放满背包的排列数 状态转移公式：dp[j] = dp[j] + dp[j - nums[i]] 初始化dp[0]：在背包容量为0时，放满背包的排列数量为1（什么都不放） 遍历顺序，排列问题，先遍历背包容量(物品可以逆序放入dp[j - nums[i]])，再遍历物品 打印dp数组 322. 零钱兑换 完全背包问题 dp[j]：背包容量为j时，凑满背包容量所需的最少硬币数 状态转移公式：dp[j] = min(dp[j], dp[j - coins[i]] + 1) 初始化dp[0]：背包容量为0时，凑满背包容量所需的最少硬币数时0,其他初始化为Integer.MAX_VALUE 遍历顺序，无所谓 打印dp数组 1234567891011121314151617class Solution &#123; public int coinChange(int[] coins, int amount) &#123; // dp[j]: 凑成整数j所需的最少的硬币书 // 状态转移方程：dp[j] = min(dp[j], dp[j - nums[i] + 1]) // 初始化：dp[0] = 0,其他初始化为1 int[] dp = new int[amount + 1]; Arrays.fill(dp, Integer.MAX_VALUE); dp[0] = 0; for (int i = 0; i &lt; coins.length; ++i) &#123; for (int j = coins[i]; j &lt;= amount; ++j) &#123; if (dp[j - coins[i]] != Integer.MAX_VALUE) dp[j] = Math.min(dp[j], dp[j - coins[i]] + 1); &#125; &#125; return dp[amount] == Integer.MAX_VALUE ? -1 : dp[amount]; &#125;&#125; 279. 完全平方数 dp[j]：装满容量为j的背包，至少要放多少个物品 状态转移公式：dp[j] = min(dp[j], dp[j - weights[i]] + 1) 初始化dp[0]:装满容量为0的背包，至少放0个物品；其他设为Integet.MAX_VALUE 遍历顺序：无所谓 打印dp数组 123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public int numSquares(int n) &#123; // 完全背包问题 // 定义物品的weights数组，先找到小于等于n的最大完全平方数 int max_weight = (int)(Math.sqrt(n)); int[] weights = new int[max_weight]; for(int i = 1; i &lt;= max_weight; i++) weights[i-1] = i*i; // 1.dp[j]：装满容量为j的背包，至少要放多少个物品 int[] dp = new int[n + 1]; // 2.状态转移公式：dp[j] = min(dp[j], dp[j - weights[i]] + 1) // 3.初始化dp[0]:装满容量为0的背包，至少放0个物品；其他设为Integet.MAX_VALUE for(int i = 1; i &lt;= n; i++) &#123; dp[i] = Integer.MAX_VALUE; &#125; // 4.遍历顺序：无所谓 for(int i = 0; i &lt; weights.length; i++) &#123; for(int j = weights[i]; j &lt;= n; j++) &#123; if(dp[j - weights[i]] != Integer.MAX_VALUE) dp[j] = Math.min(dp[j], dp[j - weights[i]] + 1); &#125; // printDp(dp, i); &#125; return dp[n]; // 5.打印dp数组 &#125; private static void printDp(int[] dp, int i) &#123; System.out.print(i + &quot;: &quot;); for (int maxValue : dp)&#123; System.out.print(maxValue + &quot; &quot;); &#125; System.out.println(); &#125;&#125; 139. 单词拆分 背包问题 + 排列(“leetcode”由“leet”与“code”组成但不能反过来由“code”与“leet”组成 )的变种，建议不要完全抽象成背包问题，便于理解 dp[j]：长度为j的字符串，可以被字典中的单词拆分。 状态转移公式：if([j, i] 这个区间的子串出现在字典里 &amp;&amp; dp[j]是true) 那么 dp[i] = true， 其中j&lt;i。 初始化dp[0]:dp[i]依赖于前面的dp[j]，所以dp[0]要初始化为true，不然全为false 遍历顺序：先遍历背包容量，再嵌套遍历物品 打印dp数组 198. 打家劫舍 dp[j]：偷窃从标号为0到j的房屋所能获得的最大价值 状态转移公式：dp[j] = max(dp[j - 1], dp[j - 2] + nums[j]) 初始化：dp[0] = nums[0], dp[1] = max(nums[0], nums[1]) 遍历顺序：单序列问题,dp[i] 是根据dp[i - 2] 和 dp[i - 1] 推导出来的，那么一定是从前到后遍历！ 遍历dp数组 优化空间复杂度 根据状态转移公式dp[j] = max(dp[j - 1], dp[j - 2] + nums[j])，dp[j]只需要dp[j-1]以及dp[j-2]两个变量即可，可以把数组大小压缩到2。 213. 打家劫舍 II 416. 分割等和子集 dp[j]：背包容量为j时，是否能用物品装满 状态转移方程：dp[j] = dp[j] || dp[j - nums[i]] 初始化：背包容量为0时，不把物品装进去即可装满，dp[0] = true 遍历顺序：一维滑动数组，零一背包，先遍历物品后遍历背包容量 337. 打家劫舍 III 方法一：HashMap f：偷当前房屋能获得的最大价值；g：不偷当前房屋能获得的最大价值 偷当前房屋f(cur) = cur.val + g(cur.left) + g(cur.right) 不偷当前房屋g(cur) = max(f(cur.left), g(cur.left)) + max(f(cur.right), g(cur.right)) 方法二：Morris + HashMap 当作是练习题了！！ **注意事项：**在访问的时候，此时需要cur.right，而这个时候已经是逆序过的，cur.right实际上指向的是自己的父节点，所以再用一个hashmap存储cur真正的右节点（或者再逆序一遍）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Solution &#123; Map&lt;TreeNode, Integer&gt; f = new HashMap&lt;&gt;(); Map&lt;TreeNode, Integer&gt; g = new HashMap&lt;&gt;(); Map&lt;TreeNode, TreeNode&gt; right = new HashMap&lt;&gt;(); public int rob(TreeNode root) &#123; // f:偷当前节点能获得的最大价值 // g:不偷当前节点能获得的最大价值 // f(cur) = cur.val + g(cur.left) + g(cur.right) // g(cur) = max(f(cur.left), g(cur.left)) + max(f(cur.right), g(cur.right)) TreeNode cur = root, mostRight = null; while (cur != null) &#123; mostRight = cur.left; if (mostRight != null) &#123; while (mostRight.right != null &amp;&amp; mostRight.right != cur) mostRight = mostRight.right; if (mostRight.right == null) &#123; mostRight.right = cur; cur = cur.left; continue; &#125; else &#123; // mostRight.right = cur mostRight.right = null; visit(cur.left); &#125; &#125; cur = cur.right; &#125; visit(root); return Math.max(f.getOrDefault(root, 0), g.getOrDefault(root, 0)); &#125; private void visit(TreeNode cur) &#123; TreeNode tail = reverse(cur); cur = tail; while (cur != null) &#123; f.put(cur, cur.val + g.getOrDefault(cur.left, 0) + g.getOrDefault(right.get(cur), 0)); int maxLeft = Math.max(f.getOrDefault(cur.left, 0), g.getOrDefault(cur.left, 0)); int maxRight = Math.max(f.getOrDefault(right.get(cur), 0), g.getOrDefault(right.get(cur), 0)); g.put(cur, maxLeft + maxRight); if (cur.right != null) right.put(cur.right, cur); cur = cur.right; &#125; reverse(tail); &#125; private TreeNode reverse(TreeNode cur) &#123; TreeNode pre = null; while (cur != null) &#123; TreeNode next = cur.right; cur.right = pre; pre = cur; cur = next; &#125; return pre; &#125;&#125; 121. 买卖股票的最佳时机 你根本没在dp！ 方法一：暴力迭代 超时咯 方法二：贪心 从前往后遍历，使用minPrice记录最小值，使用maxProfit记录最大收益 方法三：DP DP数组的定义十分重要！ 12345678910111213141516171819class Solution &#123; public int maxProfit(int[] prices) &#123; int len = prices.length; if (len == 0 || prices == null) return 0; // 1.dp[0][j]:第j天持有股票(之前买入或者当前买入)所拥有的最大价值，dp[1][j]：第j天不持有股票(之前卖出或者当前卖出)所拥有的最大价值 int[][] dp = new int[2][len]; // 2.状态转移方程：dp[0][j] = max(dp[0][j-1], -price[j]); dp[1][j] = max(dp[1][j-1], price[j] + dp[0][j - 1]) // 3.初始化：dp[0][0]必须买入，初始化为-price[0]；dp[1][0]不能卖出任何股票，初始化为0 dp[0][0] = -prices[0]; // 4.遍历顺序：dp[j]由dp[j-1]决定，所以从前往后遍历 for (int j = 1; j &lt; len; ++j) &#123; dp[0][j] = Math.max(dp[0][j - 1], -prices[j]); dp[1][j] = Math.max(dp[1][j - 1], prices[j] + dp[0][j - 1]); // 不能当天买入当天卖出所以是dp[0][j - 1] &#125; return dp[1][len - 1]; // 5.打印dp数组 &#125;&#125; 122. 买卖股票的最佳时机 II 1234567891011121314151617class Solution &#123; public int maxProfit(int[] prices) &#123; // 1.dp[0][j]:在第j天持有(之前买入，当前买入)股票时拥有的最大现金;dp[1][j]在第j天不持有(之前卖出，当前卖出)股票拥有的最大现金 int len = prices.length; int[][] dp = new int[2][len]; // 2.状态转移方程：dp[0][j] = max(dp[0][j - 1], dp[1][j - 1] - price[j]); dp[1][j] = max(dp[1][j - 1], dp[0][j - 1] + price[j]) // 3.初始化：dp[0][0] = -price[0];dp[1][0] = 0;可以当天出售 dp[0][0] = -prices[0]; // 4.遍历顺序 for (int j = 1; j &lt; len; ++j) &#123; dp[0][j] = Math.max(dp[0][j - 1], dp[1][j - 1] - prices[j]); dp[1][j] = Math.max(dp[1][j - 1], dp[0][j - 1] + prices[j]); &#125; return dp[1][len - 1]; // 5.打印dp数组 &#125;&#125; 96. 不同的二叉搜索树 12345678910111213class Solution &#123; public int numTrees(int n) &#123; int[] dp = new int[n + 1]; dp[0] = 1; dp[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= i; ++j) &#123; dp[i] += dp[j - 1] * dp[i - j]; &#125; &#125; return dp[n]; &#125;&#125; 优化空间… 123. 买卖股票的最佳时机 III 1372. 二叉树中的最长交错路径 1234567891011121314151617181920212223242526272829303132class Solution &#123; // f(cur)：以cur结尾，且cur是左子树的最大长度 // g(cur)：以cur结尾，且cur是右子树的最大长度 Map&lt;TreeNode, Integer&gt; f = new HashMap&lt;&gt;(); Map&lt;TreeNode, Integer&gt; g = new HashMap&lt;&gt;(); Queue&lt;TreeNode[]&gt; queue = new LinkedList&lt;&gt;(); public int longestZigZag(TreeNode root) &#123; // f.put(root, 0); // g.put(root, 0); queue.offer(new TreeNode[]&#123;root, null&#125;); while (!queue.isEmpty()) &#123; TreeNode[] sonFather = queue.poll(); f.put(sonFather[0], 0); g.put(sonFather[0], 0); if(sonFather[1] != null) &#123; if (sonFather[1].left == sonFather[0]) f.put(sonFather[0], g.get(sonFather[1]) + 1); if (sonFather[1].right == sonFather[0]) g.put(sonFather[0], f.get(sonFather[1]) + 1); &#125; if (sonFather[0].left != null) queue.offer(new TreeNode[]&#123;sonFather[0].left, sonFather[0]&#125;); if (sonFather[0].right != null) queue.offer(new TreeNode[]&#123;sonFather[0].right, sonFather[0]&#125;); &#125; int max = Integer.MIN_VALUE; for (TreeNode node : f.keySet()) &#123; max = Math.max(max, Math.max(f.get(node), g.get(node))); &#125; return max; &#125;&#125; 300. 最长递增子序列 dp[i]：以nums[i]结尾的最长递增子序列的长度 从前往后，在i的左开区间进行比较所有的j(j &lt; i)，如果nums[j]&lt;nums[i]，那么dp[i] = max(dp[i], dp[j] + 1) 初始化：令dp数组所有元素为1，最短序列是本身 遍历顺序：第二层从前往后，从后往前都可以，只要把i之前的元素全部遍历了就行 要注意的是，要输出的答案不是dp[dp.length-1]，而是dp数组中的最大值，比如序列为01234512，输出的是结果是dp[5]；所以可以用一个全局变量记录dp数组中的最大值 时间复杂度：$O(n^2)$ 空间复杂度：$O(n)$ 12345678910111213141516171819class Solution &#123; public int lengthOfLIS(int[] nums) &#123; int n = nums.length; if (n == 1) return 1; int[] dp = new int[n]; Arrays.fill(dp, 1); int maxLenOfSubsequence = 0; for (int i = 1; i &lt; n; ++i) &#123; for (int j = 0; j &lt; i; ++j) &#123; if (nums[i] &gt; nums[j]) &#123; dp[i] = Math.max(dp[i], dp[j] + 1); &#125; &#125; maxLenOfSubsequence = Math.max(maxLenOfSubsequence, dp[i]); &#125; return maxLenOfSubsequence; &#125;&#125; 674. 最长连续递增序列 方法一：DP dp[i]：以nums[i]结尾的最长连续递增子序列的长度 当当前数字nums[i]大于nums[i-1]，令dp[i] = dp[i - 1] + 1 初始化：令dp数组所有元素为1，最短序列是本身 时间复杂度：$O(n)$ 空间复杂度：$O(n)$ 1234567891011121314151617181920class Solution &#123; public int findLengthOfLCIS(int[] nums) &#123; int n = nums.length; if (n == 1) return 1; int[] dp = new int[n]; Arrays.fill(dp, 1); int maxLength = 0; for (int i = 1; i &lt; n; ++i) &#123; if (nums[i] &gt; nums[i - 1]) &#123; dp[i] = dp[i - 1] + 1; &#125; maxLength = Math.max(maxLength, dp[i]); &#125; // for (int i = 0; i &lt; dp.length; ++i) &#123; // System.out.print(dp[i] + &quot; &quot;); // &#125; return maxLength; &#125;&#125; 方法二：DP + 滑动数组 注意：当nums[i] &lt;= nums[i - 1]时，需要把dp[i%2]重置为1 1234567891011121314151617181920class Solution &#123; public int findLengthOfLCIS(int[] nums) &#123; int n = nums.length; if (n == 1) return 1; int[] dp = new int[2]; Arrays.fill(dp, 1); int maxLength = 0; for (int i = 1; i &lt; n; ++i) &#123; if (nums[i] &gt; nums[i - 1]) &#123; dp[i % 2] = dp[(i - 1) % 2] + 1; &#125; else &#123; dp[i % 2] = 1; &#125; maxLength = Math.max(maxLength, dp[i % 2]); &#125; return maxLength; &#125;&#125; 718. 最长重复子数组⚠️ 方法一：暴力 时间复杂度：$O(m^2n)$ 空间复杂度：$O(1)$ 123456789101112131415161718class Solution &#123; public int findLength(int[] nums1, int[] nums2) &#123; int res = 0; for (int i = 0; i &lt; nums1.length; ++i) &#123; for (int j = 0; j &lt; nums2.length; ++j) &#123; int count1 = i, count2 = j; int counter = 0; while (count1 &lt; nums1.length &amp;&amp; count2 &lt; nums2.length &amp;&amp; nums1[count1] == nums2[count2]) &#123; ++counter; ++count1; ++count2; &#125; res = Math.max(res, counter); &#125; &#125; return res; &#125;&#125; 方法二：DP dp[i][j]:以nums1[i - 1]结尾与以nums2[j - 1]结尾时的最长重复子数组 状态转移公式：当nums1[i - 1] == nums2[j - 1]时，dp[i][j] = dp[i - 1][j - 1] + 1 初始化：m为nums1的长度，n为nums2的长度，初始化(m + 1) * (n + 1)的二维数组，第一行第一列初始化为0，因为任一数组为空，就不会有重复子数组 注意事项：输出结果是dp数组中的最大值，因为最长的重复子数组不一定是在两数组的结尾处，可以在循环内比较 时间复杂度：$O(mn)$ 空间复杂度：$O(mn)$ 12345678910111213141516class Solution &#123; public int findLength(int[] nums1, int[] nums2) &#123; int m = nums1.length, n = nums2.length; int[][] dp = new int[m + 1][n + 1]; int result = 0; for (int i = 1; i &lt;= m; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; if (nums1[i - 1] == nums2[j - 1]) &#123; dp[i][j] = dp[i - 1][j - 1] + 1; result = Math.max(result, dp[i][j]); &#125; &#125; &#125; return result; &#125;&#125; 滚动数组缩减空间复杂度 dp数组为第二个数组的长度加一 不相等时要把dp[j]赋0，不然之后会出错 此时遍历第二个数组的时候，就要从后向前遍历，这样避免重复覆盖。 比如nums1 = [1, 2, 3, 1],nums2 = [1,6,8,1,3,1,2,3] i = 1时候，dp数组为[1,0,0,1,0,1,0,0] i = 2时候，dp数组为[0,0,0,0,0,0,1,0] i = 3时候，dp数组为[0,0,0,0,1,0,0,2] i=3时，如果第二层for循环j从前往后遍历，那么dp倒数第二个位置会因为3!=2，被赋0，进而导致dp最后一个位置是1而不是2 123456789101112131415161718class Solution &#123; public int findLength(int[] nums1, int[] nums2) &#123; int[] dp = new int[nums2.length + 1]; int res = 0; for (int i = 1; i &lt;= nums1.length; ++i) &#123; for (int j = nums2.length; j &gt; 0; --j) &#123; if (nums1[i - 1] == nums2[j - 1]) &#123; dp[j] = dp[j - 1] + 1; &#125; else &#123; dp[j] = 0; &#125; res = Math.max(res, dp[j]); &#125; &#125; return res; &#125;&#125; 方法三：滑动窗口 62. 不同路径 方法一：DP O(mn) 12345678910111213141516171819class Solution &#123; public int uniquePaths(int m, int n) &#123; // dp[i][j]:走到i,j位置的路径数 // 状态转移方程：dp[i][j] = dp[i - 1][j] + dp[i][j - 1] int[][] dp = new int[m][n]; for (int i = 0; i &lt; m; ++i) &#123; dp[i][0] = 1; &#125; for (int j = 0; j &lt; n; ++j) &#123; dp[0][j] = 1; &#125; for (int i = 1; i &lt; m; ++i) &#123; for (int j = 1; j &lt; n; ++j) &#123; dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; &#125; &#125; return dp[m - 1][n - 1]; &#125;&#125; 方法二：DP+滚动数组 O(n) 2行 12345678910111213141516171819class Solution &#123; public int uniquePaths(int m, int n) &#123; // dp[i][j]:走到i,j位置的路径数 // 状态转移方程：dp[i][j] = dp[i - 1][j] + dp[i][j - 1] int[][] dp = new int[2][n]; for (int i = 0; i &lt; 2; ++i) &#123; dp[i][0] = 1; &#125; for (int j = 0; j &lt; n; ++j) &#123; dp[0][j] = 1; &#125; for (int i = 1; i &lt; m; ++i) &#123; for (int j = 1; j &lt; n; ++j) &#123; dp[i % 2][j] = dp[(i - 1) % 2][j] + dp[i % 2][j - 1]; &#125; &#125; return dp[(m - 1) % 2][n - 1]; &#125;&#125; 方法三：DP+滚动数组 O(n) 1行 12345678910111213141516class Solution &#123; public int uniquePaths(int m, int n) &#123; // dp[i][j]:走到i,j位置的路径数 // 状态转移方程：dp[j] = dp[j] + dp[j - 1] // 初始化：全部初始化为1 // 遍历顺序：dp[j]依赖dp[j - 1]，所以从左往右遍历 int[] dp = new int[n]; Arrays.fill(dp, 1); for (int i = 1; i &lt; m; ++i) &#123; for (int j = 1; j &lt; n; ++j) &#123; dp[j] += dp[j - 1]; &#125; &#125; return dp[n - 1]; &#125;&#125; 63. 不同路径 II 方法一：DP 12345678910111213141516171819202122232425class Solution &#123; public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123; int m = obstacleGrid.length, n = obstacleGrid[0].length; int[][] dp = new int[m][n]; for (int i = 0; i &lt; m; ++i) &#123; if (obstacleGrid[i][0] == 1) &#123; break; &#125; dp[i][0] = 1; &#125; for (int j = 0; j &lt; n; ++j) &#123; if (obstacleGrid[0][j] == 1) break; dp[0][j] = 1; &#125; for (int i = 1; i &lt; m; ++i) &#123; for (int j = 1; j &lt; n; ++j) &#123; if (obstacleGrid[i][j] == 1) continue; dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; &#125; &#125; return dp[m - 1][n - 1]; &#125;&#125; 343. 整数拆分⚠️ 方法一：DP 123456789101112131415class Solution &#123; public int integerBreak(int n) &#123; // dp[j]:j拆分为多个数的最大乘积 int[] dp = new int[n + 1]; dp[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; for (int j = 1; j &lt; i; ++j) &#123; int k = i - j; dp[i] = Math.max(dp[i], Math.max(k * j, dp[k] * j)); &#125; &#125; return dp[n]; &#125;&#125; 96. 不同的二叉搜索树⚠️ 剑指 Offer II 102. 加减的目标值 方法一：DP 12345678910111213141516171819class Solution &#123; public int findTargetSumWays(int[] nums, int target) &#123; int sum = Arrays.stream(nums).sum(); int diff = sum - target; if (diff % 2 == 1 || diff &lt; 0) return 0; target = diff / 2; // dp[j]:装满容量为j的方法数 // dp[0] = 1,装满容量为0的背包有一种 int[] dp = new int[target + 1]; dp[0] = 1; for (int i = 0; i &lt; nums.length; ++i) &#123; for (int j = target; j &gt;= nums[i]; --j) &#123; dp[j] += dp[j - nums[i]]; &#125; &#125; return dp[target]; &#125;&#125; 树形DP 左神shi’p 树形DP题目 没有上司的舞会 337. 打家劫舍 III 96. 不同的二叉搜索树 1372. 二叉树中的最长交错路径 Binary Tree 144. 二叉树的前序遍历 方法一：递归 假设树上一共有n 个节点。 时间复杂度：遍历了整棵树，$O(n)$ 空间复杂度：和递归使用的栈大小相关，递归层数不超过n(一叉树)，$O(n)$ 1234567891011121314class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); dfs(root, result); return result; &#125; public void dfs(TreeNode root, List&lt;Integer&gt; result) &#123; if (root == null) return; result.add(root.val); dfs(root.left, result); dfs(root.right, result); &#125;&#125; 方法二：非递归 假设树上一共有n 个节点。 时间复杂度：遍历了整棵树，$O(n)$ 空间复杂度：和递归使用的栈大小相关，递归层数不超过n(一叉树)，$O(n)$ 1234567891011121314151617class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode cur = root; while (cur != null || !stack.isEmpty()) &#123; while (cur != null) &#123; result.add(cur.val); stack.push(cur); cur = cur.left; &#125; cur = stack.pop(); cur = cur.right; &#125; return result; &#125;&#125; 方法三：Morris前序遍历 morris遍历利用树的大量空闲指针，实现空间开销的极限缩减。 时间复杂度：$O(n)$，其中n是二叉树的节点数。没有左子树的节点只被访问一次，有左子树的节点被访问两次 空间复杂度：$O(1)$，只操作已存在的指针（树的空闲指针），因此只需要常数的额外空间 123456789101112131415161718192021222324252627class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); TreeNode cur = root, mostRight = null; while (cur != null) &#123; mostRight = cur.left; if (mostRight != null) &#123; while (mostRight.right != null &amp;&amp; mostRight.right != cur) mostRight = mostRight.right; if (mostRight.right == null) &#123; result.add(cur.val); mostRight.right = cur; cur = cur.left; continue; &#125; else &#123; // mostRight.right == cur mostRight.right = null; &#125; &#125; else &#123; // cur.left == null result.add(cur.val); &#125; cur = cur.right; &#125; return result; &#125;&#125; 94. 二叉树的中序遍历 方法一：递归 时间复杂度：$O(n)$，其中n为树的节点数 空间复杂度：$O(n)$，和递归使用的栈大小相关，递归层数不超过n(一叉树) 123456789101112131415class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); dfs(root, result); return result; &#125; public void dfs(TreeNode root, List&lt;Integer&gt; result) &#123; if (root != null) &#123; dfs(root.left, result); result.add(root.val); dfs(root.right, result); &#125; &#125;&#125; 方法二：非递归 时间复杂度：$O(n)$，其中n为树的节点数 空间复杂度：$O(n)$，和递归使用的栈大小相关，递归层数不超过n(一叉树) 1234567891011121314151617class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new LinkedList&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode cur = root; while (cur != null || !stack.isEmpty()) &#123; while (cur != null) &#123; stack.push(cur); cur = cur.left; &#125; cur = stack.pop(); res.add(cur.val); cur = cur.right; &#125; return res; &#125;&#125; 方法三：Morris中序遍历 morris遍历利用树的大量空闲指针，实现空间开销的极限缩减。 时间复杂度：$O(n)$，其中n是二叉树的节点数。没有左子树的节点只被访问一次，有左子树的节点被访问两次 空间复杂度：$O(1)$，只操作已存在的指针（树的空闲指针），因此只需要常数的额外空间 123456789101112131415161718192021222324class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new LinkedList&lt;&gt;(); TreeNode cur = root, mostRight = null; while (cur != null) &#123; mostRight = cur.left; if (mostRight != null) &#123; while (mostRight.right != null &amp;&amp; mostRight.right != cur) mostRight = mostRight.right; if (mostRight.right == null) &#123; mostRight.right = cur; cur = cur.left; continue; &#125; else &#123; // mostRight == cur mostRight.right = null; &#125; &#125; res.add(cur.val); cur = cur.right; &#125; return res; &#125;&#125; 145. 二叉树的后序遍历 方法一：递归 方法二：非递归 123456789101112131415161718192021222324class Solution &#123; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new LinkedList&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode cur = root, pre = null; while (cur != null || !stack.isEmpty()) &#123; while (cur != null) &#123; stack.push(cur); cur = cur.left; &#125; cur = stack.peek(); if (cur.right != null &amp;&amp; cur.right != pre) &#123; cur = cur.right; &#125; else &#123; stack.pop(); res.add(cur.val); pre = cur; cur = null; &#125; &#125; return res; &#125;&#125; 方法三：Morris后序遍历 时间复杂度：$O(n)$，其中n为树的节点数 空间复杂度：$O(n)$，和递归使用的栈大小相关，递归层数不超过n(一叉树) 如果可以到达一个节点两次(有左子树)，第二次逆序打印左子树上的右边界 最后走出循环后，逆序打印根节点的右边界 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new LinkedList&lt;&gt;(); TreeNode cur = root, mostRight = null; while (cur != null) &#123; mostRight = cur.left; if (mostRight != null) &#123; while (mostRight.right != null &amp;&amp; mostRight.right != cur) mostRight = mostRight.right; if (mostRight.right == null) &#123; mostRight.right = cur; cur = cur.left; continue; &#125; else &#123; // mostRight.right = cur mostRight.right = null; visit(cur.left, res); &#125; &#125; cur = cur.right; &#125; visit(root, res); return res; &#125; private void visit(TreeNode cur, List&lt;Integer&gt; res) &#123; TreeNode tail = reverse(cur); cur = tail; while (cur != null) &#123; res.add(cur.val); cur = cur.right; &#125; reverse(tail); &#125; private TreeNode reverse(TreeNode cur) &#123; TreeNode pre = null; while (cur != null) &#123; TreeNode next = cur.right; cur.right = pre; pre = cur; cur = next; &#125; return pre; &#125;&#125; 102. 二叉树的层序遍历 借助队列实现，关键在于通过queue.size来判断下一层的节点数！ Queue.offer(null)的话，size为1！ 226. 翻转二叉树 这道题目背后有一个让程序员心酸的故事，听说 Homebrew的作者Max Howell，就是因为没在白板上写出翻转二叉树，最后被Google拒绝了。（真假不做判断，权当一个乐子哈） 要求：左右子树交换位置 方法一：bfs层级遍历 时间复杂度：所有节点都需要入队，出队一次，所以是$O(n)$ 空间复杂度：在最坏的情况下，给定的树是满二叉树，所有叶节点($n/2 + 1$)都要入队，所以是$O(n)$ 1234567891011121314151617181920212223class Solution &#123; public TreeNode invertTree(TreeNode root) &#123; if (root == null) return root; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); TreeNode cur; while (!queue.isEmpty()) &#123; cur = queue.poll(); reverse(cur); if (cur.left != null) queue.offer(cur.left); if (cur.right != null) queue.offer(cur.right); &#125; return root; &#125; private void reverse(TreeNode cur) &#123; TreeNode temp = cur.left; cur.left = cur.right; cur.right = temp; &#125;&#125; 方法二：dfs 12345678910111213141516171819class Solution &#123; public TreeNode invertTree(TreeNode root) &#123; // 反转所有左子树和右子树，对这棵树的所有节点 dfs(root); return root; &#125; private void dfs(TreeNode root) &#123; if (root == null) return; dfs(root.left); dfs(root.right); reverse(root); &#125; private void reverse(TreeNode root) &#123; TreeNode temp = root.left; root.left = root.right; root.right = temp; &#125;&#125; 101. 对称二叉树 方法一：拷贝+翻转+判断(高情商：刷一道，解三道！低情商：只会笨方法？还是看看远方的复杂度吧) 写了80行，一题三解！不分析复杂度了。。 方法二：BFS 假设树上一共有n 个节点。 时间复杂度：遍历了整棵树，$O(n)$ 空间复杂度：和使用的队列大小相关，在最坏的情况下，给定的树是满二叉树，所有叶节点($n/2 + 1$)都要入队，所以是$O(n)$ **注意：**如果p,q都为空，continue！而不是return truel！！！ 1234567891011121314151617181920212223class Solution &#123; public boolean isSymmetric(TreeNode root) &#123; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root.left); queue.offer(root.right); TreeNode p, q; while (!queue.isEmpty()) &#123; p = queue.poll(); q = queue.poll(); if (p == null &amp;&amp; q == null) continue; if (p == null || q == null) return false; if (p.val != q.val) return false; queue.offer(p.left); queue.offer(q.right); queue.offer(p.right); queue.offer(q.left); &#125; return true; &#125;&#125; 方法三：DFS YYDS 假设树上一共有n 个节点。 时间复杂度：遍历了整棵树，$O(n)$ 空间复杂度：和递归使用的栈大小相关，递归层数不超过n(一叉树)，$O(n)$ 123456789101112class Solution &#123; public boolean isSymmetric(TreeNode root) &#123; return dfs(root.left, root.right); &#125; private boolean dfs(TreeNode left, TreeNode right) &#123; if (left == null &amp;&amp; right == null) return true; if (left == null || right == null) return false; return (left.val == right.val) &amp;&amp; dfs(left.left, right.right) &amp;&amp; dfs(left.right, right.left); &#125;&#125; 100. 相同的树 对称二叉树方法一中用到了这个笨方法，顺手做了吧。 方法一：DFS 假设树上一共有$n$个节点 时间复杂度：遍历了整棵树，$O(n)$ 空间复杂度：和递归使用的栈大小相关，递归层数不超过n，$O(n)$ 方法二：BFS 只是和对称二叉树BFS解法中的入队顺序改变一点。 假设树上一共有n 个节点。 时间复杂度：遍历了整棵树，$O(n)$ 空间复杂度：和使用的队列大小相关，在最坏的情况下，给定的树是满二叉树，所有叶节点($n/2 + 1$)都要入队，所以是$O(n)$ 104. 二叉树的最大深度 方法一：BFS 时间复杂度：遍历整棵树，$O(n)$ 空间复杂度：和使用的队列大小相关，在最坏情况下，给定的二叉树是满二叉树，$n/2 + 1$个叶节点要入队，所以是$O(n)$ 方法二：DFS 假设树上一共有$n$个节点 时间复杂度：遍历了整棵树，$O(n)$ 空间复杂度：和递归使用的栈大小相关，递归层数不超过n，$O(n)$ 559. N 叉树的最大深度 同上题二叉树的最大深度，只是在遍历子节点的时候不同。 1234for (int i = 0; i &lt; cur.children.size(); i++) &#123; if (cur.children.get(i) != null) queue.offer(cur.children.get(i));&#125; 111. 二叉树的最小深度 最小深度是从根节点到最近叶子节点的最短路径上的节点数量 方法一：DFS 首先递归左子树和右子树 如果左子树为空，那么返回右子树的高度 + 1；如果右子树为空， 那么返回左子树的高度 + 1 如果左右子树都不为空，那么返回他们最小高度 + 1 12345678910111213class Solution &#123; public int minDepth(TreeNode root) &#123; if (root == null) return 0; int leftDepth = minDepth(root.left); int rightDepth = minDepth(root.right); if (root.left == null) return rightDepth + 1; if (root.right == null) return leftDepth + 1; return Math.min(leftDepth, rightDepth) + 1; &#125;&#125; 方法二：BFS 通过队列的size知道这是第几层，上一层加入队列节点的个数就是队列的size，在得到size的同时，将记录最小深度的变量minDepth加一 遍历到第一个叶子节点的当前层数就是二叉树的最小深度 时间复杂度：遍历整棵树，$O(n)$ 空间复杂度：和使用的队列大小相关，在最坏情况下，给定的二叉树是满二叉树，$n/2 + 1$个叶节点要入队，所以是$O(n)$ 123456789101112131415161718192021222324class Solution &#123; public int minDepth(TreeNode root) &#123; if (root == null) return 0; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); TreeNode cur; int minDepth = 0; while (!queue.isEmpty()) &#123; int size = queue.size(); ++minDepth; while (size-- &gt; 0) &#123; cur = queue.poll(); if (cur.left == null &amp;&amp; cur.right == null) return minDepth; if (cur.left != null) queue.offer(cur.left); if (cur.right != null) queue.offer(cur.right); &#125; &#125; return minDepth; &#125;&#125; 222. 完全二叉树的节点个数 方法一：BFS 在每层开始遍历时，记录节点个数的变量加上队列里元素个数 方法二：DFS 边界：如果是空节点，返回0 递归左子树和右子树+1(当前节点) 12345678910class Solution &#123; public int countNodes(TreeNode root) &#123; return dfs(root); &#125; public int dfs(TreeNode root) &#123; if (root == null) return 0; return 1 + dfs(root.left) + dfs(root.right); &#125;&#125; 110. 平衡二叉树 方法一：先序DFS 终止条件：如果root为空，返回true 首先求当前节点左右子树高度是否&lt;=1，再判断递归左子树和右子树 时间复杂度：$O(n^2)$ 空间复杂度：$O(n)$ 123456789101112class Solution &#123; public boolean isBalanced(TreeNode root) &#123; if (root == null) return true; return Math.abs(height(root.left) - height(root.right)) &lt;= 1 &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right); &#125; private int height(TreeNode root) &#123; if (root == null) return 0; return Math.max(height(root.left), height(root.right)) + 1; &#125;&#125; 方法二：后序DFS⚠️ 只需遍历所有节点一次 时间复杂度$O(n)$ 空间复杂度$(n)$ 1234567891011121314151617class Solution &#123; public boolean isBalanced(TreeNode root) &#123; return height(root) &gt;= 0; &#125; public int height(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; int leftHeight = height(root.left); int rightHeight = height(root.right); if (leftHeight == -1 || rightHeight == -1 || Math.abs(leftHeight - rightHeight) &gt; 1) &#123; return -1; &#125; else &#123; return Math.max(leftHeight, rightHeight) + 1; &#125; &#125;&#125; 257. 二叉树的所有路径⚠️ 方法一：BFS 1234567891011121314151617181920212223242526class Solution &#123; public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123; List&lt;String&gt; result = new LinkedList&lt;&gt;(); Queue&lt;Object&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); queue.offer(String.valueOf(root.val)); TreeNode cur; String path = &quot;&quot;; while (!queue.isEmpty()) &#123; cur = (TreeNode)queue.poll(); path = (String)queue.poll(); if (cur.left == null &amp;&amp; cur.right == null) &#123; result.add(path); &#125; if (cur.left != null) &#123; queue.offer(cur.left); queue.offer(path + &quot;-&gt;&quot; + String.valueOf(cur.left.val)); &#125; if (cur.right != null) &#123; queue.offer(cur.right); queue.offer(path + &quot;-&gt;&quot; + String.valueOf(cur.right.val)); &#125; &#125; return result; &#125;&#125; 方法二：DFS 1234567891011121314151617181920class Solution &#123; List&lt;String&gt; result = new LinkedList&lt;&gt;(); public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123; dfs(root, &quot;&quot;); return result; &#125; public void dfs(TreeNode root, String path) &#123; if (root == null) return; path += String.valueOf(root.val); if (root.left == null &amp;&amp; root.right == null) &#123; result.add(path); &#125; else &#123; path += &quot;-&gt;&quot;; dfs(root.left, path); dfs(root.right, path); &#125; &#125; &#125; 404. 左叶子之和 ⚠️方法一：DFS 12345678910111213141516171819202122class Solution &#123; public int sumOfLeftLeaves(TreeNode root) &#123; if (root.left == null &amp;&amp; root.right == null) return 0; return dfs(root); &#125; private int dfs(TreeNode root) &#123; if (root == null) return 0; int sum = 0; if (root.left != null) &#123; sum += isLeaf(root.left) ? root.left.val : dfs(root.left); &#125; if (root.right != null) &#123; sum += dfs(root.right); &#125; return sum; &#125; private boolean isLeaf(TreeNode root) &#123; return root.left == null &amp;&amp; root.right == null; &#125;&#125; 513. 找树左下角的值 ⚠️方法一：DFS 12345678910111213141516171819class Solution &#123; int curHeight = 0; int curValue = 0; public int findBottomLeftValue(TreeNode root) &#123; dfs(root, 0); return curValue; &#125; private void dfs(TreeNode root, int height) &#123; if (root == null) return; ++height; dfs(root.left, height); dfs(root.right, height); if (height &gt; curHeight) &#123; curHeight = height; curValue = root.val; &#125; &#125;&#125; 方法二：BFS 从右往左层次遍历，最后一个访问的节点就是树左下角的值！ 12345678910111213141516171819class Solution &#123; public int findBottomLeftValue(TreeNode root) &#123; TreeNode cur; int res = 0; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while (!queue.isEmpty()) &#123; cur = queue.poll(); if (cur.right != null) &#123; queue.offer(cur.right); &#125; if (cur.left != null) &#123; queue.offer(cur.left); &#125; res = cur.val; &#125; return res; &#125;&#125; 112. 路径总和 方法一：BFS 初始化一个Object类型队列，用于存放节点与节点的值，首先把根节点和根节点的值offer进队列 开始while循环，循环的执行条件是队列不为空 首先按顺序取出节点和节点的值，注意这里需要强转 判断当前节点是否为根节点且节点的值是否为目标值，如果满足，直接return true 如果左子树不为空，先将左子树节点offer进队列，再将左子树的值加上poll出的当前节点的值offer进队列 如果右子树不为空，先将右子树节点offer进队列，再将右子树的值加上poll出的当前节点的值offer进队列 如果有这么一条路径，那么在while循环中就会return true，不会执行到这；如果没有满足条件的路径，则返回false 1234567891011121314151617181920212223242526class Solution &#123; public boolean hasPathSum(TreeNode root, int targetSum) &#123; if (root == null) return false; Queue&lt;Object&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); queue.offer(root.val); TreeNode cur; while (!queue.isEmpty()) &#123; cur = (TreeNode)queue.poll(); int val = (int)queue.poll(); if (cur.left == null &amp;&amp; cur.right == null &amp;&amp; val == targetSum) &#123; return true; &#125; if (cur.left != null) &#123; queue.offer(cur.left); queue.offer(val + cur.left.val); &#125; if (cur.right != null) &#123; queue.offer(cur.right); queue.offer(val + cur.right.val); &#125; &#125; return false; &#125;&#125; |⚠️⚠️方法二：DFS 123456789class Solution &#123; public boolean hasPathSum(TreeNode root, int targetSum) &#123; if (root == null) return false; if (root.left == null &amp;&amp; root.right == null) return targetSum == root.val; return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val); &#125;&#125; 113. 路径总和 II 方法一：BFS 使用队列存放当前节点和累加节点值 使用HashMap记录每个节点的父节点 当节点满足是叶节点且累加值等于targetSum时，通过HashMap，从该叶子节点遍历到根节点记录到list中，最后把list反转 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int targetSum) &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); if (root == null) return res; Queue&lt;Object&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); queue.offer(root.val); TreeNode cur; Map&lt;TreeNode, TreeNode&gt; sonFather = new HashMap&lt;&gt;(); while (!queue.isEmpty()) &#123; cur = (TreeNode)queue.poll(); int val = (Integer)queue.poll(); if (cur.left == null &amp;&amp; cur.right == null &amp;&amp; val == targetSum) &#123; res.add(getPath(cur, sonFather)); &#125; if (cur.left != null) &#123; queue.offer(cur.left); queue.offer(val + cur.left.val); sonFather.put(cur.left, cur); &#125; if(cur.right != null) &#123; queue.offer(cur.right); queue.offer(val + cur.right.val); sonFather.put(cur.right, cur); &#125; &#125; return res; &#125; private List&lt;Integer&gt; getPath(TreeNode node, Map&lt;TreeNode, TreeNode&gt; sonFather) &#123; List&lt;Integer&gt; path = new LinkedList&lt;&gt;(); path.add(node.val); while (node != null) &#123; node = sonFather.get(node); path.add(node.val); &#125; Collections.reverse(path); return path; &#125; ⚠️方法二：DFS 使用双端队列，每次dfs将当前节点值放入双端队列队尾，并让targetSum减去当前节点元素 如果当前节点是叶子节点且targetSum等于0，那么说明这条路径满足条件，将path加入结果 每次dfs完左右，再将双端队列最后一个元素移除！！！ 1234567891011121314151617181920class Solution &#123; Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int targetSum) &#123; dfs(root, targetSum); return res; &#125; private void dfs(TreeNode root, int targetSum) &#123; if (root == null) return; path.offerLast(root.val); targetSum -= root.val; if (root.left == null &amp;&amp; root.right == null &amp;&amp; targetSum == 0) &#123; res.add(new LinkedList&lt;&gt;(path)); &#125; dfs(root.left, targetSum); dfs(root.right, targetSum); path.pollLast(); &#125;&#125; ⭐方法三：回溯(其实方法二也是回溯) 递归终止条件是：节点为空 123456789101112131415161718192021222324252627282930313233343536/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int targetSum) &#123; if (root == null) return res; dfs(root, targetSum); return res; &#125; private void dfs(TreeNode root, int targetSum) &#123; if (root == null) return; path.add(root.val); if (root.left == null &amp;&amp; root.right == null &amp;&amp; targetSum == root.val) &#123; res.add(new LinkedList(path)); &#125; dfs(root.left, targetSum - root.val); dfs(root.right, targetSum - root.val); path.removeLast(); &#125;&#125; ⭐106. 从中序与后序遍历序列构造二叉树 草稿构造一棵二叉树，写出中序和后序序列 确定好边界条件：左闭右闭 后序序列最后一个元素是根，通过HashMap找到根节点下标 根节点左边的长度为lenOfLeft，那么先序序列和后序序列的前lenOfLeft为根节点的左子树 12345678910111213141516171819202122232425262728class Solution &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); public TreeNode buildTree(int[] inorder, int[] postorder) &#123; if (postorder == null) return null; for (int i = 0; i &lt; inorder.length; ++i) &#123; map.put(inorder[i], i); &#125; // [start, end - 1]左闭右闭 return dfs(inorder, 0, inorder.length - 1, postorder, 0, postorder.length - 1); &#125; private TreeNode dfs(int[] inorder, int inStart, int inEnd, int[] postorder, int postStart, int postEnd) &#123; if (inStart &gt; inEnd || postStart &gt; postEnd) return null; // 找到postorder最后一个元素的下标，也就是根节点 int rootValue = postorder[postEnd]; // 找到inorder中根节点的位置 int rootIdx = map.get(rootValue); // 构造树节点 TreeNode root = new TreeNode(rootValue); // 根据inorder切割左子树的大小，那么剩下的就是右子树 int lenOfLeft = rootIdx - inStart; // 按照根节点切割成左子树和右子树 root.left = dfs(inorder, inStart, rootIdx - 1, postorder, postStart, postStart + lenOfLeft - 1); root.right = dfs(inorder, rootIdx + 1, inEnd, postorder, postStart + lenOfLeft, postEnd - 1); return root; &#125;&#125; 105. 从前序与中序遍历序列构造二叉树 注意：int lenOfLeft = rootIdx - inStart; ！！！！！！！！ 1234567891011121314151617181920212223class Solution &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); public TreeNode buildTree(int[] preorder, int[] inorder) &#123; int length = inorder.length; for (int i = 0; i &lt; length; ++i) map.put(inorder[i], i); // [)左闭右开 return dfs(inorder, 0, length, preorder, 0, length); &#125; private TreeNode dfs(int[] inorder, int inStart, int inEnd, int[] preorder, int preStart, int preEnd) &#123; if (inStart &gt;= inEnd || preStart &gt;= preEnd) return null; // 找到根节点 int rootVal = preorder[preStart]; int rootIdx = map.get(rootVal); // 中序遍历中根节点左边的长度 int lenOfLeft = rootIdx - inStart; TreeNode root = new TreeNode(rootVal); root.left = dfs(inorder, inStart, rootIdx, preorder, preStart + 1, preStart + 1 + lenOfLeft); root.right = dfs(inorder, rootIdx + 1, inEnd, preorder, preStart + 1 + lenOfLeft, preEnd); return root; &#125;&#125; ⭐654. 最大二叉树 方法一：DFS 思路同106. 从中序与后序遍历序列构造二叉树 123456789101112131415161718192021class Solution &#123; public TreeNode constructMaximumBinaryTree(int[] nums) &#123; return dfs(0, nums.length, nums); &#125; private TreeNode dfs(int start, int end, int[] nums) &#123; if (start &gt;= end) return null; int index = start; int maxValue = nums[start]; for (int i = start; i &lt; end; ++i) &#123; if (maxValue &lt; nums[i]) &#123; maxValue = nums[i]; index = i; &#125; &#125; TreeNode root = new TreeNode(maxValue); root.left = dfs(start, index, nums); root.right = dfs(index + 1, end, nums); return root; &#125;&#125; 617. 合并二叉树 解题思路：当树1当前节点的左子树或右子树为空，而树2当前节点左子树或右子树不为空时：使用parentQueue存储树1树2的当前节点parent1，parent2，在遍历到下一层时，使用parent1来指向parent2的左子树或者右子树。 Debug：如果cur1左子树为空，cur2左子树不为空，将cur1,cur2加入trashQueue；同理右子树。如果cur1左右子树都为空，cur2左右子树都不为空，将cur1,cur2加入parentQueue两次！！不然之后poll的时候空指针！！ ⚠️方法二：DFS 123456789101112class Solution &#123; public TreeNode mergeTrees(TreeNode root1, TreeNode root2) &#123; if (root1 == null) return root2; if (root2 == null) return root1; root1.val += root2.val; root1.left = mergeTrees(root1.left, root2.left); root1.right = mergeTrees(root1.right, root2.right); return root1; &#125;&#125; 700. 二叉搜索树中的搜索 方法一：DFS 1234567891011121314151617class Solution &#123; public TreeNode searchBST(TreeNode root, int val) &#123; TreeNode cur = root; while (cur != null) &#123; if (cur.val == val) &#123; return cur; &#125; else if (cur.val &lt; val) &#123; cur = cur.right; &#125; else &#123; cur = cur.left; &#125; &#125; return null; &#125;&#125; ⭐98. 验证二叉搜索树 方法一：中序遍历 中序遍历二叉搜索树应该是升序的，只需要一个记录上一个节点的值的遍历preVal，并与当前节点比较，如果当前节点的值小于等于preVal(cur.val应该严格&gt;preVal不能等于)，则返回false;否则，遍历完所有节点返回true。 假设树有n个节点 时间复杂度：遍历所有节点，$O(n)$ 空间复杂度：和使用的栈相关，在最坏情况(每个节点都只有一个子节点)下，树的高度为n，都需要压栈，所以为$O(n)$ 123456789101112131415161718192021class Solution &#123; public boolean isValidBST(TreeNode root) &#123; if (root == null) return true; long preVal = Long.MIN_VALUE; TreeNode cur = root; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); while (cur != null || !stack.isEmpty()) &#123; while (cur != null) &#123; stack.push(cur); cur = cur.left; &#125; cur = stack.pop(); if (cur.val &lt;= preVal) return false; preVal = cur.val; cur = cur.right; &#125; return true; &#125;&#125; :war:方法二：递归 1234567891011121314151617class Solution &#123; public boolean isValidBST(TreeNode root) &#123; if (root == null) return true; return dfs(TreeNode root, long.MIN_VALUE, long.MAX_VALUE) &#125; public boolean dfs(TreeNode root, long pre, long post) &#123; if (root == null) return true; if (root.val &lt;= pre || root.val &gt;= post) return false; return dfs(root.left, pre, root.val) &amp;&amp; dfs(root.right, root.val, post); &#125;&#125; 方法三：Morris中序遍历 Morris遍历利用叶子节点的左右空指针，实现空间开销的极限缩减。 morris遍历的实现原则 记作当前节点为cur。 如果cur无左孩子，cur向右移动（cur=cur.right） 如果cur有左孩子，找到cur左子树上最右的节点，记为mostright 如果mostright的right指针指向空，让其指向cur，cur向左移动（cur=cur.left） 如果mostright的right指针指向cur，让其指向空，cur向右移动（cur=cur.right） 实现以上的原则，即实现了morris遍历。 morris遍历的实质 建立一种机制，对于没有左子树的节点只到达一次，对于有左子树的节点会到达两次 Morris中序遍历 如果可以到达一个节点两次(有左子树)，第二次访问 如果可以到达一个节点一次(无左子树)，直接访问 举个例子 从根节点5开始遍历，令cur = 根节点5，找到mostRight为节点1 节点1的右子树为空，将节点1的右子树指向节点5，并让cur移动到左子树(节点1) 开始遍历节点1，由于节点一无左子树，直接访问，比较节点一与preValue(初始化为最小值)， 1 &lt; Long.MIN_VALUE，将节点1的val赋值给preValue 将cur(1)移动到右子树，此时cur为之前访问过的根节点5，继续找到cur(5)左子树的最右节点1，发现节点1的右子树为当前节点cur(5)，将节点1的右子树还原为空 此时是第二次到达节点5，比较节点5与preValue(1)，并将5赋值给preValue，cur向右子树移动，此时cur到达节点4 找到cur(4)左子树的最右节点3，将节点3的右子树指向cur(4)，cur向左子树移动，此时cur到达节点3 由于节点3无左子树，直接比较节点3与preValue(5)的值，3&lt;5，返回false。 可以发现中序遍历的顺序是：15346 Morris中序遍历到达的节点顺序是：5154346，其中5和4有左子树，在到底5和4的第二次时作比较。 1234567891011121314151617181920212223242526class Solution &#123; public boolean isValidBST(TreeNode root) &#123; TreeNode cur = root, mostRight = null; long preValue = Long.MIN_VALUE; while (cur != null) &#123; mostRight = cur.left; if (mostRight != null) &#123; while (mostRight.right != null &amp;&amp; mostRight.right != cur) mostRight = mostRight.right; if (mostRight.right == null) &#123; mostRight.right = cur; cur = cur.left; continue; &#125; else if (mostRight.right == cur) &#123; mostRight.right = null; &#125; &#125; if (cur.val &lt;= preValue) return false; preValue = cur.val; cur = cur.right; &#125; return true; &#125;&#125; 时间复杂度：遍历所有节点，$O(n)$ 空间复杂度：Morris遍历利用叶子节点的左右空指针，实现空间开销的极限缩减，$O(1)$ 530. 二叉搜索树的最小绝对差 方法一：中序遍历 使用中序遍历二叉搜索树得到的结果是升序的。 ⭐⚠️方法二：双指针 双指针的思想真的很重要！！！ 初始化全局变量：pre节点初始化为空；diff存储相邻节点差值，初始化为整型最大值 中序遍历过程：第一次遍历，pre是空的，还没遇到第二个节点也就没有相邻节点之间的差值； 把当前节点(root)赋给pre，那么下一个root就是中序遍历顺序pre的下一个节点 1234567891011121314151617class Solution &#123; TreeNode pre; int diff = Integer.MAX_VALUE; public int getMinimumDifference(TreeNode root) &#123; dfs(root); return diff; &#125; private void dfs(TreeNode root) &#123; if (root == null) return; dfs(root.left); if (pre != null) diff = Math.min(diff, root.val - pre.val); pre = root; dfs(root.right); &#125;&#125; 501. 二叉搜索树中的众数 老样子，中序遍历 遍历的过程 1234567891011121314151617if (preVal == cur.val) &#123; ++counter;&#125;else &#123; counter = 1;&#125;if (!modes.contains(cur.val) &amp;&amp; counter == maxCounter) &#123; modes.add(cur.val);&#125;if (counter &gt; maxCounter) &#123; maxCounter = counter; modes.removeAll(modes); modes.add(cur.val);&#125;preVal = cur.val;cur = cur.right; 236. 二叉树的最近公共祖先 方法一：用HashMap存储所有父节点，用HashSet标记是否访问过；从p开始向上遍历，并标记访问过的父节点，再从q开始向上遍历，如果当前节点被访问过，那么这个节点就是最近公共祖先。 **注意：对于p，先设置visisted，再向上移；对于q，先判断当前节点是不是已经被visited，再向上移。**如果p,q任意一者先向上移再操作，都会导致在，p或q是最近公共节点时，返回的却是p或q的父节点 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; Map&lt;TreeNode, TreeNode&gt; map = new HashMap&lt;&gt;(); Set&lt;TreeNode&gt; visited = new HashSet&lt;&gt;(); dfs(root, map); while (p != null) &#123; visited.add(p); p = map.get(p); &#125; while (q != null) &#123; if (visited.contains(q)) &#123; return q; &#125; q = map.get(q); &#125; return root; &#125; public void dfs(TreeNode root, Map&lt;TreeNode, TreeNode&gt; map) &#123; if (root == null) return; if (root.left != null) &#123; map.put(root.left, root); &#125; if (root.right != null) &#123; map.put(root.right, root); &#125; dfs(root.left, map); dfs(root.right, map); &#125;&#125; ⚠️方法二：DFS 题解 可以不判断非p,q的叶节点 12345678910111213141516class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; return dfs(root, p, q); &#125; public TreeNode dfs(TreeNode root, TreeNode p, TreeNode q) &#123; if (root == null || root == p || root == q) return root; TreeNode left = dfs(root.left, p, q); TreeNode right = dfs(root.right, p, q); if (left == null) return right; if (right == null) return left; return root; &#125;&#125; 235. 二叉搜索树的最近公共祖先 递归：考虑三种情况 p,q是root：return root p,q在root两侧，(p.val &lt; root.val &amp;&amp; q.val &gt; root.val) || (p.val &gt; root.val &amp;&amp; q.val &lt; root.val)， return root p,q在root同一侧 (p.val &lt; root &amp;&amp; q.val &lt; root.val) || (p.val &gt; root.val &amp;&amp; q.val &gt; root.val) p.val &lt; root &amp;&amp; q.val &lt; root.val: return dfs(left, p, q) p.val &gt; root.val &amp;&amp; q.val &gt; root.val: return dfs(right, p, q) 方法一：DFS 1234567891011class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if (root == null) return null; if (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) return lowestCommonAncestor(root.left, p, q); if (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) return lowestCommonAncestor(root.right, p, q); return root; &#125;&#125; 701. 二叉搜索树中的插入操作 要点是：如何记录要插入节点的父节点 方法一：栈 从根节点开始遍历，用栈存储每个遍历过的节点，大于向右小于向左；循环结束，判断插入最后一个被遍历的节点(栈中最顶层节点)，判断大于小于，插入，结束。 遍历过程把所有元素放进栈，空节点跳出循环后，栈顶元素就是要插入节点的父节点 1234567891011121314151617181920212223242526class Solution &#123; public TreeNode insertIntoBST(TreeNode root, int val) &#123; if (root == null) return new TreeNode(val); TreeNode cur = root; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); while (cur != null) &#123; stack.push(cur); if (val &lt; cur.val) &#123; cur = cur.left; &#125; else &#123; cur = cur.right; &#125; &#125; cur = stack.pop(); TreeNode newNode = new TreeNode(val); if (cur.val &gt; val) &#123; cur.left = newNode; &#125; else &#123; cur.right = newNode; &#125; return root; &#125;&#125; 方法二：双指针 用pre指针指向上一个节点，有两个要注意的地方 初始化pre指针时，不能初始化为null，如果根节点没有左子树，而要插入的节点小于根节点，要插入的节点会成为根节点的左子树，这种情况判断一次就会跳出while循环，此时pre还是null，所以要把pre初始化为根节点 在while循环中，用pre=cur记录cur的上一个节点，但是，最后cur等于空的时候，pre再记录cur就没有意义了，所以加上if (cur != null)判断条件 123456789101112131415161718192021class Solution &#123; public TreeNode insertIntoBST(TreeNode root, int val) &#123; TreeNode res = new TreeNode(val); if (root == null) return res; TreeNode cur = root, pre = root; while (cur != null) &#123; if (cur.val &gt; val) cur = cur.left; else if (cur.val &lt; val) cur= cur.right; if (cur != null) pre = cur; &#125; if (val &gt; pre.val) pre.right = res; else pre.left = res; return root; &#125;&#125; 方法三：DFS 当时想出来了，但是卡在怎么插入这个点上**，其实这里已经用root.left或者root.right来接收 new TreeNode(val)了。**构造树！！！ 12345678910111213class Solution &#123; public TreeNode insertIntoBST(TreeNode root, int val) &#123; if (root == null) &#123; return new TreeNode(val); &#125; if (val &lt; root.val) &#123; root.left = insertIntoBST(root.left, val); &#125; else &#123; root.right = insertIntoBST(root.right, val); &#125; return root; &#125;&#125; x450. 删除二叉搜索树中的节点 解题思路： 如果目标节点大于当前节点值，则去右子树中删除； 如果目标节点小于当前节点值，则去左子树中删除； 如果目标节点就是当前节点，分为以下三种情况： 其无左子：其右子顶替其位置，删除了该节点； 其无右子：其左子顶替其位置，删除了该节点； 其左右子节点都有：其左子树转移到其右子树的最左节点的左子树上，然后右子树顶替其位置，由此删除了该节点。 写了快100行，重构一下代码。。 方法一：迭代 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public TreeNode deleteNode(TreeNode root, int key) &#123; if (root == null) return root; TreeNode cur = root, pre = root; while (cur != null) &#123; if (cur.val == key) &#123; if (cur.left == null &amp;&amp; cur.right == null) &#123; // 叶子节点 if (pre.val &lt; key) pre.right = null; else pre.left = null; &#125; else &#123; if (cur.left != null &amp;&amp; cur.right != null) &#123; // 找到要删除节点右子树上的最左节点，再把要删除节点左子树挂上去 TreeNode left = cur.left, right = cur.right; cur = cur.right; while (cur.left != null) cur = cur.left; cur.left = left; if (pre.val &lt; key) pre.right = right; else pre.left = right; &#125; else if (cur.left == null &amp;&amp; cur.right != null) &#123; TreeNode right = cur.right; if (pre.val &lt; key) pre.right = right; else pre.left = right; &#125; else if (cur.left != null &amp;&amp; cur.right == null) &#123; TreeNode left = cur.left; if (pre.val &lt; key) pre.right = left; else pre.left = left; &#125; &#125; break; &#125; else if (cur.val &lt; key) &#123; pre = cur; cur = cur.right; &#125; else &#123; pre = cur; cur = cur.left; &#125; &#125; if (root.val == key) &#123; return root.left == null ? root.right : root.left; &#125; return root; &#125;&#125; ⭐方法二：DFS 注意代码注释部分是完全冗余的！ 123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public TreeNode deleteNode(TreeNode root, int key) &#123; if (root == null) return root; if (key &lt; root.val) root.left = deleteNode(root.left, key); else if (key &gt; root.val) root.right = deleteNode(root.right, key); else &#123; //(key == root.val) &#123; if (root.left == null &amp;&amp; root.right == null) &#123; return null; &#125; else if (root.left == null &amp;&amp; root.right != null) &#123; return root.right; &#125; else if (root.left != null &amp;&amp; root.right == null) &#123; return root.left; &#125; else &#123; TreeNode cur = root.right; while (cur.left != null) cur = cur.left; cur.left = root.left; return root.right; &#125; &#125; // if (root.val == key) &#123; // if (root.left == null &amp;&amp; root.right == null) // return null; // else &#123; // return root.left == null ? root.right : root.left; // &#125; // &#125; return root; &#125;&#125; ⚠️669. 修剪二叉搜索树 借上一题的思路直接速通了 108. 将有序数组转换为二叉搜索树 方法一：二分DFS[左闭右闭] 方法二：DFS[左闭右开) 注意：拜托！mid=(end+start)&gt;&gt;1不是减啊！！！ 1234567891011121314class Solution &#123; public TreeNode sortedArrayToBST(int[] nums) &#123; return dfs(nums, 0, nums.length); &#125; private TreeNode dfs(int[] nums, int start, int end) &#123; if (start &gt;= end) return null; int mid = (end + start) &gt;&gt; 1; TreeNode root = new TreeNode(nums[mid]); root.left = dfs(nums, start, mid); root.right = dfs(nums, mid + 1, end); return root; &#125;&#125; 538. 把二叉搜索树转换为累加树 右根左中序遍历！ LeetCode官方叫它反序中序遍历 方法一：迭代 87654321从前往后累加。 方法二：DFS 123456789101112131415class Solution &#123; int sum = 0; public TreeNode convertBST(TreeNode root) &#123; dfs(root); return root; &#125; public void dfs(TreeNode root) &#123; if (root == null) return; dfs(root.right); sum += root.val; root.val = sum; dfs(root.left); &#125;&#125; [106. 从中序与后序遍历序列构造二叉树 [105. 从前序与中序遍历序列构造二叉树] 106.从中序与后序遍历序列构造二叉树 前序和中序可以唯一确定一棵二叉树。 后序和中序可以唯一确定一棵二叉树。 那么前序和后序可不可以唯一确定一棵二叉树呢？ 前序和后序不能唯一确定一棵二叉树！，因为没有中序遍历无法确定左右部分，也就是无法分割。 举一个例子： tree1 的前序遍历是[1 2 3]， 后序遍历是[3 2 1]。 tree2 的前序遍历是[1 2 3]， 后序遍历是[3 2 1]。 那么tree1 和 tree2 的前序和后序完全相同，这是一棵树么，很明显是两棵树！ 所以前序和后序不能唯一确定一棵二叉树！ 剑指 Offer II 047. 二叉树剪枝 方法一：笨方法！非递归后序DFS + HashMap存储父节点 方法二：非递归后续DFS，根本不用Hash Map！ 遍历部分如下，不管当前节点是左子树还是右子树，stack.peek()一定是父节点！ 123456789101112131415// traverseif (cur.val == 0 &amp;&amp; cur.left == null &amp;&amp; cur.right == null) &#123; if (!stack.isEmpty()) &#123; TreeNode parent = stack.peek(); if (parent.left == cur) &#123; parent.left = null; &#125; else &#123; parent.right = null; &#125; &#125; else &#123; return null; &#125;&#125; 方法三：递归 切记后续遍历的顺序， if (root.val == 0 &amp;&amp; root.left == null &amp;&amp; root.right == null)一定写在遍历左子树右子树后面。 1234567891011class Solution &#123; public TreeNode pruneTree(TreeNode root) &#123; if (root == null) return null; root.left = pruneTree(root.left); root.right = pruneTree(root.right); if (root.val == 0 &amp;&amp; root.left == null &amp;&amp; root.right == null) return null; return root; &#125;&#125; x剑指 Offer II 048. 序列化与反序列化二叉树 “#”表示null；反序列化时，用整数数组int[] i = {0}来遍历字符串，因为i[0]++可以让调用函数知道下标增加了；时使用int j = 0，在函数体内修改j的值，修改之后的值也不能传递给调用者。 12node.left = dfs(strs, i);node.right = dfs(strs, i); 剑指 Offer II 049. 从根节点到叶节点的路径数字之和 方法一：HashMap存储父节点 遍历树，使用HashMap存储所有子节点的父节点 遍历树，如果是叶子节点，利用HashMap向上寻找父节点 方法二：BFS 双队列，一个队列存节点，一个队列存累加和，每遍历到叶节点，把累加和记录到result中。 用一个队列也可以实现，offer两次，poll两次，不过要注意Queue的类型是Object，以及使用变量接受TreeNode和Integer时要强转。 123Queue&lt;Object&gt; queue = new LinkedList&lt;&gt;();TreeNode cur = (TreeNode)queue.poll();int sum = (int)queue.poll(); x剑指 Offer II 050. 向下的路径节点之和 同437. 路径总和 III 方法一：暴力 双重dfs。 注意！！！ int只有32位，只能表示$-2{31}到2{31} - 1$，虽然范围大于$-10^9 到 109$，但是节点数最多1000个！$-2{31}到2^{31} - 1$区间范围是小于${-10{12}}到10{12}$的！所以要用long来求和。 注意！！！ 树只要往下走就行，可以转弯，不是只能向左或者向右！！ 方法二：前缀和 X剑指 Offer II 051. 节点之和最大的路径 剑指 Offer II 053. 二叉搜索树中的中序后继 方法一：中序遍历二叉树 创建一个boolean变量flag初始为false，当当前节点为目标节点p，则令flag为true，返回下一个从栈中弹出的节点；如果无右继节点，那么cur已经为空且栈空，返回null。 方法二：利用搜索二叉树的特性 剑指 Offer II 054. 所有大于等于节点的值之和 方法一：中序遍历：右根左 使用一个变量记录上一个节点的值 剑指 Offer II 055. 二叉搜索树迭代器 方法一：扁平化 先中序遍历一次，使用LinkedList存储val 方法二：迭代 周五一次性把栈与队列刷完了， 今天学习了Morris遍历， 可以将非递归遍历中的空间复杂度降为O(1)，在不必用第三下次 信息的强整合， Morris遍历是最优解 ⭐Morris遍历 使用了Morris 遍历的题目 必须做一个节点第三次信息(到达一个节点三次)的强整合，用传统递归或非递归方法解；如果不必用第三下次信息的强整合，Morris遍历是最优解。 需要操作左右子树的操作不适合Morris后序遍历 98. 验证二叉搜索树 文章 morris遍历可以将非递归遍历中的空间复杂度降为O(1)。从而实现时间复杂度为O(N)，而空间复杂度为O(1)的精妙算法。 morris遍历利用的是树的大量空闲指针，实现空间开销的极限缩减。 morris遍历的实现原则 记作当前节点为cur。 如果cur无左孩子，cur向右移动（cur=cur.right） 如果cur有左孩子，找到cur左子树上最右的节点，记为mostright 如果mostright的right指针指向空，让其指向cur，cur向左移动（cur=cur.left） 如果mostright的right指针指向cur，让其指向空，cur向右移动（cur=cur.right） 实现以上的原则，即实现了morris遍历。 morris遍历的实质 建立一种机制，对于没有左子树的节点只到达一次，对于有左子树的节点会到达两次 morris遍历的实例 一个树若按层遍历的结构为{1,2,3,4,5,6,7}，即该树为满二叉树，头结点值为1，左右孩子为2,3，叶节点为4,5,6,7 一开始图示： 我们按照morris遍历来遍历该树。 1）首先cur来到头结点1，按照morris原则的第二条第一点，它存在左孩子，cur左子树上最右的节点为5，它的right指针指向空，所以让其指向1，cur向左移动到2。 2）2有左孩子，且它左子树最右的节点4指向空，按照morris原则的第二条第一点,让4的right指针指向2，cur向左移动到4 3）4不存在左孩子，按照morris原则的第一条，cur向右移动，在第二步中，4的right指针已经指向了2，所以cur会回到2 4）重新回到2，有左孩子，它左子树最右的节点为4，但是在第二步中，4的right指针已经指向了2，不为空。所以按照morris原则的第二条第二点，2向右移动到5，同时4的right指针重新指向空 5）5不存在左孩子，按照morris原则的第一条，cur向右移动，在第一步中，5的right指针已经指向了1，所以cur会回到1 6）cur回到1，回到头结点，左子树遍历完成，1有左孩子，左子树上最右的节点为5，它的right指针指向1，按照morris原则的第二条第二点，1向右移动到3，同时5的right指针重新指回空 …… 当到达最后一个节点7时，按照流程下来，此时7无左右孩子，遍历结束。 ps：建议用一张纸一步一步按照上面的讲解来画，你会更加明白整个morris遍历的。 Morris遍历(常规) 1234567891011121314151617181920212223public static void morris(Node head) &#123; if (head == null) &#123; return; &#125; Node cur = head; Node mostRight = null; while (cur != null) &#123; mostRight = cur.left; if (mostRight != null) &#123; while (mostRight.right != null &amp;&amp; mostRight.right != cur) &#123; mostRight = mostRight.right; &#125; if (mostRight.right == null) &#123; mostRight.right = cur; cur = cur.left; continue; &#125; else &#123; mostRight.right = null; &#125; &#125; cur = cur.right; &#125;&#125; Morris前序遍历 如果可以到达一个节点两次(有左子树)，第一次打印 如果可以到达一个节点一次(无左子树)，直接打印 123456789101112131415161718192021222324252627public static void morrisPre(Node head) &#123; if (head == null) &#123; return; &#125; Node cur = head; Node mostRight = null; while (cur != null) &#123; mostRight = cur.left; if (mostRight != null) &#123; while (mostRight.right != null &amp;&amp; mostRight.right != cur) &#123; mostRight = mostRight.right; &#125; if (mostRight.right == null) &#123; System.out.print(cur.value + &quot; &quot;); mostRight.right = cur; cur = cur.left; continue; &#125; else &#123; mostRight.right = null; &#125; &#125; else &#123; System.out.print(cur.value + &quot; &quot;); &#125; cur = cur.right; &#125; System.out.println();&#125; Morris中序遍历 如果可以到达一个节点两次(有左子树)，第二次打印 如果可以到达一个节点一次(无左子树)，直接打印 12345678910111213141516171819202122232425public static void morrisIn(Node head) &#123; if (head == null) &#123; return; &#125; Node cur = head; Node mostRight = null; while (cur != null) &#123; mostRight = cur.left; if (mostRight != null) &#123; while (mostRight.right != null &amp;&amp; mostRight.right != cur) &#123; mostRight = mostRight.right; &#125; if (mostRight.right == null) &#123; mostRight.right = cur; cur = cur.left; continue; &#125; else &#123; mostRight.right = null; &#125; &#125; System.out.print(cur.value + &quot; &quot;); cur = cur.right; &#125; System.out.println();&#125; Morris后序遍历 如果可以到达一个节点两次(有左子树)，第二次逆序打印左子树上的右边界 最后走出循环后，逆序打印根节点的右边界 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public static void morrisPos(Node head) &#123; if (head == null) &#123; return; &#125; Node cur = head; Node mostRight = null; while (cur != null) &#123; mostRight = cur.left; if (mostRight != null) &#123; while (mostRight.right != null &amp;&amp; mostRight.right != cur) &#123; mostRight = mostRight.right; &#125; if (mostRight.right == null) &#123; mostRight.right = cur; cur = cur.left; continue; &#125; else &#123; mostRight.right = null; printEdge(cur.left); &#125; &#125; cur = cur.right; &#125; printEdge(head); System.out.println();&#125;public static void printEdge(Node head) &#123; Node tail = reverseEdge(head); Node cur = tail; while (cur != null) &#123; System.out.print(cur.value + &quot; &quot;); cur = cur.right; &#125; reverseEdge(tail); &#125; public static Node reverseEdge(Node from) &#123; Node pre = null; Node next = null; while (from != null) &#123; next = from.right; from.right = pre; pre = from; from = next; &#125; return pre; &#125; 124. 二叉树中的最大路径和 方法一：递归 使用一个全局变量记录最大路径值 dfs递归，如果是空节点返回0或者如果值是负数返回0 比较，更新最大路径值 返回当前节点的值加上Max(左节点最大累计值，右节点最大累计值) 时间复杂度：$O(n)$，其中n是二叉树中的节点个数，对每个节点访问不超过2次 空间复杂度：$O(n)$，最坏情况是一叉树 12345678910111213141516class Solution &#123; private int maxPath = Integer.MIN_VALUE; public int maxPathSum(TreeNode root) &#123; dfs(root); return maxPath; &#125; private int dfs(TreeNode root) &#123; if (root == null) return 0; int leftMax = Math.max(dfs(root.left), 0); int rightMax = Math.max(dfs(root.right), 0); int curMaxPath = root.val + leftMax + rightMax; maxPath = Math.max(maxPath, curMaxPath); return root.val + Math.max(leftMax, rightMax); &#125;&#125; 方法二：树形DP xx String 344. 反转字符串 for循环遍历n/2次，使用一个临时变量记录左边的值，然后首尾交换 Trick:使用位运算进行swap操作，前提是进行交换的a与b在内存空间不同。 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 1234567a = a ^ b;b = a ^ b;a = a ^ b;// 简化a ^= b;b ^= a;a ^= b; 123456789101112class Solution &#123; public void reverseString(char[] s) &#123; for (int i = 0, j = s.length - 1; i &lt; s.length / 2; ++i, --j) &#123; swap(s, i, j); &#125; &#125; private void swap(char[] s, int i, int j) &#123; s[i] ^= s[j]; s[j] ^= s[i]; s[i] ^= s[j]; &#125;&#125; x541. 反转字符串 II 方法一：模拟 for循环遍历char数组，i每次向后移两步 如果最后一段长度大于等于k，则翻转前k个字符 如果最后一段长度小于k，则全部翻转 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 12345678910111213141516171819202122class Solution &#123; public String reverseStr(String s, int k) &#123; int length = s.length(); char[] ch = s.toCharArray(); for (int i = 0; i &lt; length; i += 2 * k) &#123; // 最后一段的长度有两种情况 // 1. 大于等于k，翻转前k个字符 // 2. 小于k，全部翻转 // 区间是左闭右开[i, i + 3) reverse(ch, i, Math.min(i + k, length)); &#125; return new String(ch); &#125; private void reverse(char[] ch, int i, int j) &#123; for (; i &lt; ((i + j) &gt;&gt; 1); ++i, --j) &#123; // 不要把ch写成char！ ch[i] ^= ch[j - 1]; ch[j - 1] ^= ch[i]; ch[i] ^= ch[j - 1]; &#125; &#125;&#125; 剑指 Offer 05. 替换空格 方法一：遍历 Java中String只读，所以使用StringBuilder来动态append“%20” 可以使用ASCII码来判断是否为空格，空格的ASCII码为32，s.charAt(i) == 32或者直接用s.charAt(i) == ‘ ’ 时间复杂度：$O(n)$ 空间复杂度：$O(n)$ 123456789101112class Solution &#123; public String replaceSpace(String s) &#123; StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; s.length(); ++i) &#123; if (s.charAt(i) == 32) // s.charAt(i) == ‘ ’ sb.append(&quot;%20&quot;); else sb.append(s.charAt(i)); &#125; return sb.toString(); &#125;&#125; 注意: “%20&quot;赋值给char类型的变量，而char类型只能存储单个字符，因此编译器会报错。应该将”%20&quot;替换为’%'、‘2’、'0’三个字符分别赋值给数组ch的相应位置。 方法二：双指针 **注意：**C的语言新特新有String可变长度，所以用C可以做到空间复杂度$O(1)$，这里用Java实现是需要额外的空间复杂度的，重点是双指针的思想！ 分析见注释，注意while的边界条件 时间复杂度：$O(n)$ 空间复杂度：$O(n)$ 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; public String replaceSpace(String s) &#123; // 先遍历一遍记录空格数量 int count = 0; for (int i = 0; i &lt; s.length(); ++i) if (s.charAt(i) == &#x27; &#x27;) ++count; // 每一个空格会被替换成&quot;%20&quot;,也就是说String的长度会增加count * 2，这里用char数组来处理 // left指针指向原始数组的最后一个元素 int left = s.length() - 1; char[] ch = new char[s.length() + 2 * count]; // 把前s.length()赋值给ch for (int i = 0; i &lt; s.length(); ++i) ch[i] = s.charAt(i); // 开始双指针遍历 // right指针指向新数组的最后一个元素 int right = ch.length - 1; // 循环，left遇到空格，right会比left多前移两步，最终right会追上left // 注意边界条件！当left==0的时候，如果ch[left] != &#x27; &#x27;(空格), // 则把ch[left]赋值给ch[right]这个操作是可以忽略的，因为之前已经赋值过了 // 如果当left==0的时候，如果ch[left] == &#x27; &#x27;(空格)，那么此时right的位置 // 是2，则需要赋值&quot;%20&quot;，所以left在等于0的时候要执行！！！ while (left &gt;= 0) &#123; // 当ch[left] == &#x27; &#x27;的时候，ch[right]向左添加三个字符&quot;%20&quot; if (ch[left] == &#x27; &#x27;) &#123; ch[right--] = &#x27;0&#x27;; ch[right--] = &#x27;2&#x27;; ch[right] = &#x27;%&#x27;; &#125; // 当ch[left] != &#x27; &#x27;的时候，把ch[left]赋值给ch[right] else &#123; ch[right] = ch[left]; &#125; --right; --left; &#125; return new String(ch); &#125;&#125; 151. 反转字符串中的单词 方法一：双指针 **解题思路：**从后往前遍历，right指针指向单词的最后一个字符，left往前遍历到空格为止，至此在左闭右闭的区间[left + 1, right]依次将字符加入附加在StringBuilder对象上，并在完成对整个单词的append后，再追加(append)一个空格。 定位单词：使用一个boolean变量flag用于标记当前单词的最后一个字符，并用right指向这个字符，将flag置false，再遇到下一个空格时再将flag置true。 边界条件： 首先将输入字符串转换为字符数组char[] ch，只有ch[left] == ‘ ’(空格)且ch[left + 1] != ‘ ’(空格)时，区间[left + 1, right]是一个完整的单词。如果输入的字符串为“hello world”，遍历到hello 的h时，就结束了，那么没有添加hello，所以在ch初始化的时候，在最前面添加一个空格。 1234char[] ch = new char[s.length() + 1];ch[0] = &#x27; &#x27;;for (int i = 1; i &lt; ch.length; ++i) ch[i] = s.charAt(i - 1); 遍历的执行条件是left &gt;= 0，遍历到ch[0]，也就是初始化时添加的空格为止 由于每遍历一个单词，会将单词append到StringBuilder对象上，并且再追加一个空格，那么在遍历结束后，应该删去最后一个空格。考虑到输入的字符串可能是全空，那么不会进行追加空格的操作，就不必要删去最后一个空格了。 12if (sb.length() &gt; 0) sb.setLength(sb.length() - 1); 时间复杂度：$O(n)$，其中$n$为输入字符串的长度 空间复杂度：$O(n)$，需要用$O(n)$的空间存储字符串 12345678910111213141516171819202122232425262728293031323334class Solution &#123; public String reverseWords(String s) &#123; StringBuilder sb = new StringBuilder(); char[] ch = new char[s.length() + 1]; ch[0] = &#x27; &#x27;; for (int i = 1; i &lt; ch.length; ++i) ch[i] = s.charAt(i - 1); int left = ch.length - 1, right = ch.length - 1; boolean flag = true; while (left &gt;= 0) &#123; if (ch[left] != &#x27; &#x27;) &#123; // 标记单词的最后一个字符 if (flag) &#123; right = left; flag = false; &#125; &#125; else &#123; // ch[left] == &#x27; &#x27; flag = true; if (left &lt; ch.length - 1 &amp;&amp; ch[left + 1] != &#x27; &#x27;) &#123; for (int cur = left + 1; cur &lt;= right; ++cur) &#123; sb.append(ch[cur]); &#125; sb.append(&#x27; &#x27;); &#125; &#125; --left; &#125; // 如果是字符串只包含空格，则sb.length()本来就是0 if (sb.length() &gt; 0) sb.setLength(sb.length() - 1); return sb.toString(); &#125;&#125; 剑指 Offer 58 - II. 左旋转字符串 方法一：遍历 解题思路：创建StringBuilder，先从字符串s的第n位开始遍历到最后一个字符，再从第0个字符遍历到第n-1个字符，做append操作 时间复杂度：$O(n)$，其中$n$为输入字符串的长度 空间复杂度：$O(n)$，需要用$O(n)$的空间存储字符串 123456789101112131415class Solution &#123; public String reverseLeftWords(String s, int n) &#123; if (n &gt; s.length()) return &quot;&quot;; if (n == s.length()) return s; StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; s.length() - n; ++i) sb.append(s.charAt(i + n)); for (int i = 0; i &lt; n; ++i) sb.append(s.charAt(i)); return sb.toString(); &#125;&#125; 28. 找出字符串中第一个匹配项的下标 方法一：KMP 还没有完全掌握KMP，多复习巩固 对next数组讲解很透彻 参考代码 求next数组的过程完全可以看成字符串匹配的过程，即以模式字符串为主字符串，以模式字符串的前缀为目标字符串，一旦字符串匹配成功，那么当前的next值就是匹配成功的字符串的长度。 12345678910111213141516171819202122232425262728293031class Solution &#123; public int strStr(String haystack, String needle) &#123; int n = haystack.length(), m = needle.length(); if (n &lt; m) return -1; int[] next = new int[m]; setNext(next, needle); int j = 0; for (int i = 0; i &lt; n; ++i) &#123; while (j &gt; 0 &amp;&amp; haystack.charAt(i) != needle.charAt(j)) &#123; j = next[j - 1]; &#125; if (haystack.charAt(i) == needle.charAt(j)) ++j; if (j == needle.length()) return i - j + 1; &#125; return - 1; &#125; private void setNext(int[] next, String needle) &#123; next[0] = 0; int j = 0; for (int i = 1; i &lt; next.length; ++i) &#123; while (j &gt; 0 &amp;&amp; needle.charAt(i) != needle.charAt(j)) j = next[j - 1]; if (needle.charAt(i) == needle.charAt(j)) ++j; // ++j first next[i] = j; &#125; &#125;&#125; x459. 重复的子字符串 在由重复子串组成的字符串中，最长相等前后缀不包含的子串就是最小重复子串，这里拿字符串s：abababab 来举例，ab就是最小重复单位 12345678910111213141516171819class Solution &#123; public boolean repeatedSubstringPattern(String s) &#123; int length = s.length(); int[] next = new int[length]; setNext(next, s); return next[length - 1] &gt; 0 &amp;&amp; length % (length - next[length - 1]) == 0 ? true : false; &#125; private void setNext(int[] next, String s) &#123; int j = 0; next[0] = 0; for (int i = 1; i &lt; s.length(); ++i) &#123; while (j &gt; 0 &amp;&amp; s.charAt(i) != s.charAt(j)) j = next[j - 1]; if (s.charAt(i) == s.charAt(j)) ++j; next[i] = j; &#125; &#125;&#125; 剑指 Offer II 014. 字符串中的变位词 题目要求： 换句话说，第一个字符串的排列之一是第二个字符串的 子串 。 子串的定义：在计算机科学中，子串是指一个字符串中任意连续的一段字符序列。例如，字符串 “hello world” 中的子串包括 “hello”、“world”、“ell”、“llo” 等。子串通常用于字符串匹配、编辑距离等算法中。 连续！！！连续！！！连续！！！ 方法一：滑动窗口 解题思路：由于本题只需要考虑小写英文字母，可以考虑用一个长度为26的整型数组存储字符串中字母出现的次数。首先记录s1的所有字符以及s2的前s1.length()个字符，在s1中的每个字符在record对应位置作+1操作，在s2前s1.length()中的每个字符在record对应位置作-1操作。如果此时record数组所有元素都为0，s1是s2的变位词，返回true。如果满足，则进行滑动窗口操作： 初始化i=s1.length()遍历s2，滑动区间为：(i - s1.length(), i]，每次滑动，将左边开区间字符对应的record作-1操作，将右边闭区间字符对应的record作+1操作。 再检查record数组元素是否都为0，为0表示s2中子串s2[i - s1.length() + 1, i]是s1的变位词。 时间复杂度：$O(n)$，其中$n$为输入字符串s2的长度 空间复杂度：$O(n)$，需要用$O(n)$的空间存储字符串 1234567891011121314151617181920212223242526class Solution &#123; public boolean checkInclusion(String s1, String s2) &#123; if (s1.length() &gt; s2.length()) return false; int[] record = new int[26]; for (int i = 0; i &lt; s1.length(); ++i) &#123; ++record[s1.charAt(i) - &#x27;a&#x27;]; --record[s2.charAt(i) - &#x27;a&#x27;]; &#125; if (checkZero(record)) return true; for (int i = s1.length(); i &lt; s2.length(); ++i) &#123; ++record[s2.charAt(i - s1.length()) - &#x27;a&#x27;]; --record[s2.charAt(i) - &#x27;a&#x27;]; if (checkZero(record)) return true; &#125; return false; &#125; private boolean checkZero(int[] record) &#123; for (int element: record) if (element != 0) return false; return true; &#125;&#125; 剑指 Offer II 015. 字符串中的所有变位词 注意事项：接上题，画出来模拟！很巧妙！ 如果找到了一个符合的变位词，不要再对p重新把记录加一遍！会出错，例如s=“abab”，p=“ab”，答案应该是[0, 1, 2]。 由于只有a，b两个字母，所以只使用了record的前两位。 由于滑动窗口的步长是1，一开始遍历完ab，此时record = [0, 0]，开始for循环 i = 2，指向第二个a，滑动窗口为(a,b,a]，开区间元素在record的数值要–，闭区间元素在record的位置要++，开区间元素和闭区间元素都为‘a’，所以s的下标1以‘b’开始的子串“ba”也是变位词！ 1234567891011121314151617181920212223242526272829class Solution &#123; public List&lt;Integer&gt; findAnagrams(String s, String p) &#123; List&lt;Integer&gt; index = new LinkedList&lt;&gt;(); if (s.length() &lt; p.length()) return index; int[] record = new int[26]; for (int i = 0; i &lt; p.length(); ++i) &#123; ++record[p.charAt(i) - &#x27;a&#x27;]; --record[s.charAt(i) - &#x27;a&#x27;]; &#125; if (areZeros(record)) &#123; index.add(0); &#125; for (int i = p.length(); i &lt; s.length(); ++i) &#123; ++record[s.charAt(i - p.length()) - &#x27;a&#x27;]; --record[s.charAt(i) - &#x27;a&#x27;]; if (areZeros(record)) &#123; index.add(i - p.length() + 1); &#125; &#125; return index; &#125; private boolean areZeros(int[] record) &#123; for (int element : record) if (element != 0) return false; return true; &#125;&#125; 1208. 尽可能使字符串相等⚠️ 方法一：滑动窗口 123456789101112131415161718class Solution &#123; public int equalSubstring(String s, String t, int maxCost) &#123; int n = s.length(); int[] diff = new int[n]; for (int i = 0; i &lt; n; ++i) &#123; diff[i] = Math.abs(s.charAt(i) - t.charAt(i)); &#125; int res = 0, start = 0, sum = 0; for (int end = 0; end &lt; n; ++end) &#123; sum += diff[end]; while (maxCost &lt; sum) &#123; sum -= diff[start++]; &#125; res = Math.max(res, end - start + 1); &#125; return res; &#125;&#125; String补充知识 String与char数组，StringBuilder之间相互转换 将String转换为char数组： 12codeString str = &quot;hello&quot;;char[] charArray = str.toCharArray(); 将char数组转换为String： 12codechar[] charArray = &#123;&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;&#125;;String str = new String(charArray); 将String转换为StringBuilder： 123456//1.codeString str = &quot;hello&quot;;StringBuilder sb = new StringBuilder(str);//2.StringBuilder sb = new StringBuilder();sb.append(str); 将StringBuilder转换为String： 123codeStringBuilder sb = new StringBuilder();sb.append(&quot;hello&quot;);String str = sb.toString(); 将char数组转换为StringBuilder： 123codechar[] charArray = &#123;&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;&#125;;StringBuilder sb = new StringBuilder();sb.append(charArray); 将StringBuilder转换为char数组： 123codeStringBuilder sb = new StringBuilder(&quot;hello&quot;);char[] charArray = new char[sb.length()];sb.getChars(0, sb.length(), charArray, 0); 需要注意的是，在将String转换为char数组或char时，如果字符串为空，或者字符串中的字符数量为0，则可能会导致越界异常或其他异常。因此，在进行这些转换操作时，需要进行有效性检查和异常处理。 单个字符char转换为String 在Java中，将单个字符（char）转换为字符串（String）有以下两种方法： 1.使用字符串连接符 您可以使用字符串连接符&quot;+&quot;来连接一个空字符串和单个字符，从而将其转换为字符串。例如： 12arduinoCopy codechar c = &#x27;a&#x27;;String s = &quot;&quot; + c; 在上面的代码中，首先创建一个空字符串，然后使用字符串连接符将其与字符&quot;c&quot;连接起来，从而将字符&quot;c&quot;转换为字符串。现在，字符串s将包含字符&quot;c&quot;的字符串。 2.使用String.valueOf()方法 另一种将单个字符转换为字符串的方法是使用String类的valueOf()方法。例如： 12arduinoCopy codechar c = &#x27;a&#x27;;String s = String.valueOf(c); 在上面的代码中，将字符&quot;c&quot;传递给valueOf()方法，并将返回的字符串分配给变量s。 无论使用哪种方法，您都可以将单个字符转换为字符串，从而可以对其进行各种字符串操作。 StringBuilder的append可以是char或者String StringBuilder的append()方法可以接受char类型和String类型的参数。append()方法的作用是在StringBuilder对象的末尾追加指定的字符序列，这可以是char、String、StringBuilder或其他CharSequence实例。 以下是使用StringBuilder的append()方法追加char和String类型参数的示例代码： 追加char类型参数： 123codeStringBuilder sb = new StringBuilder();char c = &#x27;a&#x27;;sb.append(c); 追加String类型参数： 123codeStringBuilder sb = new StringBuilder();String str = &quot;hello&quot;;sb.append(str); 需要注意的是，使用append()方法追加char类型参数时，会自动将char类型转换为String类型。因此，如果需要在StringBuilder中追加一个char类型的字符，可以直接使用append()方法，而不需要先将其转换为String类型。 KMP算法 生成next数组讲得很透彻 Array 704. 二分查找 方法一：左闭右开 区间：[left, right) 初始化：right = nums.length while循环终止条件应为left &lt; right（右开，right不能等于left） 当nums[mid] &lt; target时，nums[0]~nums[mid]都小于target，此时有效的有边界是mid - 1，又因为右边界是开区间，所以另right = mid 时间复杂度：$O(logn)$，由于每次查找都会将查找范围缩小一半，因此二分查找的时间复杂度是$O(logn)$，其中 n 是数组的长度 空间复杂度：$O(1)$ 12345678910111213141516class Solution &#123; public int search(int[] nums, int target) &#123; int left = 0, right = nums.length; // [left, right) while(left &lt; right) &#123; int mid = left + ((right - left) &gt;&gt; 1); if (nums[mid] == target) return mid; else if (nums[mid] &lt; target) left = mid + 1; else right = mid; &#125; return -1; &#125;&#125; 方法二：左闭右闭 区间：[left, right] 初始化：right = nums.length - 1 while循环终止条件应为left &lt;= right 当nums[mid] &lt; target时，nums[0]~nums[mid]都小于target，另right = mid - 1 时间复杂度：$O(logn)$，由于每次查找都会将查找范围缩小一半，因此二分查找的时间复杂度是$O(logn)$，其中 n 是数组的长度 空间复杂度：$O(1)$ 123456789101112131415class Solution &#123; public int search(int[] nums, int target) &#123; int left = 0, right = nums.length - 1; while (left &lt;= right) &#123; int mid = right - ((right - left) &gt;&gt; 1); if (nums[mid] &gt; target) right = mid - 1; else if (nums[mid] &lt; target) left = mid + 1; else return mid; &#125; return -1; &#125;&#125; 27. 移除元素 方法一：暴力 每当发现一个数相等，那么从当前数组的下一个数开始，全部往前移一位。 注意：因为移位后，下一个要访问的数组元素j会到当前i的位置，然后for循环结束i自增，会错过访j，所以移位后要–i。 时间复杂度：$O(n^2)$ 空间复杂度：$O(1)$ 12345678910111213141516171819class Solution &#123; public int removeElement(int[] nums, int val) &#123; int newLen = nums.length; if (newLen == 0) return 0; for (int i = 0; i &lt; newLen; i++) &#123; if (nums[i] == val) &#123; for (int j = i + 1; j &lt; newLen; j++) &#123; nums[j - 1] = nums[j]; &#125; --newLen; --i; &#125; &#125; return newLen; &#125;&#125; 方法二：双指针 初始化慢指针为0 for循环遍历快指针，当nums[fast] != val时，令nums[slow] = nums[fast]，slow指针往后移。也就是说，如果快指针找到了val，那么慢指针停在val位置，之后快指针遍历到非val的位置时，将该非val数据覆盖到慢指针的指向数组位置的数据。 最后返回慢指针(慢指针大小代表新数组的大小) 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 123456789101112class Solution &#123; public int removeElement(int[] nums, int val) &#123; int slow = 0; for (int fast = 0; fast &lt; nums.length; ++fast) &#123; if (nums[fast] != val) &#123; nums[slow] = nums[fast]; ++slow; &#125; &#125; return slow; &#125;&#125; 方法三：相向双指针 避免了需要保留的元素的重复赋值操作。 初始化：left=0, right=nums.length-1，左闭右闭区间，所以while语句的执行条件是 left &lt;= right(如果没有等于，left会少后移一次) 循环：当nums[left]不等于val时，left指针后移；当nums[left]等于val时，将nums[right]赋值给nums[left]，right指针前移；如果赋值过来的元素恰好也等于val，可以继续把右指针 right指向的元素的值赋值过来，直到左指针指向的元素的值不等于 val为止。 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 12345678910111213141516class Solution &#123; public int removeElement(int[] nums, int val) &#123; int left = 0, right = nums.length - 1; // [left, right] while (left &lt;= right) &#123; if (nums[left] == val) &#123; nums[left] = nums[right]; --right; &#125; else &#123; ++left; &#125; &#125; return left; &#125;&#125; 977. 有序数组的平方 双指针 left,right指针指向数组两端，将较大的平方数放入result数组里。 时间复杂度：$O(n)$ 空间复杂度：$O(n)$ 209. 长度最小的子数组 nums[++i]先执行自增操作还是数组寻址操作? 在Java中，表达式nums[++i]中的++i是先自增还是先寻址是有规定的。按照Java的运算符优先级规定，前置自增运算符++i的优先级高于数组下标运算符[]，因此在执行这个表达式时，先进行++i自增运算，然后再进行数组下标运算，即先自增再寻址。 因此，nums[++i]相当于先将变量i自增1，然后使用自增后的i作为数组下标去访问nums数组中的元素。如果i的初始值为0，那么nums[++i]将访问nums[1]位置上的元素，而不是nums[0]。如果数组nums越界，将会抛出ArrayIndexOutOfBoundsException异常。 nums[i++]先执行自增操作还是数组寻址操作? 在这种情况下，nums[i++]实际上会先执行数组寻址操作，然后再对i进行自增操作。这是因为数组寻址操作的优先级比自增操作的优先级高。 具体来说，这个表达式会先使用i的当前值来计算nums数组中第i个元素的地址，然后将地址作为结果返回，接着才会将i的值加1。 int a = ++i 是先赋值还是先自增 这行代码会先自增变量 i 的值，然后将自增后的结果赋值给变量 a。所以，变量 a 的值等于自增后的变量 i 的值。这个过程中，变量 i 的值会被修改，而变量 a 的值则是这个修改后的值。 可以将这行代码拆分成两步： i = i + 1； // 自增 i 的值 a = i； // 将自增后的 i 的值赋值给 a 所以，最终变量 a 的值等于自增后的变量 i 的值。 int a = i++ 是先赋值还是先自增 这行代码会先将变量 i 的值赋值给变量 a，然后再将变量 i 的值自增。所以，变量 a 的值等于变量 i 的值，而变量 i 的值会被自增。 可以将这行代码拆分成两步： a = i； // 将 i 的值赋值给 a i = i + 1； // 自增 i 的值 所以，最终变量 a 的值等于变量 i 的初始值，而变量 i 的值则是初始值加一。 while(–index) 先-- 后比较index&gt;0 1234int index = 2;while (--index &gt; 0) &#123; System.out.print(index);&#125; stdout 1 while(index–) 先比较 后– 1234int index = 2;while (index-- &gt; 0) &#123; System.out.print(index);&#125; stdout 10 System.out.print(–index) 先-- 后打印 1234int index = 2;while (index &gt; 0) &#123; System.out.print(--index);&#125; stdout 10 滑动窗口 注意：为了确保有些案例，sum一直小于target，最后输出判断：如果 result == Integer.MAX_VALUE，就输出0。 result记录最小的长度 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 123456789101112131415class Solution &#123; public int minSubArrayLen(int target, int[] nums) &#123; int counter = 0, result = Integer.MAX_VALUE; int sum = 0; for (int i = 0; i &lt; nums.length; ++i) &#123; ++counter; sum += nums[i]; while (sum &gt;= target) &#123; result = Math.min(result, counter); sum -= nums[i - (--counter)]; &#125; &#125; return result == Integer.MAX_VALUE ? 0 : result; &#125;&#125; 59. 螺旋矩阵 II 遍历顺序：从左到右(左闭右开)，从上到下(上闭下开)，从右到左(右闭左开)，从下到上(下闭上开) 思路见代码注释部分 时间复杂度：$O(n^2)$ 空间复杂度：$O(1)$ 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public int[][] generateMatrix(int n) &#123; // 用笔画一个n=5的矩阵作为例子 // 遍历顺序：从左到右(左闭右开)，从上到下(上闭下开)，从右到左(右闭左开)，从下到上(下闭上开) // 建立n行n列的矩阵 int[][] matrix = new int[n][n]; // 遍历次数 int traverseTime = n / 2; int i, j; // 写入数组的数 int data = 1; // cur:当前遍历伦茨 for (int cur = 0; cur &lt; traverseTime; ++cur) &#123; // 从左到右(左闭右开) for (j = cur; j &lt; n - cur - 1; ++j) &#123; matrix[cur][j] = data++; &#125; // 从上到下(上闭下开) for (i = cur; i &lt; n - cur - 1; ++i) &#123; matrix[i][j] = data++; &#125; // 从右到左(右闭左开) for (; j &gt; cur; --j) &#123; matrix[i][j] = data++; &#125; // 从下到上(下闭上开) for (; i &gt; cur; --i) &#123; matrix[i][j] = data++; &#125; // debug // for (int a = 0; a &lt; n; ++a) &#123; // for (int b = 0; b &lt; n; ++b) &#123; // System.out.print(matrix[a][b]); // &#125; // &#125; &#125; if (n % 2 == 1) matrix[traverseTime][traverseTime] = n * n; return matrix; &#125;&#125; 303. 区域和检索 - 数组不可变 方法一：暴力 1234567891011121314151617181920class NumArray &#123; private int[] nums; public NumArray(int[] nums) &#123; this.nums = nums; &#125; public int sumRange(int left, int right) &#123; int sum = 0; for (int i = left; i &lt;= right; ++i) &#123; sum += nums[i]; &#125; return sum; &#125;&#125;/** * Your NumArray object will be instantiated and called as such: * NumArray obj = new NumArray(nums); * int param_1 = obj.sumRange(left,right); */ 方法二：前缀和 建立一个长度为n+1的数组preSum 初始化preSum[0] = 0; preSum[i]表示数组nums从下标0到下标i-1的和 区间[left,right]的和为preSum[right + 1] - preSum[left]; preSum[right + 1]表示数组从下标0到right的和，preSum[left]表示数组从下标0到left-1的和 将前缀和数组preSum的长度设为n+1的目标是为了方便计算sumRange(left, right)时，不需要对left=0的情况做特殊处理 12345678910111213141516171819class NumArray &#123; private int[] preSum; public NumArray(int[] nums) &#123; preSum = new int[nums.length + 1]; for (int i = 1; i &lt; preSum.length; ++i) &#123; preSum[i] = preSum[i - 1] + nums[i - 1]; &#125; &#125; public int sumRange(int left, int right) &#123; return preSum[right + 1] - preSum[left]; &#125;&#125;/** * Your NumArray object will be instantiated and called as such: * NumArray obj = new NumArray(nums); * int param_1 = obj.sumRange(left,right); */ 前缀和：前缀和数组为n，需要对left=0时做特殊处理 1234567891011121314151617181920212223class NumArray &#123; private int[] preSum; public NumArray(int[] nums) &#123; preSum = new int[nums.length]; preSum[0] = nums[0]; for (int i = 1; i &lt; preSum.length; ++i) &#123; preSum[i] = preSum[i - 1] + nums[i]; &#125; &#125; public int sumRange(int left, int right) &#123; if (left == 0) &#123; return preSum[right]; &#125; return preSum[right] - preSum[left - 1]; &#125;&#125;/** * Your NumArray object will be instantiated and called as such: * NumArray obj = new NumArray(nums); * int param_1 = obj.sumRange(left,right); */ 304. 二维区域和检索 - 矩阵不可变 方法一：前缀和⚠️ 需要重刷！ 题解 123456789101112131415161718192021class NumMatrix &#123; int[][] preSum; public NumMatrix(int[][] matrix) &#123; preSum = new int[matrix.length + 1][matrix[0].length + 1]; for (int i = 1; i &lt;= matrix.length; ++i) &#123; for (int j = 1; j &lt;= matrix[0].length; ++j) &#123; preSum[i][j] = matrix[i - 1][j - 1] + preSum[i - 1][j] + preSum[i][j - 1] - preSum[i - 1][j - 1]; &#125; &#125; &#125; public int sumRegion(int row1, int col1, int row2, int col2) &#123; return preSum[row2 + 1][col2 + 1] - preSum[row2 + 1][col1] - preSum[row1][col2 + 1] + preSum[row1][col1]; &#125;&#125;/** * Your NumMatrix object will be instantiated and called as such: * NumMatrix obj = new NumMatrix(matrix); * int param_1 = obj.sumRegion(row1,col1,row2,col2); */ 1109. 航班预订统计 LinkedList 203. 移除链表元素 解题思路：在面对链表、树有关创建、删除操作，使用dummyHead！能省去不少边界判定的功夫。 初始化：dummyHead指向head，dummyHead赋值给pre，head赋值给cur 当cur的值等于所求val，pre指向cur的下一个节点 当cur的值不等于val，pre移动到cur，cur往后移一位 返回dummyHead的下一个节点。 707. 设计链表 注意事项：DummyHead + size 206. 反转链表 用笔模拟一下指针pre，cur，next的过程 时间复杂度：$O(n^2)$ 空间复杂度：$O(1)$ 24. 两两交换链表中的节点 注意要点：用纸和笔模拟一下指针pre，cur，next的过程，记得创建dummyHead 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 19. 删除链表的倒数第 N 个结点 使用dummyHead，从dummyHead，找到倒数第N个节点的前一个节点node，需要走链表长度size - N步，即可把node指向下一个节点的下一个节点即可完成删除操作。 但是链表的长度是未知的，可以先遍历一遍链表的长度，求出size，再走size-N步完成删除操作。 也可以使用快慢指针，fast与slow的起始点都为dummyHead，fast先走N步，再让fast与slow一起右移，当fast走到最后一个节点时(fast.next == null时)，slow右移了size - N步，到达倒数第N个节点的上一个节点，即可完成删除操作。 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 面试题 02.07. 链表相交 方法一：HashSet 用指针A,B分别指向两个链表头 开始循环，循环的终止条件为A,B都为空，每次循环先将A,B指向的节点放入HashSet，再向后移 当遍历到某个已经存入HashSet的节点时，这个节点就是相交节点；否则没有相交节点 时间复杂度：$O(m + n)$，其中m，n分别为两个链表的长度 空间复杂度：$O(m + n)$ 方法二：双指针 解题思路：A,B分别指向headA,headB，如果有公共节点，设公共节点长度为c，链表A和B长度分别为a,b。向右遍历，如何为空，则指向另一个链表的头。如果两个链表相交，则A向右移动了a+c+b步，B向右移动了b+c+a时相交，返回A；如果两个链表不相交，则A向右移动了a+b步，B向右移动了b+a步，都为空，退出循环返回null。 用指针A,B分别指向两个链表头headA,headB 开始循环，循环的条件是A和B不都为空，如果A为空，则A指向headB，否则向后移；如果B为空，则B指向headA，否则向后移 开始循环，循环的终止条件为A,B都为空，每次循环先将A,B指向的节点放入HashSet，再向后移 当遍历到某个已经存入HashSet的节点时，这个节点就是相交节点；否则没有相交节点 时间复杂度：$O(m + n)$，其中m，n分别为两个链表的长度 空间复杂度：$O(m + n)$ 一个错误代码实例 1234567891011121314public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; if (headA == null || headB == null) return null; ListNode pA = headA, pB = headB; while (pA != null || pB != null) &#123; pA = pA == null ? headB : pA.next; pB = pB == null ? headA : pB.next; if (pA == pB) return pA; &#125; return null; &#125;&#125; 错误如下，当两个链表只有公共部分节点1时，上述代码没有先判断，先向右移，结果指向A,B都为空，返回空。 所以解决方案是把判断AB相等的语句放在指针移动上面 12345678910111213public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; if (headA == null || headB == null) return null; ListNode pA = headA, pB = headB; while (pA != null || pB != null) &#123; if (pA == pB) return pA; pA = pA == null ? headB : pA.next; pB = pB == null ? headA : pB.next; &#125; return null; &#125; 成功 优化 当A,B只有公共部分时，直接返回结果 当A,B有自己的部分也相交时 当A,B公共部分前面节点数量相同时，遍历到相交节点直接返回结果 当A,B公共部分前面节点数量不同时，遍历a+b+c步也会相交，返回结果 当A,B不相交时，遍历完a+ 1(null) + b + 1(null) 步后，A和B都为null，返回的A为null，表示不相交 123456789101112public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; if (headA == null || headB == null) return null; ListNode pA = headA, pB = headB; while (pA != pB) &#123; pA = pA == null ? headB : pA.next; pB = pB == null ? headA : pB.next; &#125; return pA; &#125;&#125; 142. 环形链表 II **解题思路：**快慢指针，慢指针走一步，快指针走两步，如果有环，快指针总能在环中追上慢指针。当快指针和慢指针指向同一节点时，把快节点指向头节点，慢节点不动，快慢指针一起走，再次相遇时，指向的节点就是入环的第一个节点。 时间复杂度：$O(m + n)$，其中m，n分别为两个链表的长度 空间复杂度：$O(m + n)$ 1234567891011121314151617181920public class Solution &#123; public ListNode detectCycle(ListNode head) &#123; if (head == null || head.next == null) return null; ListNode fast = head.next.next, slow = head.next; while (fast != null &amp;&amp; fast.next != null) &#123; fast = fast.next.next; slow = slow.next; if (fast == slow) &#123; fast = head; while (fast != slow) &#123; fast = fast.next; slow = slow.next; &#125; return fast; &#125; &#125; return null; &#125;&#125; 剑指 Offer II 026. 重排链表 方法一：翻转合并 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public void reorderList(ListNode head) &#123; ListNode cur = head, fast = head.next; while(fast != null &amp;&amp; fast.next != null) &#123; fast = fast.next.next; cur = cur.next; &#125; ListNode mid = cur; fast = mid.next; mid.next = null; fast = reverse(fast); cur = head; while (fast != null) &#123; ListNode next1 = cur.next, next2 = fast.next; cur.next = fast; fast.next = next1; cur = next1; fast = next2; &#125; &#125; private ListNode reverse(ListNode cur) &#123; ListNode pre = null, next = null; while (cur != null) &#123; next = cur.next; cur.next = pre; pre = cur; cur = next; &#125; return pre; &#125;&#125; 剑指 Offer II 025. 链表中的两数相加 方法一：翻转三次 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; l1 = reverse(l1); l2 = reverse(l2); ListNode res = addReversedList(l1, l2); return reverse(res); &#125; private ListNode addReversedList(ListNode l1, ListNode l2) &#123; ListNode dummy = new ListNode(-1); ListNode cur = dummy; int carry = 0, sum = 0; while (l1 != null || l2 != null) &#123; l1 = l1 == null ? null : l1; l2 = l2 == null ? null : l2; sum = (l1 == null ? 0 : l1.val) + (l2 == null ? 0 : l2.val) + carry; carry = sum &gt;= 10 ? 1 : 0; sum = sum &gt;= 10 ? sum - 10 : sum; ListNode newNode = new ListNode(sum); cur.next = newNode; cur = cur.next; l1 = l1 == null ? null : l1.next; l2 = l2 == null ? null : l2.next; &#125; if (carry == 1) &#123; ListNode newNode = new ListNode(1); cur.next = newNode; &#125; return dummy.next; &#125; private ListNode reverse(ListNode cur) &#123; ListNode pre = null, next = null; while (cur != null) &#123; next = cur.next; cur.next = pre; pre = cur; cur = next; &#125; return pre; &#125;&#125; 方法二：翻转两次(最后一次不需要翻转) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; l1 = reverse(l1); l2 = reverse(l2); ListNode res = addReversedList(l1, l2); return res; &#125; private ListNode addReversedList(ListNode l1, ListNode l2) &#123; ListNode dummy = new ListNode(-1); ListNode cur = dummy; int carry = 0, sum = 0; while (l1 != null || l2 != null) &#123; l1 = l1 == null ? null : l1; l2 = l2 == null ? null : l2; sum = (l1 == null ? 0 : l1.val) + (l2 == null ? 0 : l2.val) + carry; carry = sum &gt;= 10 ? 1 : 0; sum = sum &gt;= 10 ? sum - 10 : sum; ListNode newNode = new ListNode(sum); cur = dummy.next; dummy.next = newNode; newNode.next = cur; l1 = l1 == null ? null : l1.next; l2 = l2 == null ? null : l2.next; &#125; if (carry == 1) &#123; cur = dummy.next; ListNode newNode = new ListNode(1); dummy.next = newNode; newNode.next = cur; &#125; return dummy.next; &#125; private ListNode reverse(ListNode cur) &#123; ListNode pre = null, next = null; while (cur != null) &#123; next = cur.next; cur.next = pre; pre = cur; cur = next; &#125; return pre; &#125;&#125; Hash Table 242. 有效的字母异位词 方法一：双HashMap记录词频 判断s与t的长度，若不相等，则一定不是字母异位词 建立两个HashMap&lt;Character, Integer&gt; 遍历字符串，将每个字符存入map中，并将值+1 如果map1与map2的size不相等，则一定不是字母异位词 遍历map1(我遍历的是字符串)，get字符串s，t的每一个字符出现了的次数，判断是否相同，如果不同，则一定不是字母异位词。 时间复杂度：$O(n)$，其中n为第一个字符串的长度 空间复杂度：$O(1)$ 1234567891011121314151617181920212223class Solution &#123; public boolean isAnagram(String s, String t) &#123; int len = s.length(); if (len != t.length()) return false; Map&lt;Character, Integer&gt; map1 = new HashMap&lt;&gt;(), map2 = new HashMap&lt;&gt;(); for (int i = 0; i &lt; len; ++i) &#123; char sChar = s.charAt(i); char tChar = t.charAt(i); map1.put(sChar, map1.getOrDefault(sChar, 0) + 1); map2.put(tChar, map2.getOrDefault(tChar, 0) + 1); &#125; for (int i = 0; i &lt; len; ++i) &#123; int sSize = map1.get(s.charAt(i)); int tSize = map2.getOrDefault(s.charAt(i), 0); if (sSize != tSize) &#123; return false; &#125; &#125; return true; &#125;&#125; 方法二：数组 数组其实就是一个简单哈希表，而且这道题目中字符串只有小写字符，那么就可以定义一个数组，来记录字符串s里字符出现的次数。 定一个数组record，大小为26 ，初始化为0，因为字符a到字符z的ASCII也是26个连续的数值。 遍历第一个字符串s时，只需要将s.charAt(i) - ‘a’所在的元素+1，这样统计了字符串s中每个字符出现的次数。 同样，遍历第二个字符串t时，只需要将t.charAt(i) - ‘a’所在的元素-1。 如果record全部元素为0，那么s和t是字母异位词；否则不是。 时间复杂度：$O(n)$，其中n为第一个字符串的长度 空间复杂度：$O(1)$，只使用了常数大小的辅助数组。 123456789101112131415class Solution &#123; public boolean isAnagram(String s, String t) &#123; if (s.length() != t.length()) return false; int[] record = new int[26]; for (int i = 0; i &lt; s.length(); ++i) &#123; ++record[s.charAt(i) - &#x27;a&#x27;]; --record[t.charAt(i) - &#x27;a&#x27;]; &#125; for (int i = 0; i &lt; 26; ++i) if (record[i] != 0) return false; return true; &#125;&#125; 349. 两个数组的交集 解题思路：双HashSet 首先使用一个HashSet命名为set，记录第一个数组中不包含重复的所有元素 再用一个HashSet命名为intersection，遍历第二个数组，如果第二个数组中的元素在set中，则加入intersection中 最后将intersection转换为数组，并返回 1234567891011121314151617class Solution &#123; public int[] intersection(int[] nums1, int[] nums2) &#123; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); Set&lt;Integer&gt; intersection = new HashSet&lt;&gt;(); for (int i = 0; i &lt; nums1.length; ++i) set.add(nums1[i]); for (int i = 0; i &lt; nums2.length; ++i) if (set.contains(nums2[i])) intersection.add(nums2[i]); int[] result = new int[intersection.size()]; int i = 0; for (int element : intersection) &#123; result[i++] = element; &#125; return result; &#125;&#125; 202. 快乐数 求和的过程中，sum会重复出现，用HashSet记录每一次求和，如果有重复，那么必定不是快乐数。 **注意：**sum += (n % 10) * (n % 10);+=的优先级高于%。 12345678910111213141516171819class Solution &#123; public boolean isHappy(int n) &#123; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); while (n != 1 &amp;&amp; !set.contains(n)) &#123; set.add(n); n = getSum(n); &#125; return n == 1; &#125; private int getSum(int n) &#123; int sum = 0; while (n &gt; 0) &#123; sum += (n % 10) * (n % 10); n /= 10; &#125; return sum; &#125;&#125; 1. 两数之和 方法一：暴力 注意初始化int数组：new int[]{i, j}; 时间复杂度：$O(n^2)$，其中n为第一个字符串的长度 空间复杂度：$O(1)$，只使用了常数大小的辅助数组。 12345678910111213class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int[] result = new int[2]; for (int i = 0; i &lt; nums.length - 1; ++i) &#123; for (int j = i + 1; j &lt; nums.length; ++j) &#123; if (nums[i] + nums[j] == target) &#123; return new int[]&#123;i, j&#125;; &#125; &#125; &#125; return result; &#125;&#125; 方法二：HashMap 解题思路： 建立一个HashMap，key为数组的值，value为数组索引 遍历一遍，每次遍历判断哈希表中是否存在key为target-nums[i]，如果有，则这个key对应的value与i即为所求 时间复杂度：$O(n)$ 空间复杂度：$O(n)$ 1234567891011class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; ++i) &#123; if (map.containsKey(target - nums[i])) return new int[]&#123;map.get(target - nums[i]), i&#125;; map.put(nums[i], i); &#125; return new int[2]; &#125;&#125; 454. 四数相加 II 解题思路： 用HashMap用两层循环记录前两个数组每个元素之和为key，和出现的次数为value 再两次循环后两个数组，如果map.containsKey(- i - j)，那么- i - j与当前i + j之和为0，即为本题所求，则把result加上和为- i - j的数量 时间复杂度：$O(n^2)$，两层循环 空间复杂度：$O(n^2)$，在最坏情况下，前两个数组的元素各不相同，map占n * n 12345678910111213141516171819class Solution &#123; public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); int result = 0; int n = nums1.length; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; map.put(nums1[i] + nums2[j], map.getOrDefault(nums1[i] + nums2[j], 0) + 1); &#125; &#125; for (int i : nums3) &#123; for (int j : nums4) &#123; if (map.containsKey(- i - j)) result += map.get(- i - j); &#125; &#125; return result; &#125;&#125; 383. 赎金信 解题思路：字母表 如果ransomNote的长度大于magazine的长度，直接返回false 新建一个长度为26的字母表，以及一个HashMap，key为字母-‘a’，value为字母出现的次数，将magazine中的每个字符put进map 遍历ransomNote的所有字符i，如果map中key为字符i的value大于0，那么把这个value减一；如果map中key为字符i的value小于等于0，说明magazine不存在字符i或者字符i的个数小于ransomNote中字符i的个数，那么 ransomNote 能不能由 magazine 里面的字符构成，返回false 时间复杂度：$O(n)$，两层循环 空间复杂度：$O(1)$，只需要常数大小的辅助空间 12345678910111213141516171819202122class Solution &#123; public boolean canConstruct(String ransomNote, String magazine) &#123; if (ransomNote.length() &gt; magazine.length()) return false; char[] record = new char[26]; Map&lt; Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; magazine.length(); ++i) &#123; int index = magazine.charAt(i) - &#x27;a&#x27;; map.put(index, map.getOrDefault(index, 0) + 1); &#125; for (int i = 0; i &lt; ransomNote.length(); ++i) &#123; int index = ransomNote.charAt(i) - &#x27;a&#x27;; if (map.getOrDefault(index, 0) &gt; 0) &#123; map.put(index, map.get(index) - 1); &#125; else return false; &#125; return true; &#125;&#125; x15. 三数之和 题目要求： nums[i],nums[j],nums[k]中i,j,k各不相同 输出的nums[i],nums[j],nums[k]不能重复，如果结果集合中有{1,2,3}了，就不能再加入一个{1,2,3} 不能有重复的三元组，但三元组内的元素是可以重复的！{0,0,0},{-1,-1,2}是允许的 方法一：暴力 注意：{1，2，3}和{3， 2， 1}是不同的元素！ 1234set.add(Arrays.asList(1, 2, 3));set.add(Arrays.asList(3, 1, 2));[1, 2, 3][3, 1, 2] 找到符合的元素先排序，如何hashset中不存在再加入list中。 123456789101112131415161718192021class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; Set&lt;List&lt;Integer&gt;&gt; set = new HashSet&lt;&gt;(); List&lt;List&lt;Integer&gt;&gt; list = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; nums.length - 2; ++i) &#123; for (int j = i + 1; j &lt;nums.length - 1; ++j) &#123; for (int k = j + 1; k &lt; nums.length; ++k) &#123; if (nums[i] + nums[j] + nums[k] == 0) &#123; List&lt;Integer&gt; temp = Arrays.asList(nums[i], nums[j], nums[k]); Collections.sort(temp); if (!set.contains(temp)) &#123; set.add(temp); list.add(temp); &#125; &#125; &#125; &#125; &#125; return list; &#125;&#125; 超时 方法二：排序 + 双指针 去重思路 边界判断 时间复杂度：$O(n^2)$，两层循环 空间复杂度：$O(1)$ 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;(); Arrays.sort(nums); // window: [nums[i], left, right] for (int i = 0; i &lt; nums.length - 2; ++i) &#123; if (nums[i] &gt; 0) break; // 去重 // 为什么不是nums[i] = nums[i + 1]? // 比如&#123;-1，-1，2&#125; // 如果是nums[i] = nums[i + 1]，那么&#123;-1，-1，2&#125;这个结果不会被选中 if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue; int left = i + 1, right = nums.length - 1; // 只能选取数组中不同下标的三个数，所以left == right时会使用同一个数，不执行 while (left &lt; right) &#123; int sum = nums[i] + nums[left] + nums[right]; if (sum &lt; 0) ++left; else if (sum &gt; 0) --right; else &#123; // sum == 0 result.add(Arrays.asList(nums[i], nums[left], nums[right])); // 去重 // 必须在添加完结果后去重，不然第一次的结果可能无法添加 while (right &gt; left &amp;&amp; nums[right] == nums[right - 1]) --right; while (right &gt; left &amp;&amp; nums[left] == nums[left + 1]) ++left; // 为什么两个指针都移动？去重之后，只移动一个，结果必定不等于0 --right; ++left; &#125; &#125; &#125; return result; &#125;&#125; 18. 四数之和 注意事项：nums[i]的范围，如果4个数都等于$10^9$， 那么将大于$2^{31} - 1= 2147483648 &lt; 2.15 * 10^9$(int最大的正数)，所以要用long记录四数之和 在三数之和的基础上，再增加一层循环， 区间为[nums[i], nums[left], nums[right], nums[j]] 时间复杂度：$O(n^3)$，三层循环 空间复杂度：$O(n)$，排序使用了额外的数组存储数组nums的副本 剪枝 第一层循环中，如果最小的四数之和大于target，那么后面的数更大，break 123\\\\ 第一层循环if ((long) nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 1] &gt; target) break; 第二层循环中，如果最大的四数之和小于target，那么前面的数更小，break 123\\\\ 第二层循环if ((long) nums[i] + nums[j] + nums[j - 1] + nums[j - 2] &lt; target) break; 完整代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;(); int length = nums.length; if (length &lt; 4) return result; Arrays.sort(nums); // window: [nums[i], nums[left], nums[right], nums[j]] for (int i = 0; i &lt; length - 3; ++i) &#123; // 去重 if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue; if ((long) nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 1] &gt; target) break; // 第4个数从尾开始遍历，举例&#123;-1, -1, 0, 2&#125;来确定j &gt; 2这个边界条件 for (int j = length - 1; j &gt; 2; --j) &#123; // 去重，如果使用nums[j] == nums[j - 1]判断，nums[j - 1]属于right的范围 // 那么&#123;-1，-1，1, 1&#125;这个结果不会被选中 if (j &lt; length - 1 &amp;&amp; nums[j] == nums[j + 1]) continue; if ((long) nums[i] + nums[j] + nums[j - 1] + nums[j - 2] &lt; target) break; int left = i + 1, right = j - 1; // 只能选取数组中不同下标的三个数，所以left == right时会使用同一个数，不执行 while (left &lt; right) &#123; long sum = (long) nums[i] + nums[left] + nums[right] + nums[j]; if (sum &lt; target) ++left; else if (sum &gt; target) --right; else &#123; // sum == target result.add(Arrays.asList(nums[i], nums[left], nums[right], nums[j])); while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) ++left; while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) --right; ++left; --right; &#125; &#125; &#125; &#125; return result; &#125;&#125; 剑指 Offer II 030. 插入、删除和随机访问都是 O(1) 的容器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class RandomizedSet &#123; List&lt;Integer&gt; list; Map&lt;Integer, Integer&gt; map; /** Initialize your data structure here. */ public RandomizedSet() &#123; list = new LinkedList&lt;&gt;(); map = new HashMap&lt;&gt;(); &#125; /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */ public boolean insert(int val) &#123; if (map.containsKey(val)) return false; list.add(val); map.put(val, list.size() - 1); return true; &#125; /** Removes a value from the set. Returns true if the set contained the specified element. */ public boolean remove(int val) &#123; if (!map.containsKey(val)) return false; int index = map.get(val); int lastVal = list.get(list.size() - 1); list.set(index, lastVal); list.remove(list.size() - 1); map.put(lastVal ,index); map.remove(val); return true; &#125; /** Get a random element from the set. */ public int getRandom() &#123; Random random = new Random(); return list.get(random.nextInt(list.size())); &#125;&#125;/** * Your RandomizedSet object will be instantiated and called as such: * RandomizedSet obj = new RandomizedSet(); * boolean param_1 = obj.insert(val); * boolean param_2 = obj.remove(val); * int param_3 = obj.getRandom(); */ 剑指 Offer II 031. 最近最少使用缓存 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class LRUCache &#123; class ListNode &#123; int key; int val; ListNode pre; ListNode next; public ListNode(int key, int val) &#123; this.val = val; this.key = key; &#125; &#125; ListNode head, tail; private int capacity; Map&lt;Integer, ListNode&gt; map; public LRUCache(int capacity) &#123; this.capacity = capacity; head = new ListNode(-1, -1); tail = new ListNode(-1, -1); head.next = tail; tail.pre = head; map = new HashMap&lt;&gt;(); &#125; public int get(int key) &#123; if (!map.containsKey(key)) return -1; moveToTail(key); return map.get(key).val; &#125; public void put(int key, int value) &#123; if (map.containsKey(key)) &#123; ListNode node = map.get(key); node.val = value; map.put(key, node); moveToTail(key); &#125; else &#123; // do not exist ListNode node = new ListNode(key, value); if (this.capacity != map.size()) &#123; // not full insertAtTail(node); map.put(key, node); &#125; else &#123; // full ListNode toDelete = head.next; delete(toDelete); map.remove(toDelete.key); insertAtTail(node); map.put(key, node); &#125; &#125; &#125; public void moveToTail(int key) &#123; ListNode node = map.get(key); if (node.next == tail) return; delete(node); insertAtTail(node); &#125; public void delete(ListNode node) &#123; node.pre.next = node.next; node.next.pre = node.pre; &#125; public void insertAtTail(ListNode node) &#123; node.pre = tail.pre; node.next = tail; node.pre.next = node; tail.pre = node; &#125;&#125;/** * Your LRUCache object will be instantiated and called as such: * LRUCache obj = new LRUCache(capacity); * int param_1 = obj.get(key); * obj.put(key,value); */ Stack and Queue 232. 用栈实现队列 解题思路：使用两个栈，inStack,outStack来实现队列。 push：直接将元素push进inStack pop：如果outStack不为空，则弹出outStack顶部元素；如果outStack为空，则将inStack中的元素全部弹入inStack，再弹出outStack顶部元素 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class MyQueue &#123; private Stack&lt;Integer&gt; inStack; private Stack&lt;Integer&gt; outStack; public MyQueue() &#123; inStack = new Stack&lt;&gt;(); outStack = new Stack&lt;&gt;(); &#125; public void push(int x) &#123; inStack.push(x); &#125; public int pop() &#123; if (outStack.isEmpty()) &#123; pushIntoOut(); &#125; return outStack.pop(); &#125; public int peek() &#123; if (outStack.isEmpty()) pushIntoOut(); return outStack.peek(); &#125; public boolean empty() &#123; return inStack.isEmpty() &amp;&amp; outStack.isEmpty(); &#125; public void pushIntoOut() &#123; while (!inStack.isEmpty()) &#123; outStack.push(inStack.pop()); &#125; &#125;&#125;/** * Your MyQueue object will be instantiated and called as such: * MyQueue obj = new MyQueue(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.peek(); * boolean param_4 = obj.empty(); */ 225. 用队列实现栈 方法一：单队列 push：直接将元素加入queue pop()：首先将队列元素移除并重新加入queue.size() - 1次，这样底部的元素就在队列首部了，poll出来即可 peek()：首先将队列元素移除并重新加入queue.size() - 1次，这样底部的元素就在队列首部了，先用result接收queue.peek()，再将这个元素移除并重新加入，最后返回result，peek()操作是不能改变内部数据的！！ 12345678910111213141516171819202122232425262728293031323334class MyStack &#123; private Queue&lt;Integer&gt; queue; public MyStack() &#123; queue = new LinkedList&lt;&gt;(); &#125; public void push(int x) &#123; queue.offer(x); &#125; public int pop() &#123; catchBottom(); return queue.poll(); &#125; public int top() &#123; catchBottom(); int result = queue.peek(); queue.offer(queue.poll()); return result; &#125; public boolean empty() &#123; return queue.isEmpty(); &#125; public void catchBottom() &#123; for (int i = 0; i &lt; queue.size() - 1; ++i) &#123; queue.offer(queue.poll()); &#125; &#125;&#125; 优化 在面对大量需要查看顶部元素业务的时候，每次都要重新出队入队n次，不如在push的时候就排好序， 123456789101112public void push(int x) &#123; queue.offer(x); for (int i = 0; i &lt; queue.size() - 1; ++i) &#123; queue.offer(queue.poll()); &#125;&#125;public int pop() &#123; return queue.poll();&#125;public int top() &#123; return queue.peek();&#125; 方法二：双队列 push：先在辅助队列supportQueue中加入目标数据，再将主队列queue中的数据全部弹出并加入到supportQueue中，这个时候supportQueue就是先进后出的排列顺序，最后将queue和support交换 12345678910111213141516171819202122232425262728293031class MyStack &#123; Queue&lt;Integer&gt; queue, supportQueue; public MyStack() &#123; queue = new LinkedList&lt;&gt;(); supportQueue = new LinkedList&lt;&gt;(); &#125; public void push(int x) &#123; supportQueue.offer(x); while (!queue.isEmpty()) &#123; supportQueue.offer(queue.poll()); &#125; Queue&lt;Integer&gt; temp = queue; queue = supportQueue; supportQueue = temp; &#125; public int pop() &#123; return queue.poll(); &#125; public int top() &#123; return queue.peek(); &#125; public boolean empty() &#123; return queue.isEmpty(); &#125;&#125; 20. 有效的括号 方法一：HashMap + Stack **注意事项：**如果是左括号，直接push进栈 如果是右括号，如果栈为空那么匹配不了；如果右括号和栈顶部的左括号不匹配，也不满足 最后如果栈空，则是有效的括号；否则不是 1234567891011121314151617181920class Solution &#123; public boolean isValid(String s) &#123; Map&lt;Character, Character&gt; map = new HashMap&lt;&gt;(); map.put(&#x27;&#123;&#x27;, &#x27;&#125;&#x27;); map.put(&#x27;(&#x27;, &#x27;)&#x27;); map.put(&#x27;[&#x27;, &#x27;]&#x27;); Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); for (int i = 0; i &lt; s.length(); ++i) &#123; char c = s.charAt(i); if (map.containsKey(c)) stack.push(c); else &#123; if (stack.isEmpty() || map.get(stack.pop()) != c) &#123; return false; &#125; &#125; &#125; return stack.isEmpty(); &#125;&#125; 1047. 删除字符串中的所有相邻重复项 方法一：StringBuilder 如果当前字符和前一个字符相等，则删除当前字符；否则加入当前字符 123456789101112131415161718class Solution &#123; public String removeDuplicates(String s) &#123; StringBuilder sb = new StringBuilder(); int index = -1; for (int i = 0; i &lt; s.length(); ++i) &#123; char c = s.charAt(i); if (sb.length() == 0 || c != sb.charAt(index)) &#123; sb.append(c); ++index; &#125; else &#123; sb.deleteCharAt(index); --index; &#125; &#125; return sb.toString(); &#125;&#125; 150. 逆波兰表达式求值 解题思路： 遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中 1234567891011121314151617181920212223242526272829303132class Solution &#123; public int evalRPN(String[] tokens) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for (int i = 0; i &lt; tokens.length; ++i) &#123; String token = tokens[i]; if (isNumber(token)) stack.push(Integer.parseInt(token)); else &#123; int b = stack.pop(), a = stack.pop(); switch (token) &#123; case &quot;+&quot;: stack.push(a + b); break; case &quot;-&quot;: stack.push(a - b); break; case &quot;*&quot;: stack.push(a * b); break; case &quot;/&quot;: stack.push(a / b); break; default: &#125; &#125; &#125; return stack.pop(); &#125; public boolean isNumber(String s) &#123; return !(s.equals(&quot;+&quot;) || s.equals(&quot;-&quot;) || s.equals(&quot;*&quot;) || s.equals(&quot;/&quot;)); &#125;&#125; 注意事项： 在Java中，==和.equals()都是用于比较两个对象是否相等的操作符。但是它们之间存在着不同的用法和含义。 ==用于比较两个对象的引用是否相等，也就是判断这两个对象是否是同一个对象。当比较两个基本数据类型的值时，它们的值相等时返回true；当比较两个引用类型的对象时，如果它们所指向的内存地址相同，也就是它们是同一个对象时，返回true；否则返回false。 .equals()方法用于比较两个对象的内容是否相等。默认情况下，.equals()方法比较的是两个对象的引用是否相等，也就是使用==比较，但是我们可以通过重写.equals()方法来自定义比较规则，比如根据对象的属性值来比较是否相等。 对于字符串类型的变量来说，==和.equals()方法的区别如下： ==比较的是字符串对象的引用是否相等，也就是它们是否指向同一个内存地址。 .equals()方法比较的是字符串对象的内容是否相等，也就是它们包含的字符序列是否相同。 因为Java中字符串是一个特殊的对象类型，为了方便字符串的比较操作，Java中提供了一种特殊的机制，也就是&quot;字符串常量池&quot;，它可以缓存字符串对象，使得多个字符串对象可以共享同一个对象，也就是它们的引用相等。在这种情况下，==操作符会返回true。但是在其他情况下，如果不是使用相同的字符串字面量来创建字符串对象，==操作符会返回false，此时需要使用.equals()方法来进行字符串的内容比较。 239. 滑动窗口最大值 方法一：暴力（超时） 时间复杂度：$O(kn)$ 空间复杂度：$O(n)$，存储结果的数组 1234567891011121314151617class Solution &#123; public int[] maxSlidingWindow(int[] nums, int k) &#123; int n = nums.length; int[] result = new int[n - k + 1]; if (k &gt; n) return result; // [i, i + k) for (int i = 0; i &lt; result.length; ++i) &#123; int max = Integer.MIN_VALUE; for (int j = i; j &lt; i + k; ++j) &#123; max = Math.max(max, nums[j]); &#125; result[i] = max; &#125; return result; &#125;&#125; 方法二：单调队列 1234567891011121314151617181920212223242526class Solution &#123; public int[] maxSlidingWindow(int[] nums, int k) &#123; int n = nums.length - k + 1; Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; k; ++i) &#123; while (!deque.isEmpty() &amp;&amp; nums[i] &gt; nums[deque.peekLast()]) &#123; deque.pollLast(); &#125; deque.offerLast(i); &#125; int[] result = new int[n]; result[0] = nums[deque.peekFirst()]; for (int i = k; i &lt; nums.length; ++i) &#123; while (!deque.isEmpty() &amp;&amp; nums[i] &gt; nums[deque.peekLast()]) &#123; deque.pollLast(); &#125; deque.offerLast(i); // 如果i的左区间在队首元素右边，则要移除队首元素; 用if就可以了(while也行) if (deque.peekFirst() &lt;= i - k) &#123; deque.pollFirst(); &#125; result[i - k + 1] = nums[deque.peekFirst()]; &#125; return result; &#125;&#125; 347. 前 K 个高频元素 123456789101112131415161718192021222324252627282930class Solution &#123; public int[] topKFrequent(int[] nums, int k) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; ++i) &#123; map.put(nums[i], map.getOrDefault(nums[i], 0) + 1); &#125; PriorityQueue&lt;int[]&gt; queue = new PriorityQueue&lt;&gt;(new Comparator&lt;int[]&gt;() &#123; public int compare(int[] m, int[] n) &#123; return m[1] - n[1]; &#125; &#125;); for (Map.Entry&lt;Integer, Integer&gt; entry: map.entrySet()) &#123; int num = entry.getKey(), count = entry.getValue(); if (queue.size() == k) &#123; if (count &gt; queue.peek()[1]) &#123; queue.poll(); queue.offer(new int[]&#123;num, count&#125;); &#125; &#125; else &#123; queue.offer(new int[]&#123;num, count&#125;); &#125; &#125; int[] result = new int[k]; for (int i = 0; i &lt; k; ++i) &#123; result[i] = queue.poll()[0]; &#125; return result; &#125;&#125; 优先级队列（大根堆、小根堆） Java中可以使用PriorityQueue类来创建优先级队列，它实现了一个基于优先级堆的无界优先级队列。 要创建一个大根堆，需要使用Comparator.reverseOrder()方法来创建一个反转自然顺序的比较器，示例如下： 12345PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;(Comparator.reverseOrder());maxHeap.add(5);maxHeap.add(1);maxHeap.add(10);System.out.println(maxHeap.poll()); // 输出10 要创建一个小根堆，只需要使用默认的比较器即可，示例如下： 12345PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;();minHeap.add(5);minHeap.add(1);minHeap.add(10);System.out.println(minHeap.poll()); // 输出1 在上述示例中，我们首先创建了一个空的优先级队列，然后使用add()方法向其中添加元素，使用poll()方法从队列中取出元素并删除。由于大根堆和小根堆的比较器不同，它们会按照不同的顺序取出元素。 除了示例中用到的add()和poll()方法之外，PriorityQueue类还提供了一些其他常用的方法，下面对一些常用方法进行补充说明： offer(E e): 添加元素到队列中，如果队列已满则抛出异常。 12arduinoCopy codePriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;();queue.offer(1); peek(): 获取但不删除队列的头部元素，如果队列为空则返回null。 1234arduinoCopy codePriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;();queue.offer(1);queue.offer(2);System.out.println(queue.peek()); // 输出1 remove(Object o): 从队列中删除指定的元素，如果队列中不存在该元素则返回false。 1234567arduinoCopy codePriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;();queue.offer(1);queue.offer(2);queue.offer(3);System.out.println(queue.remove(2)); // 输出trueSystem.out.println(queue.remove(4)); // 输出falseSystem.out.println(queue); // 输出[3, 1] size(): 返回队列中元素的数量。 12345arduinoCopy codePriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;();queue.offer(1);queue.offer(2);queue.offer(3);System.out.println(queue.size()); // 输出3 clear(): 删除队列中的所有元素。 123456arduinoCopy codePriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;();queue.offer(1);queue.offer(2);queue.offer(3);queue.clear();System.out.println(queue); // 输出[] 还有一些其他的方法，如toArray()、contains()、addAll()等，可以参考Java官方文档进行学习。 Greedy 455. 分发饼干 方法一：从小胃口开始喂小饼干 先把两个数组都升序排序，从左往右遍历 如果孩子满足度小于等于饼干满足度，那么++res，并让两个指针都往后移动一位 如果孩子满足度大于饼干满足度，使饼干的指针向后移动一位 直到任意一个指针超出数组范围为止 12345678910111213141516171819class Solution &#123; public int findContentChildren(int[] children, int[] cookies) &#123; int res = 0; Arrays.sort(children); Arrays.sort(cookies); int i = 0, j = 0; while (i &lt; children.length &amp;&amp; j &lt; cookies.length) &#123; if (children[i] &lt;= cookies[j]) &#123; ++res; ++i; ++j; &#125; else &#123; ++j; &#125; &#125; return res; &#125;&#125; 方法二：从大胃口开始喂大饼干 12345678910111213141516171819class Solution &#123; public int findContentChildren(int[] children, int[] cookies) &#123; int res = 0; Arrays.sort(children); Arrays.sort(cookies); int i = children.length - 1, j = cookies.length - 1; while (i &gt;= 0 &amp;&amp; j &gt;= 0) &#123; if (children[i] &lt;= cookies[j]) &#123; ++res; --i; --j; &#125; else &#123; --i; &#125; &#125; return res; &#125;&#125; 376. 摆动序列 方法一：排序+删除连续重复元素+dp(不推荐) 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; public int wiggleMaxLength(int[] nums) &#123; int n = nums.length; if (n == 1) return 1; // 1.dp[i]:以nums[i]为结尾，最长的摆动序列 List&lt;Integer&gt; list = new LinkedList&lt;&gt;(); list.add(nums[0]); for (int i = 1; i &lt; n; ++i) &#123; if (nums[i] != nums[i - 1]) list.add(nums[i]); &#125; Integer[] dummy = list.toArray(new Integer[0]); if (dummy.length == 1) return 1; if (dummy.length == 2) return 2; int[] dp = new int[dummy.length]; dp[0] = 1; dp[1] = 2; // 2.状态转移方程： // 1)nums[i] - nums[i - 1]与nums[i - 1] - nums[i- 2]异号：dp[i] = dp[i - 1] + 1 // 2)nums[i] - nums[i - 1]与nums[i - 1] - nums[i- 2]同号：dp[i] = dp[i - 1] int res = 1; for (int i = 2; i &lt; dummy.length; ++i) &#123; if ((dummy[i] - dummy[i - 1]) * (dummy[i - 1] - dummy[i - 2]) &lt; 0) &#123; dp[i] = dp[i - 1] + 1; &#125; else if ((dummy[i] - dummy[i - 1]) * (dummy[i - 1] - dummy[i - 2]) &gt; 0) &#123; dp[i] = dp[i - 1]; &#125; res = Math.max(res, dp[i]); &#125; return res; &#125;&#125; 方法二：贪心 1234567891011121314class Solution &#123; public int wiggleMaxLength(int[] nums) &#123; int preDiff = 0, postDiff = 0; int result = 1; for (int i = 0; i &lt; nums.length - 1; ++i) &#123; postDiff = nums[i + 1] - nums[i]; if ((preDiff &lt;= 0 &amp;&amp; postDiff &gt; 0) || (preDiff &gt;= 0 &amp;&amp; postDiff &lt; 0)) &#123; ++result; preDiff = postDiff; &#125; &#125; return result; &#125;&#125; 方法三：DP 12345678910111213141516171819202122232425class Solution &#123; public int wiggleMaxLength(int[] nums) &#123; int n = nums.length; if (n &lt; 2) return n; int[] up = new int[n], down = new int[n]; up[0] = 1; down[0] = 1; for (int i = 1; i &lt; n; ++i) &#123; if (nums[i] &gt; nums[i - 1]) &#123; up[i] = Math.max(up[i - 1], down[i - 1] + 1); down[i] = down[i - 1]; &#125; else if (nums[i] &lt; nums[i - 1]) &#123; up[i] = up[i - 1]; down[i] = Math.max(down[i - 1], up[i - 1] + 1); &#125; else &#123; up[i] = up[i - 1]; down[i] = down[i - 1]; &#125; &#125; return Math.max(up[n - 1], down[n - 1]); &#125;&#125; 53. 最大子数组和 方法一：DP dp[i]：以nums[i]结尾的子数组的最大数组和 状态转移方程： 当dp[i - 1] &gt;= 0 时候，dp[i] = dp[i - 1] + nums[i] 当dp[i - 1] &lt; 0时候， dp[i] = nums[i] 初始化：dp[0] = nums[0] 时间复杂度：$O(n)$ 空间复杂度：$O(n)$ 12345678910111213141516171819202122class Solution &#123; public int maxSubArray(int[] nums) &#123; int n = nums.length; if (n == 1) return nums[0]; // dp[i]：以nums[i]结尾的子数组的最数组和 int[] dp = new int[n]; dp[0] = nums[0]; int res = dp[0]; for (int i = 1; i &lt; n; ++i) &#123; if (dp[i - 1] &gt;= 0) &#123; dp[i] = dp[i - 1] + nums[i]; &#125; else &#123; // dp[i - 1] &lt; 0 dp[i] = nums[i]; &#125; res = Math.max(res, dp[i]); &#125; return res; &#125;&#125; 方法二：优化空间的DP 由于dp[i]只依赖dp[i - 1]，所以可以用一个长度为2的数组记录dp 123456789101112131415161718192021class Solution &#123; public int maxSubArray(int[] nums) &#123; int n = nums.length; if (n == 1) return nums[0]; // dp[i]：以nums[i]结尾的子数组的最数组和 int[] dp = new int[2]; dp[0] = nums[0]; int res = nums[0]; for (int i = 1; i &lt; n; ++i) &#123; if (dp[(i - 1) % 2] &gt;= 0) &#123; dp[i % 2] = dp[(i - 1) % 2] + nums[i]; &#125; else &#123; // dp[i - 1] &lt; 0 dp[i % 2] = nums[i]; &#125; res = Math.max(res, dp[i % 2]); &#125; return res; &#125;&#125; 贪心 首先把记录结果的result初始化为最小值，以及count=0 遍历数组，count加上当前元素，如果count大于result，讲count值赋给result 如果count等于负数了，令count等于0，从下一个数开始重新计算 1234567891011121314class Solution &#123; public int maxSubArray(int[] nums) &#123; int result = Integer.MIN_VALUE; int count = 0; for (int i = 0; i &lt; nums.length; ++i) &#123; count += nums[i]; if (count &gt; result) result = count; if (count &lt; 0) count = 0; &#125; return result; &#125;&#125; 122. 买卖股票的最佳时机 II 只要下一天股票价格高于当天，那么就买入当前股票并在下一天卖出 123456789101112class Solution &#123; public int maxProfit(int[] prices) &#123; int res = 0; for (int i = 0; i &lt; prices.length - 1; ++i) &#123; int diff = prices[i + 1] - prices[i]; if (diff &gt; 0) &#123; res += diff; &#125; &#125; return res; &#125;&#125; 55. 跳跃游戏 方法一：贪心 初始化一个available数组，available[i]表示是否可以到底数组元素i 如果当前节点是可到达的，令i=0前往后遍历，把available数组从i+1开始，后nums[i]个元素都赋true 初始化：第一个元素是肯定能到达的，初始化为true 时间复杂度：$O(n^2)$，最坏情况下，所有节点都刚好能到达数组倒数第二个元素，且倒数第二个元素的值为0，如[n - 2, n - 3, …, 1, 0, 1]，需要遍历$\\frac{(n-1)(n-2)}{2}$次 空间复杂度：$O(n)$ 1234567891011121314151617class Solution &#123; public boolean canJump(int[] nums) &#123; int n = nums.length; boolean[] available = new boolean[n]; available[0] = true; for (int i = 0; i &lt; n - 1; ++i) &#123; if (available[i]) &#123; for (int j = i + 1; j &lt; nums[i] + i + 1; ++j) &#123; if (j == n - 1) return true; available[j] = true; &#125; &#125; &#125; return available[n - 1]; &#125;&#125; 方法二：贪心（优化空间复杂度） 不必要用一个boolean数组来表示是否可以到达当前数组元素，可以用一个整数rightmost来判断 1234567891011121314class Solution &#123; public boolean canJump(int[] nums) &#123; int n = nums.length; int rightmost = 0; for (int i = 0; i &lt; n; ++i) &#123; if (i &lt;= rightmost) &#123; rightmost = Math.max(rightmost, i + nums[i]); if (rightmost &gt;= n - 1) return true; &#125; &#125; return false; &#125;&#125; 45. 跳跃游戏 II 方法一：dp 1234567891011121314151617class Solution &#123; public int jump(int[] nums) &#123; int n = nums.length; // 1.dp[i]：到达i的最小跳数 int[] dp = new int[n]; Arrays.fill(dp, Integer.MAX_VALUE); dp[0] = 0; for (int i = 0; i &lt; n - 1; ++i) &#123; for (int j = i + 1; j &lt; i + 1 + nums[i]; ++j) &#123; dp[j] = Math.min(dp[j], dp[i] + 1); if (j == n - 1) break; &#125; &#125; return dp[n - 1]; &#125;&#125; 方法二：贪心 123456789101112131415class Solution &#123; public int jump(int[] nums) &#123; int result = 0; int n = nums.length; int maxDistance = 0, end = 0; for (int i = 0; i &lt; n - 1; ++i) &#123; maxDistance = Math.max(maxDistance, i + nums[i]); if (i == end) &#123; end = maxDistance; ++result; &#125; &#125; return result; &#125;&#125; 1005. K 次取反后最大化的数组和 先创建一个小根堆，把数组所有元素都放进去 取反小根堆堆顶元素再放回小根堆，循环k次 时间复杂度：$O(n)$ 空间复杂度：$O(n)$ 如果小根堆堆顶是负数$x$，那么一定是最小的负数，取反后会是比较大的正数$-x$； 如果小根堆堆顶是正数$x$，那么是最小的正数，取反后是负数$-x$，由于此时只有这一个负数，所以$-x$是最小值，再放入堆顶，再取反又是最小的正数，循环到k为0为止。 12345678910111213141516171819class Solution &#123; public int largestSumAfterKNegations(int[] nums, int k) &#123; // 先创建一个小根堆，把数组所有元素都放进去 // 取反小根堆堆顶元素再放回小根堆，循环k次 PriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;(); for (int n : nums) queue.offer(n); while (!queue.isEmpty() &amp;&amp; k &gt; 0) &#123; int cur = queue.poll(); queue.offer(-1 * cur); --k; &#125; int sum = 0; while (!queue.isEmpty()) &#123; sum += queue.poll(); &#125; return sum; &#125;&#125; 方法二：优化方法一 先创建一个小根堆，把数组所有元素都放进去 首先小根堆弹出的元素$x$如果是负数，就取反(最小的负数取反是比较大的正数),再放回小根堆 小根堆弹出的元素$x$如果是是正数：此时$k$值如果能被2整除，那么重复取反堆顶元素$x$，最终$x$不变，直接将$x$加入堆中；如果$k$值如果不能被2整除，那么将-x加入堆中 123456789101112131415161718192021222324252627class Solution &#123; public int largestSumAfterKNegations(int[] nums, int k) &#123; // 先创建一个小根堆，把数组所有元素都放进去 // 要取反k次，首先小根堆弹出的元素x如果是负数，就取反(最小的负数取反是比较大的正数),再放回小根堆 // 小根堆弹出的元素x如果是是正数：此时k值如果能被2整除，那么重复取反堆顶元素x，最终x不变，直接将x加入堆中；如果k值如果不能被2整除，那么将-x加入堆中 PriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;(); for (int n : nums) queue.offer(n); while (!queue.isEmpty() &amp;&amp; k &gt; 0) &#123; int cur = queue.poll(); if (cur &lt; 0) &#123; queue.offer(-1 * cur); --k; &#125; else &#123; // cur &gt;= 0 int negPart = k % 2 == 0 ? 1 : -1; queue.offer(cur * negPart); break; &#125; &#125; int sum = 0; while (!queue.isEmpty()) &#123; sum += queue.poll(); &#125; return sum; &#125;&#125; 方法三：贪心(二刷) 首先将数组升序排序 进入for循环，注意循环的条件有两个，i &lt; nums.length || k &gt; 0 当k==0时，说明已经翻转了k次，不需要继续执行程序了，break即可 if (i == nums.length)留到最后讲解 如果，nums[i] &lt;= 0，直接翻转即可；如果nums[i] &gt; 0，那么说明此时数组里已经没有负数了，那么需要找到最小的正数，并且将剩余需要翻转的次数都对这个数使用：最小的正数只可能是当前的数或者前一个位置的数，比如数组[-5, -4, -3, 2, 3, 5]，需要翻转四次，翻转四次后数组为[5, 4, 3, 2, 3, 5]，即负数部分翻转后是降序。如果k能被2整除，那么翻转k次后这个数还是保持不变；如果不能被2整除，翻转一次即可。最后break退出for循环 如果i == nums.length，但是k的次数还没用完，这种情况只可能是数组元素全为负的情况，如果有一个正数，k都会在 if (nums[i] &gt;= 0 &amp;&amp; i &gt; 0) 语句下被消化。这种情况下，一定是最后一个数最小，如果k不能被2整除，就nums[i - 1]翻转即可。比如数组为[-4, -3, -2]，需要翻转4次，翻转3次后数组为 [4, 3, 2]，此时i == nums.length，翻转2即可 123456789101112131415161718192021class Solution &#123; public int largestSumAfterKNegations(int[] nums, int k) &#123; Arrays.sort(nums); for (int i = 0; i &lt; nums.length || k &gt; 0; ++i) &#123; if (k == 0) break; if (i == nums.length) i--; if (nums[i] &gt;= 0 &amp;&amp; i &gt; 0) &#123; i = nums[i] &gt; nums[i - 1] ? i - 1 : i; if (k % 2 == 1) &#123; nums[i] *= -1; &#125; break; &#125; nums[i] *= -1; --k; &#125; return Arrays.stream(nums).sum(); &#125;&#125; 134. 加油站⚠️ 方法一：贪心 首先如果总油量减去总消耗大于等于零那么一定可以跑完一圈 12345678910111213141516class Solution &#123; public int canCompleteCircuit(int[] gas, int[] cost) &#123; int curSum = 0; int totalSum = 0; int index = 0; for (int i = 0; i &lt; gas.length; i++) &#123; curSum += gas[i] - cost[i]; totalSum += gas[i] - cost[i]; if (curSum &lt; 0) &#123; index = (i + 1) % gas.length ; curSum = 0; &#125; &#125; return (totalSum &lt; 0) ? -1 : index; &#125;&#125; 方法二：最小累计值的下一站 123456789101112131415class Solution &#123; public int canCompleteCircuit(int[] gas, int[] cost) &#123; int rest = 0; int minDiff = Integer.MAX_VALUE; int minIndex = 0; for (int i = 0; i &lt; gas.length; ++i) &#123; rest += gas[i] - cost[i]; if (rest &lt; minDiff) &#123; minDiff = rest; minIndex = i; &#125; &#125; return rest &lt; 0 ? -1 : (minIndex + 1) % gas.length; &#125;&#125; 135. 分发糖果 先从左往右，再从右往左 12345678910111213141516class Solution &#123; public int candy(int[] ratings) &#123; int[] candy = new int[ratings.length]; Arrays.fill(candy, 1); for (int i = 1; i &lt; candy.length; ++i) &#123; if (ratings[i] &gt; ratings[i - 1]) candy[i] += candy[i - 1]; &#125; for (int i = candy.length - 1; i &gt; 0; --i) &#123; if (ratings[i - 1] &gt; ratings[i]) &#123; candy[i - 1] = Math.max(candy[i - 1], candy[i] + 1); &#125; &#125; return Arrays.stream(candy).sum(); &#125;&#125; 860. 柠檬水找零 12345678910111213141516171819202122232425262728293031323334class Solution &#123; public boolean lemonadeChange(int[] bills) &#123; if (bills[0] != 5) return false; int five = 0, ten = 0; for (int i = 0; i &lt; bills.length; ++i) &#123; if (bills[i] == 5) &#123; ++five; &#125; else if (bills[i] == 10) &#123; if (five &gt; 0) &#123; --five; ++ten; &#125; else &#123; return false; &#125; &#125; else &#123; if (five &gt; 0 &amp;&amp; ten &gt; 0) &#123; --five; --ten; &#125; else if (five &gt;= 3) &#123; five -= 3; &#125; else &#123; return false; &#125; &#125; &#125; return true; &#125;&#125; 406. 根据身高重建队列 ⚠️ 1234567891011121314151617181920class Solution &#123; public int[][] reconstructQueue(int[][] people) &#123; // 先按照身高进行降序排序，再按照k进行升序排序 Arrays.sort(people, new Comparator&lt;int[]&gt;() &#123; public int compare(int[] person1, int[] person2) &#123; if (person1[0] != person2[0]) &#123; return person2[0] - person1[0]; &#125; else &#123; return person1[1] - person2[1]; &#125; &#125; &#125;); List&lt;int[]&gt; list = new LinkedList&lt;&gt;(); for (int[] person : people) &#123; list.add(person[1], person); &#125; return list.toArray(new int[list.size()][]); &#125;&#125; 452. 用最少数量的箭引爆气球 注意事项： compare方法用return p1[0] - p2[0]会越界！ 从左往右遍历，如果左边气球的右边界大于等于右边气球的左边界，那么可以一箭双球，此时有可能有第三个气球和前面两个气球有重合，但是把第一个气球的右边界设置为重合气球右边界的最小值 1234567891011121314151617181920class Solution &#123; public int findMinArrowShots(int[][] points) &#123; Arrays.sort(points, new Comparator&lt;int[]&gt;() &#123; public int compare(int[] point1, int[] point2) &#123; return Integer.compare(point1[0], point2[0]); &#125; &#125;); int arrow = 1; for (int i = 0, j = 1; j &lt; points.length; ++j) &#123; if (points[i][1] &gt;= points[j][0]) &#123; points[i][1] = Math.min(points[i][1], points[j][1]); &#125; else &#123; ++arrow; i = j; &#125; &#125; return arrow; &#125;&#125; 435. 无重叠区间 方法一： 比较器按以下方法来，不然容易出错！！ 12345678910Arrays.sort(intervals, new Comparator&lt;int[]&gt;() &#123; public int compare(int[] p1, int[] p2) &#123; if (p1[0] == p2[0]) &#123; return Integer.compare(p1[1], p2[1]); &#125; else &#123; return Integer.compare(p1[0], p2[0]); &#125; &#125;&#125;); 先定义比较器，如果p1, p2第一个元素不相等，则按照第一个元素升序排序；如果第一个元素相等，则按照第二个元素升序排序 双指针从前往后遍历，初始i=0，j=1 当intervals[i]与intervals[j]的第一个元素相等，那么必定要移除其中一个，由于比较器的排序，intervals[j]的区间更大，那么选择移除intervals[j]，答案只需要返回最少移除了多少个数，所以将表示删除元素个数的变量erase加一，让j后移即可 当intervals[i]与intervals[j]的第一个元素不相等时候，分两种情况讨论 如果intervals[i]的第二个元素 &gt; intervals[j]的第一个元素，此时区间重合，删除第二个元素即可，将表示删除元素个数的变量erase加一；如果此时intervals[i]的第二个元素 &gt; intervals[j]的第二个元素，说明intervals[i]包含 intervals[j]，那么此时必定删除 intervals[i]，将i指向j表示删除 intervals[i]这个元素 如果intervals[i]的第二个元素 &lt;= intervals[j]的第一个元素，那么i与j之间的元素都不重复，将i移动到j的位置 1234567891011121314151617181920212223242526272829303132class Solution &#123; public int eraseOverlapIntervals(int[][] intervals) &#123; Arrays.sort(intervals, new Comparator&lt;int[]&gt;() &#123; public int compare(int[] p1, int[] p2) &#123; if (p1[0] == p2[0]) &#123; return Integer.compare(p1[1], p2[1]); &#125; else &#123; return Integer.compare(p1[0], p2[0]); &#125; &#125; &#125;); int erase = 0, n = intervals.length; for (int i = 0, j = 1; j &lt; n; ++j) &#123; if (intervals[i][0] == intervals[j][0]) &#123; ++erase; &#125; else &#123; if (intervals[i][1] &gt; intervals[j][0]) &#123; ++erase; if (intervals[i][1] &gt;= intervals[j][1]) &#123; i = j; &#125; &#125; else &#123; // intervals[i][1] &lt;= intervals[j][0] i = j; &#125; &#125; &#125; return erase; &#125;&#125; 方法二：右边界取最小的 123456789101112131415161718192021class Solution &#123; public int eraseOverlapIntervals(int[][] intervals) &#123; Arrays.sort(intervals, (a,b)-&gt; &#123; return Integer.compare(a[0],b[0]); &#125;); int count = 0; for(int i = 1;i &lt; intervals.length;i++)&#123; if(intervals[i][0] &lt; intervals[i-1][1])&#123; ++count; intervals[i][1] = Math.min(intervals[i - 1][1], intervals[i][1]); &#125; &#125; for (int[] is : intervals) &#123; for (int i : is) &#123; System.out.print(i + &quot;,&quot;); &#125; System.out.println(); &#125; return count; &#125;&#125; 二刷：左边界升序排序 1234567891011121314151617181920212223class Solution &#123; public int eraseOverlapIntervals(int[][] intervals) &#123; Arrays.sort(intervals, new Comparator&lt;int[]&gt;() &#123; public int compare(int[] a, int[] b) &#123; if (a[0] == b[0]) return Integer.compare(a[1], b[1]); else return Integer.compare(a[0], b[0]); &#125; &#125;); int res = 0; for (int i = 0, j = 1; j &lt; intervals.length; ++j) &#123; if (intervals[i][1] &gt; intervals[j][0]) &#123; intervals[i][1] = Math.min(intervals[i][1], intervals[j][1]); ++res; &#125; else &#123; i = j; &#125; &#125; return res; &#125;&#125; 763. 划分字母区间 ⚠️ 方法一：贪心 首先创建一个长度为26的整型数组，统计每次字符出现的最远位置 遍历字符串，不断更新右边界的值 当当前下标i与右边界相等时，那么就将right-i+1记录 123456789101112131415161718class Solution &#123; public List&lt;Integer&gt; partitionLabels(String s) &#123; int[] ch = new int[26]; for (int i = 0; i &lt; s.length(); ++i) &#123; ch[s.charAt(i) - &#x27;a&#x27;] = i; &#125; List&lt;Integer&gt; res = new LinkedList&lt;&gt;(); int left = 0, right = -1; for (int i = 0; i &lt; s.length(); ++i) &#123; right = Math.max(right, ch[s.charAt(i) - &#x27;a&#x27;]); if (i == right) &#123; res.add(right - left + 1); left = i + 1; &#125; &#125; return res; &#125; &#125; 56. 合并区间 方法一： 遍历数组，如果后一个元素的左边界大于等于前一个元素的右边界，那么修改后一个元素的左边界为两元素左边界最小的值，修改后一个元素的右边界为两元素右边界最大的值 如果后一个元素左边界大于前一个元素的右边界，直接把前一个元素加入结果list中 最后再把最后一个元素(修改过)加入结果list中 12345678910111213141516171819202122class Solution &#123; public int[][] merge(int[][] intervals) &#123; int n = intervals.length; Arrays.sort(intervals, new Comparator&lt;int[]&gt;() &#123; public int compare(int[] p1, int[] p2) &#123; return Integer.compare(p1[0], p2[0]); &#125; &#125;); List&lt;int[]&gt; res = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; n - 1; ++i) &#123; if (intervals[i + 1][0] &lt;= intervals[i][1]) &#123; intervals[i + 1][0] = Math.min(intervals[i + 1][0], intervals[i][0]); intervals[i + 1][1] = Math.max(intervals[i + 1][1], intervals[i][1]); &#125; else &#123; res.add(new int[]&#123;intervals[i][0], intervals[i][1]&#125;); &#125; &#125; res.add(new int[]&#123;intervals[n - 1][0], intervals[n - 1][1]&#125;); return res.toArray(new int[res.size()][]); &#125;&#125; 方法二：射气球的思路 首先将数组按照左边界升序排序 当intervals[i][1] &gt;= intervals[j][0]，那么这两个元素一定是要合并的，因为是intervals数组是按照左边界升序排序的，那么合并区间[a, b]的a一定是intervals[i][0]，将intervals[i][1]赋值为intervals[i][1]与intervals[j][1]的最大值 当intervals[i][1] &lt; intervals[j][0]，那么这个两个区间是不重合的，先把上一个重合区间加入结果集，再把j赋值给i，进行下一轮循环 当j == intervals.length - 1时候， 如果intervals[i][1] &gt;= intervals[j][0]，那么会将intervals[i][1]取intervals[i][1]与intervals[j][1]的最大值 如果intervals[i][1] &lt; intervals[j][0]，那么会将之前的重合区间存入结果集，并将j赋值给i 所以出循环，只需要把intervals[i]加入结果集就好！ 12345678910111213141516171819202122232425class Solution &#123; public int[][] merge(int[][] intervals) &#123; Arrays.sort(intervals, new Comparator&lt;int[]&gt;() &#123; public int compare(int[] a, int[] b) &#123; if (a[0] == b[0]) return Integer.compare(a[1], b[1]); else return Integer.compare(a[0], b[0]); &#125; &#125;); List&lt;int[]&gt; res = new LinkedList&lt;&gt;(); int i = 0; for (int j = 1; j &lt; intervals.length; ++j) &#123; if (intervals[i][1] &gt;= intervals[j][0]) &#123; intervals[i][1] = Math.max(intervals[i][1], intervals[j][1]); &#125; else &#123; // (intervals[i][1] &lt; intervals[j][0]) res.add(new int[]&#123;intervals[i][0], intervals[i][1]&#125;); i = j; &#125; &#125; res.add(new int[]&#123;intervals[i][0], intervals[i][1]&#125;); return res.toArray(new int[res.size()][]); &#125;&#125; 738. 单调递增的数字 从后往前遍历，如果有后一个数大于前一个数，那么就用flag记录后一个数的位置，循环结束后，从flag开始，把后面的数全部赋值‘9’ 注意边界！！！ 1234567891011121314151617class Solution &#123; public int monotoneIncreasingDigits(int n) &#123; String str = String.valueOf(n); char[] ch = str.toCharArray(); int flag = ch.length; for (int i = ch.length - 1; i &gt; 0; --i) &#123; if (ch[i - 1] &gt; ch[i]) &#123; --ch[i - 1]; flag = i; &#125; &#125; for (int i = flag; i &lt; ch.length; ++i) &#123; ch[i] = &#x27;9&#x27;; &#125; return Integer.parseInt(String.valueOf(ch)); &#125; &#125; 968. 监控二叉树⭐ 方法一：贪心 1234567891011121314151617181920212223242526272829303132class Solution &#123; int result = 0; public int minCameraCover(TreeNode root) &#123; // dfs后检查根节点是否被覆盖 if (dfs(root) == 404) ++result; return result; &#125; private int dfs(TreeNode root) &#123; // state 404:未覆盖 // state 200:覆盖 // state 201:有监控 //叶节点的左右空孩子需要返回被覆盖，这样才不会在叶子节点上装监控 if (root == null) return 200; // post traversal int leftState = dfs(root.left); int rightState = dfs(root.right); // 1.如果左右子树都被覆盖 if (leftState == 200 &amp;&amp; rightState == 200) return 404; // 2.如果左右子树至少有一个没被覆盖 if (leftState == 404 || rightState == 404) &#123; ++result; return 201; &#125; // 3.如果左右子树至少有一个监控 if (leftState == 201 || rightState == 201) return 200; return 666; &#125;&#125; BackTracing 开始回溯前要知道的 详细讲解 注意 如果递归终止条件是这个，那么结果回事全空 1234if (depth == len) &#123; res.add(path); return;&#125; 执行 main 方法以后输出如下： 1[[], [], [], [], [], []] 变量 path 所指向的列表 在深度优先遍历的过程中只有一份 ，深度优先遍历完成以后，回到了根结点，成为空列表。 在 Java 中，参数传递是 值传递，对象类型变量在传参的过程中，复制的是变量的地址。这些地址被添加到 res 变量，但实际上指向的是同一块内存地址，因此我们会看到 6 个空的列表对象。解决的方法很简单，在 res.add(path); 这里做一次拷贝即可。 修改的部分： 1234if (depth == len) &#123; res.add(new ArrayList&lt;&gt;(path)); return;&#125; 算法模板 123456789101112void backtracking(参数) &#123; if (终止条件) &#123; 存放结果; return; &#125; for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123; 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果 &#125;&#125; 77. 组合 方法一：回溯 由于已知结果要存放的数组大小为k，所以res使用ArrayList List没有removeLast方法，但是LinkedList中有！ 1234567891011121314151617181920class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; backtracing(n, k, 1); return res; &#125; private void backtracing (int n, int k, int start) &#123; if (path.size() == k) &#123; res.add(new LinkedList&lt;&gt;(path)); return; &#125; for (int i = start; i &lt;= n; ++i) &#123; path.add(i); backtracing(n, k, i + 1); // path.removeLast(); path.removeLast(); &#125; &#125;&#125; 方法二：方法一+剪枝 for循环横向遍历时候，i的执行条件为i &lt;= n - (k - path.size()) + 1 例如，当i = 2，path里已经有1，需要组合k=3个元素，n为4，那么 4 - (3 - 1) + 1 = 3，说明i最多等于3，组成path[1, 3, 4]，如果此时i = 4，那么就不能组成3个元素，只能组成[1,4] 1234567891011121314151617181920class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; backtracing(n, k, 1); return res; &#125; private void backtracing (int n, int k, int start) &#123; if (path.size() == k) &#123; res.add(new LinkedList&lt;&gt;(path)); return; &#125; for (int i = start; i &lt;= n - (k - path.size()) + 1; ++i) &#123; path.add(i); backtracing(n, k, i + 1); // path.removeLast(); path.removeLast(); &#125; &#125;&#125; 方法二：选或不选 防止底层扩容 1Deque&lt;Integer&gt; path = new ArrayDeque&lt;&gt;(k); 若n=3，k=2,即从[1,2,3]中选两个数，如果当前什么都没选(k=2)，n - k + 1= 2，说明至少要从2开始，才能满足选两个数这个要求 123int bound = n - k + 1;if (start &gt; bound) return; 代码如下 123456789101112131415161718192021222324class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; // 防止底层扩容 Deque&lt;Integer&gt; path = new ArrayDeque&lt;&gt;(k); backtracking(path, n, k, 1); return res; &#125; private void backtracking(Deque&lt;Integer&gt; path, int n, int k, int start) &#123; if (k == 0) &#123; res.add(new LinkedList&lt;&gt;(path)); return; &#125; // 若n=3，k=2,即从[1,2,3]中选两个数，如果当前什么都没选(k=2)，n - k + 1= 2， // 说明至少要从2开始，才能满足选两个数这个要求 int bound = n - k + 1; if (start &gt; bound) return; backtracking(path, n, k, start + 1); path.addLast(start); backtracking(path, n, k - 1, start + 1); path.removeLast(); &#125;&#125; 216. 组合总和 III 方法一：回溯+剪枝 i那里的剪枝可以这么理解，假设从i开始取，则从i到n一共有n-i+1个元素，而当前还需要k-path.size()个元素，所以必须满足n-i+1&gt;=k-path.size()，移项就可以得到i&lt;=n+1-(k-path.size()) 12345678910111213141516171819class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) &#123; backtracking(k, n, 1, new ArrayDeque&lt;&gt;(k)); return res; &#125; private void backtracking(int k, int n, int start, Deque&lt;Integer&gt; path) &#123; if (path.size() == k) &#123; if (n == 0) res.add(new LinkedList&lt;&gt;(path)); return; &#125; for (int i = start; i &lt;= 9 - (k - path.size()) + 1; ++i) &#123; path.add(i); backtracking(k, n - i, i + 1, path); path.removeLast(); &#125; &#125;&#125; 方法二：选或不选 注意：int bound = 9 - k + 1;而不是9 - (k - path.size()) + 1，因为这里的递归终止条件是k==0，k的语义是还剩多少元素没选！！！ 123456789101112131415161718192021class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) &#123; backtracking(k, n, 1, new ArrayDeque&lt;&gt;(k)); return res; &#125; private void backtracking(int k, int n, int start, Deque&lt;Integer&gt; path) &#123; if (k == 0) &#123; if (n == 0) res.add(new LinkedList&lt;&gt;(path)); return; &#125; int bound = 9 - k + 1; if (start &gt; bound) return; backtracking(k, n, start + 1, path); path.add(start); backtracking(k - 1, n - start, start + 1, path); path.removeLast(); &#125;&#125; 17. 电话号码的字母组合 注意边界条件！ 123456789101112131415161718192021222324class Solution &#123; List&lt;String&gt; res = new LinkedList&lt;&gt;(); StringBuilder path = new StringBuilder(); String[] alphabet = &#123;&quot;&quot;, &quot;&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;&#125;; public List&lt;String&gt; letterCombinations(String digits) &#123; if (digits == null || digits.length() == 0) return res; backtracing(digits, 0); return res; &#125; private void backtracing(String digits, int start) &#123; if (path.length() == digits.length()) &#123; res.add(new String(path)); return; &#125; char num = digits.charAt(start); String str = alphabet[num - &#x27;0&#x27;]; for (int i = 0; i &lt; str.length(); ++i) &#123; path.append(str.charAt(i)); backtracing(digits, start + 1); path.deleteCharAt(path.length() - 1); &#125; &#125;&#125; 39. 组合总和 与前面两题不同的是，可以选取相同元素；以及组合不能重复，如[3，5]与[5，3]是同一个组合 同一个 数字可以 无限制重复被选取 解析 方法一：回溯 去重：遇到这一类相同元素不计算顺序的问题，我们在搜索的时候就需要 按某种顺序搜索。具体的做法是：每一次搜索的时候设置 下一轮搜索的起点 begin，请看下图。 123456789101112131415161718192021class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; backtracing(candidates, target, 0); return res; &#125; private void backtracing(int[] candidates, int target, int start) &#123; if (target &lt; 0) return; if (target == 0) &#123; res.add(new LinkedList&lt;&gt;(path)); return; &#125; for (int i = start; i &lt; candidates.length; ++i) &#123; path.add(candidates[i]); backtracing(candidates, target - candidates[i], i); path.removeLast(); &#125; &#125;&#125; 方法二：回溯+剪枝 注意： 是i不是start！！！ 回溯前要排序！！！ 123456789101112131415161718192021222324class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; // 排序是剪枝的前提 Arrays.sort(candidates); backtracing(candidates, target, 0); return res; &#125; private void backtracing(int[] candidates, int target, int start) &#123; if (target == 0) &#123; res.add(new LinkedList&lt;&gt;(path)); return; &#125; for (int i = start; i &lt; candidates.length; ++i) &#123; // 由于进入更深层的时候，小于 0 的部分被剪枝，因此递归终止条件值只判断等于 0 的情况 if (target - candidates[i] &lt; 0) break; path.add(candidates[i]); backtracing(candidates, target - candidates[i], i); path.removeLast(); &#125; &#125;&#125; 40. 组合总和 II 树层去重，树枝不需要去重 去重和39题(上一题)以及三数之和差不多 方法一： 注意：if判断条件是i &gt; start， 不是i &gt; 0 12345678910111213141516171819202122232425这个避免重复当思想是在是太重要了。这个方法最重要的作用是，可以让同一层级，不出现相同的元素。即 1 / \\ 2 2 这种情况不会发生 但是却允许了不同层级之间的重复即： / \\ 5 5 例2 1 / 2 这种情况确是允许的 / 2 为何会有这种神奇的效果呢？首先 cur-1 == cur 是用于判定当前元素是否和之前元素相同的语句。这个语句就能砍掉例1。可是问题来了，如果把所有当前与之前一个元素相同的都砍掉，那么例二的情况也会消失。 因为当第二个2出现的时候，他就和前一个2相同了。 那么如何保留例2呢？那么就用cur &gt; begin 来避免这种情况，你发现例1中的两个2是处在同一个层级上的，例2的两个2是处在不同层级上的。在一个for循环中，所有被遍历到的数都是属于一个层级的。我们要让一个层级中，必须出现且只出现一个2，那么就放过第一个出现重复的2，但不放过后面出现的2。第一个出现的2的特点就是 cur == begin. 第二个出现的2 特点是cur &gt; begin. 1234567891011121314151617181920212223242526class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; Arrays.sort(candidates); backtracing(candidates, target, 0); return res; &#125; private void backtracing(int[] candidates, int target, int start) &#123; if (target == 0) &#123; res.add(new LinkedList&lt;&gt;(path)); return; &#125; for (int i = start; i &lt; candidates.length; ++i) &#123; // 剪枝 if (candidates[i] &gt; target) break; // 去重 if (i &gt; start &amp;&amp; candidates[i] == candidates[i - 1]) continue; path.add(candidates[i]); backtracing(candidates, target - candidates[i], i + 1); path.removeLast(); &#125; &#125;&#125; 方法二：used数组 多debug 123456789101112131415161718192021222324252627class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; Arrays.sort(candidates); boolean[] used = new boolean[candidates.length]; backtracking(candidates, used, target, 0); return res; &#125; public void backtracking(int[] candidates, boolean[] used, int target, int start) &#123; if (target == 0) &#123; res.add(new LinkedList(path)); return; &#125; for (int i = start; i &lt; candidates.length; ++i) &#123; if (target &lt; candidates[i]) break; if (i &gt; 0 &amp;&amp; candidates[i] == candidates[i - 1] &amp;&amp; !used[i - 1]) continue; path.add(candidates[i]); used[i] = true; backtracking(candidates, used, target - candidates[i], i + 1); used[i] = false; path.removeLast(); &#125; &#125;&#125; 方法三：选或不选 1234567891011121314151617181920212223class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; Arrays.sort(candidates); backtracking(candidates, false, target, 0); return res; &#125; public void backtracking(int[] candidates, boolean choosePre, int target, int start) &#123; if (target == 0) &#123; res.add(new LinkedList(path)); return; &#125; if (target &lt; 0 || start == candidates.length) return; backtracking(candidates, false, target, start + 1); if (start &gt; 0 &amp;&amp; !choosePre &amp;&amp; candidates[start] == candidates[start - 1]) return; path.add(candidates[start]); backtracking(candidates, true, target - candidates[start], start + 1); path.removeLast(); &#125;&#125; 131. 分割回文串⚠️ 12345678910111213141516171819202122232425262728class Solution &#123; List&lt;List&lt;String&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;String&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;String&gt;&gt; partition(String s) &#123; backtracking(s.toCharArray(), 0); return res; &#125; public void backtracking(char[] ch, int start) &#123; if (start == ch.length) &#123; res.add(new LinkedList(path)); return; &#125; for (int i = start; i &lt; ch.length; ++i) &#123; if (isPalindrome(ch, start, i)) &#123; path.add(new String(ch, start, i - start + 1)); backtracking(ch, i + 1); path.removeLast(); &#125; &#125; &#125; public boolean isPalindrome(char[] ch, int start, int end) &#123; while (start &lt; end) &#123; if (ch[start++] != ch[end--]) return false; &#125; return true; &#125;&#125; ⭐93. 复原 IP 地址 重做 方法一：回溯 1 78. 子集 以下两种方法的区别： 方法二有横向for循环，使用i进入递归方法 方法一有两个递归方法，分别表示选与不选，用start进入递归犯法 方法一：选或不选 123456789101112131415161718class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; backtracking(nums, 0); return res; &#125; private void backtracking(int[] nums, int start) &#123; if (start == nums.length) &#123; res.add(new LinkedList(path)); return; &#125; backtracking(nums, start + 1); path.add(nums[start]); backtracking(nums, start + 1); path.removeLast(); &#125;&#125; 方法二：for循环横向顺序遍历 12345678910111213141516class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; backtracking(nums, 0); return res; &#125; private void backtracking(int[] nums, int start) &#123; res.add(new LinkedList(path)); for (int i = start; i &lt; nums.length; i++) &#123; path.add(nums[i]); backtracking(nums, i + 1); path.removeLast(); &#125; &#125;&#125; 90. 子集 II 方法一：选或不选 如果前后两个数相等，如[1,2,2]，那么只有在第一个2被选择了，才能选择第二个2，不然会重复 123456789101112131415161718192021class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; Arrays.sort(nums); backtracking(nums, false, 0); return res; &#125; public void backtracking(int[] nums, boolean choosePre, int start) &#123; if (start == nums.length) &#123; res.add(new LinkedList(path)); return; &#125; backtracking(nums, false, start + 1); if (start &gt; 0 &amp;&amp; !choosePre &amp;&amp; nums[start - 1] == nums[start]) return; path.add(nums[start]); backtracking(nums, true, start + 1); path.removeLast(); &#125;&#125; 方法二：顺序递归 注意：if判断条件是i &gt; start， 不是i &gt; 0 12345678910111213141516171819class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; Arrays.sort(nums); backtracking(nums, 0); return res; &#125; public void backtracking(int[] nums, int start) &#123; res.add(new LinkedList(path)); for (int i = start; i &lt; nums.length; ++i) &#123; if (i &gt; start &amp;&amp; nums[i - 1] == nums[i]) continue; path.add(nums[i]); backtracking(nums, i + 1); path.removeLast(); &#125; &#125;&#125; 491. 递增子序列⚠️ 方法一：顺序DFS 注意：HashSet的位置！！！每进入一层递归，就会在for循环前创建一个HashSet，这样可以保证树层去重，并且树枝不会qu’chong 1234567891011121314151617181920212223class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; findSubsequences(int[] nums) &#123; backtracking(nums, 0); return res; &#125; public void backtracking(int[] nums, int start) &#123; if (path.size() &gt;= 2) res.add(new LinkedList(path)); Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int i = start; i &lt; nums.length; ++i) &#123; if ((!path.isEmpty() &amp;&amp; nums[i] &lt; path.peekLast())) continue; if (set.contains(nums[i])) continue; set.add(nums[i]); path.add(nums[i]); backtracking(nums, i + 1); path.pollLast(); &#125; &#125;&#125; 46. 全排列 12345678910111213141516171819202122232425class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); boolean[] used; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; used = new boolean[nums.length]; backtracking(nums); return res; &#125; private void backtracking(int[] nums) &#123; if (path.size() == nums.length) &#123; res.add(new LinkedList&lt;&gt;(path)); return; &#125; for (int i = 0; i &lt; nums.length; ++i) &#123; if (!used[i]) &#123; path.add(nums[i]); used[i] = true; backtracking(nums); used[i] = false; path.pollLast(); &#125; &#125; &#125;&#125; 47. 全排列 II 12345678910111213141516171819202122232425262728class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); boolean[] used; public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; Arrays.sort(nums); used = new boolean[nums.length]; backtracking(nums); return res; &#125; public void backtracking(int[] nums) &#123; if (path.size() == nums.length) &#123; res.add(new LinkedList(path)); return; &#125; for (int i = 0; i &lt; nums.length; ++i) &#123; if (i &gt; 0 &amp;&amp; !used[i - 1] &amp;&amp; nums[i - 1] == nums[i]) continue; if (!used[i]) &#123; path.add(nums[i]); used[i] = true; backtracking(nums); used[i] = false; path.pollLast(); &#125; &#125; &#125;&#125; 51. N 皇后 方法一：二维数组存表盘 时间复杂度$O(n^n)$ 空间复杂度$O(n^2)$ 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123; List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; char[][] chessboard = new char[n][n]; for (char[] row : chessboard) Arrays.fill(row, &#x27;.&#x27;); backtracking(0, chessboard, n); return res; &#125; private void backtracking(int row, char[][] chessboard, int n) &#123; if (row == n) &#123; res.add(toList(chessboard)); return; &#125; for (int col = 0; col &lt; n; ++col) &#123; if (isValid(row, col, chessboard, n)) &#123; chessboard[row][col] = &#x27;Q&#x27;; backtracking(row + 1, chessboard, n); chessboard[row][col] = &#x27;.&#x27;; &#125; &#125; &#125; private boolean isValid(int row, int col, char[][] chessboard, int n) &#123; for (int i = 0; i &lt; row; ++i) if (chessboard[i][col] == &#x27;Q&#x27;) return false; for (int i = row - 1, j = col - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; --i, --j) &#123; if (chessboard[i][j] == &#x27;Q&#x27;) return false; &#125; for (int i = row - 1, j = col + 1; i &gt;= 0 &amp;&amp; j &lt; n; --i, ++j) if (chessboard[i][j] == &#x27;Q&#x27;) return false; return true; &#125; private List&lt;String&gt; toList(char[][] chessboard) &#123; List&lt;String&gt; path = new ArrayList&lt;&gt;(); for (char[] ch : chessboard) &#123; path.add(String.copyValueOf(ch)); &#125; return path; &#125;&#125; 方法二：一维数组存储每行皇后的列信息 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123; List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); int[] chessboard; public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; chessboard = new int[n]; backtracking(0, n); return res; &#125; private void backtracking(int row, int n) &#123; if (row == n) &#123; res.add(generatePath(n)); return; &#125; for (int col = 0; col &lt; n; ++col) &#123; if (isValid(row, col, n)) &#123; chessboard[row] = col; backtracking(row + 1, n); chessboard[row] = 0; &#125; &#125; &#125; private boolean isValid(int row, int col, int n) &#123; for (int i = 0; i &lt; row; ++i) &#123; if (chessboard[i] == col || Math.abs(col - chessboard[i]) == Math.abs(row - i)) return false; &#125; return true; &#125; private List&lt;String&gt; generatePath(int n) &#123; List&lt;String&gt; path = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n; ++i) &#123; StringBuilder sb = new StringBuilder(); for (int j = 0; j &lt; n; ++j) &#123; if (j == chessboard[i]) sb.append(&#x27;Q&#x27;); else sb.append(&#x27;.&#x27;); &#125; path.add(sb.toString()); &#125; return path; &#125;&#125; 方法三：位运算加速 113. 路径总和 II Graph 797. 所有可能的路径 优质题解 1234567891011121314151617181920class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; allPathsSourceTarget(int[][] graph) &#123; path.offerLast(0); backtracking(0, graph); return res; &#125; private void backtracking(int start, int[][] graph) &#123; if (start == graph.length - 1) &#123; res.add(new LinkedList(path)); return; &#125; for (int x : graph[start]) &#123; path.offerLast(x); backtracking(x, graph); path.removeLast(); &#125; &#125;&#125; 200. 岛屿数量 方法一：DFS 1234567891011121314151617181920212223class Solution &#123; public int numIslands(char[][] grid) &#123; int res = 0; for (int row = 0; row &lt; grid.length; ++row) &#123; for (int col = 0; col &lt; grid[0].length; ++col) &#123; if (grid[row][col] == &#x27;1&#x27;) &#123; ++res; dfs(row, col, grid); &#125; &#125; &#125; return res; &#125; private void dfs(int row, int col, char[][] grid) &#123; if (row &lt; 0 || row &gt; grid.length - 1 || col &lt; 0 || col &gt; grid[0].length - 1 || grid[row][col] != &#x27;1&#x27;) return; grid[row][col] = &#x27;2&#x27;; dfs(row - 1, col, grid); dfs(row + 1, col, grid); dfs(row, col - 1, grid); dfs(row, col + 1, grid); &#125;&#125; 方法二：BFS 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public int numIslands(char[][] grid) &#123; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); int m = grid.length; int n = grid[0].length; int res = 0; for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (grid[i][j] == &#x27;1&#x27;) &#123; ++res; grid[i][j] = &#x27;2&#x27;; queue.offer(new int[]&#123;i, j&#125;); while (!queue.isEmpty()) &#123; int[] coor = queue.poll(); int row = coor[0], col = coor[1]; if (row - 1 &gt;= 0 &amp;&amp; grid[row - 1][col] == &#x27;1&#x27;) &#123; queue.offer(new int[]&#123;row -1, col&#125;); grid[row - 1][col] = &#x27;2&#x27;; &#125; if (row + 1 &lt; m &amp;&amp; grid[row + 1][col] == &#x27;1&#x27;) &#123; queue.offer(new int[]&#123;row + 1, col&#125;); grid[row + 1][col] = &#x27;2&#x27;; &#125; if (col - 1 &gt;= 0 &amp;&amp; grid[row][col - 1] == &#x27;1&#x27;) &#123; queue.offer(new int[]&#123;row, col - 1&#125;); grid[row][col - 1] = &#x27;2&#x27;; &#125; if (col + 1 &lt; n &amp;&amp; grid[row][col + 1] == &#x27;1&#x27;) &#123; queue.offer(new int[]&#123;row, col + 1&#125;); grid[row][col + 1] = &#x27;2&#x27;; &#125; &#125; &#125; &#125; &#125; return res; &#125;&#125; 方法三：不修改输入数据的DFSF 123456789101112131415161718192021222324class Solution &#123; public int numIslands(char[][] grid) &#123; int res = 0; boolean[][] visited = new boolean[grid.length][grid[0].length]; for (int row = 0; row &lt; grid.length; ++row) &#123; for (int col = 0; col &lt; grid[0].length; ++col) &#123; if (!visited[row][col] &amp;&amp; grid[row][col] == &#x27;1&#x27;) &#123; ++res; dfs(row, col, grid, visited); &#125; &#125; &#125; return res; &#125; private void dfs(int row, int col, char[][] grid, boolean[][] visited) &#123; if (row &gt;= 0 &amp;&amp; col &gt;= 0 &amp;&amp; row &lt; grid.length &amp;&amp; col &lt; grid[0].length &amp;&amp; !visited[row][col] &amp;&amp; grid[row][col] == &#x27;1&#x27;) &#123; visited[row][col] = true; int[][] dirs = new int[][]&#123;&#123;0, -1&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;, &#123;1, 0&#125;&#125;; for (int[] dir : dirs) &#123; dfs(row + dir[0], col + dir[1], grid, visited); &#125; &#125; &#125;&#125; 695. 岛屿的最大面积 方法一：DFS 1234567891011121314151617181920212223242526class Solution &#123; int res = 0; int size = 0; public int maxAreaOfIsland(int[][] grid) &#123; for (int i = 0; i &lt; grid.length; ++i) &#123; for (int j = 0; j &lt; grid[0].length; ++j) &#123; if (grid[i][j] == 1) &#123; size = 0; dfs(i, j, grid); System.out.println(res); &#125; &#125; &#125; return res; &#125; private void dfs(int i, int j, int[][] grid) &#123; if (i &lt; 0 || j &lt; 0 || i == grid.length || j == grid[0].length || grid[i][j] != 1) return; grid[i][j] = 2; res = Math.max(res, ++size); dfs(i - 1, j, grid); dfs(i + 1, j, grid); dfs(i, j - 1, grid); dfs(i, j + 1, grid); &#125;&#125; 不修改输入的DFS 12345678910111213141516171819202122232425class Solution &#123; public int maxAreaOfIsland(int[][] grid) &#123; int res = 0; boolean[][] visited = new boolean[grid.length][grid[0].length]; for (int i = 0; i &lt; grid.length; ++i) &#123; for (int j = 0; j &lt; grid[0].length; ++j) &#123; if (!visited[i][j] &amp;&amp; grid[i][j] == 1) &#123; res = Math.max(res, dfs(i, j, grid, visited)); &#125; &#125; &#125; return res; &#125; private int dfs(int i, int j, int[][] grid, boolean[][] visited) &#123; if (i &lt; 0 || j &lt; 0 || i == grid.length || j == grid[0].length || grid[i][j] != 1 || visited[i][j]) return 0; int res = 1; visited[i][j] = true; int[][] dirs = new int[][]&#123;&#123;0, -1&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;, &#123;1, 0&#125;&#125;; for (int[] dir : dirs) &#123; res += dfs(i + dir[0], j + dir[1], grid, visited); &#125; return res; &#125;&#125; 方法三：DFS标准写法 123456789101112131415161718192021222324252627282930class Solution &#123; public int maxAreaOfIsland(int[][] grid) &#123; int res = 0; int m = grid.length, n = grid[0].length; for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (grid[i][j] == 1) &#123; res = Math.max(res, dfs(i, j, grid)); &#125; &#125; &#125; return res; &#125; public int dfs(int i, int j, int[][] grid) &#123; int res = 1; grid[i][j] = 2; int[][] dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col, grid.length, grid[0].length) &amp;&amp; grid[row][col] == 1) &#123; grid[row][col] = 2; res += dfs(row, col, grid); &#125; &#125; return res; &#125; public boolean isValid(int i, int j, int m, int n) &#123; return (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n); &#125;&#125; 827. 最大人工岛⚠️⭐ 优质题解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution &#123; public int largestIsland(int[][] grid) &#123; Map&lt;Integer, Integer&gt; idToArea = new HashMap&lt;&gt;(); int id = 2; int m = grid.length, n = grid[0].length; int res = 0; for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (grid[i][j] == 1) &#123; idToArea.put(id, getSingleArea(i, j, grid, id)); ++id; &#125; &#125; &#125; for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; res = Math.max(res, dfs(i, j, grid, idToArea)); &#125; &#125; return res; &#125; private int dfs(int i, int j, int[][] grid, Map&lt;Integer,Integer&gt; idToArea) &#123; // if (i &lt; 0 || j &lt; 0 || i == grid.length || j == grid[0].length) // return 0; if (grid[i][j] &gt; 0) &#123; return idToArea.get(grid[i][j]); &#125; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); int res = 1; int[][] dirs = new int[][]&#123;&#123;0, -1&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;, &#123;1, 0&#125;&#125;; for (int[] dir : dirs) &#123; if (i + dir[0] &lt; 0 || j + dir[1] &lt; 0 || i + dir[0] == grid.length || j + dir[1] == grid[0].length) continue; set.add(grid[i + dir[0]][j + dir[1]]); &#125; for (int element : set) &#123; res += idToArea.getOrDefault(element, 0); &#125; return res; &#125; private int getSingleArea(int i, int j, int[][] grid, int id) &#123; if (i &lt; 0 || j &lt; 0 || i == grid.length || j == grid.length || grid[i][j] != 1) return 0; int res = 1; grid[i][j] = id; int[][] dirs = new int[][]&#123;&#123;0, -1&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;, &#123;1, 0&#125;&#125;; for (int[] dir : dirs) &#123; res += getSingleArea(i + dir[0], j + dir[1], grid, id); &#125; return res; &#125;&#125; 二刷 注意hashmap与hashset的使用细节 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution &#123; public int largestIsland(int[][] grid) &#123; int res = 0; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); int id = 2; for (int i = 0; i &lt; grid.length; ++i) &#123; for (int j = 0; j &lt; grid[0].length; ++j) &#123; if (grid[i][j] == 1) &#123; map.put(id, getArea(i, j, grid, id)); ++id; &#125; &#125; &#125; for (int i = 0; i &lt; grid.length; ++i) &#123; for (int j = 0; j &lt; grid[0].length; ++j) &#123; res = Math.max(res, dfs(i, j, grid, map)); &#125; &#125; return res; &#125; public int dfs(int i, int j, int[][] grid, Map&lt;Integer, Integer&gt; map) &#123; if (grid[i][j] &gt; 0) return map.get(grid[i][j]); Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); int res = 1; int[][] dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col, grid)) &#123; int id = grid[row][col]; set.add(id); &#125; &#125; for (int id : set) &#123; res += map.getOrDefault(id, 0); &#125; return res; &#125; public int getArea(int i, int j, int[][] grid, int id) &#123; grid[i][j] = id; int res = 1; int[][] dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col, grid) &amp;&amp; grid[row][col] == 1) &#123; grid[row][col] = id; res += getArea(row, col, grid, id); &#125; &#125; return res; &#125; public boolean isValid(int i, int j, int[][] grid) &#123; return (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; grid.length &amp;&amp; j &lt; grid[0].length); &#125;&#125; 463. 岛屿的周长 方法一：DFS 岛屿的上下左右如果是水域或者超出边界，那么周长加一 1234567891011121314151617181920212223242526272829303132class Solution &#123; public int islandPerimeter(int[][] grid) &#123; for (int i = 0; i &lt; grid.length; ++i) &#123; for (int j = 0; j &lt; grid[0].length; ++j) &#123; if (grid[i][j] == 1) &#123; grid[i][j] = 2; return dfs(i, j, grid); &#125; &#125; &#125; return -1; &#125; private int dfs(int i, int j, int[][] grid) &#123; int res = 0; int[][] dirs = new int[][]&#123;&#123;0, -1&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;, &#123;1, 0&#125;&#125;; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col, grid) &amp;&amp; grid[row][col] == 1) &#123; grid[row][col] = 2; res += dfs(row, col, grid); &#125; else &#123; if (!isValid(row, col, grid) || grid[row][col] == 0) ++res; &#125; &#125; return res; &#125; private boolean isValid(int i, int j, int[][] grid) &#123; return !(i &lt; 0 || j &lt; 0 || i == grid.length || j == grid[0].length); &#125;&#125; 1020. 飞地的数量⚠️ 遇到一个陆地，只会返回numEnclaves进入dfs返回的值，因为相连的陆地在grid中会被修改，numEnclaves循环中不会再次fang’wen 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public int numEnclaves(int[][] grid) &#123; int res = 0; for (int i = 0; i &lt; grid.length; ++i) &#123; for (int j = 0; j &lt; grid[0].length; ++j) &#123; if (grid[i][j] == 1) &#123; grid[i][j] = 2; res += dfs(i, j, grid); &#125; &#125; &#125; return res; &#125; private int dfs(int i, int j, int[][] grid) &#123; int res = 1; int[][] dirs = new int[][]&#123;&#123;0, -1&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;, &#123;1, 0&#125;&#125;; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (!isValid(row, col, grid)) &#123; grid[i][j] = 3; &#125; else if (grid[row][col] == 1) &#123; grid[row][col] = 2; int ans = dfs(row, col, grid); if (ans == 0) &#123; grid[i][j] = 3; &#125; else res += ans; &#125; &#125; return grid[i][j] == 3 ? 0 : res; &#125; private boolean isValid(int i, int j, int[][] grid) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; grid.length &amp;&amp; j &lt; grid[0].length; &#125;&#125; 130. 被围绕的区域 从边界(第一行，最后一行以及第一列和最后一列)找到O，这些O肯定不会被围绕，把这些O都标记为# 把其他位置的O全部赋值为X，将#还原为O 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; public void solve(char[][] board) &#123; int m = board.length, n = board[0].length; if (m &lt;= 2 || n &lt;= 2) return; for (int i = 0; i &lt; m; i += m - 1) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (board[i][j] == &#x27;O&#x27;) &#123; board[i][j] = &#x27;#&#x27;; dfs(i, j, board); &#125; &#125; &#125; for (int j = 0; j &lt; n; j += n - 1) &#123; for (int i = 0; i &lt; m; ++i) &#123; if (board[i][j] == &#x27;O&#x27;) &#123; board[i][j] = &#x27;#&#x27;; dfs(i, j, board); &#125; &#125; &#125; for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (board[i][j] == &#x27;O&#x27;) board[i][j] = &#x27;X&#x27;; else if (board[i][j] == &#x27;#&#x27;) board[i][j] = &#x27;O&#x27;; &#125; &#125; &#125; private void dfs(int i, int j, char[][] board) &#123; int[][] dirs = new int[][] &#123;&#123;0, -1&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;, &#123;1, 0&#125;&#125;; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col, board) &amp;&amp; board[row][col] == &#x27;O&#x27;) &#123; board[row][col] = &#x27;#&#x27;; dfs(row, col, board); &#125; &#125; &#125; private boolean isValid(int i, int j, char[][] board) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; board[0].length &amp;&amp; i &lt; board.length; &#125;&#125; 417. 太平洋大西洋水流问题⭐ 方法一：DFS 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; pacificAtlantic(int[][] heights) &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); int m = heights.length, n = heights[0].length; boolean[][] pacific = new boolean[m][n], atlantic = new boolean[m][n]; for (int j = 0; j &lt; n; ++j) dfs(0, j, heights, pacific); for (int i = 1; i &lt; m; ++i) dfs(i, 0, heights, pacific); for (int j = 0; j &lt; n; ++j) dfs(m - 1, j, heights, atlantic); for (int i = 0; i &lt; m - 1; ++i) dfs(i, n - 1, heights, atlantic); for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (pacific[i][j] &amp;&amp; atlantic[i][j]) &#123; List&lt;Integer&gt; temp = new ArrayList&lt;&gt;(2); temp.add(i); temp.add(j); res.add(temp); &#125; &#125; &#125; return res; &#125; public void dfs(int i, int j, int[][] heights, boolean[][] ocean) &#123; if (ocean[i][j]) return; ocean[i][j] = true; int[][] dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col, heights) &amp;&amp; heights[row][col] &gt;= heights[i][j]) dfs(row, col, heights, ocean); &#125; &#125; public boolean isValid(int i, int j, int[][] heights) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; heights.length &amp;&amp; j &lt; heights[0].length; &#125;&#125; 127. 单词接龙 方法一：单向广度优先搜索 需要两个队列存储邻居，第一个队列存储的邻居neighbor1距离beginWord的距离是d，将neighbor1的邻居neighbor2存储在queue2中，neighbor2距离beginWord的距离是d + 1 每当把访问完所有queue1中的neighbor1，并且将neighbor2加入到queue2中，那么需要访问新一轮邻居，于是把queue1指向queue2(queue2赋值给queue1)，queue2再新开辟一段空间，此时length(距离)需要加一 开始时需要使用一个HashSet，并将单词表直接放进去，Set&lt;String&gt; set = new HashSet&lt;&gt;(wordList)。函数getNeibours用于找到当前单词所有可能的邻居单词(只有一个字母不同)，对比set中的单词表，如果set中有对应的邻居单词x，则把x加入queue1，并且从set中移除x(如果不移除x，则会重复计算，比如hot的邻居有lot,如果不移除lot，那么下次，如下图 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123; public int ladderLength(String beginWord, String endWord, List&lt;String&gt; wordList) &#123; Queue&lt;String&gt; queue1 = new LinkedList&lt;&gt;(); Queue&lt;String&gt; queue2 = new LinkedList&lt;&gt;(); Set&lt;String&gt; set = new HashSet&lt;&gt;(wordList); int length = 1; queue1.offer(beginWord); while (!queue1.isEmpty()) &#123; String word = queue1.poll(); if (word.equals(endWord)) return length; List&lt;String&gt; neibours = getNeibours(word); for (String str : neibours) &#123; if (set.contains(str)) &#123; queue2.offer(str); set.remove(str); &#125; &#125; if (queue1.isEmpty()) &#123; ++length; queue1 = queue2; queue2 = new LinkedList&lt;&gt;(); &#125; &#125; return 0; &#125; public List&lt;String&gt; getNeibours(String word) &#123; List&lt;String&gt; neibours = new ArrayList&lt;&gt;(); char[] ch = word.toCharArray(); for (int i = 0; i &lt; ch.length; ++i) &#123; char original = ch[i]; for (char j = &#x27;a&#x27;; j &lt;= &#x27;z&#x27;; ++j) &#123; if (j != original) &#123; ch[i] = j; neibours.add(new String(ch)); &#125; &#125; // backtracking ch[i] = original; &#125; return neibours; &#125;&#125; 剑指 Offer II 109. 开密码锁 注意visited的位置！！！同上一题，在入队时就在visited加入该邻居，避免之后的重复访问 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123; public int openLock(String[] deadends, String target) &#123; Set&lt;String&gt; deadSet = new HashSet&lt;&gt;(Arrays.asList(deadends)), visited = new HashSet&lt;&gt;(); String init = &quot;0000&quot;; if (deadSet.contains(init) || deadSet.contains(target)) return -1; visited.add(init); Queue&lt;String&gt; queue1 = new LinkedList&lt;&gt;(), queue2 = new LinkedList&lt;&gt;(); queue1.offer(init); int res = 0; while (!queue1.isEmpty()) &#123; String code = queue1.poll(); if (code.equals(target)) return res; List&lt;String&gt; neibors = getNeibors(code); for (String neibor : neibors) &#123; if (!deadSet.contains(neibor) &amp;&amp; !visited.contains(neibor)) &#123; queue2.offer(neibor); visited.add(neibor); &#125; &#125; if (queue1.isEmpty()) &#123; ++res; queue1 = queue2; queue2 = new LinkedList&lt;&gt;(); &#125; &#125; return -1; &#125; public List&lt;String&gt; getNeibors(String code) &#123; List&lt;String&gt; neibors = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; code.length(); ++i) &#123; char cur = code.charAt(i); StringBuilder sb = new StringBuilder(code); // down char changed = cur == &#x27;0&#x27; ? &#x27;9&#x27; : (char) (cur - 1); sb.setCharAt(i, changed); neibors.add(sb.toString()); // up changed = cur == &#x27;9&#x27; ? &#x27;0&#x27; : (char) (cur + 1); sb.setCharAt(i, changed); neibors.add(sb.toString()); &#125; return neibors; &#125;&#125; 剑指 Offer II 106. 二分图⚠️ 方法一：DFS 染色法需要二刷 12345678910111213141516171819202122232425262728293031323334class Solution &#123; private static final int UNCOLORED = 0; private static final int RED = 1; private static final int BLUE = 2; private int[] colorArray; private boolean res = true; public boolean isBipartite(int[][] graph) &#123; colorArray = new int[graph.length]; for (int i = 0; i &lt; graph.length &amp;&amp; res; ++i) &#123; if (colorArray[i] == UNCOLORED) &#123; dfs(i, graph, RED); &#125; &#125; return res; &#125; private void dfs(int i, int[][] graph, int color) &#123; colorArray[i] = color; int neighborColor = color == RED ? BLUE : RED; for (int neibor : graph[i]) &#123; if (colorArray[neibor] == UNCOLORED) &#123; dfs(neibor, graph, neighborColor); if (!res) return; &#125; else if (colorArray[neibor] == neighborColor) &#123; continue; &#125; else &#123; res = false; return; &#125; &#125; &#125;&#125; 方法二：BFS 123456789101112131415161718192021222324252627282930class Solution &#123; private static final int UNCOLORED = 0; private static final int RED = 1; private static final int BLUE = 2; private int[] colorArray; public boolean isBipartite(int[][] graph) &#123; int n = graph.length; colorArray = new int[graph.length]; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; n; ++i) &#123; if (colorArray[i] == UNCOLORED) &#123; queue.offer(i); colorArray[i] = RED; while (!queue.isEmpty()) &#123; int cur = queue.poll(); int neiborColor = colorArray[cur] == RED ? BLUE : RED; for (int neibor : graph[cur]) &#123; if (colorArray[neibor] == UNCOLORED) &#123; queue.offer(neibor); colorArray[neibor] = neiborColor; &#125; else if (colorArray[neibor] != neiborColor) return false; &#125; &#125; &#125; &#125; return true; &#125;&#125; 剑指 Offer II 107. 矩阵中的距离 方法一：BFS 12345678910111213141516171819202122232425262728293031323334class Solution &#123; public int[][] updateMatrix(int[][] mat) &#123; int m = mat.length, n = mat[0].length; int[][] dist = new int[m][n]; boolean[][] visited = new boolean[m][n]; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; mat.length; ++i) &#123; for (int j = 0; j &lt; mat[i].length; ++j) &#123; if (mat[i][j] == 0) &#123; visited[i][j] = true; // dist[i][j] = 0; queue.offer(new int[]&#123;i, j&#125;); &#125; &#125; &#125; int[][] dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; while (!queue.isEmpty()) &#123; int[] pos = queue.poll(); int distance = dist[pos[0]][pos[1]]; for (int[] dir : dirs) &#123; int row = pos[0] + dir[0], col = pos[1] + dir[1]; if (isValid(row, col, m, n) &amp;&amp; !visited[row][col]) &#123; visited[row][col] = true; queue.offer(new int[]&#123;row, col&#125;); dist[row][col] = distance + 1; &#125; &#125; &#125; return dist; &#125; private boolean isValid(int i, int j, int m, int n) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125;&#125; 剑指 Offer II 111. 计算除法⚠️ 方法一：BFS 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123; public double[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, double[] values, List&lt;List&lt;String&gt;&gt; queries) &#123; double[] res = new double[queries.size()]; Map&lt;String, Map&lt;String, Double&gt;&gt; graph = buildGraph(equations, values); for (int i = 0; i &lt; queries.size(); ++i) &#123; String from = queries.get(i).get(0); String to = queries.get(i).get(1); if (!graph.containsKey(from) || !graph.containsKey(to)) res[i] = -1; else &#123; Set&lt;String&gt; visited = new HashSet&lt;&gt;(); res[i] = dfs(graph, visited, from, to); &#125; &#125; return res; &#125; private double dfs(Map&lt;String, Map&lt;String, Double&gt;&gt; graph, Set&lt;String&gt; visited, String from, String to) &#123; if (from.equals(to)) return 1.0; visited.add(from); for (Map.Entry&lt;String, Double&gt; entry: graph.get(from).entrySet()) &#123; String key = entry.getKey(); double val = entry.getValue(); if (!visited.contains(key)) &#123; double res = dfs(graph, visited, key, to); if (res != -1) &#123; return res * val; &#125; &#125; &#125; visited.remove(from); return -1.0; &#125; private Map&lt;String, Map&lt;String, Double&gt;&gt; buildGraph(List&lt;List&lt;String&gt;&gt; equations, double[] values) &#123; Map&lt;String, Map&lt;String, Double&gt;&gt; graph = new HashMap&lt;&gt;(); for (int i = 0; i &lt; equations.size(); ++i) &#123; String var1 = equations.get(i).get(0); String var2 = equations.get(i).get(1); graph.putIfAbsent(var1, new HashMap&lt;&gt;()); graph.get(var1).put(var2, values[i]); graph.putIfAbsent(var2, new HashMap&lt;&gt;()); graph.get(var2).putIfAbsent(var1, 1.0 / values[i]); &#125; return graph; &#125;&#125; 剑指 Offer II 112. 最长递增路径⭐ 方法一：DFS 1234567891011121314151617181920212223242526272829303132class Solution &#123; int[][] dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; int[][] path; public int longestIncreasingPath(int[][] matrix) &#123; int res = 0, m = matrix.length, n = matrix[0].length; path = new int[m][n]; for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; int dist = dfs(i, j, m, n, matrix); res = Math.max(res, dist); &#125; &#125; return res; &#125; public int dfs(int i, int j, int m, int n, int[][] matrix) &#123; if (path[i][j] != 0) return path[i][j]; int max = 1; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col, m, n) &amp;&amp; matrix[row][col] &gt; matrix[i][j]) &#123; int dist = dfs(row, col, m, n, matrix); max = Math.max(max, dist + 1); &#125; &#125; path[i][j] = max; return max; &#125; public boolean isValid(int i, int j, int m, int n) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125;&#125; 剑指 Offer II 113. 课程顺序 方法一：拓扑排序 123456789101112131415161718192021222324252627class Solution &#123; public int[] findOrder(int numCourses, int[][] prerequisites) &#123; Map&lt;Integer, List&lt;Integer&gt;&gt; graph = new HashMap&lt;&gt;(); for (int i = 0; i &lt; numCourses; ++i) graph.put(i, new LinkedList&lt;&gt;()); int[] inDegrees = new int[numCourses]; for (int i = 0; i &lt; prerequisites.length; ++i) &#123; ++inDegrees[prerequisites[i][0]]; graph.get(prerequisites[i][1]).add(prerequisites[i][0]); &#125; List&lt;Integer&gt; order = new LinkedList&lt;&gt;(); Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; numCourses; ++i) if (inDegrees[i] == 0) queue.offer(i); while (!queue.isEmpty()) &#123; int node = queue.poll(); order.add(node); for (int next : graph.get(node)) &#123; if (--inDegrees[next] == 0) &#123; queue.offer(next); &#125; &#125; &#125; return order.size() == numCourses ? order.stream().mapToInt(Integer::intValue).toArray() : new int[0]; &#125;&#125; 剑指 Offer II 114. 外星文字典 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123; public String alienOrder(String[] words) &#123; Map&lt;Character, Set&lt;Character&gt;&gt; graph = new HashMap&lt;&gt;(); Map&lt;Character, Integer&gt; inDegrees = new HashMap&lt;&gt;(); for (String word : words) &#123; for (char ch : word.toCharArray()) &#123; graph.putIfAbsent(ch, new HashSet&lt;&gt;()); inDegrees.putIfAbsent(ch, 0); &#125; &#125; for (int i = 1; i &lt; words.length; ++i) &#123; String word1 = words[i - 1]; String word2 = words[i]; if (word1.startsWith(word2) &amp;&amp; !word1.equals(word2)) return &quot;&quot;; for (int j = 0; j &lt; word1.length() &amp;&amp; j &lt; word2.length(); ++j) &#123; char ch1 = word1.charAt(j); char ch2 = word2.charAt(j); if (ch1 != ch2) &#123; if (!graph.get(ch1).contains(ch2)) &#123; graph.get(ch1).add(ch2); inDegrees.put(ch2, inDegrees.get(ch2) + 1); &#125; break; &#125; &#125; &#125; Queue&lt;Character&gt; queue = new LinkedList&lt;&gt;(); for (Map.Entry&lt;Character, Integer&gt; entry : inDegrees.entrySet()) &#123; if (entry.getValue() == 0) &#123; queue.offer(entry.getKey()); &#125; &#125; StringBuilder res = new StringBuilder(); while (!queue.isEmpty()) &#123; char ch = queue.poll(); res.append(ch); Set&lt;Character&gt; nexts = graph.get(ch); for (char next : nexts) &#123; inDegrees.put(next, inDegrees.get(next) - 1); if (inDegrees.get(next) == 0) queue.offer(next); &#125; &#125; return res.length() == graph.size() ? res.toString() : &quot;&quot;; &#125;&#125; 剑指 Offer II 115. 重建序列 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123; public boolean sequenceReconstruction(int[] nums, int[][] sequences) &#123; Map&lt;Integer, Set&lt;Integer&gt;&gt; graph = new HashMap&lt;&gt;(); Map&lt;Integer, Integer&gt; inDegrees = new HashMap&lt;&gt;(); for (int[] sequence : sequences) &#123; for (int num : sequence) &#123; graph.putIfAbsent(num, new HashSet&lt;&gt;()); inDegrees.put(num, 0); &#125; &#125; for (int i = 0; i &lt; sequences.length; ++i) &#123; for (int j = 1; j &lt; sequences[i].length; ++j) &#123; int num1 = sequences[i][j - 1], num2 = sequences[i][j]; if (!graph.get(num1).contains(num2)) &#123; graph.get(num1).add(num2); inDegrees.put(num2, inDegrees.get(num2) + 1); &#125; &#125; &#125; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); for (Map.Entry&lt;Integer, Integer&gt; entry : inDegrees.entrySet()) &#123; if (entry.getValue() == 0) &#123; queue.offer(entry.getKey()); &#125; &#125; List&lt;Integer&gt; res = new LinkedList&lt;&gt;(); while (queue.size() == 1) &#123; int num = queue.poll(); res.add(num); Set&lt;Integer&gt; nexts = graph.get(num); for (int next : nexts) &#123; inDegrees.put(next, inDegrees.get(next) - 1); if (inDegrees.get(next) == 0) queue.offer(next); &#125; &#125; int[] resToArr = res.stream().mapToInt(Integer::intValue).toArray(); return Arrays.equals(resToArr, nums); &#125;&#125; 剑指 Offer II 116. 省份数量 方法一：DFS 1234567891011121314151617181920212223class Solution &#123; public int findCircleNum(int[][] isConnected) &#123; int n = isConnected.length; int res = 0; boolean[] visited = new boolean[n]; for (int i = 0; i &lt; n; ++i) &#123; if (!visited[i]) &#123; visited[i] = true; dfs(i, n, visited, isConnected); ++res; &#125; &#125; return res; &#125; private void dfs(int i, int n, boolean[] visited, int[][] isConnected) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (isConnected[i][j] == 1 &amp;&amp; !visited[j]) &#123; visited[j] = true; dfs(j, n, visited, isConnected); &#125; &#125; &#125;&#125; 方法二：BFS 12345678910111213141516171819202122232425class Solution &#123; public int findCircleNum(int[][] isConnected) &#123; int n = isConnected.length; int res = 0; boolean[] visited = new boolean[n]; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; n; ++i) &#123; if (!visited[i]) &#123; ++res; queue.offer(i); while (!queue.isEmpty()) &#123; int province = queue.poll(); visited[province] = true; for (int j = 0; j &lt; n; ++j) &#123; if (isConnected[province][j] == 1 &amp;&amp; !visited[j]) &#123; visited[j] = true; queue.offer(j); &#125; &#125; &#125; &#125; &#125; return res; &#125;&#125; 方法三：并查集 并查集的讲解 findFather一定要return fathers[i]，而不是return i，因为当0的father是1的时候，return 1 而不是return 0！ 两层for循环第二层j = i + 1，因为首先j = i的话，是遍历两个相同的节点没意义；其次，i之前的节点在之前就已经合并过了，所以不需要再遍历了 123456789101112131415161718192021222324252627282930313233class Solution &#123; public int findCircleNum(int[][] isConnected) &#123; int n = isConnected.length; int res = n; int[] fathers = new int[n]; for (int i = 0; i &lt; n; ++i) fathers[i] = i; for (int i = 0; i &lt; n; ++i) &#123; for (int j = i + 1; j &lt; n; ++j) &#123; if (isConnected[i][j] == 1 &amp;&amp; union(i, j, fathers)) &#123; --res; &#125; &#125; &#125; return res; &#125; private boolean union(int i, int j, int[] fathers) &#123; int fatherOfI = findFather(i, fathers); int fatherOfJ = findFather(j, fathers); if (fatherOfI != fatherOfJ) &#123; fathers[fatherOfI] = fatherOfJ; return true; &#125; return false; &#125; private int findFather(int i, int[] fathers) &#123; if (i != fathers[i]) fathers[i] = findFather(fathers[i], fathers); return fathers[i]; &#125;&#125; 剑指 Offer II 117. 相似的字符串 方法一：并查集 判断是否是相似字符串的函数isAnalogical之前用的蠢方法，还要拷贝再交换，直接判断不同字符num的个数就行 如果num==0，那么相似 由于题目给出的字符串数组中，所有字符串互为 字母异位词(字母顺序不同)，所以num == 2时，是交换了两个字符，如果num &gt; 2，就不符合题意了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123; public int numSimilarGroups(String[] strs) &#123; int n = strs.length; int res = n; int[] fathers = new int[n]; for (int i = 0; i &lt; n; ++i) fathers[i] = i; for (int i = 0; i &lt; n; ++i) &#123; for (int j = i + 1; j &lt; n; ++j) &#123; String str1 = strs[i], str2 = strs[j]; if (isAnalogical(str1, str2) &amp;&amp; union(i, j, fathers)) &#123; --res; &#125; &#125; &#125; return res; &#125; private boolean union(int i, int j, int[] fathers) &#123; int fatherOfI = findFather(i, fathers); int fatherOfJ = findFather(j, fathers); if (fatherOfI != fatherOfJ) &#123; fathers[fatherOfI] = fatherOfJ; return true; &#125; return false; &#125; private int findFather(int i, int[] fathers) &#123; if (i != fathers[i]) fathers[i] = findFather(fathers[i], fathers); return fathers[i]; &#125; private boolean isAnalogical(String a, String b) &#123; int num = 0; for (int i = 0; i &lt; a.length(); i++) &#123; if (a.charAt(i) != b.charAt(i)) &#123; num++; if (num &gt; 2) &#123; return false; &#125; &#125; &#125; return true; &#125;&#125; 剑指 Offer II 118. 多余的边 方法一：并查集 123456789101112131415161718192021222324252627282930class Solution &#123; public int[] findRedundantConnection(int[][] edges) &#123; int n = edges.length; int[] fathers = new int[n + 1]; for (int i = 0; i &lt; n; ++i) fathers[i] = i; for (int[] edge : edges) &#123; int node1 = edge[0], node2 = edge[1]; if (!union(node1, node2, fathers)) return new int[]&#123;node1, node2&#125;; &#125; return new int[2]; &#125; private boolean union(int i, int j, int[] fathers) &#123; int fatherOfI = findFather(i, fathers); int fatherOfJ = findFather(j, fathers); if (fatherOfI != fatherOfJ) &#123; fathers[fatherOfI] = fatherOfJ; return true; &#125; return false; &#125; private int findFather(int i, int[] fathers) &#123; if (i != fathers[i]) fathers[i] = findFather(fathers[i], fathers); return fathers[i]; &#125;&#125; 剑指 Offer II 119. 最长连续序列 方法一：暴力 12345678910111213141516171819202122class Solution &#123; public int longestConsecutive(int[] nums) &#123; if (nums.length == 0) return 0; Arrays.sort(nums); for (int i : nums) System.out.print(i + &quot; &quot;); int res = 1, cur = 1; for (int i = 1; i &lt; nums.length; ++i) &#123; if (nums[i] == nums[i - 1]) continue; if (nums[i] - nums[i - 1] == 1) &#123; ++cur; res = Math.max(res, cur); &#125; else &#123; cur = 1; &#125; &#125; return res; &#125;&#125; 方法二：并查集 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public int longestConsecutive(int[] nums) &#123; Map&lt;Integer, Integer&gt; fathers = new HashMap&lt;&gt;(), count = new HashMap&lt;&gt;(); Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int num : nums) &#123; fathers.put(num, num); count.put(num, 1); set.add(num); &#125; for (int num : nums) &#123; if (set.contains(num + 1)) &#123; union(num, num + 1, fathers, count); &#125; if (set.contains(num - 1)) &#123; union(num, num - 1, fathers, count); &#125; &#125; int res = 0; for (int val : count.values()) &#123; res = Math.max(res, val); &#125; return res; &#125; private void union(int i, int j, Map&lt;Integer, Integer&gt; fathers, Map&lt;Integer, Integer&gt; count) &#123; int fatherOfI = findFather(i, fathers); int fatherOfJ = findFather(j, fathers); if (fatherOfI != fatherOfJ) &#123; fathers.put(fatherOfI, fatherOfJ); count.put(fatherOfJ, count.get(fatherOfI) + count.get(fatherOfJ)); &#125; &#125; private int findFather(int i, Map&lt;Integer, Integer&gt; fathers) &#123; int fatherOfI = fathers.get(i); if (i != fatherOfI) &#123; fathers.put(i, findFather(fatherOfI, fathers)); &#125; return fathers.get(i); &#125;&#125; Binary Search 剑指 Offer II 068. 查找插入位置 方法一： 如果nums中有target，那么会被找到并被返回 如果nums中没有target，那么有三种情况，这个数应该被插入道 第一个位置 最后一个位置 中间 这三种情况的索引都是退出循环后的left！！！ 12345678910111213141516class Solution &#123; public int searchInsert(int[] nums, int target) &#123; int left = 0, right = nums.length - 1; while (left &lt;= right) &#123; int mid = right - ((right - left) &gt;&gt; 1); if (nums[mid] == target) return mid; else if (nums[mid] &gt; target) right = mid - 1; else &#123; left = mid + 1; &#125; &#125; return left; &#125;&#125; 方法二： 1234567891011121314151617class Solution &#123; public int searchInsert(int[] nums, int target) &#123; int left = 0, right = nums.length - 1; while (left &lt;= right) &#123; int mid = right - ((right - left) &gt;&gt; 1); if (nums[mid] &gt;= target) &#123; if (mid == 0 || nums[mid - 1] &lt; target) return mid; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; return nums.length; &#125;&#125; Heap 剑指 Offer II 059. 数据流的第 K 大数值 方法一：小根堆 1234567891011121314151617181920212223242526class KthLargest &#123; private PriorityQueue&lt;Integer&gt; queue; private int size; public KthLargest(int k, int[] nums) &#123; queue = new PriorityQueue&lt;&gt;(); size = k; for (int num : nums) &#123; add(num); &#125; &#125; public int add(int val) &#123; queue.offer(val); if (queue.size() &gt; size) &#123; queue.poll(); &#125; return queue.peek(); &#125;&#125;/** * Your KthLargest object will be instantiated and called as such: * KthLargest obj = new KthLargest(k, nums); * int param_1 = obj.add(val); */ 方法二：小根堆另一种写法 1234567891011121314151617181920212223242526272829class KthLargest &#123; private PriorityQueue&lt;Integer&gt; queue; private int k; public KthLargest(int k, int[] nums) &#123; queue = new PriorityQueue&lt;&gt;(); this.k = k; for (int num : nums) &#123; add(num); &#125; &#125; public int add(int val) &#123; if (queue.size() &lt; k) &#123; queue.offer(val); &#125; else if (queue.size() == k &amp;&amp; queue.peek() &lt; val) &#123; queue.poll(); queue.offer(val); &#125; return queue.peek(); &#125;&#125;/** * Your KthLargest object will be instantiated and called as such: * KthLargest obj = new KthLargest(k, nums); * int param_1 = obj.add(val); */ 剑指 Offer II 060. 出现频率最高的 k 个数字 方法一：小根堆 小根堆的比较方式 小根堆的类型是Map.Entry 123456789101112131415161718192021222324class Solution &#123; public int[] topKFrequent(int[] nums, int k) &#123; Map&lt;Integer, Integer&gt; count = new HashMap&lt;&gt;(); for (int num : nums) &#123; count.put(num, count.getOrDefault(num, 0) + 1); &#125; PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; minHeap = new PriorityQueue&lt;&gt;( (e1, e2) -&gt; e1.getValue() - e2.getValue()); for (Map.Entry&lt;Integer, Integer&gt; entry : count.entrySet()) &#123; if (minHeap.size() &lt; k) &#123; minHeap.offer(entry); &#125; else if (entry.getValue() &gt; minHeap.peek().getValue()) &#123; minHeap.poll(); minHeap.offer(entry); &#125; &#125; int[] res = new int[k]; int i = 0; while (!minHeap.isEmpty()) res[i++] = minHeap.poll().getKey(); return res; &#125;&#125; 剑指 Offer II 061. 和最小的 k 个数对 方法一：大根堆 12345678910111213141516171819202122class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; kSmallestPairs(int[] nums1, int[] nums2, int k) &#123; PriorityQueue&lt;int[]&gt; maxHeap = new PriorityQueue&lt;&gt;( (o1, o2) -&gt; o2[0] + o2[1] - o1[0] - o1[1]); for (int i = 0; i &lt; Math.min(k, nums1.length); ++i) &#123; for (int j = 0; j &lt; Math.min(k, nums2.length); ++j) &#123; if (maxHeap.size() &lt; k) maxHeap.offer(new int[]&#123;nums1[i], nums2[j]&#125;); else if (maxHeap.peek()[0] + maxHeap.peek()[1] &gt; nums1[i] + nums2[j]) &#123; maxHeap.poll(); maxHeap.offer(new int[]&#123;nums1[i], nums2[j]&#125;); &#125; &#125; &#125; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); while (!maxHeap.isEmpty()) &#123; int[] temp = maxHeap.poll(); res.add(Arrays.asList(temp[0], temp[1])); &#125; return res; &#125;&#125; 排序 快速排序 边界问题：end &gt; start。当start == end的时候，已经是排序好的一个数，不需要在进行partition 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public int[] sortArray(int[] nums) &#123; quickSort(nums, 0, nums.length - 1); return nums; &#125; private void quickSort(int[] nums, int start, int end) &#123; if (end &gt; start) &#123; int pivot = partition(nums, start, end); quickSort(nums, start, pivot - 1); quickSort(nums, pivot + 1, end); &#125; &#125; private int partition(int[] nums, int start, int end) &#123; int random = new Random().nextInt(end - start + 1) + start; swap(nums, random, end); int small = start - 1; for (int i = start; i &lt; end; ++i) &#123; if (nums[i] &lt; nums[end]) &#123; ++small; swap(nums, small, i); &#125; &#125; // 没有小于pivot的数了 ++small; swap(nums, small, end); return small; &#125; private void swap(int[] nums, int random, int end) &#123; if (random != end) &#123; int temp = nums[end]; nums[end] = nums[random]; nums[random] = temp; &#125; &#125; public static void main(String[] args) &#123; int[] nums = new int[]&#123;5, 2, 3, 1, 4&#125;; int[] clone = nums.clone(); QuickSort quickSort = new QuickSort(); quickSort.sortArray(nums); for (int num : nums) System.out.print(num + &quot; &quot;); System.out.println(); Arrays.sort(clone); for (int cl : clone) System.out.print(cl + &quot; &quot;); &#125; 剑指 Offer II 076. 数组中的第 k 大的数字 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public int findKthLargest(int[] nums, int k) &#123; int target = nums.length - k; int start = 0, end = nums.length - 1; int pivot = partition(nums, start, end); while (pivot != target) &#123; if (pivot &gt; target) &#123; end = pivot - 1; &#125; else &#123; start = pivot + 1; &#125; pivot = partition(nums, start, end); &#125; return nums[pivot]; &#125; public int partition(int[] nums, int start , int end) &#123; int random = new Random().nextInt(end - start + 1) + start; swap(nums, random, end); int small = start - 1; for (int i = start; i &lt; end; ++i) &#123; if (nums[i] &lt; nums[end]) &#123; ++small; swap(nums, small, i); &#125; &#125; ++small; swap(nums, small, end); return small; &#125; public void swap(int[] nums, int index1, int index2) &#123; if (index1 != index2) &#123; int temp = nums[index1]; nums[index1] = nums[index2]; nums[index2] = temp; &#125; &#125;&#125; 前缀树 剑指 Offer II 062. 实现前缀树 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Trie &#123; static class TrieNode &#123; TrieNode[] children; boolean isWord; public TrieNode() &#123; children = new TrieNode[26]; &#125; &#125; private TrieNode root; public Trie() &#123; root = new TrieNode(); &#125; /** Inserts a word into the trie. */ public void insert(String word) &#123; TrieNode cur = root; for (char ch : word.toCharArray()) &#123; if (cur.children[ch - &#x27;a&#x27;] == null) &#123; cur.children[ch - &#x27;a&#x27;] = new TrieNode(); &#125; cur = cur.children[ch - &#x27;a&#x27;]; &#125; cur.isWord = true; &#125; /** Returns if the word is in the trie. */ public boolean search(String word) &#123; TrieNode cur = root; for (char ch : word.toCharArray()) &#123; if (cur.children[ch - &#x27;a&#x27;] == null) return false; cur = cur.children[ch - &#x27;a&#x27;]; &#125; return cur.isWord; &#125; /** Returns if there is any word in the trie that starts with the given prefix. */ public boolean startsWith(String prefix) &#123; TrieNode cur = root; for (char ch : prefix.toCharArray()) &#123; if (cur.children[ch - &#x27;a&#x27;] == null) return false; cur = cur.children[ch - &#x27;a&#x27;]; &#125; return true; &#125;&#125; 剑指 Offer II 063. 替换单词 方法一：前缀树 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123; static class TrieNode &#123; private TrieNode[] children; private boolean isWord; public TrieNode() &#123; children = new TrieNode[26]; &#125; &#125; public String replaceWords(List&lt;String&gt; dictionary, String sentence) &#123; TrieNode root = buildTrie(dictionary); String[] words = sentence.split(&quot; &quot;); StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; words.length; ++i) &#123; String prefix = findPrefix(root, words[i]); if (!prefix.isEmpty()) &#123; words[i] = prefix; &#125; &#125; return String.join(&quot; &quot;, words); &#125; private String findPrefix(TrieNode root, String word) &#123; TrieNode cur = root; StringBuilder sb = new StringBuilder(); for (char ch : word.toCharArray()) &#123; if (cur.children[ch - &#x27;a&#x27;] == null || cur.isWord) break; sb.append(ch); cur = cur.children[ch - &#x27;a&#x27;]; &#125; return cur.isWord == true ? sb.toString() : &quot;&quot;; &#125; private TrieNode buildTrie(List&lt;String&gt; dictionary) &#123; TrieNode root = new TrieNode(); for (String str : dictionary) &#123; TrieNode cur = root; for (char ch : str.toCharArray()) &#123; if (cur.children[ch - &#x27;a&#x27;] == null) cur.children[ch - &#x27;a&#x27;] = new TrieNode(); cur = cur.children[ch - &#x27;a&#x27;]; &#125; cur.isWord = true; &#125; return root; &#125;&#125; 剑指 Offer II 064. 神奇的字典⚠️ 方法一：前缀树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class MagicDictionary &#123; static class TrieNode &#123; private TrieNode[] children; private boolean isWord; public TrieNode() &#123; children = new TrieNode[26]; &#125; &#125; /** Initialize your data structure here. */ private TrieNode root; public MagicDictionary() &#123; root = new TrieNode(); &#125; public void buildDict(String[] dictionary) &#123; for (String str : dictionary) &#123; TrieNode cur = root; for (char ch : str.toCharArray()) &#123; if (cur.children[ch - &#x27;a&#x27;] == null) cur.children[ch - &#x27;a&#x27;] = new TrieNode(); cur = cur.children[ch - &#x27;a&#x27;]; &#125; cur.isWord = true; &#125; &#125; public boolean search(String searchWord) &#123; return dfs(root, searchWord, 0, 0); &#125; public boolean dfs(TrieNode root, String searchWord, int index, int modifiedNum) &#123; if (root == null) return false; if (root.isWord &amp;&amp; index == searchWord.length() &amp;&amp; modifiedNum == 1) return true; if (modifiedNum &lt;= 1 &amp;&amp; index &lt; searchWord.length()) &#123; boolean found = false; for (int j = 0; j &lt; 26 &amp;&amp; !found; ++j) &#123; int next = j == searchWord.charAt(index) - &#x27;a&#x27; ? modifiedNum : modifiedNum + 1; found = dfs(root.children[j], searchWord, index + 1, next); &#125; return found; &#125; return false; &#125;&#125;/** * Your MagicDictionary object will be instantiated and called as such: * MagicDictionary obj = new MagicDictionary(); * obj.buildDict(dictionary); * boolean param_2 = obj.search(searchWord); *///leetcode submit region end(Prohibit modification and deletion) 剑指 Offer II 065. 最短的单词编码⚠️⭐ 方法一：前缀树 这种DFS技巧非常重要！！！ 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123; static class TrieNode &#123; private TrieNode[] children; private boolean isEnd; public TrieNode() &#123; children = new TrieNode[26]; &#125; &#125; private int res = 0; public int minimumLengthEncoding(String[] words) &#123; TrieNode root = buildTree(words); dfs(root, 1); return res; &#125; private void dfs(TrieNode root, int length) &#123; boolean isLeaf = true; for (TrieNode child : root.children) &#123; if (child != null) &#123; isLeaf = false; dfs(child, length + 1); &#125; &#125; if (isLeaf) res += length; &#125; private TrieNode buildTree(String[] words) &#123; TrieNode root = new TrieNode(); for (int i = 0; i &lt; words.length; ++i) &#123; String word = words[i]; TrieNode cur = root; for (int j = word.length() - 1; j &gt;= 0; --j) &#123; char ch = word.charAt(j); if (cur.children[ch - &#x27;a&#x27;] == null) cur.children[ch - &#x27;a&#x27;] = new TrieNode(); cur = cur.children[ch - &#x27;a&#x27;]; &#125; cur.isEnd = true; &#125; return root; &#125;&#125; 剑指 Offer II 066. 单词之和 方法一：前缀树 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class MapSum &#123; static class TrieNode &#123; private TrieNode[] children; private int val; public TrieNode() &#123; children = new TrieNode[26]; &#125; &#125; private TrieNode root; /** Initialize your data structure here. */ public MapSum() &#123; root = new TrieNode(); &#125; public void insert(String key, int val) &#123; TrieNode cur = root; for (char ch : key.toCharArray()) &#123; if (cur.children[ch - &#x27;a&#x27;] == null) cur.children[ch - &#x27;a&#x27;] = new TrieNode(); cur = cur.children[ch - &#x27;a&#x27;]; &#125; cur.val = val; &#125; public int sum(String prefix) &#123; TrieNode cur = root; for (char ch : prefix.toCharArray()) &#123; if (cur.children[ch - &#x27;a&#x27;] == null) return 0; cur = cur.children[ch - &#x27;a&#x27;]; &#125; return dfs(cur); &#125; private int dfs(TrieNode cur) &#123; int sum = cur.val; for (TrieNode child : cur.children) &#123; if (child != null) sum += dfs(child); &#125; return sum; &#125; public static void main(String[] args) &#123; MapSum mapSum = new MapSum(); mapSum.insert(&quot;apple&quot;, 3); mapSum.sum(&quot;ap&quot;); mapSum.insert(&quot;app&quot;, 2); mapSum.sum(&quot;ap&quot;); &#125;&#125;/** * Your MapSum object will be instantiated and called as such: * MapSum obj = new MapSum(); * obj.insert(key,val); * int param_2 = obj.sum(prefix); */ 剑指 Offer II 067. 最大的异或 方法一：前缀树 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123; static class TrieNode &#123; private TrieNode[] children; public TrieNode() &#123; children = new TrieNode[2]; &#125; &#125; public int findMaximumXOR(int[] nums) &#123; TrieNode root = buildTrie(nums); int max = 0; for (int num : nums) &#123; TrieNode cur = root; int xor = 0; for (int i = 31; i &gt;= 0; --i) &#123; int bit = (num &gt;&gt; i) &amp; 1; if (cur.children[1 - bit] != null) &#123; cur = cur.children[1 - bit]; xor = (xor &lt;&lt; 1) + 1; &#125; else &#123; cur = cur.children[bit]; xor = xor &lt;&lt; 1; &#125; &#125; max = Math.max(max, xor); &#125; return max; &#125; private TrieNode buildTrie(int[] nums) &#123; TrieNode root = new TrieNode(); for (int num : nums) &#123; TrieNode cur = root; for (int i = 31; i &gt;= 0; --i) &#123; int bit = (num &gt;&gt; i) &amp; 1; if (cur.children[bit] == null) &#123; cur.children[bit] = new TrieNode(); &#125; cur = cur.children[bit]; &#125; &#125; return root; &#125;&#125; tips 新建数组时赋值 int[] array = new int[]{3, 4}； 链表转数组 方法一： 1int[] intArray = linkedList.stream().mapToInt(Integer::intValue).toArray(); 这行代码可以分解为以下几个部分： linkedList.stream(): 将LinkedList转换为Stream。 mapToInt(Integer::intValue): 将Stream中的每一个元素转换为int类型。 Integer::intValue是一个方法引用，表示调用Integer对象的intValue()方法，将其转换为对应的int值。 toArray(): 将转换后的元素放到一个int数组中。 toArray()的作用是将Stream中的所有元素转换为一个数组，返回值是一个int[]类型的数组。 综上所述，int[] intArray = linkedList.stream().mapToInt(Integer::intValue).toArray();的语义是将LinkedList中的所有元素转换为int类型，并将其放入一个int数组中。在这个过程中，我们使用了Java 8引入的Stream API，它提供了许多方便的操作，可以简化代码的编写和调试。 方法二： 1res.toArray(new int[res.size()][]); 创建长度二维数组，其中一维数组的长度不确定 1new int[][]&#123;&#123;1, 2&#125;, &#123;3&#125;, &#123;3&#125;, &#123;&#125;&#125; char转int，String转int 1234567// 将字符转换为整数char c = &#x27;8&#x27;;int num = Character.getNumericValue(c); // num = 8// 将字符串转换为整数String str = &quot;123&quot;;int num2 = Integer.parseInt(str); // num2 = 123 String转int时，什么时候用parseInt什么时候用valueOf 在Java中，parseInt和valueOf都可以将字符串转换为整数。parseInt方法将字符串转换为基本数据类型int，而valueOf方法将字符串转换为对象类型Integer。因此，使用哪个方法取决于你要使用返回的数据类型。 如果你只需要一个基本数据类型int，那么使用parseInt是最好的选择，因为它会返回一个原始类型，不会产生额外的对象开销。 例如： java Copy code String str = “123”; int num = Integer.parseInt(str); 如果你需要一个对象类型Integer，则使用valueOf方法是最好的选择。valueOf方法返回一个Integer对象，这在某些情况下非常有用。 例如： java Copy code String str = “123”; Integer num = Integer.valueOf(str); 总之，如果你只需要一个基本数据类型，那么使用parseInt方法，否则使用valueOf方法。 使用scanner.nextLine()读取行末的换行符 1234567891011public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); scanner.nextLine(); for (int i = 0; i &lt; n; ++i) &#123; String word = scanner.nextLine(); System.out.println(&quot;word: &quot; + word); Main main = new Main(); String ans = main.process(word); System.out.println(ans); &#125; 这段代码首先从标准输入中读取一个整数n，然后通过调用scanner.nextLine()读取掉n后面的换行符。接下来，通过for循环n次，读取n行字符串，每次读取一行字符串后，调用process方法进行处理，最后将处理结果打印到标准输出中。 需要注意的是，在使用Scanner读取完整行时，由于nextInt只读取整数，因此需要在nextInt后面调用nextLine读取行末的换行符。这样做是为了防止接下来的nextLine方法误读取行末的换行符。 创建长度不同的二维数组 在Java中，可以创建长度不同的二维数组。以下是创建长度不同的二维数组的示例： 1234int[][] arr = new int[3][];arr[0] = new int[2];arr[1] = new int[3];arr[2] = new int[4]; 在这个示例中，我们创建了一个3 x n的二维数组，其中n的长度不同。第一行有两个元素，第二行有三个元素，第三行有四个元素。我们可以通过以下方式访问数组的元素： 123456789arr[0][0] = 1;arr[0][1] = 2;arr[1][0] = 3;arr[1][1] = 4;arr[1][2] = 5;arr[2][0] = 6;arr[2][1] = 7;arr[2][2] = 8;arr[2][3] = 9; 请注意，当您创建长度不同的二维数组时，每行的长度必须在运行时确定。因此，您必须在运行时动态地为每行分配内存空间。 12345678910182 1 1 2 22 1 1 1 42 1 1 2 22 2 2 1 4001 1 11 1 1 数组拷贝：ch.clone与Arrays.copyOf的区别 对基础类型的拷贝都是值传递的拷贝(深拷贝)，对对象的拷贝都是拷贝的引用(浅拷贝) IDEA创建live template 在 IntelliJ IDEA 中使用 Live Template 来创建并查集的固定代码，可以按照以下步骤进行操作： 打开 IntelliJ IDEA，进入设置面板。你可以通过点击菜单栏的 “File” -&gt; “Settings” (Windows/Linux) 或 “IntelliJ IDEA” -&gt; “Preferences” (Mac) 打开设置面板。 在设置面板中，选择 “Editor” -&gt; “Live Templates”。 在左侧的面板中，选择你想要创建代码模板的语言，比如 “Java”。 点击右侧面板的 “+” 按钮，添加一个新的模板。 在 “Abbreviation” 输入框中输入一个简短的缩写，用于触发代码模板。 在 “Template text” 输入框中输入代码模板的内容，例如： 12345678910111213141516171819202122// 并查集初始化int[] parent = new int[n];for (int i = 0; i &lt; n; i++) &#123; parent[i] = i;&#125;// 并查集查找根节点private int find(int x) &#123; if (parent[x] != x) &#123; parent[x] = find(parent[x]); &#125; return parent[x];&#125;// 并查集合并两个集合private void union(int x, int y) &#123; int rootX = find(x); int rootY = find(y); if (rootX != rootY) &#123; parent[rootX] = rootY; &#125;&#125; 点击 “Define” 按钮，选择模板的定义范围，比如选择 “Java”。 点击 “Apply” 或 “OK” 完成模板的创建。 现在，你可以在代码编辑器中输入你设定的缩写，比如 “uf”，然后按下 Tab 键，就会自动插入你定义的并查集代码模板。你可以根据需要修改模板中的变量名和其他细节，以适应你的项目要求。 笔试面试 5.8小红书 第一题. 第二题. 123456789101112131415161718192021222324最大最小值 时间限制： 1000MS 内存限制： 65536KB 题目描述： 有一个长度为n的序列，其中第i个元素ai，你现在可以对这个序列进行最多k次操作，每次可选择一个连续的区间将其中的元素删掉，但剩余的元素个数必须大于0。 现在想让剩余元素的最小值尽可能大，求上述情况下的最大值。 输入描述 第一行两个正整数n和k，分别表示初始序列中元素的个数以及最多的操作次数。 接下来1行，n个正整数，其中第i个数为ai。 对于所有数据，1&lt;=n&lt;=10^5，0&lt;=k&lt;=10^5，1&lt;=ai &lt;=10^6。 输出描述 输出仅包含一个正整数，表示答案。 样例输入 8 1 58 57 86 89 25 26 61 42 样例输出 58 123这道题是要求给定一个序列，你可以进行最多k次操作，每次操作可以删除序列中的某个连续区间，但是最后删除后剩余元素的最小值尽可能大。你需要输出这个最大的最小值。举个例子，对于样例输入 [58, 57, 86, 89, 25, 26, 61, 42]，可以进行1次操作，比如删除区间[86,89]，剩下的序列为[58, 57, 25, 26, 61, 42]，此时剩余元素的最小值为25，最大的最小值就是25。你需要编写一个程序来自动寻找最大的最小值。 第三题. 5.10 微众银行 第一题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293```![1](https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/1.jpg) ### 第二题![第二题](https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/第二题.jpg) ```javapackage 面试题.微众银行暑期实习.第2题;import java.lang.reflect.Array;import java.util.*;public class Main &#123; public static void main(String[] args) &#123; Main main = new Main(); Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); int k = scanner.nextInt(); scanner.nextLine(); long[] energy = new long[n], score = new long[n]; for (int i = 0; i &lt; n; ++i) &#123; energy[i] = scanner.nextLong(); &#125; scanner.nextLine(); for (int i = 0; i &lt; n; ++i) &#123; score[i] = scanner.nextLong(); &#125; long[] res = main.process(n, k, energy, score); for (long i : res) System.out.print(i + &quot; &quot;); &#125; Queue&lt;Long&gt; queue = new PriorityQueue&lt;&gt;(); private long[] process(int n, int k, long[] energy, long[] score) &#123; long[] res = new long[n]; Map&lt;Long, Long&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; n; ++i) &#123; map.put(energy[i], score[i]); &#125; long[] oriEnery = new long[n]; for (int i = 0; i &lt; n; ++i) oriEnery[i] = energy[i]; Arrays.sort(energy); for (int i = 0; i &lt; k; ++i) &#123; long s = map.get(energy[i]); queue.offer(s); &#125; long sum = map.get(energy[0]); for (int i = 1; i &lt; k; ++i) &#123; res[i] = sum; sum += map.get(energy[i]); &#125; for (int i = k; i &lt; n; ++i) &#123; res[i] = getKMax(); long s = map.get(energy[i]); if (s &gt; queue.peek()) &#123; queue.poll(); queue.offer(s); &#125; &#125; long[] res2 = new long[n]; //resAsOriginalSequence for (int i = 0; i &lt; n; ++i) &#123; long e = oriEnery[i]; int index = 0; for (; index &lt; n; ++index) &#123; if (energy[index] == e) break; &#125; res2[i] = res[index]; &#125; return res2; &#125; private int getKMax() &#123; int sum = 0; Queue&lt;Long&gt; queue2 = new PriorityQueue&lt;&gt;(); while (!queue.isEmpty()) &#123; long temp = queue.poll(); sum += temp; queue2.offer(temp); &#125; queue = queue2; return sum; &#125;&#125; 第三题","categories":[],"tags":[]}],"categories":[{"name":"AWS","slug":"AWS","permalink":"https://leopol1d.github.io/categories/AWS/"},{"name":"Ultimate AWS Certified Cloud Practitioner CLF-C02","slug":"AWS/Ultimate-AWS-Certified-Cloud-Practitioner-CLF-C02","permalink":"https://leopol1d.github.io/categories/AWS/Ultimate-AWS-Certified-Cloud-Practitioner-CLF-C02/"},{"name":"ELB & ASG","slug":"AWS/Ultimate-AWS-Certified-Cloud-Practitioner-CLF-C02/ELB-ASG","permalink":"https://leopol1d.github.io/categories/AWS/Ultimate-AWS-Certified-Cloud-Practitioner-CLF-C02/ELB-ASG/"},{"name":"Algorithms","slug":"Algorithms","permalink":"https://leopol1d.github.io/categories/Algorithms/"},{"name":"Graph","slug":"Algorithms/Graph","permalink":"https://leopol1d.github.io/categories/Algorithms/Graph/"},{"name":"EC2 - Elastic Compute Cloud","slug":"AWS/Ultimate-AWS-Certified-Cloud-Practitioner-CLF-C02/EC2-Elastic-Compute-Cloud","permalink":"https://leopol1d.github.io/categories/AWS/Ultimate-AWS-Certified-Cloud-Practitioner-CLF-C02/EC2-Elastic-Compute-Cloud/"},{"name":"AWS Cloud Practitioner Essentials","slug":"AWS/AWS-Cloud-Practitioner-Essentials","permalink":"https://leopol1d.github.io/categories/AWS/AWS-Cloud-Practitioner-Essentials/"},{"name":".*","slug":"","permalink":"https://leopol1d.github.io/categories/"},{"name":"Contest","slug":"Contest","permalink":"https://leopol1d.github.io/categories/Contest/"},{"name":"LCP","slug":"Contest/LCP","permalink":"https://leopol1d.github.io/categories/Contest/LCP/"},{"name":"Dynamic Programming","slug":"Algorithms/Dynamic-Programming","permalink":"https://leopol1d.github.io/categories/Algorithms/Dynamic-Programming/"},{"name":"Binary Index Tree","slug":"Algorithms/Binary-Index-Tree","permalink":"https://leopol1d.github.io/categories/Algorithms/Binary-Index-Tree/"},{"name":"Memorization Search","slug":"Algorithms/Memorization-Search","permalink":"https://leopol1d.github.io/categories/Algorithms/Memorization-Search/"},{"name":"Segment Tree","slug":"Algorithms/Segment-Tree","permalink":"https://leopol1d.github.io/categories/Algorithms/Segment-Tree/"},{"name":"Prefix Sum","slug":"Algorithms/Prefix-Sum","permalink":"https://leopol1d.github.io/categories/Algorithms/Prefix-Sum/"},{"name":"Sort","slug":"Algorithms/Sort","permalink":"https://leopol1d.github.io/categories/Algorithms/Sort/"},{"name":"Sliding Window","slug":"Algorithms/Sliding-Window","permalink":"https://leopol1d.github.io/categories/Algorithms/Sliding-Window/"},{"name":"Trie","slug":"Algorithms/Trie","permalink":"https://leopol1d.github.io/categories/Algorithms/Trie/"},{"name":"Binary Search","slug":"Algorithms/Binary-Search","permalink":"https://leopol1d.github.io/categories/Algorithms/Binary-Search/"},{"name":"Queue && Stack","slug":"Algorithms/Queue-Stack","permalink":"https://leopol1d.github.io/categories/Algorithms/Queue-Stack/"},{"name":"backtracking","slug":"Algorithms/backtracking","permalink":"https://leopol1d.github.io/categories/Algorithms/backtracking/"}],"tags":[{"name":"Cloud Computing","slug":"Cloud-Computing","permalink":"https://leopol1d.github.io/tags/Cloud-Computing/"},{"name":"AWS","slug":"AWS","permalink":"https://leopol1d.github.io/tags/AWS/"},{"name":"Scalability","slug":"Scalability","permalink":"https://leopol1d.github.io/tags/Scalability/"},{"name":"High Availability","slug":"High-Availability","permalink":"https://leopol1d.github.io/tags/High-Availability/"},{"name":"图论","slug":"图论","permalink":"https://leopol1d.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"DFS","slug":"DFS","permalink":"https://leopol1d.github.io/tags/DFS/"},{"name":"BFS","slug":"BFS","permalink":"https://leopol1d.github.io/tags/BFS/"},{"name":"Shortest Path Problem","slug":"Shortest-Path-Problem","permalink":"https://leopol1d.github.io/tags/Shortest-Path-Problem/"},{"name":"Topological Sort","slug":"Topological-Sort","permalink":"https://leopol1d.github.io/tags/Topological-Sort/"},{"name":"Security Group","slug":"Security-Group","permalink":"https://leopol1d.github.io/tags/Security-Group/"},{"name":"EC2","slug":"EC2","permalink":"https://leopol1d.github.io/tags/EC2/"},{"name":"Ultimate AWS Certified Cloud Practitioner CLF-C02","slug":"Ultimate-AWS-Certified-Cloud-Practitioner-CLF-C02","permalink":"https://leopol1d.github.io/tags/Ultimate-AWS-Certified-Cloud-Practitioner-CLF-C02/"},{"name":"DDoS","slug":"DDoS","permalink":"https://leopol1d.github.io/tags/DDoS/"},{"name":"WAF","slug":"WAF","permalink":"https://leopol1d.github.io/tags/WAF/"},{"name":"Shield","slug":"Shield","permalink":"https://leopol1d.github.io/tags/Shield/"},{"name":"Network Firewall","slug":"Network-Firewall","permalink":"https://leopol1d.github.io/tags/Network-Firewall/"},{"name":"Penetration Testing","slug":"Penetration-Testing","permalink":"https://leopol1d.github.io/tags/Penetration-Testing/"},{"name":"CloudHSM","slug":"CloudHSM","permalink":"https://leopol1d.github.io/tags/CloudHSM/"},{"name":"Artifact","slug":"Artifact","permalink":"https://leopol1d.github.io/tags/Artifact/"},{"name":"GuardDuty","slug":"GuardDuty","permalink":"https://leopol1d.github.io/tags/GuardDuty/"},{"name":"Inspector","slug":"Inspector","permalink":"https://leopol1d.github.io/tags/Inspector/"},{"name":"Macie","slug":"Macie","permalink":"https://leopol1d.github.io/tags/Macie/"},{"name":"Security Hub","slug":"Security-Hub","permalink":"https://leopol1d.github.io/tags/Security-Hub/"},{"name":"RDB","slug":"RDB","permalink":"https://leopol1d.github.io/tags/RDB/"},{"name":"ElasticCache","slug":"ElasticCache","permalink":"https://leopol1d.github.io/tags/ElasticCache/"},{"name":"DynamoDB","slug":"DynamoDB","permalink":"https://leopol1d.github.io/tags/DynamoDB/"},{"name":"DynamoDB Global Tables","slug":"DynamoDB-Global-Tables","permalink":"https://leopol1d.github.io/tags/DynamoDB-Global-Tables/"},{"name":"Redshift","slug":"Redshift","permalink":"https://leopol1d.github.io/tags/Redshift/"},{"name":"EMR","slug":"EMR","permalink":"https://leopol1d.github.io/tags/EMR/"},{"name":"Athena","slug":"Athena","permalink":"https://leopol1d.github.io/tags/Athena/"},{"name":"QuickSight","slug":"QuickSight","permalink":"https://leopol1d.github.io/tags/QuickSight/"},{"name":"DocumentDB","slug":"DocumentDB","permalink":"https://leopol1d.github.io/tags/DocumentDB/"},{"name":"Neptune","slug":"Neptune","permalink":"https://leopol1d.github.io/tags/Neptune/"},{"name":"Timestream","slug":"Timestream","permalink":"https://leopol1d.github.io/tags/Timestream/"},{"name":"QLDB","slug":"QLDB","permalink":"https://leopol1d.github.io/tags/QLDB/"},{"name":"Managed Blockchain","slug":"Managed-Blockchain","permalink":"https://leopol1d.github.io/tags/Managed-Blockchain/"},{"name":"Glue","slug":"Glue","permalink":"https://leopol1d.github.io/tags/Glue/"},{"name":"DMS","slug":"DMS","permalink":"https://leopol1d.github.io/tags/DMS/"},{"name":"AWS Cloud Practitioner Essentials","slug":"AWS-Cloud-Practitioner-Essentials","permalink":"https://leopol1d.github.io/tags/AWS-Cloud-Practitioner-Essentials/"},{"name":"Disaster Tolerance","slug":"Disaster-Tolerance","permalink":"https://leopol1d.github.io/tags/Disaster-Tolerance/"},{"name":"hash","slug":"hash","permalink":"https://leopol1d.github.io/tags/hash/"},{"name":"力扣杯","slug":"力扣杯","permalink":"https://leopol1d.github.io/tags/%E5%8A%9B%E6%89%A3%E6%9D%AF/"},{"name":"树形DP","slug":"树形DP","permalink":"https://leopol1d.github.io/tags/%E6%A0%91%E5%BD%A2DP/"},{"name":"动态规划","slug":"动态规划","permalink":"https://leopol1d.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"树状数组","slug":"树状数组","permalink":"https://leopol1d.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"记忆化搜索","slug":"记忆化搜索","permalink":"https://leopol1d.github.io/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"},{"name":"线段树","slug":"线段树","permalink":"https://leopol1d.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"前缀和，差分数组","slug":"前缀和，差分数组","permalink":"https://leopol1d.github.io/tags/%E5%89%8D%E7%BC%80%E5%92%8C%EF%BC%8C%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/"},{"name":"动态规划,背包问题","slug":"动态规划-背包问题","permalink":"https://leopol1d.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"name":"排序","slug":"排序","permalink":"https://leopol1d.github.io/tags/%E6%8E%92%E5%BA%8F/"},{"name":"贪心","slug":"贪心","permalink":"https://leopol1d.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"滑动窗口","slug":"滑动窗口","permalink":"https://leopol1d.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"name":"前缀树","slug":"前缀树","permalink":"https://leopol1d.github.io/tags/%E5%89%8D%E7%BC%80%E6%A0%91/"},{"name":"二分查找","slug":"二分查找","permalink":"https://leopol1d.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"图","slug":"图","permalink":"https://leopol1d.github.io/tags/%E5%9B%BE/"},{"name":"迷宫问题","slug":"迷宫问题","permalink":"https://leopol1d.github.io/tags/%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98/"},{"name":"单调栈","slug":"单调栈","permalink":"https://leopol1d.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"name":"单调队列","slug":"单调队列","permalink":"https://leopol1d.github.io/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"},{"name":"最短路","slug":"最短路","permalink":"https://leopol1d.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"最小生成树","slug":"最小生成树","permalink":"https://leopol1d.github.io/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"},{"name":"并查集","slug":"并查集","permalink":"https://leopol1d.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"拓扑排序","slug":"拓扑排序","permalink":"https://leopol1d.github.io/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"name":"回溯","slug":"回溯","permalink":"https://leopol1d.github.io/tags/%E5%9B%9E%E6%BA%AF/"}]}