{"meta":{"title":"Leopold's Blog","subtitle":"Algorithms","description":"For offers","author":"Leopold","url":"https://leopol1d.github.io","root":"/"},"pages":[{"title":"","date":"2023-05-23T10:05:13.718Z","updated":"2023-05-23T10:05:13.718Z","comments":false,"path":"css/fluid-extension.css","permalink":"https://leopol1d.github.io/css/fluid-extension.css","excerpt":"","text":"::-webkit-scrollbar { width: 8px; height: 8px; } ::-webkit-scrollbar-track { border-radius: 4px; background-color: rgba(255, 255, 255, .1); } ::-webkit-scrollbar-thumb { border-radius: 4px; background-color: rgba(0, 120, 231, .5); } ::-webkit-scrollbar-thumb:window-inactive { background-color: rgba(0, 120, 231, .3) } ::-webkit-scrollbar-thumb:hover { background-color: rgba(0, 120, 231, .7) } ::-webkit-scrollbar-thumb:active { background-color: rgba(0, 120, 231, .9) } figure.highlight { background: #FFFFFF; border-radius: 5px; box-shadow: 0 4px 7px 0 rgba(0, 0, 0, .4); padding-top: 30px } figure.highlight::before { background: #fc625d; border-radius: 50%; box-shadow: 20px 0 #fdbc40, 40px 0 #35cd4b; content: ' '; height: 12px; left: 12px; margin-top: -20px; position: absolute; width: 12px; } .table-container { overflow: auto; margin-bottom: 16px; } /* Avoid affecting the style of codeblock */ .markdown-body .table-container table { display: table !important; margin-bottom: 0 !important; } #navbar { -webkit-backdrop-filter: blur(3px); backdrop-filter: blur(3px); } div.dropdown-menu { min-width: inherit !important; text-align: center !important; background-color: var(--navbar-bg-color) !important; right: 0; left: initial !important; box-shadow: 0 4px 7px 0 rgba(0, 0, 0, .5); -webkit-animation: sub_menus .3s .1s ease both; -moz-animation: sub_menus .3s .1s ease both; -o-animation: sub_menus .3s .1s ease both; -ms-animation: sub_menus .3s .1s ease both; animation: sub_menus .3s .1s ease both; } @-moz-keyframes sub_menus { 0% { opacity: 0; -webkit-transform: translateY(10px); -moz-transform: translateY(10px); -o-transform: translateY(10px); -ms-transform: translateY(10px); transform: translateY(10px); } 100% { opacity: 1; -webkit-transform: translateY(0); -moz-transform: translateY(0); -o-transform: translateY(0); -ms-transform: translateY(0); transform: translateY(0); } } @-webkit-keyframes sub_menus { 0% { opacity: 0; -webkit-transform: translateY(10px); -moz-transform: translateY(10px); -o-transform: translateY(10px); -ms-transform: translateY(10px); transform: translateY(10px); } 100% { opacity: 1; -webkit-transform: translateY(0); -moz-transform: translateY(0); -o-transform: translateY(0); -ms-transform: translateY(0); transform: translateY(0); } } @-o-keyframes sub_menus { 0% { opacity: 0; -webkit-transform: translateY(10px); -moz-transform: translateY(10px); -o-transform: translateY(10px); -ms-transform: translateY(10px); transform: translateY(10px); } 100% { opacity: 1; -webkit-transform: translateY(0); -moz-transform: translateY(0); -o-transform: translateY(0); -ms-transform: translateY(0); transform: translateY(0); } } @keyframes sub_menus { 0% { opacity: 0; -webkit-transform: translateY(10px); -moz-transform: translateY(10px); -o-transform: translateY(10px); -ms-transform: translateY(10px); transform: translateY(10px); } 100% { opacity: 1; -webkit-transform: translateY(0); -moz-transform: translateY(0); -o-transform: translateY(0); -ms-transform: translateY(0); transform: translateY(0); } } /* 代码和表格设置最大高度，高度或宽度超出都不会显示在页面中，可以通过滚动条查看 */ table { padding: 0; word-break: initial; overflow-x: auto; max-height: 44em; overflow-y: auto !important; }"},{"title":"tags~","date":"2023-05-20T07:00:53.000Z","updated":"2023-05-20T07:05:43.906Z","comments":false,"path":"tags/index.html","permalink":"https://leopol1d.github.io/tags/index.html","excerpt":"","text":""},{"title":"标题","date":"2023-05-21T03:11:41.458Z","updated":"2023-05-21T03:11:41.458Z","comments":false,"path":"about/index.html","permalink":"https://leopol1d.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"lcp350","slug":"lcp350","date":"2023-07-05T01:15:00.000Z","updated":"2023-07-05T09:24:36.934Z","comments":true,"path":"2023/07/05/lcp350/","link":"","permalink":"https://leopol1d.github.io/2023/07/05/lcp350/","excerpt":"","text":"总行驶距离 1234567891011121314151617class Solution &#123; public int distanceTraveled(int mainTank, int additionalTank) &#123; int res = 0, ori = mainTank; while (mainTank &gt; 0) &#123; --mainTank; res += 10; if (ori == mainTank + 5) &#123; if (additionalTank &gt; 0) &#123; --additionalTank; ++mainTank; ori = mainTank; &#125; &#125; &#125; return res; &#125;&#125; 找出分区值 1234567891011121314class Solution &#123; public int findValueOfPartition(int[] nums) &#123; Arrays.sort(nums); int n = nums.length; int[] arr = new int[n - 1]; for (int i = 0; i &lt; n - 1; ++i) arr[i] = nums[i + 1] - nums[i]; int min = Integer.MAX_VALUE; for (int x : arr) &#123; min = Math.min(min, x); &#125; return min; &#125;&#125; 特别的排列 方法一：三种回溯(超时) 回溯一 123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public int specialPerm(int[] nums) &#123; visited = new boolean[nums.length]; Arrays.sort(nums); dfs(nums, 0); return res; &#125; int res = 0, MOD = (int) (1e9 + 7); Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); boolean[] visited; private void dfs(int[] nums, int index) &#123; if (path.size() == nums.length) &#123; res = (res + 1) % MOD; return; &#125; for (int i = 0; i &lt; nums.length; ++i) &#123; if (visited[i]) continue; if (i != 0 &amp;&amp; nums[i - 1] == nums[i] &amp;&amp; !visited[i - 1]) continue; if (path.isEmpty() || check(nums[i], path.peekLast())) &#123; visited[i] = true; path.offerLast(nums[i]); dfs(nums, i + 1); path.pollLast(); visited[i] = false; &#125; &#125; &#125; private boolean check(int a, int b) &#123; return (a % b == 0) || (b % a == 0); &#125;&#125; 回溯二 123456789101112131415161718192021222324252627282930313233343536public int specialPerm(int[] nums) &#123; visited = new boolean[nums.length]; dp = new HashMap&lt;&gt;(); Arrays.sort(nums); return dfs(nums);&#125;int MOD = (int) (1e9 + 7);Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;();boolean[] visited;Map&lt;String, Integer&gt; dp;private int dfs(int[] nums) &#123; if (path.size() == nums.length) return 1; int res = 0; for (int i = 0; i &lt; nums.length; ++i) &#123; if (visited[i]) continue; if (i != 0 &amp;&amp; nums[i - 1] == nums[i] &amp;&amp; !visited[i - 1]) continue; if (path.isEmpty() || check(nums[i], path.peekLast())) &#123; visited[i] = true; path.offerLast(nums[i]); res = (res + dfs(nums)) % MOD; path.pollLast(); visited[i] = false; &#125; &#125; return res;&#125;private boolean check(int a, int b) &#123; return (a % b == 0) || (b % a == 0);&#125; 回溯三 12345678910111213141516171819202122232425262728293031323334public int specialPerm(int[] nums) &#123; this.nums = nums; visited = new boolean[nums.length]; dp = new HashMap&lt;&gt;(); Arrays.sort(nums); return dfs(0, -1);&#125;private int dfs(int index, int lastChoosed) &#123; if (index == nums.length) return 1; int res = 0; for (int i = 0; i &lt; nums.length; ++i) &#123; if (visited[i]) continue; if (lastChoosed != -1 &amp;&amp; nums[lastChoosed] == nums[i] &amp;&amp; !visited[i]) continue; if (lastChoosed == -1 || check(nums[lastChoosed], nums[i])) &#123; visited[i] = true; res = (res + dfs(index + 1, i)) % MOD; visited[i] = false; &#125; &#125; return res;&#125;int MOD = (int) (1e9 + 7);boolean[] visited;int[] nums;Map&lt;String, Integer&gt; dp;private boolean check(int a, int b) &#123; return (a % b == 0) || (b % a == 0);&#125; 方法二：记忆化搜索 + 状态压缩 先看题解 举例 nums = [2, 3, 6, 6] 2，6，3，6 3，6，2，6 6，2，6，3 6，3，6，2 2，6，6，3 3，6，6，2 其中2，6，6，3与6，2，6，3可以使用记忆化搜索 [2，6]，6，3与[6，2]，6，3, 下标为2的6前[2, 6]与[6,2]是同一个组合(不考虑顺序) 只要下标为i(2)是相同的数(6)，并且前i个数是同一个组合，那么在i之后是重复计算 计算过[2，6]，6后，再遇到[6，2]，6，只要返回map里的值就行 状态压缩 u | (1 &lt;&lt; i)存储的是数组下标，初始u = 0。 | 是或运算, 1 &lt;&lt; i 将1左移i位 例如，将2(下标0)存入u中， 初始u = 0000, 0000 | (1 &lt;&lt; 0) = 0001 将6(下标1)存入u中 u = 0001 0001 | (1 &lt;&lt; 1) = 0011 将[2, 6]存入u中 u = 0011 == 将[6, 2]存入u中u = 0011 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public int specialPerm(int[] nums) &#123; this.nums = nums; visited = new boolean[nums.length]; dp = new HashMap&lt;&gt;(); Arrays.sort(nums); return dfs(0, -1, 0); &#125; private int dfs(int index, int lastChoosed, int u) &#123; if (index == nums.length) return 1; String key = lastChoosed + &quot;#&quot; + u; if (dp.containsKey(key)) return dp.get(key); int res = 0; for (int i = 0; i &lt; nums.length; ++i) &#123; if (visited[i]) continue; // 去重，这道题可以不要这段if if (lastChoosed != -1 &amp;&amp; nums[lastChoosed] == nums[i] &amp;&amp; !visited[i]) continue; if (lastChoosed == -1 || check(nums[lastChoosed], nums[i])) &#123; visited[i] = true; res = (res + dfs(index + 1, i, (u | (1 &lt;&lt; i)))) % MOD; visited[i] = false; &#125; &#125; dp.put(key, res); return res; &#125; int MOD = (int) (1e9 + 7); boolean[] visited; int[] nums; Map&lt;String, Integer&gt; dp; private boolean check(int a, int b) &#123; return (a % b == 0) || (b % a == 0); &#125;&#125; 给墙壁刷油漆 方法一：记忆化搜索 dfs(int index, int leftTime) index是遍历到的cost的下标，leftTime是可以白嫖的次数(1单位时间白嫖1次) 付费：dfs(index + 1, leftTime + time[index]) + cost[index]; 白嫖：dfs(index + 1, leftTime - 1); 初始化：dp = new int[n][2 * n]; leftTime可能是负数而且最小-n 剪枝：如果白嫖次数大于等于剩余需要刷漆的次数，那么全部白嫖的花费最小 12if (leftTime &gt;= n - index) return 0; 代码 123456789101112131415161718192021222324252627class Solution &#123; public int paintWalls(int[] cost, int[] time) &#123; n = cost.length; this.cost = cost; this.time = time; dp = new int[n][2 * n]; for (int[] arr : dp) Arrays.fill(arr, -1); return dfs(0, 0); &#125; private int dfs(int index, int leftTime) &#123; if (index == n) return leftTime &gt;= 0 ? 0 : Integer.MAX_VALUE / 2; if (leftTime &gt;= n - index) return 0; if (dp[index][leftTime + n] != -1) return dp[index][leftTime + n]; int pay = dfs(index + 1, leftTime + time[index]) + cost[index]; int free = dfs(index + 1, leftTime - 1); return dp[index][leftTime + n] = Math.min(pay, free); &#125; int[] cost, time; int[][] dp; int n;&#125;","categories":[],"tags":[]},{"title":"lcpBi107","slug":"lcpBi107","date":"2023-07-04T01:29:10.000Z","updated":"2023-07-04T07:15:05.085Z","comments":true,"path":"2023/07/04/lcpBi107/","link":"","permalink":"https://leopol1d.github.io/2023/07/04/lcpBi107/","excerpt":"","text":"最大字符串配对数目 方法一：记忆化搜索 123456789101112131415161718192021222324class Solution &#123; public int longestString(int x, int y, int z) &#123; dp = new HashMap&lt;&gt;(); return dfs(x, y, z, &#x27; &#x27;); // AA BB AB &#125; Map&lt;String, Integer&gt; dp; private int dfs(int x, int y, int z, char lastChar) &#123; if (x == 0 &amp;&amp; y == 0 &amp;&amp; z == 0) return 0; String key = x + &quot;,&quot; + y + &quot;,&quot; + z + &quot;,&quot; + lastChar; if (dp.containsKey(key)) return dp.get(key); int max = 0; if (x &gt; 0 &amp;&amp; lastChar != &#x27;A&#x27;) max = Math.max(max, dfs(x - 1, y, z, &#x27;A&#x27;) + 2); if (y &gt; 0 &amp;&amp; lastChar != &#x27;B&#x27;) max = Math.max(max, dfs(x, y - 1, z, &#x27;B&#x27;) + 2); if (z &gt; 0 &amp;&amp; lastChar != &#x27;A&#x27;) max = Math.max(max, dfs(x, y, z - 1, &#x27;B&#x27;) + 2); dp.put(key, max); return max; &#125;&#125; 方法二：记忆化搜索 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455```## 字符串连接删减字母![ ](https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230704113929490.png)### 方法一：记忆化搜索[题解](https://leetcode.cn/problems/decremental-string-concatenation/solutions/1/hui-su-ji-yi-hua-sou-suo-java-by-tailtal-dmix/)1. 如果当前要合并的单词为words[index]，并且已合并单词str的首尾字符分别为first，last，记words[index]的首尾字符分别为first2, last2。2. 现在有两种拼接方式： 1. str + words[index] ： - 如果last == first2，那么**拼接成新字符串长度的增量**为len1 = words[index].length() - 1 - 否则，**拼接成新字符串长度的增量**为len1 = words[index].length() 2. words[index] + str - 如果last2 == first，那么**拼接成新字符串长度的增量**为len2 = words[index].length() - 1 - 否则，**拼接成新字符串长度的增量**为len2 = words[index].length() 3. 取min(len1, len2)，存入map中，key为index + &quot;,&quot; + first + &quot;,&quot; + last 4. 在下次遍历到相同index，first，last的时候，**虽然已合并单词str的长度可能不同，但是字符串长度增量是相同的！**```javaclass Solution &#123; public int minimizeConcatenatedLength(String[] words) &#123; this.words = words; n = words.length; dp = new HashMap&lt;&gt;(); int res = dfs(1, words[0].charAt(0), words[0].charAt(words[0].length() - 1)) + words[0].length(); return res; &#125; String[] words; int n; Map&lt;String, Integer&gt; dp; private int dfs(int index, char first, char last) &#123; if (index == n) return 0; String key = index + &quot;,&quot; + first + &quot;,&quot; + last; if (dp.containsKey(key)) return dp.get(key); char first2 = words[index].charAt(0), last2 = words[index].charAt(words[index].length() - 1); int min = Integer.MAX_VALUE; // first插入到words[index]后面 int res1 = dfs(index + 1, first2, last); min = Math.min(min, res1 + words[index].length() - (first == last2 ? 1 : 0)); // last插入到words[index]前面 int res2 = dfs(index + 1, first, last2); min = Math.min(min, res2 + words[index].length() - (last == first2 ? 1 : 0)); dp.put(key, min); return min; &#125;&#125; 统计没有收到请求的服务器数目 方法一：模拟(超时) 123456789101112131415161718192021222324252627class Solution &#123; public int[] countServers(int n, int[][] logs, int x, int[] queries) &#123; int[] res = new int[queries.length]; int maxTime = 0; for (int q : queries) maxTime = Math.max(maxTime, q); int[][] arr = new int[n + 1][(int) 1e6]; for (int[] log : logs) &#123; arr[log[0]][log[1]] = 1; &#125; for (int k = 0; k &lt; queries.length; ++k) &#123; int right = queries[k], left = right - x; for (int i = 1; i &lt;= n; ++i) &#123; boolean flag = false; for (int j = left; j &lt;= right; ++j) &#123; if (arr[i][j] == 1) &#123; flag = true; break; &#125; &#125; if (!flag) ++res[k]; &#125; &#125; return res; &#125;&#125;","categories":[],"tags":[]},{"title":"lcp351","slug":"lcp351","date":"2023-07-03T06:04:33.000Z","updated":"2023-07-04T03:39:40.777Z","comments":true,"path":"2023/07/03/lcp351/","link":"","permalink":"https://leopol1d.github.io/2023/07/03/lcp351/","excerpt":"","text":"美丽下标对的数目 123456789101112131415161718192021222324252627class Solution &#123; public int countBeautifulPairs(int[] nums) &#123; int res = 0; for (int i = 0; i &lt; nums.length; ++i) for (int j = i + 1; j &lt; nums.length; ++j) if (check(i, j, nums)) ++res; return res; &#125; private boolean check(int i, int j, int[] nums) &#123; int num1 = nums[i], num2 = nums[j]; char ch1 = String.valueOf(num1).charAt(0); String str = String.valueOf(num2); char ch2 = str.charAt(str.length() - 1); int l = Integer.parseInt(String.valueOf(ch1)), r = Integer.parseInt(String.valueOf(ch2)); int small = l &lt; r ? l : r; int great = l &gt; r ? l : r; if (small == 1) return true; for (int k = 2; k &lt;= small; ++k) &#123; if (small % k == 0 &amp;&amp; great % k == 0) return false; &#125; return true; &#125;&#125; 得到整数零需要执行的最少操作数 123456789101112131415161718class Solution &#123; public int makeTheIntegerZero(int num1, int num2) &#123; /** * 1. 从小到大枚举答案 * 2. 假设操作次数为 k * 则问题变为：x = num1 - k * num2 能不能是k个2^i之和 * 能的话就立即返回结果 * 3. 如果x.bitCount &lt;= k，那么一定可以是k个2^i之和 * 对于循环退出条件，那么如果num2 &lt; 0, 那么当 x &lt; k，再增大k只会让x越来越小，此时肯定要结束循环 * 若num2 &lt; 0，因为num2只能是-1 -2 -3...这样，也就是说若k + 1，则x 会增加 -num2，也就是说至少也会+1 * 则k永远无法追上x，此时也要结束循环 */ for (long k = 1; k &lt;= num1 - k * num2; k++) &#123; if (k &gt;= Long.bitCount(num1 - k * num2)) return (int)k; &#125; return -1; &#125;&#125; 将数组划分成若干好子数组的方式 123456789101112131415161718192021222324252627class Solution &#123; public int numberOfGoodSubarraySplits(int[] nums) &#123; // &#123;0,1,|0,0,1|,0,0,1,0&#125; // &#123;0,1,|0,0,1,0|,0,1,0&#125; // &#123;0,1,|0,0,1,0,0|,1,0&#125; // &#123;0,1,0,|0,1|,0,0,1,0&#125; // &#123;0,1,0,|0,1,0|,0,1,0&#125; // &#123;0,1,0,|0,1,0,0|,1,0&#125; // &#123;0,1,0,0,|1,|0,0,1,0&#125; // &#123;0,1,0,0,|1,0,|0,1,0&#125; // &#123;0,1,0,0,|1,0,0,|1,0&#125; final long MOD = (long) 1e9 + 7; List&lt;Integer&gt; list = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; nums.length; ++i) if (nums[i] == 1) list.add(i); int[] interval = list.stream().mapToInt(i -&gt; i).toArray(); if (interval.length == 0) return 0; long res = 1; for (int i = 1; i &lt; interval.length; ++i) res = (res * (interval[i] - interval[i - 1])) % MOD; return (int) res; &#125;&#125; 机器人碰撞 方法一：栈模拟 类似于735. 行星碰撞 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123; public List&lt;Integer&gt; survivedRobotsHealths(int[] positions, int[] healths, String directions) &#123; int n = positions.length; Map&lt;Integer, Integer&gt; posToIdx = new HashMap&lt;&gt;(), posToHealth = new HashMap&lt;&gt;(); Map&lt;Integer, Character&gt; posToDir = new HashMap&lt;&gt;(); for (int i = 0; i &lt; n; ++i) &#123; posToIdx.put(positions[i], i); posToHealth.put(positions[i], healths[i]); posToDir.put(positions[i], directions.charAt(i)); &#125; Arrays.sort(positions); Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for (int i = 0; i &lt; n; ++i) &#123; boolean alive = true; char dir = posToDir.get(positions[i]); while (alive &amp;&amp; !stack.isEmpty() &amp;&amp; dir == &#x27;L&#x27; &amp;&amp; posToDir.get(stack.peek()) == &#x27;R&#x27; ) &#123; int topPos = stack.peek(); int topHealth = posToHealth.get(topPos); if (posToHealth.get(positions[i]) &gt; topHealth) &#123; stack.pop(); posToHealth.put(positions[i], posToHealth.get(positions[i]) - 1); &#125; else if (posToHealth.get(positions[i]) &lt; topHealth) &#123; alive = false; posToHealth.put(topPos, posToHealth.get(topPos) - 1); &#125; else &#123; //== alive = false; stack.pop(); &#125; &#125; if (alive) stack.push(positions[i]); &#125; int[] newHealths = new int[n]; while (!stack.isEmpty()) &#123; int pos = stack.pop(); int index = posToIdx.get(pos), health = posToHealth.get(pos); newHealths[index] = health; &#125; List&lt;Integer&gt; survivor = new LinkedList&lt;&gt;(); for (int x : newHealths) if (x != 0) survivor.add(x); return survivor; &#125;&#125; ​","categories":[],"tags":[]},{"title":"lcp346","slug":"lcp346","date":"2023-07-01T06:47:34.000Z","updated":"2023-07-03T05:03:29.683Z","comments":true,"path":"2023/07/01/lcp346/","link":"","permalink":"https://leopol1d.github.io/2023/07/01/lcp346/","excerpt":"","text":"链接 2696. 删除子串后的字符串最小长度 方法一：暴力枚举 12345678910111213141516171819202122232425262728293031323334class Solution &#123; public int minLength(String s) &#123; int res = s.length(); int[] last = new int[s.length()]; int lastIndex = -1; for (int i = 1; i &lt; s.length(); ++i) &#123; char ch1 = s.charAt(i - 1), ch2 = s.charAt(i); if (ch1 == &#x27;A&#x27; || ch1 == &#x27;C&#x27;) &#123; if (ch2 != &#x27;B&#x27; &amp;&amp; ch2 != &#x27;D&#x27;) &#123; last[++lastIndex] = i - 1; &#125; else if ((ch1 == &#x27;A&#x27; &amp;&amp; ch2 == &#x27;B&#x27;) || (ch1 == &#x27;C&#x27; &amp;&amp; ch2 == &#x27;D&#x27;)) &#123; res -= 2; int step = 1; for (int r = i + 1; lastIndex &gt;= 0 &amp;&amp; r &lt; s.length(); ++r) &#123; char ch3 = s.charAt(last[lastIndex]), ch4 = s.charAt(r); if ((ch3 == &#x27;A&#x27; &amp;&amp; ch4 == &#x27;B&#x27;) || (ch3 == &#x27;C&#x27; &amp;&amp; ch4 == &#x27;D&#x27;)) &#123; res -= 2; ++step; --lastIndex; &#125; else &#123; i += step; break; &#125; &#125; &#125; &#125; else &#123; // ch1 != AC lastIndex = -1; &#125; &#125; return res; &#125;&#125; 方法二：栈 12345678910111213class Solution &#123; public int minLength(String s) &#123; Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); for (int i = 0; i &lt; s.length(); ++i) &#123; char ch = s.charAt(i); if (!stack.isEmpty() &amp;&amp; ((stack.peek() == &#x27;A&#x27; &amp;&amp; ch == &#x27;B&#x27;) || (stack.peek() == &#x27;C&#x27; &amp;&amp; ch == &#x27;D&#x27;))) stack.pop(); else stack.push(ch); &#125; return stack.size(); &#125;&#125; 2697. 字典序最小回文串 方法一：DP(超时) 1234567891011121314151617181920212223class Solution &#123; public String makeSmallestPalindrome(String s) &#123; int n = s.length(); String[][] dp = new String[n][n]; for (int i = 0; i &lt; n; ++i) &#123; char chI = s.charAt(i); for (int j = 0; j &lt;= i; ++j) &#123; char chJ = s.charAt(j); char small = chJ - chI &lt; 0 ? chJ : chI; if (i == j) dp[j][i] = String.valueOf(chI); else if (i - j == 1) dp[j][i] = String.valueOf(small) + small; else if (i - j == 2) dp[j][i] = String.valueOf(small) + s.charAt(j + 1) + small; else &#123; dp[j][i] = String.valueOf(small) + dp[j + 1][i - 1] + small; &#125; &#125; &#125; return dp[0][n - 1]; &#125;&#125; 方法二：贪心 1234567891011class Solution &#123; public String makeSmallestPalindrome(String s) &#123; char[] arr = s.toCharArray(); for (int i = 0, j = s.length() - 1; i &lt; j; ++i, --j) &#123; char small = arr[i] &lt; arr[j] ? arr[i] : arr[j]; arr[i] = small; arr[j] = small; &#125; return new String(arr); &#125;&#125; 求一个整数的惩罚数 方法一：回溯 123456789101112131415161718192021222324252627282930313233class Solution &#123; public int punishmentNumber(int n) &#123; int res = 0; for (int i = 1; i &lt;= n; ++i) &#123; if (check(i)) res += i * i; &#125; return res; &#125; private boolean check(int x) &#123; path.clear(); return dfs(x, String.valueOf(x * x), 0); &#125; Deque&lt;String&gt; path = new LinkedList&lt;&gt;(); private boolean dfs(int x, String str, int index) &#123; if (index == str.length()) &#123; int sum = 0; for (String s : path) sum += Integer.parseInt(s); return sum == x; &#125; for (int i = index; i &lt; str.length(); ++i) &#123; String sub = str.substring(index, i + 1); path.offerLast(sub); if (dfs(x, str, i + 1)) return true; path.pollLast(); &#125; return false; &#125;&#125; 修改图中的边权 方法一： 1","categories":[],"tags":[]},{"title":"microsoft","slug":"microsoft","date":"2023-06-28T07:33:03.000Z","updated":"2023-06-28T09:59:16.974Z","comments":true,"path":"2023/06/28/microsoft/","link":"","permalink":"https://leopol1d.github.io/2023/06/28/microsoft/","excerpt":"","text":"236. 二叉树的最近公共祖先 使用DFS解决 124. 二叉树中的最大路径和 215. 数组中的第K个最大元素 297. 二叉树的序列化与反序列化 方法一：DFS 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Codec &#123; // Encodes a tree to a single string. public String serialize(TreeNode root) &#123; if (root == null) return &quot;#&quot;; String left = serialize(root.left); String right = serialize(root.right); return root.val + &quot;,&quot; + left + &quot;,&quot; + right; &#125; // Decodes your encoded data to tree. public TreeNode deserialize(String data) &#123; String[] nodes = data.split(&quot;,&quot;); return dfs(nodes); &#125; int i = 0; public TreeNode dfs(String[] nodes) &#123; String str = nodes[i++]; if (str.equals(&quot;#&quot;)) return null; TreeNode root = new TreeNode(Integer.valueOf(str)); root.left = dfs(nodes); root.right = dfs(nodes); return root; &#125;&#125;// Your Codec object will be instantiated and called as such:// Codec ser = new Codec();// Codec deser = new Codec();// TreeNode ans = deser.deserialize(ser.serialize(root)); 为什么左边的代码不行，因为如何nodes[i]是节点，i没有自增！ 206. 反转链表","categories":[],"tags":[]},{"title":"Package Problem","slug":"package-problem","date":"2023-06-26T02:52:41.000Z","updated":"2023-06-26T05:39:31.714Z","comments":true,"path":"2023/06/26/package-problem/","link":"","permalink":"https://leopol1d.github.io/2023/06/26/package-problem/","excerpt":"","text":"dp数组的初始化、状态转移方程、遍历顺序至关重要 其中的关键是状态转移方程，初始化以及遍历顺序都由状态转移方程确定 01背包 01背包-二维dp数组(m行) 代码 12345678910111213141516171819202122232425262728293031323334353637383940package 背包;public class bag01_2d &#123; public static void main(String[] args) &#123; int[] weight = &#123;4, 1, 3&#125;; int[] value = &#123;30, 15, 20&#125;; int capacity = 4; int res = calcMaxValue(weight, value, capacity); System.out.println(&quot;res: &quot; + res); &#125; private static int calcMaxValue(int[] weight, int[] value, int capacity) &#123; int[][] dp = new int[weight.length][capacity + 1]; /* * dp[i][j]:容量为j的背包，在物品0~i中任选，能获得的最大价值 * 状态转移；if(j &gt;= weight[i]) dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]) 选物品i或不选物品i * else dp[i][j] = dp[i - 1][j] 不选物品i * 初始化：由状态转移可以看出，dp[i][j]依赖于dp[i - 1][j]，所以需要初始化第0行 * 第0行：选择物品0.如果j &gt; weight[0]，dp[0][j] = value[0] * 第0列：背包容量为0，什么都装不下，dp[i][0] = 0 * */ for (int j = 0; j &lt;= capacity; ++j) dp[0][j] = j &gt;= weight[0] ? value[0] : 0; for (int i = 1; i &lt; weight.length; ++i) &#123; for (int j = 1; j &lt;= capacity; ++j) &#123; if (j &gt;= weight[i]) dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); else dp[i][j] = dp[i - 1][j]; &#125; &#125; for (int i = 0; i &lt; weight.length; ++i) &#123; for (int j = 0; j &lt;= capacity; ++j) System.out.print(dp[i][j] + &quot;\\t&quot;); System.out.println(); &#125; System.out.println(); return dp[weight.length - 1][capacity]; &#125;&#125; 输出 123450 0 0 0 30 0 15 15 15 30 0 15 15 20 35 res: 35 01背包-二维dp数组(两行) 状态转移： 1234if(j &gt;= weight[i]) dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]) 选物品i或不选物品ielse dp[i][j] = dp[i - 1][j] 不选物品i 可以看出dp[i][j]只可能被dp[i - 1][j]和dp[i - 1][j - weight[i]]推导出，也就是说第i行只与第i - 1行关联，那么dp数组只需要用两行 与使用m行的代码相比，只需要将dp数组更改为2行，dp[i]与dp[i - 1]改为dp[i % 2]与dp[(i - 1) % 2] 初始化后(遍历完第0个物品后)的dp数组为 120 0 0 0 30 0 0 0 0 0 遍历完第1个物品后的dp数组为 120 0 0 0 30 0 15 15 15 30 遍历第2个物品时，只需要遍历第1个物品的dp数据，不需要遍历第0个物品的dp数据，所以把遍历第2个物品的dp数据覆盖在第0行 120 0 0 20 35 0 15 15 15 30 代码 1234567891011121314151617181920212223242526272829package 背包;public class bag01_2d &#123; public static void main(String[] args) &#123; int[] weight = &#123;4, 1, 3&#125;; int[] value = &#123;30, 15, 20&#125;; int capacity = 4; int res = calcMaxValue(weight, value, capacity); System.out.println(&quot;res: &quot; + res); &#125; private static int calcMaxValue(int[] weight, int[] value, int capacity) &#123; int[][] dp = new int[2][capacity + 1]; for (int j = 0; j &lt;= capacity; ++j) dp[0][j] = j &gt;= weight[0] ? value[0] : 0; for (int i = 1; i &lt; weight.length; ++i) &#123; for (int j = weight[i]; j &lt;= capacity; ++j) &#123; dp[i % 2][j] = Math.max(dp[(i - 1) % 2][j], dp[(i - 1) % 2][j - weight[i]] + value[i]); &#125; &#125; for (int i = 0; i &lt; 2; ++i) &#123; for (int j = 0; j &lt;= capacity; ++j) System.out.print(dp[i][j] + &quot;\\t&quot;); System.out.println(); &#125; System.out.println(); return dp[(weight.length - 1) % 2][capacity]; &#125;&#125; 输出 12340 0 0 20 35 0 15 15 15 30 res: 35 01背包-滚动数组(一维dp数组) 两行能搞定，一行也行！ 现在使用一维dp数组 1int[] dp = new int[capacity + 1]; 回顾一下使用二维dp数组是如何填表的 1234560 0 0 0 30 0 15 15 15 30 0 15 15 20 35 // int[] weight = &#123;4, 1, 3&#125;;// int[] value = &#123;30, 15, 20&#125;;// int capacity = 4; 直接看第二行最后一个元素35(此时i = 2, j = 4)，它是由dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);更新 dp[i - 1][j - weight[i]] = dp[1][1] = 15, value[i] = 20 35是由左上方的15加上value[2]得到的 所以使用一维滚动数组，在更新dp[4]的时候(相对于两维数组是要更新dp[2][4])， 需要上一行的dp[1](相对于二维dp数组是dp[1][1])， 那么j的遍历顺序一定要从后往前！否则(从前往后)，dp[1]是二维dp数组中dp[2][1]的数据 1for (int j = capacity; j &gt;= weight[i]; --j) 代码 初始化为0即可 12345678910111213141516171819202122232425package 背包;public class bag01 &#123; public static void main(String[] args) &#123; int[] weight = &#123;4, 1, 3&#125;; int[] value = &#123;30, 15, 20&#125;; int capacity = 4; int res = calcMaxValue(weight, value, capacity); System.out.println(res); &#125; private static int calcMaxValue(int[] weight, int[] value, int capacity) &#123; int[] dp = new int[capacity + 1]; for (int i = 0; i &lt; weight.length; ++i) for (int j = capacity; j &gt;= weight[i]; --j) dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]); for (int j = 0; j &lt;= capacity; j++)&#123; System.out.print(dp[j] + &quot; &quot;); &#125; return dp[capacity]; &#125;&#125; 输出 10 15 15 20 35 35","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://leopol1d.github.io/categories/Algorithms/"},{"name":"Dynamic Programming","slug":"Algorithms/Dynamic-Programming","permalink":"https://leopol1d.github.io/categories/Algorithms/Dynamic-Programming/"}],"tags":[{"name":"动态规划,背包问题","slug":"动态规划-背包问题","permalink":"https://leopol1d.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"}]},{"title":"Sort","slug":"sort","date":"2023-06-12T07:52:25.000Z","updated":"2023-06-13T02:56:46.388Z","comments":true,"path":"2023/06/12/sort/","link":"","permalink":"https://leopol1d.github.io/2023/06/12/sort/","excerpt":"","text":"贪心是一种思想，使用贪心思想解决的问题，如果能被总结成具体某一类问题，那么就有具体的名字，比如单源最短路问题，最小生成树问题，拓扑排序问题，如果不能被总结出来，那它就叫贪心问题哈哈。 贪心问题经常需要借助排序来实现。 快速排序 取一个随机值作为下标，与最后一个位置交换 small始终指向最后一个小于pivot的下标，初始为start - 1 从start开始遍历，不需要遍历最后一个数(特殊处理) 当nums[i] &lt; nums[end]，将small前移，并且交换i与small 退出循环后，将small前移，与最后一个位置的数(pivot)交换 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445package sort;import java.util.Random;public class test &#123; public int[] sortArray(int[] nums) &#123; quickSort(nums, 0, nums.length - 1); return nums; &#125; public void quickSort(int[] nums, int start, int end) &#123; if (start &lt; end) &#123; // 递归到子数组只有一个数字为止 int pivot = partition(nums, start, end); quickSort(nums, start, pivot - 1); quickSort(nums, pivot + 1, end); &#125; &#125; private int partition(int[] nums, int start, int end) &#123; int random = new Random().nextInt(end - start + 1) + start; // nextInt左闭右开 swap(nums, random, end); int small = start - 1; for (int i = start; i &lt; end; ++i) // end存放的是pivot，退出循环特殊处理 if (nums[i] &lt; nums[end]) swap(nums, ++small, i); swap(nums, end, ++small); return small; &#125; private void swap(int[] nums, int index1, int index2) &#123; if (index1 == index2) return; int temp = nums[index1]; nums[index1] = nums[index2]; nums[index2] = temp; &#125; public static void main(String[] args) &#123; test t = new test(); int[] arr = new int[]&#123;3,5,8,10,34,1,544,-13&#125;; t.sortArray(arr); for (int x : arr) System.out.print(x + &quot; &quot;); &#125;&#125; 计数排序 计数排序是一种线性时间的整数排序算法。如果数组的长度为n，整数范围(数组中最大整数与最小整数的差值)为k对于k远小于n的场景(如对某公司所有员工的年龄排序)，那么计数排序的时间复杂度优于其他基于比较的排序算法(如归并排序、快速排序)， 三次遍历！ 遍历原始数组nums，得出最大值max与最小值min，并创建大小为max - min + 1的count数组 遍历nums数组，把对应整数num出现的次数记录在count数组的count[num - min]中 令num从min遍历到max，将num顺序填入nums中(每个num有count[num - min]个) 代码 123456789101112131415public int[] sortArray(int[] nums) &#123; int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE; for (int num : nums) &#123; min = Math.min(min, num); max = Math.max(max, num); &#125; int[] count = new int[max - min + 1]; for (int num : nums) ++count[num - min]; int i = 0; for (int num = min; num &lt;= max; ++num) while (count[num - min]-- &gt; 0) nums[i++] = num; return nums;&#125; 剑指 Offer II 074. 合并区间 方法一：射气球的思路 首先将数组按照左边界升序排序 当intervals[i][1] &gt;= intervals[j][0]，那么这两个元素一定是要合并的，因为是intervals数组是按照左边界升序排序的，那么合并区间[a, b]的a一定是intervals[i][0]，将intervals[i][1]赋值为intervals[i][1]与intervals[j][1]的最大值 当intervals[i][1] &lt; intervals[j][0]，那么这个两个区间是不重合的，先把上一个重合区间加入结果集，再把j赋值给i，进行下一轮循环 当j == intervals.length - 1时候， 如果intervals[i][1] &gt;= intervals[j][0]，那么会将intervals[i][1]取intervals[i][1]与intervals[j][1]的最大值 如果intervals[i][1] &lt; intervals[j][0]，那么会将之前的重合区间存入结果集，并将j赋值给i 所以出循环，只需要把intervals[i]加入结果集就好！ 1234567891011121314151617class Solution &#123; public int[][] merge(int[][] intervals) &#123; Arrays.sort(intervals, (o1, o2) -&gt; Integer.compare(o1[0], o2[0])); List&lt;int[]&gt; list = new LinkedList&lt;&gt;(); int i = 0; for (int j = 1; j &lt; intervals.length; ++j) &#123; if (intervals[i][1] &gt;= intervals[j][0]) intervals[i][1] = Math.max(intervals[i][1], intervals[j][1]); else &#123; list.add(new int[]&#123;intervals[i][0], intervals[i][1]&#125;); i = j; &#125; &#125; list.add(new int[]&#123;intervals[i][0], intervals[i][1]&#125;); return list.toArray(new int[list.size()][]); &#125;&#125; 剑指 Offer II 075. 数组相对排序 数据范围是[0, 1000]，创建大小为1001的count数组 统计arr1中出现整数的个数 按照arr2整数出现的顺序填arr1数组 从0到1000(升序)，把剩下的数组填入arr1数组 123456789101112131415class Solution &#123; public int[] relativeSortArray(int[] arr1, int[] arr2) &#123; int[] count = new int[1001]; for (int num : arr1) ++count[num]; int i = 0; for (int num : arr2) while (count[num]-- &gt; 0) arr1[i++] = num; for (int num = 0; num &lt;= 1000; ++num) while (count[num]-- &gt; 0) arr1[i++] = num; return arr1; &#125;&#125; 剑指 Offer II 076. 数组中的第 k 大的数字 快排找到下标为n-k的数x，左边的数都小于x，右边的数都大于x 12345678910111213141516171819202122232425262728293031323334class Solution &#123; public int findKthLargest(int[] nums, int k) &#123; int n = nums.length, target = n - k, start = 0, end = n - 1; int pivot = partition(nums, start, end); while (pivot != target) &#123; if (pivot &gt; target) end = pivot - 1; else start = pivot + 1; pivot = partition(nums, start, end); &#125; return nums[pivot]; &#125; private int partition(int[] nums, int start, int end) &#123; int random = new Random().nextInt(end - start + 1) + start; swap(nums, random, end); int small = start - 1; for (int i = start; i &lt; end; ++i) if (nums[i] &lt; nums[end]) swap(nums, ++small, i); swap(nums, ++small, end); return small; &#125; private void swap(int[] nums, int index1, int index2) &#123; if (index1 == index2) return; int temp = nums[index1]; nums[index1] = nums[index2]; nums[index2] = temp; &#125; &#125;","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://leopol1d.github.io/categories/Algorithms/"},{"name":"Sort","slug":"Algorithms/Sort","permalink":"https://leopol1d.github.io/categories/Algorithms/Sort/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://leopol1d.github.io/tags/%E6%8E%92%E5%BA%8F/"},{"name":"贪心","slug":"贪心","permalink":"https://leopol1d.github.io/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"Sliding Window","slug":"sliding-window","date":"2023-06-10T04:07:54.000Z","updated":"2023-06-10T15:02:46.935Z","comments":true,"path":"2023/06/10/sliding-window/","link":"","permalink":"https://leopol1d.github.io/2023/06/10/sliding-window/","excerpt":"","text":"滑动窗口主要解决满足某个条件的连续子串问题，因为我们枚举 区间、子数组、子串问题的时候时间复杂度是\\(O(n^2)\\)，使用滑窗可以将时间复杂度优化至\\(O(n)\\)。 优质题解 3. 无重复字符的最长子串 left = Math.max(left , map.get(s.charAt(i))+1);十分tricky，举例 abba 当遍历到第二个a的时候，此时的left指向第二个b，right指向第二个a，字符出现重复，所以要更新left，往map里一查，之前出现的a下标比left还小，说明当前记录的最长不重复子串就不包含第一个a，所以left不变 然后不管出没出现重复字符，都要执行 map.put(s.charAt(i) , i);如果字符串是abbab，当遍历到最后一个b的时候，left赋值为第二个b 的下标 + 1 的位置，也就是a下标的位置；如果出现重复字符就不执行map.put(s.charAt(i) , i)，那么此时b在map里记录的下标是第一个b的下标 123456789101112131415161718192021222324252627282930313233public int lengthOfLongestSubstring(String s) &#123; HashMap&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); int maxLen = 0;//用于记录最大不重复子串的长度 int left = 0;//滑动窗口左指针 for (int i = 0; i &lt; s.length() ; i++) &#123; /** 1、首先，判断当前字符是否包含在map中，如果不包含，将该字符添加到map（字符，字符在数组下标）, 此时没有出现重复的字符，左指针不需要变化。此时不重复子串的长度为：i-left+1，与原来的maxLen比较，取最大值； 2、如果当前字符 ch 包含在 map中，此时有2类情况： 1）当前字符包含在当前有效的子段中，如：abca，当我们遍历到第二个a，当前有效最长子段是 abc，我们又遍历到a， 那么此时更新 left 为 map.get(a)+1=1，当前有效子段更新为 bca； 2）当前字符不包含在当前最长有效子段中，如：abba，我们先添加a,b进map，此时left=0，我们再添加b，发现map中包含b， 而且b包含在最长有效子段中，就是1）的情况，我们更新 left=map.get(b)+1=2，此时子段更新为 b，而且map中仍然包含a，map.get(a)=0； 随后，我们遍历到a，发现a包含在map中，且map.get(a)=0，如果我们像1）一样处理，就会发现 left=map.get(a)+1=1，实际上，left此时 应该不变，left始终为2，子段变成 ba才对。 为了处理以上2类情况，我们每次更新left，left=Math.max(left , map.get(ch)+1). 另外，更新left后，不管原来的 s.charAt(i) 是否在最长子段中，我们都要将 s.charAt(i) 的位置更新为当前的i， 因此此时新的 s.charAt(i) 已经进入到 当前最长的子段中！ */ if(map.containsKey(s.charAt(i))) &#123; left = Math.max(left , map.get(s.charAt(i))+1); &#125; //不管是否更新left，都要更新 s.charAt(i) 的位置！ map.put(s.charAt(i) , i); maxLen = Math.max(maxLen , i-left+1); &#125; return maxLen; &#125; 30. 串联所有单词的子串 \"ling mind rabo ofoo owin gdin gbar rwin g monkeypoundcake\" [\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"] 187. 重复的DNA序列 方法一：暴搜(说是滑动窗口也行吧) 1234567891011121314class Solution &#123; public List&lt;String&gt; findRepeatedDnaSequences(String s) &#123; List&lt;String&gt; res = new LinkedList&lt;&gt;(); Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); for (int l = 0; l &lt;= s.length() - 10; ++l) &#123; String subStr = s.substring(l, l + 10); map.put(subStr, map.getOrDefault(subStr, 0) + 1); &#125; for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) if (entry.getValue() &gt; 1) res.add(entry.getKey()); return res; &#125;&#125; 一次循环也可 12345678910111213class Solution &#123; public List&lt;String&gt; findRepeatedDnaSequences(String s) &#123; List&lt;String&gt; res = new LinkedList&lt;&gt;(); Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); for (int l = 0; l &lt;= s.length() - 10; ++l) &#123; String subStr = s.substring(l, l + 10); map.put(subStr, map.getOrDefault(subStr, 0) + 1); if (map.getOrDefault(subStr, 0) == 2) res.add(subStr); &#125; return res; &#125;&#125; 76. 最小覆盖子串 方法一：滑动窗口(超时check部分) 12345678910111213141516171819202122232425262728293031class Solution &#123; public String minWindow(String s, String t) &#123; String res = &quot;&quot;; if (s.length() &lt; t.length()) return res; int minLen = 100000; int[] map = new int[256]; for (char ch : t.toCharArray()) ++map[ch - &#x27;A&#x27;]; for (int left = 0, i = 0; i &lt; s.length(); ++i) &#123; char ch = s.charAt(i); --map[ch - &#x27;A&#x27;]; while (i - left + 1 &gt;= t.length() &amp;&amp; check(map, t)) &#123; if (i - left + 1 &lt; minLen) &#123; res = s.substring(left, i + 1); minLen = i - left + 1; &#125; ++map[s.charAt(left) - &#x27;A&#x27;]; ++left; &#125; &#125; return res; &#125; private boolean check(int[] map, String t) &#123; for (char ch : t.toCharArray()) if (map[ch - &#x27;A&#x27;] &gt; 0) return false; return true; &#125;&#125; 把t提前转换好勉强能过，char[] arr = t.toCharArray(); 1234567891011121314151617181920212223242526272829303132class Solution &#123; public String minWindow(String s, String t) &#123; String res = &quot;&quot;; if (s.length() &lt; t.length()) return res; char[] arr = t.toCharArray(); int minLen = 100000; int[] map = new int[128]; for (char ch : arr) ++map[ch - &#x27;A&#x27;]; for (int left = 0, i = 0; i &lt; s.length(); ++i) &#123; char ch = s.charAt(i); --map[ch - &#x27;A&#x27;]; while (i - left + 1 &gt;= t.length() &amp;&amp; check(map, arr)) &#123; if (i - left + 1 &lt; minLen) &#123; res = s.substring(left, i + 1); minLen = i - left + 1; &#125; ++map[s.charAt(left) - &#x27;A&#x27;]; ++left; &#125; &#125; return res; &#125; private boolean check(int[] map, char[] arr) &#123; for (char ch : arr) if (map[ch - &#x27;A&#x27;] &gt; 0) return false; return true; &#125;&#125; 209. 长度最小的子数组 12345678910111213class Solution &#123; public int minSubArrayLen(int target, int[] nums) &#123; int sum = 0, minLen = 100001; for (int left = 0, right = 0; right &lt; nums.length; ++right) &#123; sum += nums[right]; while (sum &gt;= target) &#123; minLen = Math.min(minLen, right - left + 1); sum -= nums[left++]; &#125; &#125; return minLen == 100001 ? 0 : minLen; &#125;&#125; 567. 字符串的排列 方法一：滑动窗口 123456789101112131415161718192021222324class Solution &#123; public boolean checkInclusion(String s1, String s2) &#123; int[] map = new int[26]; for (char ch : s1.toCharArray()) ++map[ch - &#x27;a&#x27;]; for (int left = 0, right = 0; right &lt; s2.length(); ++right) &#123; --map[s2.charAt(right) - &#x27;a&#x27;]; if (right - left + 1 &gt;= s1.length()) &#123; if (check(map, s1)) return true; ++map[s2.charAt(left++) - &#x27;a&#x27;]; &#125; &#125; return false; &#125; private boolean check(int[] map, String s) &#123; for (char ch : s.toCharArray()) if (map[ch - &#x27;a&#x27;] != 0) return false; return true; &#125; &#125; 1208. 尽可能使字符串相等 方法一：滑动窗口 123456789101112class Solution &#123; public int equalSubstring(String s, String t, int maxCost) &#123; int maxLen = 0, cost = 0; for (int left = 0, i = 0; i &lt; s.length() &amp;&amp; i &lt; t.length(); ++i) &#123; cost += Math.abs(s.charAt(i) - t.charAt(i)); while (left &lt;= i &amp;&amp; cost &gt; maxCost) cost -= Math.abs(Math.abs(s.charAt(left) - t.charAt(left++))); maxLen = Math.max(maxLen, i - left + 1); &#125; return maxLen; &#125;&#125;","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://leopol1d.github.io/categories/Algorithms/"},{"name":"Sliding Window","slug":"Algorithms/Sliding-Window","permalink":"https://leopol1d.github.io/categories/Algorithms/Sliding-Window/"}],"tags":[{"name":"滑动窗口","slug":"滑动窗口","permalink":"https://leopol1d.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"}]},{"title":"Trie","slug":"trie","date":"2023-06-06T08:38:03.000Z","updated":"2023-06-08T08:12:45.454Z","comments":true,"path":"2023/06/06/trie/","link":"","permalink":"https://leopol1d.github.io/2023/06/06/trie/","excerpt":"","text":"前缀树主要用于解决与字符串查找相关d 剑指 Offer II 062. 实现前缀树 方法一：前缀树 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Trie &#123; static class TrieNode &#123; private TrieNode[] children = new TrieNode[26]; private boolean isWord; &#125; /** Initialize your data structure here. */ private TrieNode root = new TrieNode(); /** Inserts a word into the trie. */ public void insert(String word) &#123; TrieNode node = root; for (char ch : word.toCharArray()) &#123; if (node.children[ch - &#x27;a&#x27;] == null) node.children[ch - &#x27;a&#x27;] = new TrieNode(); node = node.children[ch - &#x27;a&#x27;]; &#125; node.isWord = true; &#125; /** Returns if the word is in the trie. */ public boolean search(String word) &#123; TrieNode node = root; for (char ch : word.toCharArray()) &#123; if (node.children[ch - &#x27;a&#x27;] == null) return false; node = node.children[ch - &#x27;a&#x27;]; &#125; return node.isWord; &#125; /** Returns if there is any word in the trie that starts with the given prefix. */ public boolean startsWith(String prefix) &#123; TrieNode node = root; for (char ch : prefix.toCharArray()) &#123; if (node.children[ch - &#x27;a&#x27;] == null) return false; node = node.children[ch - &#x27;a&#x27;]; &#125; return true; &#125;&#125;/** * Your Trie object will be instantiated and called as such: * Trie obj = new Trie(); * obj.insert(word); * boolean param_2 = obj.search(word); * boolean param_3 = obj.startsWith(prefix); */ 剑指 Offer II 063. 替换单词 一刷： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123; static class TrieNode &#123; private TrieNode[] children; private boolean isWord; public TrieNode() &#123; children = new TrieNode[26]; &#125; &#125; public String replaceWords(List&lt;String&gt; dictionary, String sentence) &#123; TrieNode root = buildTrie(dictionary); String[] words = sentence.split(&quot; &quot;); StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; words.length; ++i) &#123; String prefix = findPrefix(root, words[i]); if (!prefix.isEmpty()) &#123; words[i] = prefix; &#125; &#125; return String.join(&quot; &quot;, words); &#125; private String findPrefix(TrieNode root, String word) &#123; TrieNode cur = root; StringBuilder sb = new StringBuilder(); for (char ch : word.toCharArray()) &#123; if (cur.children[ch - &#x27;a&#x27;] == null || cur.isWord) break; sb.append(ch); cur = cur.children[ch - &#x27;a&#x27;]; &#125; return cur.isWord == true ? sb.toString() : &quot;&quot;; &#125; private TrieNode buildTrie(List&lt;String&gt; dictionary) &#123; TrieNode root = new TrieNode(); for (String str : dictionary) &#123; TrieNode cur = root; for (char ch : str.toCharArray()) &#123; if (cur.children[ch - &#x27;a&#x27;] == null) cur.children[ch - &#x27;a&#x27;] = new TrieNode(); cur = cur.children[ch - &#x27;a&#x27;]; &#125; cur.isWord = true; &#125; return root; &#125;&#125; 二刷 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; static class TrieNode &#123; TrieNode[] children = new TrieNode[26]; boolean isWord; &#125; TrieNode root = new TrieNode(); private void buildDict(List&lt;String&gt; dictionary) &#123; for (String word : dictionary) &#123; TrieNode node = root; for (char ch : word.toCharArray()) &#123; if (node.children[ch - &#x27;a&#x27;] == null) node.children[ch - &#x27;a&#x27;] = new TrieNode(); node = node.children[ch - &#x27;a&#x27;]; &#125; node.isWord = true; &#125; &#125; public String replaceWords(List&lt;String&gt; dictionary, String sentence) &#123; buildDict(dictionary); String[] words = sentence.split(&quot; &quot;); StringBuilder res = new StringBuilder(), sb = new StringBuilder(); for (String word : words) &#123; TrieNode node = root; for (char ch : word.toCharArray()) &#123; if (node.children[ch - &#x27;a&#x27;] == null) break; sb.append(ch); node = node.children[ch - &#x27;a&#x27;]; if (node.isWord) &#123; sb.append(&quot; &quot;); res.append(sb); sb = new StringBuilder(); break; &#125; &#125; sb = new StringBuilder(); if (!node.isWord) res.append(word + &quot; &quot;); &#125; res.deleteCharAt(res.length() - 1); return res.toString(); &#125;&#125; 剑指 Offer II 064. 神奇的字典 方法一：前缀树 注意：一定要判断root.isWord，比如字典里有“hello”，search(“hhll”) 12if (root.isWord &amp;&amp; index == searchWord.length() &amp;&amp; diff == 1) return true; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class MagicDictionary &#123; static class TrieNode &#123; TrieNode[] children = new TrieNode[26]; boolean isWord; &#125; /** Initialize your data structure here. */ TrieNode root = new TrieNode(); public void buildDict(String[] dictionary) &#123; for (String word : dictionary) &#123; TrieNode node = root; for (char ch : word.toCharArray()) &#123; if (node.children[ch - &#x27;a&#x27;] == null) node.children[ch - &#x27;a&#x27;] = new TrieNode(); node = node.children[ch - &#x27;a&#x27;]; &#125; node.isWord = true; &#125; &#125; public boolean search(String searchWord) &#123; return dfs(root, searchWord, 0, 0); &#125; private boolean dfs(TrieNode root, String searchWord, int index, int diff) &#123; if (root == null || diff &gt; 1) return false; if (root.isWord &amp;&amp; index == searchWord.length() &amp;&amp; diff == 1) return true; if (index == searchWord.length()) return false; boolean found = false; for (int i = 0; i &lt; 26; ++i) &#123; if (found) break; int nextDiff = i == searchWord.charAt(index) - &#x27;a&#x27; ? diff : diff + 1; found = dfs(root.children[i], searchWord, index + 1, nextDiff); &#125; return found; &#125;&#125;/** * Your MagicDictionary object will be instantiated and called as such: * MagicDictionary obj = new MagicDictionary(); * obj.buildDict(dictionary); * boolean param_2 = obj.search(searchWord); */","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://leopol1d.github.io/categories/Algorithms/"},{"name":"Trie","slug":"Algorithms/Trie","permalink":"https://leopol1d.github.io/categories/Algorithms/Trie/"}],"tags":[{"name":"前缀树","slug":"前缀树","permalink":"https://leopol1d.github.io/tags/%E5%89%8D%E7%BC%80%E6%A0%91/"}]},{"title":"Binary Search","slug":"binary-search","date":"2023-06-06T01:05:05.000Z","updated":"2023-06-21T02:25:56.127Z","comments":true,"path":"2023/06/06/binary-search/","link":"","permalink":"https://leopol1d.github.io/2023/06/06/binary-search/","excerpt":"","text":"mid的计算方式 1234int mid1 = right - ((right - left) &gt;&gt; 1);int mid2 = left + (right - left) / 2;当right = 5， left = 4时mid1 = 5, mid2 = 4 总结经验 求大于(等于)target的最小值返回left 思路：尽量执行right = mid - 1，当最后一次满足check(mid) &lt;= target并向左滑动右区间，之后只会向右滑动左区间，最后left = right + 1退出while循环，left就是最小的最大值 12345678while (left &lt;= right) &#123; int mid = (left + right) &gt;&gt; 1; if (check(mid) &lt;= target) // mid大了 right = mid - 1; else left = mid + 1;&#125;return left; while的执行条件为left &lt;= right if (check(mid) &lt;= m) // mid大了 right = mid - 1; return left; 只要nums[mid] &gt; target，令right = mid - 1，当遇到大于target的最小值时，也会让right = mid - 1，之后在while循环中都不满足nums[mid] &gt; target，只会执行left = mid + 1，直到left = right + 1退出while循环，此时的left便是大于target的最小值 求小于target的最大值返回right 35. 搜索插入位置 求大于等于target的最小值 如果target在数组中，则会在while循环内被return 如果target不在数组中，while会遍历到left&gt;right结束循环 在left&gt;right的上一步一定是left == right，此时nums[mid]&lt;target，由于右边界是right，可以确定target一定小于nums[right + 1] (或者nums[right]已经是右边界了) 所以while退出循环时，left指向的位置是大于target的，插入在这个位置就好 123456789101112131415 class Solution &#123; public int searchInsert(int[] nums, int target) &#123; int left = 0, right = nums.length - 1; while (left &lt;= right) &#123; int mid = (left + right) &gt;&gt; 1; if (nums[mid] == target) return mid; else if (nums[mid] &gt; target) right = mid - 1; else left = mid + 1; &#125; return left; &#125;&#125; 剑指 Offer II 069. 山峰数组的顶部 123456789101112131415class Solution &#123; public int peakIndexInMountainArray(int[] arr) &#123; int left = 1, right = arr.length - 2; while (left &lt;= right) &#123; int mid = (left + right) &gt;&gt; 1; if (arr[mid] &gt; arr[mid - 1] &amp;&amp; arr[mid] &gt; arr[mid + 1]) return mid; else if (arr[mid] &gt; arr[mid - 1]) left = mid + 1; else right = mid - 1; &#125; return -1; &#125;&#125; 剑指 Offer II 070. 排序数组中只出现一次的数字 优质题解,这道题需要在纸上模拟 在单一元素x之前,成对出现的第一个元素下标一定是偶数 在单一元素x之后,成对出现的第一个元素下标一定是奇数 举例 12数组:1 1 2 2 3 4 4 5 5下标:0 1 2 3 4 5 6 7 8 单一元素x的值为3,下标为4 在x之前,成对出现的元素有1 1, 2 2,第一个1的下标为0,第一个2的下标为2,均为偶数 在x之后,成对出现的元素有4 4,5 5,第一个4的下标为5,第一个5的下标为7,均为奇数 因此可以根据mid下标的奇偶性来进行二分 如果mid的下标是偶数 如果mid + 1 &lt; n &amp;&amp; nums[mid] == nums[mid + 1],那么单一元素x一定在mid + 1后,令 left = mid + 2; 否则,当nums[mid] != nums[mid + 1]时,mid可能就是单一元素x,如果不是,那么x也肯定在mid前面,令right = mid 如果mid的下标是奇数 如果mid - 1 &gt;= 0 &amp;&amp; nums[mid] == nums[mid - 1],那么单一元素x一定在mid后面,令left = mid + 1 否则,当nums[mid] != nums[mid - 1]时,肯定是mid - 1或者mid - 1之前出现了x,令right = mid - 1 举例 12数组:1 2 2 4 4 下标:0 1 2 3 4 当left == right时,退出循环,此时left(right)下标对应的数就是x 12345678910111213141516171819202122class Solution &#123; public int singleNonDuplicate(int[] nums) &#123; int n = nums.length; int left = 0, right = n - 1; while (left &lt; right) &#123; int mid = (left + right) &gt;&gt; 1; if (mid % 2 == 0) &#123; if (mid + 1 &lt; n &amp;&amp; nums[mid] == nums[mid + 1]) left = mid + 2; else right = mid; &#125; else &#123; if (mid - 1 &gt;= 0 &amp;&amp; nums[mid] == nums[mid - 1]) left = mid + 1; else right = mid - 1; &#125; &#125; return nums[right]; &#125;&#125; 如果nums时未排序的，那么这就是另一类经典面试题 将数组中所有数字异或，最终的结果就是那个唯一只出现一次的数字 12345678class Solution &#123; public int singleNonDuplicate(int[] nums) &#123; int res = 0; for (int i = 0; i &lt; nums.length; ++i) res = res ^ nums[i]; return res; &#125;&#125; 剑指 Offer II 071. 按权重生成随机数 方法一: 前缀和 + 二分查找 剑指offer题解 123456789101112131415161718192021222324252627282930313233343536class Solution &#123; private int total; private int[] preSum; private int n; public Solution(int[] w) &#123; n = w.length; preSum = new int[n]; for (int i = 0; i &lt; n; ++i) &#123; total += w[i]; preSum[i] += total; &#125; &#125; public int pickIndex() &#123; Random random = new Random(); // 找到大于p的最小值的下标 int p = random.nextInt(total); int left = 0, right = n - 1; while (left &lt;= right) &#123; int mid = (left + right) &gt;&gt; 1; if (preSum[mid] == p) return mid + 1; else if (preSum[mid] &gt; p) right = mid - 1; else left = mid + 1; &#125; return left; &#125;&#125;/** * Your Solution object will be instantiated and called as such: * Solution obj = new Solution(w); * int param_1 = obj.pickIndex(); */ 剑指 Offer II 072. 求平方根 方法一：二分查找 求平方小于等于x的最大值 如果x取根号为整数，会在while循环被返回 如果x取根号不为整数，while循环不会return，结束时right = left - 1，\\(right^2 &lt; x\\)并且\\(left^2 &gt; x\\)， right就是所求答案 123456789101112131415 class Solution &#123; public int mySqrt(int x) &#123; int left = 1, right = x; while (left &lt;= right) &#123; int mid = right - (right - left &gt;&gt; 1); if (mid == x / mid) return mid; else if (mid &lt; x / mid) left = mid + 1; else right = mid - 1; &#125; return right; &#125;&#125; 方法二：二分查找另一种写法 12345678910111213141516class Solution &#123; public int mySqrt(int x) &#123; int left = 1, right = x; while (left &lt;= right) &#123; int mid = right - (right - left &gt;&gt; 1); if (mid &lt;= x / mid) &#123; if ((mid + 1) &gt; x / (mid + 1)) return mid; left = mid + 1; &#125; else right = mid - 1; &#125; return 0; &#125;&#125; 剑指 Offer II 073. 狒狒吃香蕉 方法一：二分查找 1234if (hours &lt;= h) &#123; // 吃香蕉速度太快了 res = mid; right = mid - 1;&#125; 只要hours &lt;= h，说明速度太快，降低速度，并且记录这次能满足hours = h的速度 之后总会进入else语句，最终left &gt; right退出循环 最后一次记录的res就是答案 123456789101112131415161718192021222324252627class Solution &#123; public int minEatingSpeed(int[] piles, int h) &#123; int n = 0; for (int pile : piles) n = Math.max(n, pile); int left = 1, right = n,res = -1; while (left &lt;= right) &#123; int mid = (left + right) &gt;&gt; 1; int hours = getHours(mid, piles); if (hours &lt;= h) &#123; // 吃香蕉速度太快了 res = mid; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; return res; &#125; private int getHours(int speed, int[] piles) &#123; int hours = 0; for (int pile : piles) hours += (pile + speed - 1) / speed; return hours; &#125;&#125; 方法二：二分查找另一种写法 与方法一类似，不过不需要用一个变量记录答案 最后一次满足在h小时内吃完香蕉后，right = mid - 1,这个mid就是答案 之后一直循环else，最后left = right + 1退出循环，这个left就是最后一次满足在h小时内吃完香蕉的su'du 12345678910111213141516171819202122232425class Solution &#123; public int minEatingSpeed(int[] piles, int h) &#123; int n = 0; for (int pile : piles) n = Math.max(n, pile); int left = 1, right = n; while (left &lt;= right) &#123; int mid = (left + right) &gt;&gt; 1; int hours = getHours(mid, piles); if (hours &lt;= h) &#123; // 吃香蕉速度太快了 right = mid - 1; &#125; else left = mid + 1; &#125; return left; &#125; private int getHours(int speed, int[] piles) &#123; int hours = 0; for (int pile : piles) hours += (pile + speed - 1) / speed; return hours; &#125;&#125; 278. 第一个错误的版本 和排序数组中只出现一次的数字类似 方法一：二分查找 如果isBadVersion(mid)为true，说明当前版本或者之前的版本出错，那么令right = mid - 1(即使是mid出错了)往前面搜。当遇到第一个出错的版本(我们不知道是不是第一个)，并且执行right = mid - 1，之后的while循环中只会执行else部分， 即left = mid + 1;最终left会等于right + 1并且退出while循环，这个left就是第一个出错的版本 12345678910111213141516/* The isBadVersion API is defined in the parent class VersionControl. boolean isBadVersion(int version); */public class Solution extends VersionControl &#123; public int firstBadVersion(int n) &#123; int left = 1, right = n; while (left &lt;= right) &#123; int mid = right - ((right - left) &gt;&gt; 1); if (isBadVersion(mid)) // 当前版本或者之前的版本出错 right = mid - 1; else left = mid + 1; &#125; return left; &#125;&#125; 162. 寻找峰值 方法一：两端添加负无穷 一定要return 0，解决只有一个数的用例 12345678910111213141516171819 class Solution &#123; public int findPeakElement(int[] arr) &#123; int n = arr.length, left = 1, right = n; int[] nums = new int[n + 2]; for (int i = 0; i &lt; n; ++i) nums[i + 1] = arr[i]; nums[0] = nums[n + 1] = Integer.MIN_VALUE; while (left &lt;= right) &#123; int mid = right - ((right - left) &gt;&gt; 1); if (nums[mid] &gt; nums[mid - 1] &amp;&amp; nums[mid] &gt; nums[mid + 1]) return mid - 1; if (nums[mid] &lt; nums[mid + 1]) left = mid + 1; else right = mid - 1; &#125; return 0; &#125;&#125; 方法二： int mid = left + (right - left) / 2; // mid要选较小的 12345678910111213class Solution &#123; public int findPeakElement(int[] nums) &#123; int n = nums.length, left = 0, right = n - 1; while (left &lt; right) &#123; int mid = left + (right - left) / 2; // mid要选较小的 if (mid + 1 &lt; n &amp;&amp; nums[mid] &gt; nums[mid + 1]) right = mid; else left = mid + 1; &#125; return left; &#125;&#125; 367. 有效的完全平方数 方法一：二分查找 123456789101112131415class Solution &#123; public boolean isPerfectSquare(int num) &#123; int left = 1, right = num; while (left &lt;= right) &#123; int mid = right - ((right - left) &gt;&gt; 1); if (mid == num / mid &amp;&amp; num % mid == 0) return true; if (mid &gt; num / mid) right = mid - 1; else left = mid + 1; &#125; return false; &#125;&#125; 744. 寻找比目标字母大的最小字母 求大于target的最小值 首先判断target是否大于letters中最后一个字符，如果大于，直接返回letters[0] 进入while循环，如果letters[mid] - 'a' &lt;= target - 'a'，令left = mid + 1，最后一次执行这个else循环的letters[mid]就是答案 123456789101112131415class Solution &#123; public char nextGreatestLetter(char[] letters, char target) &#123; int left = 0, right = letters.length - 1; if (target - &#x27;a&#x27; &gt;= letters[right] - &#x27;a&#x27;) return letters[0]; while (left &lt;= right) &#123; int mid = (left + right) &gt;&gt; 1; if (letters[mid] - &#x27;a&#x27; &gt; target - &#x27;a&#x27;) right = mid - 1; else left = mid + 1; &#125; return letters[left]; &#125; &#125; 34. 在排序数组中查找元素的第一个和最后一个位置 方法一：二分查找 二分两次，第一次找大于等于target的最小值，第二次找小于等于target的最大值，从而找到target第一个以及最后一个位置 12345678910111213141516171819202122232425262728293031class Solution &#123; public int[] searchRange(int[] nums, int target) &#123; int[] res = new int[]&#123;-1, -1&#125;; if (nums.length == 0) return res; int resL = -1, resR = -1; int left = 0, right = nums.length - 1; while (left &lt;= right) &#123; int mid = (left + right) &gt;&gt; 1; if (nums[mid] &gt;= target) right = mid - 1; else left = mid + 1; &#125; if (left &gt;= 0 &amp;&amp; left &lt; nums.length) resL = nums[left] == target ? left : -1; left = 0; right = nums.length - 1; while (left &lt;= right) &#123; int mid = (left + right) &gt;&gt; 1; if (nums[mid] &gt; target) right = mid - 1; else left = mid + 1; &#125; if (right &gt;= 0 &amp;&amp; right &lt; nums.length) resR = nums[right] == target ? right : -1; res = new int[]&#123;resL, resR&#125;; return res; &#125;&#125; 410. 分割数组的最大值 优质题解 方法一：二分查找 不能写成getSplitNum(nums, mid) &gt;= k，以下这个例子 输入：nums = [7,2,5,10,8], m = 2 输出：18 解释： 一共有四种方法将 nums 分割为 2 个子数组。 其中最好的方式是将其分为 [7,2,5] 和 [10,8] 。 因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。 如果写成getSplitNum(nums, mid) &gt;= k，当mid=21(答案是18),得到的getSplitNum(nums, mid) = 2 &gt;= k，会继续让mid往更大的方向搜 12345if (getSplitNum(nums, mid) &gt; k) left = mid + 1;else // 分割的数量太少，mid选大了 right = mid - 1; 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public int splitArray(int[] nums, int k) &#123; /* 1.如果把数组分割成n个子数组，那么n个子数组各自和的最大值为数组中的最大值 2.如果把数组分割成1个子数组，那么这个子数组的最大值为数组的和 把以上两种情况返回的最大值当作二分查找的左右边界 每次选择一个中间值mid用于分割数组，被分割的数组和必须小于等于mid，返回分割的子数组个数splitNum 目标是确定一个恰当的「子数组各自的和的最大值」，使得它对应的「子数组的分割数」恰好等于 m 如果splitNum &gt; k，说明mid小了，选更大的值可以让 * */ int left = 0, right = 0; for (int num: nums) &#123; if (left &lt; num) left = num; right += num; &#125; while (left &lt;= right) &#123; int mid = (left + right) &gt;&gt; 1; // 分割的数量太多，mid选小了 if (getSplitNum(nums, mid) &gt; k) left = mid + 1; else // 分割的数量太少，mid选大了 right = mid - 1; &#125; return left; &#125; private int getSplitNum(int[] nums, int maxSum) &#123; // [至少是一个分割] [当前区间的和] int splitNum = 1, curSum = 0; for (int num : nums) &#123; if (curSum + num &gt; maxSum) &#123; ++splitNum; curSum = 0; &#125; curSum += num; &#125; return splitNum; &#125;&#125; 二刷 123456789101112131415161718192021222324252627282930class Solution &#123; public int splitArray(int[] nums, int k) &#123; int l = 0, r = 0; for (int x : nums) &#123; r += x; l = Math.max(l, x); &#125; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; // k个桶，容量上限为mid，是否能容纳所有数组元素 if (check(nums, k, mid)) // 如果能容纳，mid上限选大了或者刚刚好 r = mid - 1; else l = mid + 1; &#125; return l; &#125; private boolean check(int[] nums, int k, int mid) &#123; int bucket = 1, sum = 0; for (int x : nums) &#123; if (sum + x &gt; mid) &#123; ++bucket; sum = 0; &#125; sum += x; &#125; return bucket &lt;= k; &#125;&#125; LCP 12. 小张刷题计划 和分割数组的最大值相比，加了一个条件，每个分割后的数组减去其中的最大值 getSpendDay函数，在每一个新的一天第一次要刷的题先不加入totalTime，先记录maxTime，最后少计入时长的那道题就是需要花费时间最长的题 12345678910111213141516171819202122232425262728293031class Solution &#123; public int minTime(int[] time, int m) &#123; int left = 0, right = 0; for (int t : time) right += t; while (left &lt;= right) &#123; int mid = (left + right) &gt;&gt; 1; if (getSpendDay(time, mid) &lt;= m) // mid大了 right = mid - 1; else left = mid + 1; &#125; return left; &#125; public int getSpendDay(int[] time, int limit) &#123; int totalTime = 0, maxTime = 0, day = 1; for (int t : time) &#123; int nextTime = Math.min(maxTime, t); if (totalTime + nextTime &lt;= limit) &#123; totalTime += nextTime; maxTime = Math.max(maxTime, t); &#125; else &#123; ++day; totalTime = 0; maxTime = t; &#125; &#125; return day; &#125;&#125; 1482. 制作 m 束花所需的最少天数 方法一：二分查找 求能满足条件的最小值 如果用以下代码 12345if (check(bloomDay, k, mid) &lt;= m) // 天数不够凑成m束花 left = mid + 1;else right = mid - 1;return right; 举例 输入：bloomDay = [1,10,3,10,2], m = 3, k = 1 输出：3 解释：让我们一起观察这三天的花开过程，x 表示花开，而 _ 表示花还未开。 现在需要制作 3 束花，每束只需要 1 朵。 1 天后：[x, , , , ] // 只能制作 1 束花 2 天后：[x, , , _, x] // 只能制作 2 束花 3 天后：[x, , x, , x] // 可以制作 3 束花，答案为 3 mid == 5，check(bloomDay, k, mid) == 3(m)，此时还左区间还要向右边滑动当然错了 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; public int minDays(int[] bloomDay, int m, int k) &#123; /** 摘m束花的最小等待天数:能满足条件的最小值 等待bloomDay数组中的最大元素天能摘n束花 等待bloomDay 0天摘0束花 在这两者之间二分 如果选取的天数能凑成小于m束花，则left = mid + 1 如果选取的天数能凑成大于m束花，则right = mid - 1 */ int n = bloomDay.length; if (n / m &lt; k) return -1; int left = 0, right = 0; for (int flower : bloomDay) right = Math.max(right, flower); while (left &lt;= right) &#123; int mid = (left + right) &gt;&gt; 1; if (check(bloomDay, k, mid) &lt; m) // 天数不够凑成m束花 left = mid + 1; else right = mid - 1; &#125; return left; &#125; private int check(int[] bloomDay, int k, int days) &#123; int bouquets = 0, curFlower = 0; for (int flower : bloomDay) &#123; if (flower &lt;= days) &#123; ++curFlower; if (curFlower == k) &#123; ++bouquets; curFlower = 0; &#125; &#125; else &#123; curFlower = 0; &#125; &#125; return bouquets; &#125; &#125; 1011. 在 D 天内送达包裹的能力 和分割数组的最大值一样 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public int shipWithinDays(int[] weights, int days) &#123; // 把weights数组分割为days份，求最大的被分割子数组和的最小值 // 当运载能力为数组中最大的元素时，最多n天运输完所有货物 // 当运载能力为数组的和时，一天能运输完所有货物 // 在这两者之间进行二分 int n = weights.length, left = 0, right = 0; for (int w : weights) &#123; left = Math.max(left, w); right += w; &#125; while (left &lt;= right) &#123; int mid = (left + right) &gt;&gt; 1; if (check(weights, mid) &lt;= days) // 运载能力太强了 right = mid - 1; else left = mid + 1; &#125; return left; &#125; private int check(int[] weights, int capacity) &#123; int total = 0, spendDay = 1; for (int w : weights) &#123; if (total + w &lt;= capacity) total += w; else &#123; ++spendDay; total = w; &#125; &#125; return spendDay; &#125; &#125; 1552. 两球之间的磁力 1234567891011121314151617181920212223242526272829303132class Solution &#123; public int maxDistance(int[] position, int m) &#123; /** 1.最小的最大值：尽量执行left = mid + 1,最后一次执行它后，之后都只会执行right = mid - 1 最后right = left - 1退出循环，此时的right就是最小的最大值 2.二分查找当前磁力(最小求间距)是否可以放得下m个球 3.如果放得下m个球，增大球间距 4.如果放不下m个球，减小球间距 */ Arrays.sort(position); int n = position.length, left = 1, right = position[n - 1] - position[0]; while (left &lt;= right) &#123; int mid = (left + right) &gt;&gt; 1; if (check(position, mid) &gt;= m) left = mid + 1; else right = mid - 1; &#125; return right; &#125; private int check(int[] position, int limit) &#123; int pre = position[0], count = 1; for (int i = 1; i &lt; position.length; ++i) &#123; if (position[i] - pre &gt;= limit) &#123; pre = position[i]; ++count; &#125; &#125; return count; &#125; &#125;","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://leopol1d.github.io/categories/Algorithms/"},{"name":"Binary Search","slug":"Algorithms/Binary-Search","permalink":"https://leopol1d.github.io/categories/Algorithms/Binary-Search/"}],"tags":[{"name":"二分查找","slug":"二分查找","permalink":"https://leopol1d.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"}]},{"title":"Maze Problem","slug":"maze-problem","date":"2023-06-05T07:50:35.000Z","updated":"2023-06-12T07:20:06.543Z","comments":true,"path":"2023/06/05/maze-problem/","link":"","permalink":"https://leopol1d.github.io/2023/06/05/maze-problem/","excerpt":"","text":"130. 被围绕的区域 方法一：DFS 从边界出发，把边界以及与边界连通的O标记为B` 遍历整个board，把B还原为O，把O(此时的O是被X包围的)改变为X 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public void solve(char[][] board) &#123; m = board.length; n = board[0].length; if (m &lt;= 2 || n &lt;= 2) return; for (int i = 0; i &lt; m; i += m - 1) for (int j = 0; j &lt; n; ++j) if (board[i][j] == &#x27;O&#x27;) dfs(i, j, board); for (int j = 0; j &lt; n; j += n - 1) for (int i = 0; i &lt; m; ++i) if (board[i][j] == &#x27;O&#x27;) dfs(i, j, board); for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (board[i][j] == &#x27;B&#x27;) board[i][j] = &#x27;O&#x27;; else if (board[i][j] == &#x27;O&#x27;) board[i][j] = &#x27;X&#x27;; &#125; &#125; &#125; int[][] dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; int m, n; private void dfs(int i, int j, char[][] board) &#123; board[i][j] = &#x27;B&#x27;; // backtrack for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col) &amp;&amp; board[row][col] == &#x27;O&#x27;) dfs(row, col, board); &#125; &#125; private boolean isValid(int i, int j) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125; &#125; 200. 岛屿数量 方法一：DFS 123456789101112131415161718192021222324252627282930313233class Solution &#123; public int numIslands(char[][] grid) &#123; m = grid.length; n = grid[0].length; for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (grid[i][j] == &#x27;1&#x27;) &#123; dfs(i, j, grid); ++res; &#125; &#125; &#125; return res; &#125; int res = 0, m, n; int[][] dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; private void dfs(int i, int j, char[][] grid) &#123; grid[i][j] = &#x27;2&#x27;; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col) &amp;&amp; grid[row][col] == &#x27;1&#x27;) dfs(row, col, grid); &#125; &#125; private boolean isValid(int i, int j) &#123; return i &gt;= 0 &amp;&amp; j &gt;=0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125; &#125; 方法二：BFS 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; public int numIslands(char[][] grid) &#123; m = grid.length; n = grid[0].length; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (grid[i][j] == &#x27;1&#x27;) &#123; bfs(queue, i, j, grid); ++res; &#125; &#125; &#125; return res; &#125; int res = 0, m, n; int[][] dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; private void bfs(Queue&lt;int[]&gt; queue, int i, int j, char[][] grid) &#123; queue.offer(new int[]&#123;i, j&#125;); while (!queue.isEmpty()) &#123; int[] node = queue.poll(); for (int[] dir : dirs) &#123; int row = node[0] + dir[0], col = node[1] + dir[1]; if (isValid(row, col) &amp;&amp; grid[row][col] == &#x27;1&#x27;) &#123; grid[row][col] = &#x27;2&#x27;; queue.offer(new int[]&#123;row, col&#125;); &#125; &#125; &#125; &#125; private boolean isValid(int i, int j) &#123; return i &gt;= 0 &amp;&amp; j &gt;=0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125; &#125; 329. 矩阵中的最长递增路径 方法一：DFS + 记忆化搜索 如果之前计算过dp[i][j]，直接返回dp[i][j] 计算从matrix[i][j]为起点的最长路径，并用max记录最大值 12if (isValid(row, col) &amp;&amp; matrix[row][col] &gt; matrix[i][j]) &#123; max = Math.max(max, dfs(row, col, matrix)); 返回上一个节点的时候需要加上1，因为当前节点也需要加上，并用dp[i][j]记录 1return dp[i][j] = max + 1; 1234567891011121314151617181920212223242526272829303132class Solution &#123; public int longestIncreasingPath(int[][] matrix) &#123; m = matrix.length; n = matrix[0].length; dp = new int[m][n]; for (int i = 0; i &lt; m; ++i) for (int j = 0; j &lt; n; ++j) res = Math.max(res, dfs(i, j, matrix)); return res; &#125; int res = 1, m, n; int[][] dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;, dp; private int dfs(int i, int j, int[][] matrix) &#123; if (dp[i][j] != 0) return dp[i][j]; int max = 0; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col) &amp;&amp; matrix[row][col] &gt; matrix[i][j]) &#123; max = Math.max(max, dfs(row, col, matrix)); &#125; &#125; return dp[i][j] = max + 1; &#125; private boolean isValid(int i, int j) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125; &#125; 417. 太平洋大西洋水流问题 把四条边先标记好，然后dfs 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; pacificAtlantic(int[][] heights) &#123; m = heights.length; n = heights[0].length; pacific = new boolean[m][n]; atlantic = new boolean[m][n]; for (int j = 0; j &lt; n; ++j) pacific[0][j] = true; for (int i = 0; i &lt; m; ++i) pacific[i][0] = true; for (int j = 0; j &lt; n; ++j) atlantic[m - 1][j] = true; for (int i = 0; i &lt; m; ++i) atlantic[i][n - 1] = true; for (int i = 0; i &lt; m; ++i) for (int j = 0; j &lt; n; ++j) if (pacific[i][j] || atlantic[i][j]) dfs(i, j, heights); for (int i = 0; i &lt; m; ++i) for (int j = 0; j &lt; n; ++j) if (pacific[i][j] &amp;&amp; atlantic[i][j]) res.add(Arrays.asList(i, j)); return res; &#125; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); boolean[][] pacific, atlantic; int m, n; int[][] dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; private void dfs(int i, int j, int[][]heights) &#123; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col) &amp;&amp; heights[row][col] &gt;= heights[i][j]) &#123; if (pacific[i][j] &amp;&amp; !pacific[row][col]) &#123; pacific[row][col] = true; dfs(row, col, heights); &#125; if (atlantic[i][j] &amp;&amp; !atlantic[row][col]) &#123; atlantic[row][col] = true; dfs(row, col, heights); &#125; &#125; &#125; &#125; private boolean isValid(int i, int j) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125; &#125; 463. 岛屿的周长 方法一：DFS 初始每个陆地的边长都为4，如果周围有一个相连的陆地，那么周长-1，如上图grid[1][1]，上下左右都有陆地，所以它拥有的边长为4 - 4 = 0 只要陆地i, j的邻居row, col不是水域，那么先将周长减一 如果grid[row][col] == 2，说明之前访问过，不需要继续dfs，但是需要讲周长减一 如果grid[row][col] == 1，周长需要减一并且需要dfs访问 1234if (isValid(row, col) &amp;&amp; grid[row][col] != 0) &#123; --length; if (grid[row][col] == 1) dfs(row, col, grid); 代码 123456789101112131415161718192021222324252627282930313233class Solution &#123; public int islandPerimeter(int[][] grid) &#123; m = grid.length; n = grid[0].length; for (int i = 0; i &lt; m; ++i) for (int j = 0; j &lt; n; ++j) if (grid[i][j] == 1) dfs(i, j, grid); return res; &#125; int res = 0, m, n; int[][] dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; private void dfs(int i, int j, int[][] grid) &#123; grid[i][j] = 2; int length = 4; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col) &amp;&amp; grid[row][col] != 0) &#123; --length; if (grid[row][col] == 1) dfs(row, col, grid); &#125; &#125; res += length; &#125; private boolean isValid(int i, int j) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125; &#125; 方法二：BFS 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public int islandPerimeter(int[][] grid) &#123; m = grid.length; n = grid[0].length; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; m; ++i) for (int j = 0; j &lt; n; ++j) if (grid[i][j] == 1) &#123; queue.offer(new int[]&#123;i, j&#125;); grid[i][j] = 2; bfs(i, j, grid, queue); return res; &#125; return -1; &#125; int res = 0, m, n; int[][] dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; private void bfs(int i, int j, int[][] grid, Queue&lt;int[]&gt; queue) &#123; while (!queue.isEmpty()) &#123; int[] node = queue.poll(); int length = 4; for (int[] dir : dirs) &#123; int row = node[0] + dir[0], col = node[1] + dir[1]; if (isValid(row, col) &amp;&amp; grid[row][col] != 0) &#123; --length; if (grid[row][col] == 1) &#123; grid[row][col] = 2; queue.offer(new int[]&#123;row, col&#125;); &#125; &#125; &#125; res += length; &#125; &#125; private boolean isValid(int i, int j) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125;&#125; 695. 岛屿的最大面积 方法一：DFS 1234567891011121314151617181920212223242526272829class Solution &#123; public int maxAreaOfIsland(int[][] grid) &#123; m = grid.length; n = grid[0].length; for (int i = 0; i &lt; m; ++i) for (int j = 0; j &lt; n; ++j) if (grid[i][j] == 1) res = Math.max(res, dfs(i, j, grid)); return res; &#125; int m, n, res = 0; int[][] dirs = new int[][]&#123;&#123;0, -1&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;, &#123;1, 0&#125;&#125;; private int dfs(int i, int j, int[][] grid) &#123; int length = 1; grid[i][j] = 2; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col) &amp;&amp; grid[row][col] == 1) length += dfs(row, col, grid); &#125; return length; &#125; private boolean isValid(int i, int j) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125;&#125; 方法二：并查集 注意 只有当grid[i][j] == 1时才判断 如果row,col不超过边界，且grid[row][col]是陆地(1或者2)，且没有被访问过(如果访问过， 那么grid[i][j]与grid[row][col]的parent一致)，则将grid[i][j]赋值2(1表示没有被访问的陆地，2表示被访问过的陆地) 如果row,col不超过边界，且grid[row][col]是陆地(1或者2)，但是被访问过(此时也会绑定grid[i][j]与grid[row][col]的parent)，不执行 12345678 if (grid[i][j] == 1) &#123; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; // 1.不超过边界 2.是陆地 3.没有被访问过 if (isValid(row, col) &amp;&amp; grid[row][col] != 0 &amp;&amp; union(i * n + j, row * n + col)) grid[i][j] = 2; &#125;&#125; 遍历所有陆地，将每块陆地的祖先存入map，值为子孙的数量，那么含有最大子孙的数量就是岛屿最大数量 map进行put操作时，key为findParent(i * n + j)，因为在之前进行union的过程(parent[parentOfI] = parentOfJ)，直接将i的祖先的祖先赋值为j的祖先，但是此时i的祖先还没有同步，所以这里是进行一个祖先同步的操作 1234567Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();for (int i = 0; i &lt; m; ++i) for (int j = 0; j &lt; n; ++j) if (grid[i][j] != 0) &#123; map.put(findParent(i * n + j), map.getOrDefault(parent[i * n + j], 0) + 1); res = Math.max(res, map.get(parent[i * n + j])); &#125; 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution &#123; public int maxAreaOfIsland(int[][] grid) &#123; m = grid.length; n = grid[0].length; init(m, n); for (int i = 0; i &lt; m; ++i) for (int j = 0; j &lt; n; ++j) if (grid[i][j] == 1) &#123; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; // 1.不超过边界 2.是陆地 3.没有被访问过 if (isValid(row, col) &amp;&amp; grid[row][col] != 0 &amp;&amp; union(i * n + j, row * n + col)) grid[i][j] = 2; &#125; &#125; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; m; ++i) for (int j = 0; j &lt; n; ++j) if (grid[i][j] != 0) &#123; map.put(findParent(i * n + j), map.getOrDefault(parent[i * n + j], 0) + 1); res = Math.max(res, map.get(parent[i * n + j])); &#125; return res; &#125; int m, n, res = 0; int[][] dirs = new int[][]&#123;&#123;0, -1&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;, &#123;1, 0&#125;&#125;; int[] parent; private void init(int m, int n) &#123; parent = new int[m * n]; for (int i = 0; i &lt; m * n; ++i) parent[i] = i; &#125; private int findParent(int i) &#123; return i == parent[i] ? parent[i] : (parent[i] = findParent(parent[i])); &#125; private boolean union(int i, int j) &#123; int parentOfI = findParent(i), parentOfJ = findParent(j); if (parentOfI != parentOfJ) &#123; parent[parentOfI] = parentOfJ; return true; &#125; return false; &#125; private boolean isValid(int i, int j) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125;&#125; 733. 图像渲染 方法一：BFS 小心死循环，curColor很关键 12345678910111213141516171819202122232425262728293031class Solution &#123; public int[][] floodFill(int[][] image, int sr, int sc, int color) &#123; int curColor = image[sr][sc]; if (color == curColor) return image; m = image.length; n = image[0].length; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); queue.offer(new int[]&#123;sr, sc&#125;); image[sr][sc] = color; while (!queue.isEmpty()) &#123; int[] node = queue.poll(); for (int[] dir : dirs) &#123; int row = node[0] + dir[0], col = node[1] + dir[1]; if (isValid(row, col) &amp;&amp; image[row][col] == curColor) &#123; queue.offer(new int[]&#123;row, col&#125;); image[row][col] = color; &#125; &#125; &#125; return image; &#125; int m, n; int[][] dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; private boolean isValid(int i, int j) &#123; return i &gt;=0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125; &#125; 方法二：DFS 1234567891011121314151617181920212223242526272829class Solution &#123; public int[][] floodFill(int[][] image, int sr, int sc, int color) &#123; int curColor = image[sr][sc]; if (color == curColor) return image; m = image.length; n = image[0].length; image[sr][sc] = color; dfs(sr, sc, color, curColor, image); return image; &#125; int m, n; int[][] dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; private void dfs(int i, int j, int color, int curColor, int[][] image) &#123; image[i][j] = color; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col) &amp;&amp; image[row][col] == curColor) dfs(row, col, color, curColor, image); &#125; &#125; private boolean isValid(int i, int j) &#123; return i &gt;=0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125; &#125; 1020. 飞地的数量 方法一：DFS 同太平洋大西洋水流问题，从边缘进入dfs 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public int numEnclaves(int[][] grid) &#123; m = grid.length; n = grid[0].length; if (m &lt;= 2 || n &lt;= 2) return 0; for (int i = 0; i &lt; m; i += m - 1) for (int j = 0; j &lt; n; ++j) if (grid[i][j] == 1) dfs(i, j, grid); for (int j = 0; j &lt; n; j += n - 1) for (int i = 1; i &lt; m - 1; ++i) if (grid[i][j] == 1) dfs(i, j, grid); for (int i = 1; i &lt; m; ++i) for (int j = 1; j &lt; n; ++j) if (grid[i][j] == 1) ++res; return res; &#125; int res = 0, m, n; int[][] dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; private void dfs(int i, int j, int[][] grid) &#123; grid[i][j] = 0; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col) &amp;&amp; grid[row][col] == 1) dfs(row, col, grid); &#125; &#125; private boolean isValid(int i, int j) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125;&#125; 1559. 二维网格图中探测环 方法一：BFS 每次从队列中取出一个节点时，记录当前队列大小size，初始化neigbors = 0 在上下左右四个方向遍历，如果相邻节点没有越界且与当前字符相同，++neighbors，如果没访问过，加入队列，visited赋值true 遍历完四个方向后，如果neigbors - 1== queue.size() - size，(-1是减去上一次访问过，并将当前节点入队的节点)，说明新入队的邻居之前都没有访问过 如果neigbors - 1 &gt; queue.size() - size，说明遍历到了其他方向遍历过来的节点，那么可以形成环 举例 从下标(0, 0)开始BFS遍历，有两条路径，一条向右出发(记为路径A)，一条向下出发(记为路径B)，这里默认先遍历右边再遍历下面 当遍历了5步后，如下图 (路径A)此时下标为(2, 3)的节点往下遍历，将右下角编号为(3, 3)的节点赋值true，如下图 (路径B)现在下标为(3, 2)的节点往右遍历，邻居neighbors = 2，但是queue.size() - size = 0(队列没有新入队节点)，说明路径A已经遍历过这个节点了 ，那么路径B可以按照路径A返回起点，所以可以形成环 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123; public boolean containsCycle(char[][] grid) &#123; m = grid.length; n = grid[0].length; visited = new boolean[m][n]; for (int i = 0; i &lt; m; ++i) for (int j = 0; j &lt; n; ++j) if (!visited[i][j] &amp;&amp; bfs(i, j, grid)) return true; return false; &#125; private boolean bfs(int i, int j, char[][] grid) &#123; queue.offer(new int[]&#123;i, j&#125;); visited[i][j] = true; while (!queue.isEmpty()) &#123; int[] node = queue.poll(); int neibors = 0, size = queue.size(); for (int[] dir : dirs) &#123; int row = node[0] + dir[0], col = node[1] + dir[1]; if (isValid(row, col) &amp;&amp; grid[row][col] == grid[node[0]][node[1]]) &#123; ++neibors; if (!visited[row][col]) &#123; queue.offer(new int[]&#123;row, col&#125;); visited[row][col] = true; &#125; &#125; &#125; if (neibors - 1 &gt; queue.size() - size) return true; &#125; return false; &#125; int m, n; boolean[][] visited; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); int[][] dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; private boolean isValid(int i, int j) &#123; return i &gt;=0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125;&#125; 方法二：DFS 通过preI,preJ记录上一个已访问节点 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public boolean containsCycle(char[][] grid) &#123; m = grid.length; n = grid[0].length; visited = new boolean[m][n]; for (int i = 0; i &lt; m; ++i) for (int j = 0; j &lt; n; ++j) if (!visited[i][j] &amp;&amp; dfs(i, j, grid, -1, -1)) return true; return false; &#125; private boolean dfs(int i, int j, char[][] grid, int preI, int preJ) &#123; if (visited[i][j]) return true; visited[i][j] = true; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col) &amp;&amp; grid[row][col] == grid[i][j]) &#123; if (row == preI &amp;&amp; col == preJ) continue; if (dfs(row, col, grid, i, j)) return true; &#125; &#125; return false; &#125; int m, n; boolean[][] visited; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); int[][] dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; private boolean isValid(int i, int j) &#123; return i &gt;=0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125;&#125;","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://leopol1d.github.io/categories/Algorithms/"},{"name":"Graph","slug":"Algorithms/Graph","permalink":"https://leopol1d.github.io/categories/Algorithms/Graph/"}],"tags":[{"name":"图","slug":"图","permalink":"https://leopol1d.github.io/tags/%E5%9B%BE/"},{"name":"迷宫问题","slug":"迷宫问题","permalink":"https://leopol1d.github.io/tags/%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98/"}]},{"title":"Monotonic Stack","slug":"monotonic-stack","date":"2023-06-02T01:41:22.000Z","updated":"2023-06-27T07:42:39.406Z","comments":true,"path":"2023/06/02/monotonic-stack/","link":"","permalink":"https://leopol1d.github.io/2023/06/02/monotonic-stack/","excerpt":"","text":"求某个区间的最大(小)值，可以使用单调队列 单调栈的作用：存放之前遍历过的元素i，当比nums[i]更大(小)的元素出现时，计算结果，并将i弹出 239. 滑动窗口最大值 维护一个单调递减的双端队列，队列大小为[0, k]，队列存储数组下标，从而更好判断滑动窗口区间 存储答案的队列res大小为n - k + 1 遍历数组nums 当队列不为空且当前元素大于队尾元素在nums中对应的值时，将队尾元素弹出，从而保持队列的单调递减性 12while (!queue.isEmpty() &amp;&amp; nums[i] &gt; nums[queue.peekLast()]) queue.pollLast(); 完成步骤4后，将当前元素nums[i]加入队列 当队首元素等于i - k，说明已经遍历过k轮，滑动窗口的左边界已经超过队首元素了，弹出队首元素 12if (queue.peekFirst() == i - k) queue.pollFirst(); 只有当i &gt;= k - 1时，才记录结果res 1234567891011121314151617class Solution &#123; public int[] maxSlidingWindow(int[] nums, int k) &#123; int n = nums.length; int[] res = new int[n - k + 1]; Deque&lt;Integer&gt; queue = new LinkedList(); for (int i = 0; i &lt; n; ++i) &#123; while (!queue.isEmpty() &amp;&amp; nums[i] &gt; nums[queue.peekLast()]) queue.pollLast(); queue.offerLast(i); if (queue.peekFirst() == i - k) queue.pollFirst(); if (i &gt;= k - 1) res[i - k + 1] = nums[queue.peekFirst()]; &#125; return res; &#125;&#125; 单调栈是一种基于栈的数据结构，所谓的单调就是满足单调递增（单调递减）的栈。主要用于解决 下一个更大的元素问题，也就是找到下一个更大的元素。 单调栈的意义：用 O(n) 复杂度的一重遍历找到每个元素前后最近的更小/大元素位置 739. 每日温度 方法一：单调栈 创建一个栈，存储元素下标 遍历数组元素 当栈不为空且数组元素值 &gt; 栈顶元素对应数组的值 弹出栈顶元素并用变量i - topIndex;接收 topIndex的下一个更大值的距离为i - topIndex; 将i压栈 遍历完for循环，如果栈不为空，说明栈里的元素不存在比它更大的元素 123456789101112131415class Solution &#123; public int[] dailyTemperatures(int[] temperatures) &#123; int n = temperatures.length; int[] res = new int[n]; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for (int i = 0; i &lt; n; ++i) &#123; while (!stack.isEmpty() &amp;&amp; temperatures[i] &gt; temperatures[stack.peek()]) &#123; int topIndex = stack.pop(); res[topIndex] = i - topIndex; &#125; stack.push(i); &#125; return res; &#125;&#125; 496. 下一个更大元素 I 方法一：单调栈 + HashMap res[i] = map.getOrDefault(nums1[i], -1);假设nums1[i]在nums2中的下标为j，如果map查不到nums1[i]，说明nums2[j]在j之后没有比nums2[j]更大的元素 123456789101112131415161718class Solution &#123; public int[] nextGreaterElement(int[] nums1, int[] nums2) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums2.length; ++i) &#123; while (!stack.isEmpty() &amp;&amp; nums2[i] &gt; nums2[stack.peek()]) &#123; int topIndex = stack.pop(); map.put(nums2[topIndex], nums2[i]); &#125; stack.push(i); &#125; int[] res = new int[nums1.length]; for (int i = 0; i &lt; nums1.length; ++i) &#123; res[i] = map.getOrDefault(nums1[i], -1); &#125; return res; &#125;&#125; 503. 下一个更大元素 II 方法一：单调栈 初始res数组为-1很重要！默认所有元素都没有更大的下一个元素 1Arrays.fill(res, -1); 循环数组遍历两次，即使第一轮遍历已经被赋值，第二轮也只会赋相同的值，不影响 12345678910111213141516class Solution &#123; public int[] nextGreaterElements(int[] nums) &#123; int n = nums.length; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); int[] res = new int[n]; Arrays.fill(res, -1); for (int i = 0; i &lt; 2 * n; ++i) &#123; while (!stack.isEmpty() &amp;&amp; nums[i % n] &gt; nums[stack.peek()]) &#123; int topIndex = stack.pop(); res[topIndex] = nums[i % n]; &#125; stack.push(i % n); &#125; return res; &#125;&#125; 316. 去除重复字母 方法一：单调栈 遇到一个新字符 如果比栈顶小 并且在新字符后面还有和栈顶一样的 就把栈顶的字符抛弃了 12345678910111213141516171819202122232425class Solution &#123; public String removeDuplicateLetters(String s) &#123; int[] count = new int[26]; for (int i = 0; i &lt; s.length(); ++i) ++count[s.charAt(i) - &#x27;a&#x27;]; boolean[] visited = new boolean[26]; Deque&lt;Integer&gt; stack = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; s.length(); ++i) &#123; char ch = s.charAt(i); --count[ch - &#x27;a&#x27;]; if (visited[ch - &#x27;a&#x27;]) continue; while(!stack.isEmpty() &amp;&amp; s.charAt(stack.peek()) &gt; ch &amp;&amp; count[s.charAt(stack.peek()) - &#x27;a&#x27;] &gt; 0) &#123; visited[s.charAt(stack.peek()) - &#x27;a&#x27;] = false; stack.pop(); &#125; visited[ch - &#x27;a&#x27;] = true; stack.push(i); &#125; StringBuilder sb = new StringBuilder(); while (!stack.isEmpty()) sb.append(s.charAt(stack.pollLast())); return sb.toString(); &#125;&#125; 84. 柱状图中最大的矩形 方法一：单调栈 思路 对于一个高度，如果能得到向左和向右的边界 那么就能对每个高度求一次面积 遍历所有高度，即可得出最大面积 使用单调栈，在出栈操作时得到前后边界并计算面积 注意边界问题 12Arrays.fill(rights, n);Arrays.fill(left, -1); 123456789101112131415161718192021222324252627282930class Solution &#123; public int largestRectangleArea(int[] heights) &#123; int n = heights.length; int[] rights = new int[n]; Arrays.fill(rights, n); Deque&lt;Integer&gt; stack = new LinkedList(); for (int i = 0 ; i &lt; n ; i++)&#123; while (!stack.isEmpty() &amp;&amp; heights[stack.getLast()] &gt; heights[i]) &#123; int top = stack.pollLast(); rights[top] = i; &#125; stack.addLast(i); &#125; int[] left = new int[n]; Arrays.fill(left, -1); stack.clear(); for (int i = n - 1 ; i &gt;= 0 ; i--) &#123; while (!stack.isEmpty() &amp;&amp; heights[stack.getLast()] &gt; heights[i]) &#123; int top = stack.pollLast(); left[top] = i; &#125; stack.addLast(i); &#125; int res = 0; for (int i = 0 ; i &lt; n ; i++) &#123; res = Math.max(res, (rights[i] - left[i] - 1) * heights[i]); &#125; return res; &#125;&#125; 42. 接雨水 方法一：单调栈 优质题解 12345678910111213141516171819class Solution &#123; public int trap(int[] height) &#123; int n = height.length, index = 0, res = 0; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); while (index &lt; n) &#123; while (!stack.isEmpty() &amp;&amp; height[index] &gt; height[stack.peek()]) &#123; int topIndex = stack.pop(); int h = height[topIndex]; if (stack.isEmpty()) break; int min = Math.min(height[index], height[stack.peek()]); int width = index - stack.peek() - 1; res += (min - h) * width; &#125; stack.push(index++); &#125; return res; &#125;&#125;","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://leopol1d.github.io/categories/Algorithms/"},{"name":"Queue && Stack","slug":"Algorithms/Queue-Stack","permalink":"https://leopol1d.github.io/categories/Algorithms/Queue-Stack/"}],"tags":[{"name":"单调栈","slug":"单调栈","permalink":"https://leopol1d.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"name":"单调队列","slug":"单调队列","permalink":"https://leopol1d.github.io/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"}]},{"title":"Shortest Path Problem","slug":"shortest-path-problem","date":"2023-05-31T01:21:07.000Z","updated":"2023-07-03T04:02:12.760Z","comments":true,"path":"2023/05/31/shortest-path-problem/","link":"","permalink":"https://leopol1d.github.io/2023/05/31/shortest-path-problem/","excerpt":"","text":"迪杰斯特拉 解析 开一个dis数组，记录从给定点x到其他点的最短距离，初始化为max，；开一个visited数组，记录顶点是否被访问过 将x的dis初始为0 开始遍历，首先找到未被访问且距离x最短的顶点y，将y的visited赋值true 更新的dis中顶点z的距离：未被访问且 z与x的距离大于 x到y + y到z的距离 743. 网络延迟时间 方法一：迪杰斯特拉 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123;final int inf = Integer.MAX_VALUE / 2; public int networkDelayTime(int[][] times, int n, int k) &#123; int[][] graph = new int[n + 1][n + 1]; for (int[] g : graph) Arrays.fill(g, inf); for (int[] time : times) &#123; int from = time[0], to = time[1], weight = time[2]; graph[from][to] = weight; &#125; int[] dist = dijkstra(graph, n, k); int res = 0; for (int x : dist) &#123; if (x == inf) return -1; res = Math.max(res, x); &#125; for (int d : dist) System.out.print(d + &quot;, &quot;); System.out.println(); return res; &#125; public int[] dijkstra(int[][] graph, int n, int from) &#123; int[] dist = new int[n + 1]; for (int i = 1; i &lt;= n; ++i) if (i != from) dist[i] = inf; // 不要把visited[from]初始为true，dist[from] = 0，会在下面的for循环中被第一个选到 boolean[] visited = new boolean[n + 1]; for (int i = 0; i &lt; n; ++i) &#123; // 每遍历一次将一个顶点visit赋值true，需要遍历n次 int minIndex = -1, minDist = inf; for (int j = 1; j &lt;= n; ++j) &#123; if (!visited[j] &amp;&amp; dist[j] &lt; minDist) &#123; minIndex = j; minDist = dist[j]; &#125; &#125; if (minIndex == -1) // 如果有节点非连通，则返回 return dist; visited[minIndex] = true; for (int j = 1; j &lt;= n; ++j) if (!visited[j] &amp;&amp; dist[j] &gt; graph[minIndex][j] + minDist) dist[j] = graph[minIndex][j] + minDist; &#125; return dist; &#125;&#125; 方法二：堆优化dijkstra 我们还可以使用一个小根堆来寻找「未确定节点」中与起点距离最近的点 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123; final int inf = Integer.MAX_VALUE / 2; public int networkDelayTime(int[][] times, int n, int k) &#123; int[][] graph = new int[n + 1][n + 1]; for (int[] g : graph) Arrays.fill(g, inf); for (int[] time : times) &#123; int from = time[0], to = time[1], weight = time[2]; graph[from][to] = weight; &#125; int[] dist = dijkstra(graph, n, k); int res = 0; for (int x : dist) &#123; if (x == inf) return -1; res = Math.max(res, x); &#125; return res; &#125; public int[] dijkstra(int[][] graph, int n, int from) &#123; int[] dist = new int[n + 1]; for (int i = 1; i &lt;= n; ++i) if (i != from) dist[i] = inf; boolean[] visited = new boolean[n + 1]; PriorityQueue&lt;int[]&gt; queue = new PriorityQueue&lt;&gt;(((o1, o2) -&gt; o1[1] - o2[1])); queue.offer(new int[]&#123;from, 0&#125;); while (!queue.isEmpty()) &#123; int[] arr = queue.poll(); int node = arr[0], disToFrom = arr[1]; if (visited[node]) continue; visited[node] = true; for (int i = 1; i &lt;= n; ++i) &#123; // graph[node][i] &lt; inf表示node与i有边 if (graph[node][i] &lt; inf &amp;&amp; dist[i] &gt; disToFrom + graph[node][i]) &#123; dist[i] = disToFrom + graph[node][i]; queue.offer(new int[]&#123;i, dist[i]&#125;); &#125; &#125; &#125; return dist; &#125;&#125; 322. 零钱兑换 方法一：BFS 12345678910111213141516171819202122class Solution &#123; public int coinChange(int[] coins, int amount) &#123; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); // 第一个元素表示已经凑成的钱(距离)，第二个元素表示使用的硬币数(步数) queue.offer(new int[]&#123;0 , 0&#125;); boolean[] visited = new boolean[amount + 1]; visited[0] = true; while (!queue.isEmpty()) &#123; int[] node = queue.poll(); int sum = node[0], num = node[1]; if (sum == amount) return num; for (int coin : coins) &#123; if (coin &gt; amount - sum || visited[sum + coin]) continue; queue.offer(new int[]&#123;sum + coin, num + 1&#125;); visited[sum + coin] = true; &#125; &#125; return -1; &#125;&#125; 45. 跳跃游戏 II 方法一：BFS 123456789101112131415161718192021class Solution &#123; public int jump(int[] nums) &#123; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); queue.offer(new int[]&#123;0, 0&#125;); boolean[] visited = new boolean[nums.length]; visited[0]= true; while (!queue.isEmpty()) &#123; int[] node = queue.poll(); int pos = node[0], step = node[1]; if (pos == nums.length - 1) return step; for (int i = 1; i &lt;= nums[pos]; ++i) &#123; if (pos + i &gt;= nums.length || visited[pos + i]) continue; queue.offer(new int[]&#123;pos + i, step + 1&#125;); visited[pos + i] = true; &#125; &#125; return -1; &#125;&#125; 542. 01 矩阵 方法一：BFS queue三元组，分别为横坐标i，纵坐标j，mat[i][j]距离0的距离 将所有0加入队列，并标记visited BFS搜索 123456789101112131415161718192021222324252627282930313233class Solution &#123; public int[][] updateMatrix(int[][] mat) &#123; int m = mat.length, n = mat[0].length; int[][] res = new int[m][n]; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); boolean[][] visited = new boolean[m][n]; for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (mat[i][j] == 0) &#123; queue.offer(new int[]&#123;i, j, 0&#125;); // x, y, distance visited[i][j] = true; &#125; &#125; &#125; while (!queue.isEmpty()) &#123; int[] node = queue.poll(); int i = node[0], j = node[1], dist = node[2]; for (int[] dir :dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col, m, n) &amp;&amp; !visited[row][col]) &#123; res[row][col] = dist + 1; queue.offer(new int[]&#123;row, col, dist + 1&#125;); visited[row][col] = true; &#125; &#125; &#125; return res; &#125; int[][] dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; private boolean isValid(int i, int j, int m, int n) &#123; return i &gt;= 0 &amp;&amp; j &gt;=0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125;&#125; 773. 滑动谜题 1334. 阈值距离内邻居最少的城市 不能用BFS做，这是求多源最短路径 方法一：弗洛伊德 dp[i][j]表示i到j的最短距离 枚举所有中间节点k，如果i经过中间节点k再到达j比i直接到达j更短，那么将dp[i][j]赋值为dp[i][k] + dp[k][j] 1234567891011121314151617181920212223242526272829303132class Solution &#123; public int findTheCity(int n, int[][] edges, int distanceThreshold) &#123; int[][] dp = buildGraph(n, edges); for (int k = 0; k &lt; n; ++k) for (int i = 0; i &lt; n; ++i) for (int j = 0; j &lt; n; ++j) dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k][j]); int minNum = 100000, minIndex = -1; for (int i = 0; i &lt; n; ++i) &#123; int neighborsNum = 0; for (int j = 0; j &lt; n; ++j) if (i!= j &amp;&amp; dp[i][j] &lt;= distanceThreshold) ++neighborsNum; if (neighborsNum &lt;= minNum) &#123; minNum = neighborsNum; minIndex = i; &#125; &#125; return minIndex; &#125; private int[][] buildGraph(int n, int[][] edges) &#123; int[][] graph = new int[n][n]; for (int[] row : graph) Arrays.fill(row, 100000); for (int[] edge : edges) &#123; int from = edge[0], to = edge[1], weight = edge[2]; graph[from][to] = graph[to][from] = weight; &#125; return graph; &#125;&#125;","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://leopol1d.github.io/categories/Algorithms/"},{"name":"Graph","slug":"Algorithms/Graph","permalink":"https://leopol1d.github.io/categories/Algorithms/Graph/"}],"tags":[{"name":"图","slug":"图","permalink":"https://leopol1d.github.io/tags/%E5%9B%BE/"},{"name":"最短路","slug":"最短路","permalink":"https://leopol1d.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"}]},{"title":"Minimum Spanning Tree","slug":"minimum-spanning-tree","date":"2023-05-30T07:23:03.000Z","updated":"2023-06-05T01:18:34.602Z","comments":true,"path":"2023/05/30/minimum-spanning-tree/","link":"","permalink":"https://leopol1d.github.io/2023/05/30/minimum-spanning-tree/","excerpt":"","text":"1584. 连接所有点的最小费用 方法一：Kruskal算法 依次选择权值最小的边 如果要加入的边会使得图形成环，则跳过 使用并查集来判断是否会形成环 如果两个顶点不在同一个子图中，连接边不会形成环 如果两个顶点在同一个子图中，连接边会形成环 恰好可以用union解决 比如有三个顶点，1，2，3那么所有的边为(1,2),(1,3),(2,3) 1int[][] edges = new int[n * (n - 1) / 2][3]; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123; public int minCostConnectPoints(int[][] points) &#123; int n = points.length; // edge[0]:顶点1，edge[1]:顶点2，edge[2]:权值(举例) int[][] edges = new int[n * (n - 1) / 2][3]; int index = 0; for (int i = 0; i &lt; n; ++i) for (int j = i + 1; j &lt; n; ++j) edges[index++] = new int[]&#123;i, j, Math.abs(points[i][0] - points[j][0]) + Math.abs(points[i][1] - points[j][1])&#125;; return kruskal(edges, n); &#125; private int kruskal(int[][] edges, int n) &#123; int res = 0; init(n); Arrays.sort(edges, (o1, o2) -&gt; Integer.compare(o1[2], o2[2])); for (int[] edge : edges) &#123; int node1 = edge[0], node2 = edge[1]; if (union(node1, node2)) &#123; // node1与node2不在同一个子图中，加入这条边不会形成环 res += edge[2]; &#125; &#125; return res; &#125; int[] parent; private boolean union(int i, int j) &#123; int rootI = findParent(i), rootJ = findParent(j); if (rootI != rootJ) &#123; parent[rootI] = rootJ; return true; &#125; return false; &#125; private int findParent(int i) &#123; if (i != parent[i]) parent[i] = findParent(parent[i]); return parent[i]; &#125; private void init(int n) &#123; parent = new int[n]; for (int i = 0; i &lt; n; ++i) parent[i] = i; &#125;&#125; 面试用：节点多，边少的时候用 稠密图 方法二：Prim算法 误区：以下是prim，prim需要更新的是已选顶点集距离未选顶点的最短距离 123for (int j = 0; j &lt; n; ++j) if (!visited[j] &amp;&amp; dist[j] &gt; graph[minIndex][j]) dist[j] = graph[minIndex][j]; 以下是dijkstra 123for (int j = 1; j &lt;= n; ++j) if (!visited[j] &amp;&amp; dist[j] &gt; graph[minIndex][j] + minDist) dist[j] = graph[minIndex][j] + minDist; 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public int minCostConnectPoints(int[][] points) &#123; int n = points.length, index = 0; int[][] graph = new int[n][n]; for (int i = 0; i &lt; n; ++i) for (int j = i + 1; j &lt; n; ++j) graph[i][j] = graph[j][i] = getMDistance(points[i], points[j]); return prim(graph, n); &#125; private int prim(int[][] graph, int n) &#123; int res = 0, inf = Integer.MAX_VALUE &gt;&gt; 1; // 已选顶点集距离未选顶点的距离 int[] dist = new int[n]; boolean[] visited = new boolean[n]; for (int i = 1; i &lt; n; ++i) dist[i] = inf; for (int i = 0; i &lt; n; ++i) &#123; int minIndex = -1, minDist = inf; for (int j = 0; j &lt; n; ++j) &#123; if (!visited[j] &amp;&amp; dist[j] &lt; minDist) &#123; minDist = dist[j]; minIndex = j; &#125; &#125; visited[minIndex] = true; res += minDist; for (int j = 0; j &lt; n; ++j) if (!visited[j] &amp;&amp; dist[j] &gt; graph[minIndex][j]) dist[j] = graph[minIndex][j]; &#125; return res; &#125; public int getMDistance(int[] d1, int[] d2) &#123; return Math.abs(d1[0] - d2[0]) + Math.abs(d1[1] - d2[1]); &#125;&#125;","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://leopol1d.github.io/categories/Algorithms/"},{"name":"Graph","slug":"Algorithms/Graph","permalink":"https://leopol1d.github.io/categories/Algorithms/Graph/"}],"tags":[{"name":"图","slug":"图","permalink":"https://leopol1d.github.io/tags/%E5%9B%BE/"},{"name":"最小生成树","slug":"最小生成树","permalink":"https://leopol1d.github.io/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"}]},{"title":"Union Find","slug":"union-find","date":"2023-05-29T09:51:43.000Z","updated":"2023-05-30T07:16:21.259Z","comments":true,"path":"2023/05/29/union-find/","link":"","permalink":"https://leopol1d.github.io/2023/05/29/union-find/","excerpt":"","text":"并查集是一种高效的数据结构，用于解决 连通问题、成环问题等。 模板 123456789101112131415161718192021int[] parent; private boolean union(int i, int j) &#123; int rootI = findParent(i), rootJ = findParent(j); if (rootI != rootJ) &#123; parent[rootI] = rootJ; return true; &#125; return false; &#125; private int findParent(int i) &#123; if (i != parent[i]) parent[i] = findParent(parent[i]); return parent[i]; &#125; private void init(int n) &#123; parent = new int[n]; for (int i = 0; i &lt; n; ++i) parent[i] = i; &#125; 547. 省份数量 方法一：BFS 1234567891011121314151617181920212223242526272829class Solution &#123; boolean[] visited; public int findCircleNum(int[][] isConnected) &#123; int n = isConnected.length, res = 0; visited = new boolean[n]; for (int i = 0; i &lt; n; ++i) &#123; if (!visited[i]) &#123; bfs(i, isConnected, n); ++res; &#125; &#125; return res; &#125; private void bfs(int i, int[][] isConnected, int n) &#123; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); queue.offer(i); visited[i] = true; while (!queue.isEmpty()) &#123; int node = queue.poll(); for (int j = 0; j &lt; n; ++j) &#123; if (isConnected[node][j] == 1 &amp;&amp; !visited[j]) &#123; visited[j] = true; queue.offer(j); &#125; &#125; &#125; &#125;&#125; 方法二：DFS 1234567891011121314151617181920212223class Solution &#123; boolean[] visited; public int findCircleNum(int[][] isConnected) &#123; int n = isConnected.length, res = 0; visited = new boolean[n]; for (int i = 0; i &lt; n; ++i) &#123; if (!visited[i]) &#123; dfs(i, isConnected, n); ++res; &#125; &#125; return res; &#125; private void dfs(int index, int[][] isConnected, int n) &#123; visited[index] = true; for (int i = 0; i &lt; n; ++i) &#123; if (isConnected[index][i] == 1 &amp;&amp; !visited[i]) &#123; dfs(i, isConnected, n); &#125; &#125; &#125;&#125; 方法三：并查集 12345678910111213141516171819202122232425262728public int findCircleNum(int[][] isConnected) &#123; int n = isConnected.length, res = n; parent = new int[n]; for (int i = 0; i &lt; n; ++i) parent[i] = i; for (int i = 0; i &lt; n; ++i) &#123; for (int j = i + 1; j &lt; n; ++j) &#123; if (isConnected[i][j] == 1 &amp;&amp; union(i, j)) --res; &#125; &#125; return res;&#125;int[] parent;private boolean union(int i, int j) &#123; int rootI = findParent(i), rootJ = findParent(j); if (rootI != rootJ) &#123; parent[rootI] = rootJ; return true; &#125; return false;&#125;private int findParent(int i) &#123; if (i != parent[i]) parent[i] = findParent(parent[i]); return parent[i];&#125; 684. 冗余连接 方法一：并查集 初始化为森林，依次连接节点之间的边 如果连接边之前，节点不在同一个子集，那么合并 如果连接边之前，节点已经在同一个子集了，那么一定会形成环，这条边就是最后的冗余连接 123456789101112131415161718192021222324252627282930313233class Solution &#123; public int[] findRedundantConnection(int[][] edges) &#123; int n = edges.length; init(n + 1); for (int[] edge : edges) &#123; if (!union(edge[0], edge[1])) &#123; return edge; &#125; &#125; return new int[0]; &#125; int[] parent; private boolean union(int i, int j) &#123; int rootI = findParent(i), rootJ = findParent(j); if (rootI != rootJ) &#123; parent[rootI] = rootJ; return true; &#125; return false; &#125; private int findParent(int i) &#123; if (i != parent[i]) parent[i] = findParent(parent[i]); return parent[i]; &#125; private void init(int n) &#123; parent = new int[n]; for (int i = 0; i &lt; n; ++i) parent[i] = i; &#125;&#125; 1319. 连通网络的操作次数 方法一：并查集 找到连通分量 123for (int i = 0 ; i &lt; n ; i++) if (parent[i] == i) require++; 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123; public int makeConnected(int n, int[][] connections) &#123; init(n); int redundancy = 0; for (int[] connection : connections) &#123; if (!union(connection[0], connection[1])) &#123; // 已连通 ++redundancy; &#125; &#125; // 找到连通分量数，n个连通分量需要用n-1条边连接 int require = -1; for (int i = 0 ; i &lt; n ; i++) if (parent[i] == i) require++; if (require &lt;= redundancy) return require; return -1; &#125; int[] parent; private boolean union(int i, int j) &#123; int rootI = findParent(i), rootJ = findParent(j); if (rootI != rootJ) &#123; parent[rootI] = rootJ; return true; &#125; return false; &#125; private int findParent(int i) &#123; if (i != parent[i]) parent[i] = findParent(parent[i]); return parent[i]; &#125; private void init(int n) &#123; parent = new int[n]; for (int i = 0; i &lt; n; ++i) parent[i] = i; &#125;&#125; 面试题 16.19. 水域大小 方法一：DFS 12345678910111213141516171819202122232425262728293031323334class Solution &#123; int[][] dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;, &#123;-1, -1&#125;, &#123;-1, 1&#125;, &#123;1, -1&#125;, &#123;1, 1&#125;&#125;; boolean[][] visited; public int[] pondSizes(int[][] land) &#123; int m = land.length, n = land[0].length; visited = new boolean[m][n]; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (!visited[i][j] &amp;&amp; land[i][j] == 0) list.add(dfs(land, m, n, i, j)); &#125; &#125; int[] res = list.stream().mapToInt(i-&gt;i).toArray(); Arrays.sort(res); return res; &#125; private int dfs(int[][] land, int m, int n, int i, int j) &#123; visited[i][j] = true; int length = 1; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(m, n, row, col) &amp;&amp; !visited[row][col] &amp;&amp; land[row][col] == 0) &#123; length += dfs(land, m, n, row, col); &#125; &#125; return length; &#125; private boolean isValid(int m, int n, int i, int j) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125;&#125; 方法二：并查集 使用哈希表count记录池塘的大小 初始化，额外将count赋值1 123456private void init(int n) &#123; parent = new int[n]; for (int i = 0; i &lt; n; ++i) &#123; parent[i] = i; count.put(i, 1); &#125; 如果land[i][j] != 0，那么必然不会是池塘，将count值赋-1 12if (land[i][j] != 0) count.put(i * n + j, -1); 遍历依次合并，合并时将新parent的count加上被合并的count，并将被合并的parent的count赋值-1(便于收集结果) 12345678910private boolean union(int i, int j) &#123; int rootI = findParent(i), rootJ = findParent(j); if (rootI != rootJ) &#123; parent[rootI] = rootJ; count.put(rootJ, count.get(rootI) + count.get(rootJ)); count.put(rootI, -1); return true; &#125; return false;&#125; 收集结果 123for (int val : count.values()) if (val != -1) list.add(val); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class Solution &#123; Map&lt;Integer, Integer&gt; count = new HashMap&lt;&gt;(); public int[] pondSizes(int[][] land) &#123; int[][] dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;, &#123;-1, -1&#125;, &#123;-1, 1&#125;, &#123;1, -1&#125;, &#123;1, 1&#125;&#125;; int m = land.length, n = land[0].length; init(m * n); for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (land[i][j] != 0) count.put(i * n + j, -1); if (land[i][j] == 0) &#123; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(m, n, row, col) &amp;&amp; land[row][col] == 0) &#123; union(i * n + j, row * n + col); &#125; &#125; &#125; &#125; &#125;// for (Map.Entry&lt;Integer, Integer&gt; entry : count.entrySet()) &#123;// System.out.println(&quot;key: &quot; + entry.getKey() + &quot;, value: &quot; + entry.getValue());// &#125; List&lt;Integer&gt; list = new LinkedList&lt;&gt;(); for (int val : count.values()) if (val != -1) list.add(val); int[] res = list.stream().mapToInt(i-&gt;i).toArray(); Arrays.sort(res); return res; &#125; private boolean isValid(int m, int n, int i, int j) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125; int[] parent; private boolean union(int i, int j) &#123; int rootI = findParent(i), rootJ = findParent(j); if (rootI != rootJ) &#123; parent[rootI] = rootJ; count.put(rootJ, count.get(rootI) + count.get(rootJ)); count.put(rootI, -1); return true; &#125; return false; &#125; private int findParent(int i) &#123; if (i != parent[i]) parent[i] = findParent(parent[i]); return parent[i]; &#125; private void init(int n) &#123; parent = new int[n]; for (int i = 0; i &lt; n; ++i) &#123; parent[i] = i; count.put(i, 1); &#125; &#125;&#125; 721. 账户合并 方法一：并查集 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Solution &#123; Map&lt;String, Integer&gt; emailToId = new HashMap&lt;&gt;(); Map&lt;Integer, List&lt;String&gt;&gt; idToEmail = new HashMap&lt;&gt;(); public List&lt;List&lt;String&gt;&gt; accountsMerge(List&lt;List&lt;String&gt;&gt; accounts) &#123; int n = accounts.size(); init(n); for (int i = 0; i &lt; n; ++i) &#123; int size = accounts.get(i).size(); for (int j = 1; j &lt; size; ++j) &#123; String email = accounts.get(i).get(j); if (!emailToId.containsKey(email)) &#123; emailToId.put(email, i); &#125; else &#123; union(i, emailToId.get(email)); &#125; &#125; &#125; for (String email : emailToId.keySet()) &#123; int rootId = findParent(emailToId.get(email)); List&lt;String&gt; emails = idToEmail.getOrDefault(rootId, new LinkedList&lt;&gt;()); emails.add(email); idToEmail.put(rootId, emails); &#125; // 加入name List&lt;List&lt;String&gt;&gt; res = new LinkedList&lt;&gt;(); for (Map.Entry&lt;Integer, List&lt;String&gt;&gt; entry : idToEmail.entrySet()) &#123; int id = entry.getKey(); String name = accounts.get(id).get(0); List&lt;String&gt; row = new LinkedList&lt;&gt;(); row.add(name); List&lt;String&gt; emails = entry.getValue(); Collections.sort(emails); row.addAll(emails); res.add(row); &#125; return res; &#125; int[] parent; private boolean union(int i, int j) &#123; int rootI = findParent(i), rootJ = findParent(j); if (rootI != rootJ) &#123; parent[rootI] = rootJ; return true; &#125; return false; &#125; private int findParent(int i) &#123; if (i != parent[i]) parent[i] = findParent(parent[i]); return parent[i]; &#125; private void init(int n) &#123; parent = new int[n]; for (int i = 0; i &lt; n; ++i) parent[i] = i; &#125;&#125;","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://leopol1d.github.io/categories/Algorithms/"},{"name":"Graph","slug":"Algorithms/Graph","permalink":"https://leopol1d.github.io/categories/Algorithms/Graph/"}],"tags":[{"name":"图","slug":"图","permalink":"https://leopol1d.github.io/tags/%E5%9B%BE/"},{"name":"并查集","slug":"并查集","permalink":"https://leopol1d.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"}]},{"title":"Topological Sort","slug":"topological-sort","date":"2023-05-29T02:05:49.000Z","updated":"2023-05-29T08:00:16.375Z","comments":true,"path":"2023/05/29/topological-sort/","link":"","permalink":"https://leopol1d.github.io/2023/05/29/topological-sort/","excerpt":"","text":"模板 首先通过Map创建图graph，graph的key是节点，graph的value是节点key后继的集合；一般如下定义 1Map&lt;Character, Set&lt;Character&gt;&gt; graph = new HashMap&lt;&gt;(); 创建一个节点映射其入度的Map；一般如下定义 1Map&lt;Character, Integer&gt; inDegrees = new HashMap&lt;&gt;(); 初始化graph的节点，把每个节点都加入图中；初始化inDegrees 123456for (String word : words) &#123; for (char ch : word.toCharArray()) &#123; graph.putIfAbsent(ch, new HashSet&lt;&gt;()); inDegrees.putIfAbsent(ch, 0); &#125;&#125; 初始化graph的边，同时计算入度 12345678910111213for (int i = 1; i &lt; words.length; ++i) &#123; String word1 = words[i - 1], word2 = words[i]; for (int j = 0; j &lt; word1.length() &amp;&amp; j &lt; word2.length(); ++j) &#123; char ch1 = word1.charAt(j), ch2 = word2.charAt(j); if (ch1 != ch2) &#123; if (!graph.get(ch1).contains(ch2)) &#123; graph.get(ch1).add(ch2); inDegrees.put(ch2, inDegrees.get(ch2) + 1); &#125; break; &#125; &#125;&#125; 创建队列，并把入度为0的节点加入队列 1234Queue&lt;Character&gt; queue = new LinkedList&lt;&gt;();for (char key : inDegrees.keySet()) if (inDegrees.get(key) == 0) queue.offer(key); 创建一个记录结果的容器，每次从queue中取出一个节点，把该节点加入结果集，并将该节点后继的入度减一，如果该节点后继的入度为0，则加入队列 12345678910StringBuilder sb = new StringBuilder(); while (!queue.isEmpty()) &#123; char node = queue.poll(); sb.append(node); for (char next : graph.get(node)) &#123; inDegrees.put(next, inDegrees.get(next) - 1); if (inDegrees.get(next) == 0) queue.offer(next); &#125; &#125; 如果结果集包含所有节点，则是有向无环图 207. 课程表 方法一：拓扑排序 123456789101112131415161718192021222324252627class Solution &#123; public boolean canFinish(int numCourses, int[][] prerequisites) &#123; // key表示先修的课程，value表示list中的课程需要先修key Map&lt;Integer, List&lt;Integer&gt;&gt; graph = new HashMap&lt;&gt;(); for (int i = 0; i &lt; numCourses; ++i) graph.put(i, new LinkedList&lt;&gt;()); int[] inDegrees = new int[numCourses]; for (int[] arr : prerequisites) &#123; graph.get(arr[1]).add(arr[0]); ++inDegrees[arr[0]]; &#125; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; numCourses; ++i) if (inDegrees[i] == 0) queue.offer(i); List&lt;Integer&gt; order = new ArrayList&lt;&gt;(); while (!queue.isEmpty()) &#123; int node = queue.poll(); order.add(node); for (int next : graph.get(node)) &#123; if (--inDegrees[next] == 0) queue.offer(next); &#125; &#125; return order.size() == numCourses ? true : false; &#125;&#125; 210. 课程表 II 方法一：拓扑排序 1234567891011121314151617181920212223242526class Solution &#123; public int[] findOrder(int numCourses, int[][] prerequisites) &#123; Map&lt;Integer, List&lt;Integer&gt;&gt; graph = new HashMap&lt;&gt;(); for (int i = 0; i &lt; numCourses; ++i) graph.put(i, new LinkedList&lt;&gt;()); int[] inDegrees = new int[numCourses]; for (int[] arr : prerequisites) &#123; graph.get(arr[1]).add(arr[0]); ++inDegrees[arr[0]]; &#125; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; numCourses; ++i) if (inDegrees[i] == 0) queue.offer(i); List&lt;Integer&gt; order = new ArrayList&lt;&gt;(); while (!queue.isEmpty()) &#123; int node = queue.poll(); order.add(node); for (int next : graph.get(node)) &#123; if (--inDegrees[next] == 0) queue.offer(next); &#125; &#125; return order.size() == numCourses ? order.stream().mapToInt(i-&gt;i).toArray() : new int[0]; &#125;&#125; 剑指 Offer II 114. 外星文字典 方法一：拓扑排序 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123; public String alienOrder(String[] words) &#123; Map&lt;Character, Set&lt;Character&gt;&gt; graph = new HashMap&lt;&gt;(); Map&lt;Character, Integer&gt; inDegrees = new HashMap&lt;&gt;(); for (String word : words) &#123; for (char ch : word.toCharArray()) &#123; graph.putIfAbsent(ch, new HashSet&lt;&gt;()); inDegrees.putIfAbsent(ch, 0); &#125; &#125; for (int i = 1; i &lt; words.length; ++i) &#123; String word1 = words[i - 1], word2 = words[i]; if (word1.startsWith(word2) &amp;&amp; !word1.equals(word2)) return &quot;&quot;; for (int j = 0; j &lt; word1.length() &amp;&amp; j &lt; word2.length(); ++j) &#123; char ch1 = word1.charAt(j), ch2 = word2.charAt(j); if (ch1 != ch2) &#123; if (!graph.get(ch1).contains(ch2)) &#123; graph.get(ch1).add(ch2); inDegrees.put(ch2, inDegrees.get(ch2) + 1); &#125; break; &#125; &#125; &#125; Queue&lt;Character&gt; queue = new LinkedList&lt;&gt;(); for (char key : inDegrees.keySet()) if (inDegrees.get(key) == 0) queue.offer(key); StringBuilder sb = new StringBuilder(); while (!queue.isEmpty()) &#123; char node = queue.poll(); sb.append(node); for (char next : graph.get(node)) &#123; inDegrees.put(next, inDegrees.get(next) - 1); if (inDegrees.get(next) == 0) queue.offer(next); &#125; &#125; return sb.length() == inDegrees.size() ? sb.toString() : &quot;&quot;; &#125;&#125; 剑指 Offer II 115. 重建序列 方法一：拓扑排序 判断有向图的拓扑排序序列是否唯一 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public boolean sequenceReconstruction(int[] nums, int[][] sequences) &#123; Map&lt;Integer, Set&lt;Integer&gt;&gt; graph = new HashMap&lt;&gt;(); Map&lt;Integer, Integer&gt; inDegrees = new HashMap&lt;&gt;(); for (int[] seq : sequences) &#123; for (int i = 0; i &lt; seq.length; ++i) &#123; graph.putIfAbsent(seq[i], new HashSet&lt;&gt;()); inDegrees.putIfAbsent(seq[i], 0); &#125; &#125; for (int[] seq : sequences) &#123; for (int i = 1; i &lt; seq.length; ++i) &#123; int num1 = seq[i - 1], num2 = seq[i]; if (!graph.get(num1).contains(num2)) &#123; graph.get(num1).add(num2); inDegrees.put(num2, inDegrees.get(num2) + 1); &#125; &#125; &#125; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); for (int node : inDegrees.keySet()) if (inDegrees.get(node) == 0) queue.offer(node); List&lt;Integer&gt; order = new LinkedList&lt;&gt;(); while (queue.size() == 1) &#123; int node = queue.poll(); order.add(node); for (int next : graph.get(node)) &#123; inDegrees.put(next, inDegrees.get(next) - 1); if (inDegrees.get(next) == 0) queue.offer(next); &#125; &#125; int[] res = order.stream().mapToInt(i-&gt;i).toArray(); return Arrays.equals(res, nums); &#125;&#125; 310. 最小高度树 方法一：拓扑排序 此题的思路是：找到所有边缘上的节点，然后一层一层删除，直到队列为空，那队列中最后的值就是答案了。比如样例1：边缘的节点为0，2，3，删除后就只剩下1了。不难发现，边缘的节点就是度数为1的节点。 定义graph时为空，需要初始化每一个List 1List&lt;Integer&gt;[] graph = new List[n]; 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public List&lt;Integer&gt; findMinHeightTrees(int n, int[][] edges) &#123; if (n == 1) return Arrays.asList(0); List&lt;Integer&gt;[] graph = new List[n]; for (int i = 0; i &lt; n; ++i) graph[i] = new ArrayList&lt;&gt;(); int[] degree = new int[n]; for (int[] edge : edges) &#123; int node1 = edge[0], node2 = edge[1]; graph[node1].add(node2); graph[node2].add(node1); ++degree[node1]; ++degree[node2]; &#125; Queue&lt;Integer&gt; queue = new ArrayDeque&lt;&gt;(); for (int i = 0; i &lt; n; ++i) if (degree[i] == 1) queue.offer(i); List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); while (!queue.isEmpty()) &#123; res = new ArrayList&lt;&gt;(); int size = queue.size(); for (int i = 0; i &lt; size; ++i) &#123; int node = queue.poll(); res.add(node); for (int next : graph[node]) &#123; if (--degree[next] == 1) queue.offer(next); &#125; &#125; &#125; return res; &#125;&#125; 802. 找到最终的安全状态 方法一：拓扑排序 找到所有不进入环的节点 求反向图，拓扑排序 入度为0的节点符合要求 12345678910111213141516171819202122232425262728293031class Solution &#123; public List&lt;Integer&gt; eventualSafeNodes(int[][] graph) &#123; int n = graph.length; List&lt;Integer&gt;[] adj = new List[n]; int[] indegrees = new int[n]; for (int i = 0; i &lt; n; ++i) &#123; adj[i] = new ArrayList&lt;&gt;(); &#125; for (int i = 0; i &lt; graph.length; ++i) &#123; for (int j = 0; j &lt; graph[i].length; ++j) &#123; adj[graph[i][j]].add(i); &#125; indegrees[i] = graph[i].length; &#125; Queue&lt;Integer&gt; queue = new ArrayDeque&lt;&gt;(); for (int i = 0; i &lt; n; ++i) if (indegrees[i] == 0) queue.offer(i); while (!queue.isEmpty()) &#123; int node = queue.poll(); for (int next : adj[node]) if (--indegrees[next] == 0) queue.offer(next); &#125; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n; ++i) if (indegrees[i] == 0) res.add(i); return res; &#125;&#125;","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://leopol1d.github.io/categories/Algorithms/"},{"name":"Graph","slug":"Algorithms/Graph","permalink":"https://leopol1d.github.io/categories/Algorithms/Graph/"}],"tags":[{"name":"图","slug":"图","permalink":"https://leopol1d.github.io/tags/%E5%9B%BE/"},{"name":"拓扑排序","slug":"拓扑排序","permalink":"https://leopol1d.github.io/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"}]},{"title":"Dynamic Programming","slug":"dynamic-programming","date":"2023-05-27T02:11:44.000Z","updated":"2023-06-26T02:47:55.668Z","comments":true,"path":"2023/05/27/dynamic-programming/","link":"","permalink":"https://leopol1d.github.io/2023/05/27/dynamic-programming/","excerpt":"","text":"自底向上的动态规划 509. 斐波那契数 方法一：暴搜 1234567891011class Solution &#123; public int fib(int n) &#123; return dfs(n); &#125; private int dfs(int index) &#123; if (index == 0 || index == 1) return index; return dfs(index - 1) + dfs(index - 2); &#125;&#125; 方法二：记忆化搜索 12345678910111213141516class Solution &#123; public int fib(int n) &#123; dp = new int[n + 1]; return dfs(n); &#125; int[] dp; private int dfs(int index) &#123; if (index == 0 || index == 1) return index; if (dp[index] != 0) return dp[index]; return dp[index] = dfs(index - 1) + dfs(index - 2); &#125;&#125; 方法三：DP 1234567891011class Solution &#123; public int fib(int n) &#123; if (n == 0 || n == 1) return n; int[] dp = new int[n + 1]; dp[1] = 1; for (int i = 2; i &lt;= n; ++i) dp[i] = dp[i - 2] + dp[i - 1]; return dp[n]; &#125;&#125; 方法四：DP + 滚动数组 1234567891011class Solution &#123; public int fib(int n) &#123; if (n == 0 || n == 1) return n; int[] dp = new int[3]; dp[1] = 1; for (int i = 2; i &lt;= n; ++i) dp[i % 3] = dp[(i - 2) % 3] + dp[(i - 1) % 3]; return dp[n % 3]; &#125;&#125; 198. 打家劫舍 方法一：暴搜 12345678910class Solution &#123; public int rob(int[] nums) &#123; return dfs(nums, nums.length - 1); &#125; private int dfs(int[] nums, int index) &#123; if (index == 0 || index &lt; 0) return index == 0 ? nums[0] : 0; return Math.max(dfs(nums, index - 2) + nums[index], dfs(nums, index - 1)); &#125;&#125; 方法二：记忆化搜索 123456789101112131415class Solution &#123; int[] dp; public int rob(int[] nums) &#123; dp = new int[nums.length]; Arrays.fill(dp, -1); return dfs(nums, nums.length - 1); &#125; private int dfs(int[] nums, int index) &#123; if (index == 0 || index &lt; 0) return index == 0 ? nums[0] : 0; if (dp[index] != -1) return dp[index]; return dp[index] = Math.max(dfs(nums, index - 2) + nums[index], dfs(nums, index - 1)); &#125;&#125; 方法三：DP 12345678910111213141516class Solution &#123; public int rob(int[] nums) &#123; // dp[i]：经过第i个房间能获得的最大价值 if (nums.length == 1) return nums[0]; if (nums.length == 2) return Math.max(nums[0], nums[1]); int[] dp = new int[nums.length]; dp[0] = nums[0]; dp[1] = Math.max(nums[0], nums[1]); for (int i = 2; i &lt; nums.length; ++i) &#123; dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]); &#125; return dp[nums.length - 1]; &#125;&#125; 方法四：DP + 滚动数组 12345678910111213141516class Solution &#123; public int rob(int[] nums) &#123; // dp[i]：经过第i个房间能获得的最大价值 if (nums.length == 1) return nums[0]; if (nums.length == 2) return Math.max(nums[0], nums[1]); int[] dp = new int[3]; dp[0] = nums[0]; dp[1] = Math.max(nums[0], nums[1]); for (int i = 2; i &lt; nums.length; ++i) &#123; dp[i % 3] = Math.max(dp[(i - 1) % 3], dp[(i - 2) % 3] + nums[i]); &#125; return dp[(nums.length - 1) % 3]; &#125;&#125; 64. 最小路径和 方法一：回溯 回溯一 123456789101112131415161718class Solution &#123; public int minPathSum(int[][] grid) &#123; dfs(grid, 0, 0, 0); return res; &#125; int res = 8000000; private void dfs(int[][] grid, int i, int j, int sum) &#123; if (i == grid.length || j == grid[0].length) return; sum += grid[i][j]; if (i == grid.length - 1 &amp;&amp; j == grid[0].length - 1) &#123; res = Math.min(res, sum); return; &#125; dfs(grid, i + 1, j, sum); dfs(grid, i, j + 1, sum); &#125;&#125; 回溯二 1234567891011121314151617class Solution &#123; public int minPathSum(int[][] grid) &#123; dfs(grid, 0, 0, 0); return res; &#125; int res = 8000000; private int dfs(int[][] grid, int i, int j, int sum) &#123; if (i == grid.length || j == grid[0].length) return 0; sum += grid[i][j]; if (i == grid.length - 1 &amp;&amp; j == grid[0].length - 1) &#123; res = Math.min(res, sum); return sum; &#125; return dfs(grid, i + 1, j, sum) + dfs(grid, i, j + 1, sum); &#125;&#125; 方法二：记忆化搜索 12345678910111213141516171819class Solution &#123; public int minPathSum(int[][] grid) &#123; dp = new int[grid.length][grid[0].length]; for (int[] arr : dp) Arrays.fill(arr, -1); return dfs(grid, 0, 0); &#125; int[][] dp; private int dfs(int[][] grid, int i, int j) &#123; if (i == grid.length || j == grid[0].length) return 8000000; if (dp[i][j] != -1) return dp[i][j]; if (i == grid.length - 1 &amp;&amp; j == grid[0].length - 1) &#123; return grid[i][j]; &#125; return dp[i][j] = grid[i][j] + Math.min(dfs(grid, i + 1, j), dfs(grid, i, j + 1)); &#125;&#125; 方法三：DP 12345678910111213141516171819class Solution &#123; public int minPathSum(int[][] grid) &#123; // dp[i][j]:走到grid[i][j]的最小路径 // 状态转移：dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] // 初始化：第0行和第0列 int[][] dp = new int[grid.length][grid[0].length]; dp[0][0] = grid[0][0]; for (int i = 1; i &lt; grid.length; ++i) dp[i][0] += dp[i - 1][0] + grid[i][0]; for (int j = 1; j &lt; grid[0].length; ++j) dp[0][j] += dp[0][j - 1] + grid[0][j]; for (int i = 1; i &lt; grid.length; ++i) &#123; for (int j = 1; j &lt; grid[0].length; ++j) &#123; dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]; &#125; &#125; return dp[grid.length - 1][grid[0].length - 1]; &#125;&#125; 62. 不同路径 方法一：回溯 123456789101112class Solution &#123; public int uniquePaths(int m, int n) &#123; return dfs(m, n, 1, 1); &#125; private int dfs(int m, int n, int i, int j) &#123; if (i == m + 1 || j == n + 1) return 0; if (i == m &amp;&amp; j == n) return 1; return dfs(m, n, i + 1, j) + dfs(m, n, i, j + 1); &#125;&#125; 方法二：记忆化搜索 12345678910111213141516class Solution &#123; public int uniquePaths(int m, int n) &#123; dp = new int[m + 1][n + 1]; return dfs(m, n, 1, 1); &#125; int[][] dp; private int dfs(int m, int n, int i, int j) &#123; if (i == m + 1 || j == n + 1) return 0; if (i == m &amp;&amp; j == n) return 1; if (dp[i][j] != 0) return dp[i][j]; return dp[i][j] = dfs(m, n, i + 1, j) + dfs(m, n, i, j + 1); &#125;&#125; 方法三：组合数学 res = res * i / j不能写成*=，因为可能i / j不为整数 12345678class Solution &#123; public int uniquePaths(int m, int n) &#123; long res = 1; for (int i = n, j = 1; j &lt; m; ++i, ++j) res = res * i / j; return (int) res; &#125;&#125; 方法四：DP 第0行第0列赋值1，反正后面都会被覆盖，干脆全赋值1 12for (int[] arr : dp) Arrays.fill(arr, 1); 123456789101112131415class Solution &#123; public int uniquePaths(int m, int n) &#123; if (m == 1 || n == 1) return 1; int[][] dp = new int[m][n]; for (int[] arr : dp) Arrays.fill(arr, 1); for (int i = 1; i &lt; m; ++i) &#123; for (int j = 1; j &lt; n; ++j) &#123; dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; &#125; &#125; return dp[m - 1][n - 1]; &#125;&#125; 方法五：DP + 滚动数组(两行) 边界都是1，所以可以滚动，不同路径那题不行 123456789101112131415class Solution &#123; public int uniquePaths(int m, int n) &#123; if (m == 1 || n == 1) return 1; int[][] dp = new int[2][n]; for (int[] arr : dp) Arrays.fill(arr, 1); for (int i = 1; i &lt; m; ++i) &#123; for (int j = 1; j &lt; n; ++j) &#123; dp[i % 2][j] = dp[(i - 1) % 2][j] + dp[i % 2][j - 1]; &#125; &#125; return dp[(m - 1) % 2][n - 1]; &#125;&#125; 方法五：DP + 滚动数组(一行) 这里把数组全部初始化为1，是为了模拟第0行 1234567891011121314class Solution &#123; public int uniquePaths(int m, int n) &#123; if (m == 1 || n == 1) return 1; int[] dp = new int[n]; Arrays.fill(dp, 1); for (int i = 1; i &lt; m; ++i) &#123; for (int j = 1; j &lt; n; ++j) &#123; dp[j] += + dp[j - 1]; &#125; &#125; return dp[n - 1]; &#125;&#125; 63. 不同路径 II 方法一：回溯 1234567891011121314class Solution &#123; public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123; int m = obstacleGrid.length, n = obstacleGrid[0].length; return dfs(obstacleGrid, m, n, 0, 0); &#125; private int dfs(int[][] obstacleGrid, int m, int n, int i, int j) &#123; if (i == m || j == n || obstacleGrid[i][j] == 1) return 0; if (i == m - 1 &amp;&amp; j == n - 1) return 1; return dfs(obstacleGrid, m, n, i + 1, j) + dfs(obstacleGrid, m, n, i, j + 1); &#125;&#125; 方法二：记忆化搜索 12345678910111213141516171819class Solution &#123; public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123; int m = obstacleGrid.length, n = obstacleGrid[0].length; dp = new int[m][n]; for (int[] arr : dp) Arrays.fill(arr, -1); return dfs(obstacleGrid, m, n, 0, 0); &#125; int[][] dp; private int dfs(int[][] obstacleGrid, int m, int n, int i, int j) &#123; if (i == m || j == n || obstacleGrid[i][j] == 1) return 0; if (i == m - 1 &amp;&amp; j == n - 1) return 1; if (dp[i][j] != -1) return dp[i][j]; return dp[i][j] = dfs(obstacleGrid, m, n, i + 1, j) + dfs(obstacleGrid, m, n, i, j + 1); &#125;&#125; 方法三：DP 123456789101112131415161718192021222324class Solution &#123; public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123; int m = obstacleGrid.length, n = obstacleGrid[0].length; int[][] dp = new int[m][n]; for (int i = 0; i &lt; m; ++i) &#123; if (obstacleGrid[i][0] == 1) break; dp[i][0] = 1; &#125; for (int j = 0; j &lt; n; ++j) &#123; if (obstacleGrid[0][j] == 1) break; dp[0][j] = 1; &#125; for (int i = 1; i &lt; m; ++i) &#123; for (int j = 1; j &lt; n; ++j) &#123; if (obstacleGrid[i][j] == 1) continue; dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; &#125; &#125; return dp[m - 1][n - 1]; &#125;&#125; 方法五：DP + 滚动数组 123456789101112131415161718class Solution &#123; public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123; int m = obstacleGrid.length, n = obstacleGrid[0].length; int[] dp = new int[n]; dp[0] = obstacleGrid[0][0] == 1 ? 0 : 1; for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (obstacleGrid[i][j] == 1) &#123; dp[j] = 0; continue; &#125; if (j &gt;= 1 &amp;&amp; obstacleGrid[i][j - 1] == 0) dp[j] += dp[j - 1]; &#125; &#125; return dp[n - 1]; &#125;&#125; 118. 杨辉三角 方法一：DP 最后一行的长度是2n - 1 123456789101112131415161718class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); int[][] dp = new int[numRows][numRows * 2 + 1]; dp[0][dp[0].length / 2] = 1; res.add(new LinkedList&lt;&gt;(Arrays.asList(1))); for (int i = 1; i &lt; numRows; ++i) &#123; List&lt;Integer&gt; list = new LinkedList&lt;&gt;(); for (int j = 0; j &lt; dp[0].length; ++j) &#123; dp[i][j] = (j &lt; dp[0].length - 1 ? dp[i - 1][j + 1] : 0) + (j &gt;= 1 ? dp[i - 1][j - 1] : 0); if (dp[i][j] != 0) list.add(dp[i][j]); &#125; res.add(list); &#125; return res; &#125;&#125; 方法二：DP 第一列与最后一列是1 1234567891011121314151617181920212223242526class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123; /* 1 1 1 1 2 1 1 3 3 1 */ List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); List&lt;Integer&gt; row = new LinkedList&lt;&gt;(); // 第一行 row.add(1); res.add(row); for (int i = 2; i &lt;= numRows; ++i) &#123; row = new LinkedList&lt;&gt;(); // 第一列 row.add(1); for (int j = 1; j &lt; i - 1; ++j) row.add(res.get(i - 2).get(j - 1) + res.get(i - 2).get(j)); // 最后一列 row.add(1); res.add(row); // 在res中的下标为i - 1 &#125; return res; &#125;&#125; 120. 三角形最小路径和 二刷回溯 123456789101112131415161718class Solution &#123; public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123; /* 2 3 4 6 5 7 4 1 8 3 */ return dfs(triangle, 0, 0); &#125; private int dfs(List&lt;List&lt;Integer&gt;&gt; triangle, int i, int j) &#123; if (i == triangle.size()) return 0; return triangle.get(i).get(j) + Math.min(dfs(triangle, i + 1, j), dfs(triangle, i + 1, j + 1)); &#125;&#125; 二刷记忆化搜索 123456789101112131415161718192021222324class Solution &#123; public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123; /* 2 3 4 6 5 7 4 1 8 3 */ dp = new int[triangle.size()][triangle.size()]; for (int[] arr : dp) Arrays.fill(arr, 10001); return dfs(triangle, 0, 0); &#125; int[][] dp; private int dfs(List&lt;List&lt;Integer&gt;&gt; triangle, int i, int j) &#123; if (i == triangle.size()) return 0; if (dp[i][j] != 10001) return dp[i][j]; return dp[i][j] = triangle.get(i).get(j) + Math.min(dfs(triangle, i + 1, j), dfs(triangle, i + 1, j + 1)); &#125;&#125; 二刷DP dp数组多创建一列，把dp数组初始化为10001，处理第一列没有左上方元素与最后一列没有正上方元素的特殊情况 1int[][] dp = new int[triangle.size()][triangle.size() + 1]; 代码 1234567891011121314151617181920212223242526class Solution &#123; public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123; /* 2 3 4 6 5 7 4 1 8 3 */ if (triangle.size() == 1) return triangle.get(0).get(0); // dp[i][j]：到达i，j的最短距离 int[][] dp = new int[triangle.size()][triangle.size() + 1]; int min = 10001; for (int[] arr : dp) Arrays.fill(arr, 10001); dp[0][1] = triangle.get(0).get(0); for (int i = 1; i &lt; triangle.size(); ++i) &#123; for (int j = 0; j &lt; triangle.get(i).size(); ++j) &#123; dp[i][j + 1] = Math.min(dp[i - 1][j], dp[i - 1][j + 1]) + triangle.get(i).get(j); if (i == triangle.size() - 1) min = Math.min(min, dp[i][j + 1]); &#125; &#125; return min; &#125;&#125; 从最后一行开始遍历 12345678910111213141516171819class Solution &#123; public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123; /* 2 3 4 6 5 7 4 1 8 3 */ // dp[i][j]：到达i，j的最短距离 int n = triangle.size(); int[][] dp = new int[n + 1][n + 1]; for (int i = n - 1; i &gt;= 0; --i) &#123; for (int j = 0; j &lt;= i; ++j) &#123; dp[i][j] = Math.min(dp[i + 1][j], dp[i + 1][j + 1]) + triangle.get(i).get(j); &#125; &#125; return dp[0][0]; &#125;&#125; 方法一：回溯 1234567891011121314151617181920class Solution &#123; public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123; int n = triangle.size(); int[][] list = new int[n][n]; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; i + 1; ++j) &#123; list[i][j] = triangle.get(i).get(j); &#125; &#125; return dfs(list, n, 0, 0); &#125; private int dfs(int[][] list, int n, int i, int j) &#123; if (j &gt; i) return 0; if (i == n - 1) return list[i][j]; return Math.min(dfs(list, n, i + 1, j), dfs(list, n, i + 1, j + 1)) + list[i][j]; &#125;&#125; 方法二：记忆化搜索一 12345678910111213141516171819202122232425class Solution &#123; public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123; int n = triangle.size(); int[][] list = new int[n][n]; dp = new int[n][n]; for (int[] arr : dp) Arrays.fill(arr, Integer.MAX_VALUE); for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; i + 1; ++j) &#123; list[i][j] = triangle.get(i).get(j); &#125; &#125; return dfs(list, n, 0, 0); &#125; int[][] dp; private int dfs(int[][] list, int n, int i, int j) &#123; if (j &gt; i) return 0; if (i == n - 1) return list[i][j]; if (dp[i][j] != Integer.MAX_VALUE) return dp[i][j]; return dp[i][j] = Math.min(dfs(list, n, i + 1, j), dfs(list, n, i + 1, j + 1)) + list[i][j]; &#125;&#125; 优化记忆化搜索 只改动了base case i == n-1就直接返回，会使最后一次dp信息漏掉，如果最后一行很长，那么会多进入dfs很多次 注意最后一行 12345678910111213141516171819202122232425class Solution &#123; public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123; int n = triangle.size(); int[][] list = new int[n][n]; dp = new int[n][n]; for (int[] arr : dp) Arrays.fill(arr, Integer.MAX_VALUE); for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; i + 1; ++j) &#123; list[i][j] = triangle.get(i).get(j); &#125; &#125; return dfs(list, n, 0, 0); &#125; int[][] dp; private int dfs(int[][] list, int n, int i, int j) &#123; if (j &gt; i) return 0; if (i == n) return 0; if (dp[i][j] != Integer.MAX_VALUE) return dp[i][j]; return dp[i][j] = Math.min(dfs(list, n, i + 1, j), dfs(list, n, i + 1, j + 1)) + list[i][j]; &#125;&#125; 方法三：DP 1234567891011121314151617181920212223class Solution &#123; public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123; int n = triangle.size(); int[][] dp = new int[n][n]; for (int[] arr : dp) Arrays.fill(arr, Integer.MAX_VALUE); int res = Integer.MAX_VALUE; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; i + 1; ++j) &#123; int pre = 0; if (i &gt;= 1) &#123; pre = dp[i - 1][j]; if (j &gt;= 1) pre = Math.min(pre, dp[i - 1][j - 1]); &#125; dp[i][j] = triangle.get(i).get(j) + pre; if (i == n - 1) res = Math.min(res, dp[i][j]); &#125; &#125; return res; &#125;&#125; 方法四：DP + 滚动数组 和01背包类似，第二次for循环要倒序遍历；如果正序遍历那么pre = dp[j]拿到的是第i行的数据，我们需要的是第i-1行的数据 12345678910111213141516171819202122class Solution &#123; public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123; int n = triangle.size(); int[] dp = new int[n]; Arrays.fill(dp, 1000000); int res = Integer.MAX_VALUE; for (int i = 0; i &lt; n; ++i) &#123; for (int j = i; j &gt;= 0; --j) &#123; int pre = 0; if (i &gt;= 1) &#123; pre = dp[j]; if (j &gt;= 1) pre = Math.min(pre, dp[j - 1]); &#125; dp[j] = triangle.get(i).get(j) + pre; if (i == n - 1) res = Math.min(res, dp[j]); &#125; &#125; return res; &#125;&#125; 279. 完全平方数 完全背包问题 方法一：DP 1234567891011121314151617181920class Solution &#123; public int numSquares(int n) &#123; int m = (int) Math.sqrt(n); int[] nums = new int[m]; for (int i = 0; i &lt; m; ++i) &#123; nums[i] = (i + 1) * (i + 1); &#125; // dp[j]:容量为j的背包最少需要多少个数字填满 // dp[0] = 0 int[] dp = new int[n + 1]; for (int i = 1; i &lt; dp.length; ++i) dp[i] = 10001; for (int i = 0; i &lt; nums.length; ++i) &#123; for (int j = nums[i]; j &lt;= n; ++j) &#123; dp[j] = Math.min(dp[j], dp[j - nums[i]] + 1); &#125; &#125; return dp[n]; &#125;&#125; 377. 组合总和 Ⅳ 思路： 排列问题 爬楼梯问题 方法一：DP 1234567891011121314151617class Solution &#123; public int combinationSum4(int[] nums, int target) &#123; // dp[i]:组成i的排列种数 // dp[i] += dp[i - nums[j]] // dp[0] = 1，后面状态根据1往上加 int[] dp = new int[target + 1]; dp[0] = 1; for (int i = 1; i &lt;= target; ++i) &#123; for (int j = 0; j &lt; nums.length; ++j) &#123; if (i &gt;= nums[j]) &#123; dp[i] += dp[i - nums[j]]; &#125; &#125; &#125; return dp[target]; &#125;&#125; 如果要求返回所有排列数，如下 12345678910111213141516171819202122232425262728293031package 背包;import java.util.*;public class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum4(int[] nums, int target) &#123; backtracking(nums, target, 0); return res; &#125; private void backtracking(int[] nums, int target, int index) &#123; if (target == 0) &#123; res.add(new LinkedList&lt;&gt;(path)); return; &#125; for (int i = index; i &lt; nums.length; ++i) &#123; if (target &lt; nums[i]) break; path.offerLast(nums[i]); backtracking(nums, target - nums[i], index); path.pollLast(); &#125; &#125; public static void main(String[] args) &#123; Solution solution = new Solution(); System.out.println(solution.combinationSum4(new int[]&#123;1, 2, 3&#125;, 4)); &#125;&#125; 300. 最长递增子序列 方法一：DP 1234567891011121314151617class Solution &#123; public int lengthOfLIS(int[] nums) &#123; // dp[j]: 以下标j结尾的最长递增子序列的长度 int res = 1; int[] dp = new int[nums.length]; Arrays.fill(dp, 1); for (int i = 0; i &lt; nums.length; ++i) &#123; for (int j = i + 1; j &lt; nums.length; ++j) &#123; if (nums[j] &gt; nums[i]) &#123; dp[j] = Math.max(dp[j], dp[i] + 1); &#125; res = Math.max(res, dp[j]); &#125; &#125; return res; &#125;&#125; 二刷DP：从前往后 12345678910111213141516171819class Solution &#123; public int lengthOfLIS(int[] nums) &#123; if (nums.length == 1) return 1; // dp[i]：下标为i前的子数组的最长递增子序列的长度 int[] dp = new int[nums.length]; Arrays.fill(dp, 1); int res = 1; for (int i = 1; i &lt; nums.length; ++i) &#123; for (int j = 0; j &lt; i; ++j) &#123; if (nums[j] &lt; nums[i]) &#123; dp[i] = Math.max(dp[i], dp[j] + 1); res = Math.max(res, dp[i]); &#125; &#125; &#125; return res; &#125;&#125; 方法二：贪心 + 二分 674. 最长连续递增序列 方法一：暴力 12345678910111213141516171819class Solution &#123; public int findLengthOfLCIS(int[] nums) &#123; // dp[j]: 以下标j为结尾的子数组的长度 int res = 1; for (int i = 0; i &lt; nums.length; ++i) &#123; int length = 1; for (int j = i + 1; j &lt; nums.length; ++j) &#123; if (nums[j] &gt; nums[j - 1]) &#123; ++length; res = Math.max(res, length); &#125; else &#123; length = 1; &#125; &#125; &#125; return res; &#125;&#125; 方法二：DP 1234567891011121314151617class Solution &#123; public int findLengthOfLCIS(int[] nums) &#123; // dp[j]: 以下标j为结尾的最长连续递增序列的长度 // dp[j] = dp[j - 1] + 1 // dp[:] = 1 int[] dp = new int[nums.length]; Arrays.fill(dp, 1); int res = 1; for (int i = 1; i &lt; nums.length; ++i) &#123; if (nums[i] &gt; nums[i - 1]) &#123; dp[i] = dp[i - 1] + 1; res = Math.max(res, dp[i]); &#125; &#125; return res; &#125;&#125; 方法三：DP + 滚动数组 如果nums[i] &lt;= nums[i-1]，记得dp[i % 2] = 1; 1234567891011121314151617181920class Solution &#123; public int findLengthOfLCIS(int[] nums) &#123; // dp[j]: 以下标j为结尾的最长连续递增序列的长度 // dp[j] = dp[j - 1] + 1 // dp[:] = 1 int[] dp = new int[2]; Arrays.fill(dp, 1); int res = 1; for (int i = 1; i &lt; nums.length; ++i) &#123; if (nums[i] &gt; nums[i - 1]) &#123; dp[i % 2] = dp[(i - 1) % 2] + 1; res = Math.max(res, dp[i % 2]); &#125; else &#123; dp[i % 2] = 1; &#125; &#125; return res; &#125;&#125; 718. 最长重复子数组 动动脑子吧你 方法一：暴力 时间复杂度：\\(O(m^2n)\\) 空间复杂度：\\(O(1)\\) 123456789101112131415161718class Solution &#123; public int findLength(int[] nums1, int[] nums2) &#123; int res = 0; for (int i = 0; i &lt; nums1.length; ++i) &#123; for (int j = 0; j &lt; nums2.length; ++j) &#123; int count1 = i, count2 = j; int counter = 0; while (count1 &lt; nums1.length &amp;&amp; count2 &lt; nums2.length &amp;&amp; nums1[count1] == nums2[count2]) &#123; ++counter; ++count1; ++count2; &#125; res = Math.max(res, counter); &#125; &#125; return res; &#125;&#125; 方法二：DP dp[i][j]:以nums1[i - 1]结尾与以nums2[j - 1]结尾时的最长重复子数组 状态转移公式：当nums1[i - 1] == nums2[j - 1]时，dp[i][j] = dp[i - 1][j - 1] + 1 初始化：m为nums1的长度，n为nums2的长度，初始化(m + 1) * (n + 1)的二维数组，第一行第一列初始化为0，因为任一数组为空，就不会有重复子数组 注意事项：输出结果是dp数组中的最大值，因为最长的重复子数组不一定是在两数组的结尾处，可以在循环内比较 时间复杂度：\\(O(mn)\\) 空间复杂度：\\(O(mn)\\) 12345678910111213141516class Solution &#123; public int findLength(int[] nums1, int[] nums2) &#123; int m = nums1.length, n = nums2.length; int[][] dp = new int[m + 1][n + 1]; int result = 0; for (int i = 1; i &lt;= m; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; if (nums1[i - 1] == nums2[j - 1]) &#123; dp[i][j] = dp[i - 1][j - 1] + 1; result = Math.max(result, dp[i][j]); &#125; &#125; &#125; return result; &#125;&#125; 滚动数组缩减空间复杂度 dp数组为第二个数组的长度加一 不相等时要把dp[j]赋0，不然之后会出错 此时遍历第二个数组的时候，就要从后向前遍历，这样避免重复覆盖。 比如nums1 = [1, 2, 3, 1],nums2 = [1,6,8,1,3,1,2,3] i = 1时候，dp数组为[1,0,0,1,0,1,0,0] i = 2时候，dp数组为[0,0,0,0,0,0,1,0] i = 3时候，dp数组为[0,0,0,0,1,0,0,2] i=3时，如果第二层for循环j从前往后遍历，那么dp倒数第二个位置会因为3!=2，被赋0，进而导致dp最后一个位置是1而不是2 123456789101112131415161718class Solution &#123; public int findLength(int[] nums1, int[] nums2) &#123; int[] dp = new int[nums2.length + 1]; int res = 0; for (int i = 1; i &lt;= nums1.length; ++i) &#123; for (int j = nums2.length; j &gt; 0; --j) &#123; if (nums1[i - 1] == nums2[j - 1]) &#123; dp[j] = dp[j - 1] + 1; &#125; else &#123; dp[j] = 0; &#125; res = Math.max(res, dp[j]); &#125; &#125; return res; &#125;&#125; 1143. 最长公共子序列 方法一：DP 1234567891011121314151617class Solution &#123; public int longestCommonSubsequence(String text1, String text2) &#123; // dp[i][j]: text1以i为结尾，text2以j为结尾的最长公共子序列长度 // text[i - 1] == text[j - 1]:dp[i][j] = dp[i - 1][j - 1] + 1 // text[i - 1] != text[j - 1]:dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) int[][] dp = new int[text1.length() + 1][text2.length() + 1]; for (int i = 1; i &lt;= text1.length(); ++i) &#123; for (int j = 1; j &lt;= text2.length(); ++j) &#123; if (text1.charAt(i - 1) == text2.charAt(j - 1)) dp[i][j] = dp[i - 1][j - 1] + 1; else dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]); &#125; &#125; return dp[text1.length()][text2.length()]; &#125;&#125; 方法二：DP + 滚动数组(两行) 12345678910111213141516171819class Solution &#123; public int longestCommonSubsequence(String text1, String text2) &#123; // dp[i][j]: text1以i为结尾，text2以j为结尾的最长公共子序列长度 // text[i - 1] == text[j - 1]:dp[i][j] = dp[i - 1][j - 1] + 1 // text[i - 1] != text[j - 1]:dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) int[][] dp = new int[2][text2.length() + 1]; for (int i = 1; i &lt;= text1.length(); ++i) &#123; for (int j = 1; j &lt;= text2.length(); ++j) &#123; if (text1.charAt(i - 1) == text2.charAt(j - 1)) &#123; dp[i % 2][j] = dp[(i - 1) % 2][j - 1] + 1; &#125; else &#123; dp[i % 2][j] = Math.max(dp[i % 2][j - 1], dp[(i - 1) % 2][j]); &#125; &#125; &#125; return dp[text1.length() % 2][text2.length()]; &#125;&#125; 583. 两个字符串的删除操作 方法一：最长公共子序列 代码和最长公共子序列一模一样，只是返回值不同 找出最长公共子序列长度为x，然后用word1的长度 + word2的长度 - x 1234567891011121314151617181920class Solution &#123; public int minDistance(String text1, String text2) &#123; // dp[i][j]: text1以i为结尾，text2以j为结尾的最长公共子序列长度 // text[i - 1] == text[j - 1]:dp[i][j] = dp[i - 1][j - 1] + 1 // text[i - 1] != text[j - 1]:dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) int[][] dp = new int[2][text2.length() + 1]; for (int i = 1; i &lt;= text1.length(); ++i) &#123; for (int j = 1; j &lt;= text2.length(); ++j) &#123; if (text1.charAt(i - 1) == text2.charAt(j - 1)) &#123; dp[i % 2][j] = dp[(i - 1) % 2][j - 1] + 1; &#125; else &#123; dp[i % 2][j] = Math.max(dp[i % 2][j - 1], dp[(i - 1) % 2][j]); &#125; &#125; &#125; // return dp[text1.length() % 2][text2.length()]; return text1.length() + text2.length() - dp[text1.length() % 2][text2.length()] * 2; &#125;&#125; 方法二：DP dp[i][j]：使得以i为结尾的子串sub1与以j为结尾的子串sub2相同所需的最少删除次数 m为word1的长度，n为word2的长度，创建大小为(m + 1) * (n + 1)大小的dp数组，首先需要初始化第0行与第0列，初始化第0行表示使为空字符串的sub1与长度为j的子串sub2相同所需的最少删除次数，举例word1 = “sea”，word2 = “eeat”，空字符串与空字符串：0，空字符串与“e”：1，空字符串与“ee”：2，空字符串与“eea”：3，空字符串与“eeat”：4。 初始化第0列类似。以下为初始化dp数组 0 1 2 3 4 1 0 0 0 0 2 0 0 0 0 3 0 0 0 0 状态转移方程： 如果两个字符i、j相同，那么所需删除的次数和没加入这两个字符所需要的次数一致 12if (word1.charAt(i - 1) == word2.charAt(j - 1)) dp[i][j] = dp[i - 1][j - 1]; 如果两个字符i、j不同，所需删除的次数为如下 1dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + 1; 12345678910111213141516171819class Solution &#123; public int minDistance(String word1, String word2) &#123; int m = word1.length(), n = word2.length(); int[][] dp = new int[m + 1][n + 1]; for (int j = 0; j &lt;= n; ++j) dp[0][j] = j; for (int i = 0; i &lt;= m; ++i) dp[i][0] = i; for (int i = 1; i &lt;= m; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; if (word1.charAt(i - 1) == word2.charAt(j - 1)) dp[i][j] = dp[i - 1][j - 1]; else dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + 1; &#125; &#125; return dp[m][n]; &#125;&#125; 72. 编辑距离 优质题解 方法一：DP 1234567891011121314151617181920class Solution &#123; public int minDistance(String word1, String word2) &#123; int m = word1.length(), n = word2.length(); int[][] dp = new int[m + 1][n + 1]; for (int i = 1; i &lt;= m; ++i) dp[i][0] = dp[i - 1][0] + 1; for (int j = 1; j &lt;= n; ++j) dp[0][j] = dp[0][j - 1] + 1; for (int i = 1; i &lt;= m; ++i) &#123; char ch1 = word1.charAt(i - 1); for (int j = 1; j &lt;= n; ++j) &#123; if (ch1 != word2.charAt(j - 1)) dp[i][j] = Math.min(Math.min(dp[i - 1][j - 1], dp[i - 1][j]), dp[i][j - 1]) + 1; else dp[i][j] = dp[i - 1][j - 1]; &#125; &#125; return dp[m][n]; &#125;&#125; 二刷DP 当 word1[i] == word2[j]，dp[i][j] = dp[i-1][j-1]； 当 word1[i] != word2[j]，dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1 其中，dp[i-1][j-1] 表示替换操作，dp[i-1][j] 表示删除操作，dp[i][j-1] 表示插入操作。 12345678910111213141516171819class Solution &#123; public int minDistance(String word1, String word2) &#123; int m = word1.length(), n = word2.length(); int[][] dp = new int[m + 1][n + 1]; for (int j = 1; j &lt;= n; ++j) dp[0][j] = j; for (int i = 1; i &lt;= m; ++i) dp[i][0] = i; for (int i = 1; i &lt;= m; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; if (word1.charAt(i - 1) == word2.charAt(j - 1)) dp[i][j] = dp[i - 1][j - 1]; else dp[i][j] = Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1; &#125; &#125; return dp[m][n]; &#125;&#125; 647. 回文子串 优质题解 二刷看的题解 状态：dp[i][j] 表示字符串s在[i,j]区间的子串是否是一个回文串。 状态转移方程：当 s[i] == s[j] &amp;&amp; (j - i &lt; 2 || dp[i + 1][j - 1]) 时，dp[i][j]=true，否则为false 这个状态转移方程是什么意思呢？ 当只有一个字符时，比如 a 自然是一个回文串。 当有两个字符时，如果是相等的，比如 aa，也是一个回文串。 当有三个及以上字符时，比如 ababa 这个字符记作串 1，把两边的 a 去掉，也就是 bab 记作串 2，可以看出只要串2是一个回文串，那么左右各多了一个 a 的串 1 必定也是回文串。所以当 s[i]==s[j] 时，自然要看 dp[i+1][j-1] 是不是一个回文串。 1234567891011121314class Solution &#123; public int countSubstrings(String s) &#123; // dp[i][j]: s[i:j]的回文子串个数 int n = s.length(), res = 0; boolean[][] dp = new boolean[n][n]; for (int j = 0; j &lt; n; ++j) for (int i = 0; i &lt;= j; ++i) if (s.charAt(i) == s.charAt(j) &amp;&amp; (j - i &lt;= 1 || dp[i + 1][j - 1])) &#123; dp[i][j] = true; ++res; &#125; return res; &#125;&#125; 换一种遍历顺序 1234567891011121314class Solution &#123; public int countSubstrings(String s) &#123; // dp[i][j]: s[i:j]的回文子串个数 int n = s.length(), res = 0; boolean[][] dp = new boolean[n][n]; for (int i = n - 1; i &gt;= 0; --i) for (int j = i; j &lt; n; ++j) if (s.charAt(i) == s.charAt(j) &amp;&amp; (j - i &lt;= 1 || dp[i + 1][j - 1])) &#123; dp[i][j] = true; ++res; &#125; return res; &#125;&#125; 方法一：DP 1234567891011121314151617181920class Solution &#123; public int countSubstrings(String s) &#123; int n = s.length(), res = 0; boolean[][] dp = new boolean[n][n]; for (int j = 0; j &lt; n; ++j) &#123; for (int i = j; i &gt;= 0; --i) &#123; if (i == j) dp[i][j] = true; else if (i + 1 == j) dp[i][j] = s.charAt(i) == s.charAt(j) ? true : false; else &#123; dp[i][j] = s.charAt(i) == s.charAt(j) &amp;&amp; dp[i + 1][j - 1]; &#125; if (dp[i][j]) ++res; &#125; &#125; return res; &#125;&#125; 516. 最长回文子序列 方法一：DP 12345678910111213141516171819202122232425class Solution &#123; public int longestPalindromeSubseq(String s) &#123;// dp[i][j]: 字符串从下标i到j的最长回文子序列// dp[i][j]:// s[i] == s[j]: d[i + 1][j - 1]// s[i] != s[j]: max(dp[i + 1][j], dp[i][j - 1]) int n = s.length(); int[][] dp = new int[n][n]; for (int j = 0; j &lt; n; ++j) &#123; for (int i = j; i &gt;= 0; --i) &#123; if (i == j) dp[i][j] = 1; else if (i + 1 == j) dp[i][j] = s.charAt(i) == s.charAt(j) ? 2 : 1; else &#123; if (s.charAt(i) == s.charAt(j)) dp[i][j] = dp[i + 1][j - 1] + 2; else dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]); &#125; &#125; &#125; return dp[0][n - 1]; &#125;&#125; 二刷 dp[i][j - 1] dp[i][j] dp[i + 1][j - 1] dp[i + 1][j] 从下往上，从左往右遍历 else if (s.charAt(i) == s.charAt(j))一定要else if不能是if。如果是if会越界(i = n - 1时, dp[i + 1][j - 1]越界) 1234567891011121314151617class Solution &#123; public int longestPalindromeSubseq(String s) &#123; int n = s.length(); int[][] dp = new int[n][n]; for (int i = n - 1; i &gt;= 0; --i) &#123; for (int j = i; j &lt; n; ++j) &#123; if (i == j) dp[i][j] = 1; else if (s.charAt(i) == s.charAt(j)) dp[i][j] = dp[i + 1][j - 1] + 2; else dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]); &#125; &#125; return dp[0][n - 1]; &#125;&#125; 剑指 Offer II 092. 翻转字符 注意：(ch == '1' ? 0 : 1)的括号 方法一：DP 1234567891011121314151617181920class Solution &#123; public int minFlipsMonoIncr(String s) &#123; // dp[i][0]: 经过若干转换使得子串s[:i]有序且最后一位是0的最少翻转次数 // dp[i][1]：经过若干转换使得子串s[:i]有序且最后一位是1的最少翻转次数 /* 状态转移：dp[i][0] = dp[i - 1][0] + s[i] == 0 ? 0 : 1; dp[i][1] = Math.min(dp[i - 1][0], dp[i - 1][1]) + s[i] == 1 ? 0 : 1; 初始化：dp[0][0] = s[0] == 0 ? 0 : 1; dp[0][1] = s[0] == 1 ? 0 : 1; */ int[][] dp = new int[s.length()][2]; dp[0][0] = s.charAt(0) == &#x27;0&#x27; ? 0 : 1; dp[0][1] = s.charAt(0) == &#x27;1&#x27; ? 0 : 1; for (int i = 1; i &lt; s.length(); ++i) &#123; char ch = s.charAt(i); dp[i][0] = dp[i - 1][0] + (ch == &#x27;0&#x27; ? 0 : 1); dp[i][1] = Math.min(dp[i - 1][0], dp[i - 1][1]) + (ch == &#x27;1&#x27; ? 0 : 1); &#125; return Math.min(dp[s.length() - 1][0], dp[s.length() - 1][1]); &#125;&#125; 剑指 Offer II 093. 最长斐波那契数列 方法一：DP 12345678910111213141516171819class Solution &#123; public int lenLongestFibSubseq(int[] arr) &#123; int n = arr.length; int[][] dp = new int[n][n]; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); int res = 0; for (int i = 0; i &lt; n; ++i) map.put(arr[i], i); for (int i = 2; i &lt; n; ++i) &#123; for (int j = i - 1; j &gt;= 0; --j) &#123; int k = map.getOrDefault(arr[i] - arr[j], -1); if (k &gt;= 0 &amp;&amp; k &lt; j) dp[j][i] = Math.max(dp[k][j] + 1, 3); res = Math.max(res, dp[j][i]); &#125; &#125; return res; &#125;&#125; 分割回文串 II 123456789101112131415161718192021222324252627282930class Solution &#123; public int minCut(String s) &#123; int n = s.length(); /** i &lt; j &amp;&amp; s[i] == s[j], dp[i][j] = dp[i + 1][j - 1] */ boolean[][] dp = new boolean[n][n]; for (int i = n - 1; i &gt;= 0; --i) for (int j = i; j &lt; n; ++j) if (s.charAt(i) == s.charAt(j) &amp;&amp; (j - i &lt;= 1 || dp[i + 1][j - 1])) dp[i][j] = true; /** if (dp[0][n - 1]) return 0; if (dp[i][j]) */ int[] memo = new int[n]; for (int i = 0; i &lt; n; ++i) &#123; if (dp[0][i]) memo[i] = 0; else &#123; memo[i] = i; for (int j = 1; j &lt;= i; ++j) &#123; if (dp[j][i]) memo[i] = Math.min(memo[i], memo[j - 1] + 1); &#125; &#125; &#125; return memo[n - 1]; &#125;&#125; 剑指 Offer II 096. 字符串交织 初始化出错了，debug半天 1234for (int i = 1; i &lt;= n &amp;&amp; s2.charAt(i - 1) == s3.charAt(i - 1); ++i) // 不符合提前终止for循环 dp[0][i] = true;for (int i = 1; i &lt;= m &amp;&amp; s1.charAt(i - 1) == s3.charAt(i - 1); ++i) dp[i][0] = true; 代码 12345678910111213141516171819class Solution &#123; public boolean isInterleave(String s1, String s2, String s3) &#123; int m = s1.length(), n = s2.length(), t = s3.length(); if (t != m + n) return false; // dp[i][j] = (s1[i] == s3[i + j] &amp;&amp; dp[i - 1][j]) || (s2[j] == s3[i + j] &amp;&amp; dp[i][j - 1]) boolean[][] dp = new boolean[m + 1][n + 1]; dp[0][0] = true; for (int i = 1; i &lt;= n &amp;&amp; s2.charAt(i - 1) == s3.charAt(i - 1); ++i) dp[0][i] = true; for (int i = 1; i &lt;= m &amp;&amp; s1.charAt(i - 1) == s3.charAt(i - 1); ++i) dp[i][0] = true; for (int i = 1; i &lt;= m; ++i) for (int j = 1; j &lt;= n; ++j) if ((s1.charAt(i - 1) == s3.charAt(i + j - 1) &amp;&amp; dp[i - 1][j]) || (s2.charAt(j - 1) == s3.charAt(i + j - 1) &amp;&amp; dp[i][j - 1])) dp[i][j] = true; return dp[m][n]; &#125;&#125; 剑指 Offer II 097. 子序列的数目 方法一：DP 注意初始化 123456789101112131415161718192021222324class Solution &#123; public int numDistinct(String s, String t) &#123; /** s = &quot;bagg&quot;, t = &quot;bag&quot; 对于bag的最后一个&#x27;g&#x27;，可以使用它，或者不使用它 */ int m = s.length(), n = t.length(); if (m &lt; n) return 0; int[][] dp = new int[m + 1][n + 1]; dp[0][0] = 1; for (int i = 1;i &lt;= m; ++i) dp[i][0] = 1; for (int i = 1; i &lt;= m; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; if (s.charAt(i - 1) == t.charAt(j - 1)) dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]; else dp[i][j] = dp[i - 1][j]; &#125; &#125; return dp[m][n]; &#125;&#125; 方法二：记忆化搜索 优质题解 1234567891011121314151617181920212223242526class Solution &#123; public int numDistinct(String s, String t) &#123; m = s.length(); n = t.length(); dp = new int[m][n]; for (int[] arr : dp) Arrays.fill(arr, -1); return dfs(s, t, m - 1, n - 1); &#125; int m, n; int[][] dp; private int dfs(String s, String t, int i, int j) &#123; if (j &lt; 0) // base case 当j指针越界，此时t为空串，s不管是不是空串，匹配方式数都是1 return 1; if (i &lt; 0) // base case i指针越界，此时s为空串，t不是，s怎么也匹配不了t，方式数0 return 0; if (dp[i][j] != -1) return dp[i][j]; if (s.charAt(i) == t.charAt(j)) return dp[i][j] = dfs(s, t, i - 1, j - 1) + dfs(s, t, i - 1, j); else return dp[i][j] = dfs(s, t, i - 1, j); &#125;&#125; 392. 判断子序列 方法一：DP 1234567891011121314151617class Solution &#123; public boolean isSubsequence(String s, String t) &#123; /** dp[i][j]:s[:i]是否是t[:j]的子序列 dp[i][j] = dp[i][j - 1] || dp[i - 1][j - 1] &amp;&amp; s[i] == t[j] 初始化：s为空，都是t的子串 */ int m = s.length(), n = t.length(); boolean[][] dp = new boolean[m + 1][n + 1]; for (int j = 0; j &lt;= n; ++j) dp[0][j] = true; for (int i = 1; i &lt;= m; ++i) for (int j = 1; j &lt;= n; ++j) dp[i][j] = dp[i][j - 1] || dp[i - 1][j - 1] &amp;&amp; s.charAt(i - 1) == t.charAt(j - 1); return dp[m][n]; &#125;&#125;","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://leopol1d.github.io/categories/Algorithms/"},{"name":"Dynamic Programming","slug":"Algorithms/Dynamic-Programming","permalink":"https://leopol1d.github.io/categories/Algorithms/Dynamic-Programming/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://leopol1d.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"Memorization Search","slug":"memorization-searcch","date":"2023-05-24T02:32:30.724Z","updated":"2023-06-19T05:53:29.663Z","comments":true,"path":"2023/05/24/memorization-searcch/","link":"","permalink":"https://leopol1d.github.io/2023/05/24/memorization-searcch/","excerpt":"","text":"自顶向下的动态规划——记忆化搜索 记忆化搜索好解决不常见状态转移方程的dp问题 198. 打家劫舍 方法一：DP 1234567891011121314151617class Solution &#123; public int rob(int[] nums) &#123; // 1.dp[j]: 到达标号为j的房屋可获得的最大价值 // 2.状态转移：dp[j] = max(dp[j - 1], dp[j - 2] + nums[j]) // 3.初始化：dp[0] = nums[0], dp[1] = max(nums[0], nums[1]) // 4.遍历顺序：从前往后 int[] dp = new int[nums.length]; dp[0] = nums[0]; if (nums.length == 1) return nums[0]; dp[1] = Math.max(nums[0], nums[1]); for (int i = 2; i &lt; nums.length; ++i) &#123; dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]); &#125; return dp[nums.length - 1]; &#125;&#125; 方法二：DP + 滚动数组 由状态转移方程可以看出，dp[i]由前面两个状态得出，所以dp数组的长度只需要为3 1234567891011121314151617class Solution &#123; public int rob(int[] nums) &#123; // 1.dp[j]: 到达标号为j的房屋可获得的最大价值 // 2.状态转移：dp[j] = max(dp[j - 1], dp[j - 2] + nums[j]) // 3.初始化：dp[0] = nums[0], dp[1] = max(nums[0], nums[1]) // 4.遍历顺序：从前往后 if (nums.length == 1) return nums[0]; int[] dp = new int[3]; dp[0] = nums[0]; dp[1] = Math.max(nums[0], nums[1]); for (int i = 2; i &lt; nums.length; ++i) &#123; dp[i % 3] = Math.max(dp[(i - 1) % 3], dp[(i - 2) % 3] + nums[i]); &#125; return dp[(nums.length - 1) % 3]; &#125;&#125; 方法三：记忆化搜索 自顶向下，举个例子nums=[1,2,3,1] 返回的答案为dfs(3, nums) 要求，需要知道dfs(3-1,nums)与dfs(3-2,nums)+nums[3]，然后取最大值 求dfs(2,nums)，需要知道dfs(2-1,nums)与dfs(2-2,nums)+nums[2]，然后取最大值 ....... 1234567891011121314151617181920public class Solution &#123; int[] dp; public int rob(int[] nums) &#123; dp = new int[nums.length]; Arrays.fill(dp, -1); return dfs(nums.length - 1, nums); &#125; private int dfs(int index, int[] nums) &#123; if (index &lt; 0) return 0; if (dp[index] != -1) return dp[index];// int dont = dfs(index - 1, nums);// int steal = dfs(index - 2, nums) + nums[index];// return dp[index] = Math.max(dont, steal); return dp[index] = Math.max(dfs(index - 1, nums), dfs(index - 2, nums) + nums[index]); &#125;&#125; 二刷记忆化搜索 1234567891011121314151617class Solution &#123; public int rob(int[] nums) &#123; dp = new int[nums.length]; Arrays.fill(dp, -1); return dfs(nums, 0); &#125; int[] dp; private int dfs(int[] nums, int index) &#123; if (index &gt;= nums.length) return 0; if (dp[index] != -1) return dp[index]; return dp[index] = Math.max(dfs(nums, index + 1), dfs(nums, index + 2) + nums[index]); &#125;&#125; 方法四：回溯 1234567891011class Solution &#123; public int rob(int[] nums) &#123; return dfs(nums, 0); &#125; private int dfs(int[] nums, int index) &#123; if (index &gt;= nums.length) return 0; return Math.max(dfs(nums, index + 1), dfs(nums, index + 2) + nums[index]); &#125;&#125; 213. 打家劫舍 II 方法一：DP 12345678910111213141516171819class Solution &#123; public int rob(int[] nums) &#123; if (nums.length == 1) return nums[0]; if (nums.length == 2) return Math.max(nums[0], nums[1]); return Math.max(process(nums, 0, nums.length - 1), process(nums, 1, nums.length)); &#125; private int process(int[] nums, int start, int end) &#123; int[] dp = new int[end - start]; dp[0] = nums[start]; dp[1] = Math.max(nums[start], nums[start + 1]); for (int i = 2; i &lt; end - start; ++i) &#123; dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i + start]); &#125; return dp[end - start - 1]; &#125;&#125; 方法二：DP + 滚动数组 12345678910111213141516171819class Solution &#123; public int rob(int[] nums) &#123; if (nums.length == 1) return nums[0]; if (nums.length == 2) return Math.max(nums[0], nums[1]); return Math.max(process(nums, 0, nums.length - 1), process(nums, 1, nums.length)); &#125; private int process(int[] nums, int start, int end) &#123; int[] dp = new int[3]; dp[0] = nums[start]; dp[1] = Math.max(nums[start], nums[start + 1]); for (int i = 2; i &lt; end - start; ++i) &#123; dp[i % 3] = Math.max(dp[(i - 1) % 3], dp[(i - 2) % 3] + nums[i + start]); &#125; return dp[(end - start - 1) % 3]; &#125;&#125; 方法三：记忆化搜索 1234567891011121314151617181920212223class Solution &#123; int[] dp; public int rob(int[] nums) &#123; if (nums.length == 1) return nums[0]; if (nums.length == 2) return Math.max(nums[0], nums[1]); dp = new int[nums.length]; Arrays.fill(dp, -1); int res1 = dfs(nums, 0, nums.length - 2); Arrays.fill(dp, -1); int res2 = dfs(nums, 1, nums.length - 1); return Math.max(res1, res2); &#125; private int dfs(int[] nums, int start, int index) &#123; if (index &lt; start) return 0; if (dp[index] != -1) return dp[index]; return dp[index] = Math.max(dfs(nums, start, index - 1), dfs(nums, start, index - 2) + nums[index]); &#125;&#125; 二刷记忆化搜索 12345678910111213141516171819202122class Solution &#123; public int rob(int[] nums) &#123; if (nums.length == 1) return nums[0]; this.nums = nums; dp = new int[nums.length]; Arrays.fill(dp, -1); int res1 = dfs(0, nums.length - 1); Arrays.fill(dp, -1); return Math.max(res1, dfs(1, nums.length)); &#125; int[] dp, nums; private int dfs(int start, int end) &#123; if (start &gt;= end) return 0; if (dp[start] != -1) return dp[start]; return dp[start] = Math.max(dfs(start + 1, end), dfs(start + 2, end) + nums[start]); &#125;&#125; 337. 打家劫舍 III 方法一：DP 1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; // steal: 偷当前节点能获得的最大金额 // pass: 不偷当前节点能获得的最大金额 // steal(cur) = cur.val + pass(cur.left) + pass(cur.right) // pass(cur) = max(steal(cur.left), pass(steal.right)) + max(steal(cur.right), pass(steal.right)) Map&lt;TreeNode, Integer&gt; steal = new HashMap&lt;&gt;(); Map&lt;TreeNode, Integer&gt; pass = new HashMap&lt;&gt;(); public int rob(TreeNode root) &#123; dfs(root); return Math.max(steal.getOrDefault(root, 0), pass.getOrDefault(root, 0)); &#125; public void dfs(TreeNode root) &#123; if (root == null) return; dfs(root.left); dfs(root.right); steal.put(root, root.val + pass.getOrDefault(root.left, 0) + pass.getOrDefault(root.right, 0)); pass.put(root, Math.max(steal.getOrDefault(root.left, 0), pass.getOrDefault(root.left, 0)) + Math.max(steal.getOrDefault(root.right, 0), pass.getOrDefault(root.right, 0))); &#125;&#125; 方法二：乱写的的dfs 1234567891011121314151617181920212223242526272829class Solution &#123; // steal: 偷当前节点能获得的最大金额 // pass: 不偷当前节点能获得的最大金额 // steal(cur) = cur.val + pass(cur.left) + pass(cur.right) // pass(cur) = max(steal(cur.left), pass(steal.right)) + max(steal(cur.right), pass(steal.right)) Map&lt;TreeNode, Integer&gt; steal = new HashMap&lt;&gt;(); Map&lt;TreeNode, Integer&gt; pass = new HashMap&lt;&gt;(); public int rob(TreeNode root) &#123; int steal = dfs(root, 0); int pass = dfs(root, 1); return Math.max(steal, pass); &#125; public int dfs(TreeNode root, int flag) &#123; if (root == null) return 0; if (flag == 1 &amp;&amp; pass.get(root) != null) &#123; return pass.get(root); &#125; else if (flag == 0 &amp;&amp; steal.get(root) != null) &#123; return steal.get(root); &#125; steal.put(root, root.val + pass.getOrDefault(root.left, dfs(root.left, 1)) + pass.getOrDefault(root.right, dfs(root.right, 1))); pass.put(root, Math.max(steal.getOrDefault(root.left, dfs(root.left, 0)), pass.getOrDefault(root.left, dfs(root.left, 1))) + Math.max(steal.getOrDefault(root.right, dfs(root.right, 0)), pass.getOrDefault(root.right, dfs(root.right, 1)))); if (flag == 0) return steal.getOrDefault(root, 0); else return pass.getOrDefault(root, 0); &#125;&#125; 方法三：记忆化搜索 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public int rob(TreeNode root) &#123; return dfs(root); &#125; Map&lt;TreeNode, Integer&gt; map = new HashMap&lt;&gt;(); public int dfs(TreeNode root) &#123; if (root == null) return 0; if (map.containsKey(root)) return map.get(root); int left = 0, right = 0; if (root.left != null) left = dfs(root.left.left) + dfs(root.left.right); if (root.right != null) right = dfs(root.right.left) + dfs(root.right.right); int steal = root.val + left + right; int pass = dfs(root.left) + dfs(root.right); int max = Math.max(steal, pass); map.put(root, max); return max; &#125;&#125; 494. 目标和 方法一：01背包 12345678910111213141516171819class Solution &#123; public int findTargetSumWays(int[] nums, int target) &#123; int sum = Arrays.stream(nums).sum(); int diff = sum - target; if (diff % 2 == 1 || diff &lt; 0) return 0; target = diff / 2; // dp[j]:装满容量为j的方法数 // dp[0] = 1,装满容量为0的背包有一种 int[] dp = new int[target + 1]; dp[0] = 1; for (int i = 0; i &lt; nums.length; ++i) &#123; for (int j = target; j &gt;= nums[i]; --j) &#123; dp[j] += dp[j - nums[i]]; &#125; &#125; return dp[target]; &#125;&#125; 方法二：回溯 使用sum，对sum作加操作，相当于对target作减操作 1234567891011121314151617class Solution &#123; int res = 0; public int findTargetSumWays(int[] nums, int target) &#123; backtracking(nums, target, 0); return res; &#125; private void backtracking(int[] nums, int target, int start) &#123; if (start == nums.length) &#123; if (target == 0) ++res; return; &#125; backtracking(nums, target + nums[start], start + 1); backtracking(nums, target - nums[start], start + 1); &#125;&#125; 方法三：回溯的另一种写法 123456789101112class Solution &#123; public int findTargetSumWays(int[] nums, int target) &#123; return dfs(nums, target, 0, 0); &#125; private int dfs(int[] nums, int target, int start, int sum) &#123; if (start == nums.length) &#123; return target == sum ? 1 : 0; &#125; return dfs(nums, target, start + 1, sum - nums[start]) + dfs(nums, target, start + 1, sum + nums[start]); &#125;&#125; 更加精简的回溯 1234567891011class Solution &#123; public int findTargetSumWays(int[] nums, int target) &#123; return dfs(nums, target, 0); &#125; private int dfs(int[] nums, int target, int index) &#123; if (index == nums.length) return target == 0 ? 1 : 0; return dfs(nums, target - nums[index], index + 1) + dfs(nums, target + nums[index], index + 1); &#125;&#125; 方法四：记忆化搜索 相比回溯，使用数组记录已经计算过的结果，return前先赋值给数组memo 每次遍历时，首先检查memo中是否已经有结果(已经计算过了)，有结果直接返回结果 123456789101112131415161718class Solution &#123; int[][] memo; public int findTargetSumWays(int[] nums, int target) &#123; memo = new int[nums.length][2001]; for (int[] m : memo) Arrays.fill(m, -1); return dfs(nums, target, nums.length - 1, 0); &#125; private int dfs(int[] nums, int target, int start, int sum) &#123; if (start &lt; 0) &#123; return target == sum ? 1 : 0; &#125; if (memo[start][sum + 1000] != -1) return memo[start][sum + 1000]; return memo[start][sum + 1000] = dfs(nums, target, start - 1, sum - nums[start]) + dfs(nums, target, start - 1, sum + nums[start]); &#125;&#125; 二刷记忆化搜索 需要多开辟一点数组空间 123456789101112131415161718class Solution &#123; public int findTargetSumWays(int[] nums, int target) &#123; dp = new int[3001][nums.length + 1]; for (int[] arr : dp) Arrays.fill(arr, -1); return dfs(nums, target, 0); &#125; int[][] dp; private int dfs(int[] nums, int target, int index) &#123; if (index == nums.length) return target == 0 ? 1 : 0; if (dp[target + 1000][index] != -1) return dp[target + 1000][index]; return dp[target + 1000][index] = dfs(nums, target - nums[index], index + 1) + dfs(nums, target + nums[index], index + 1); &#125;&#125; 64. 最小路径和 方法一：回溯超时 12345678910111213141516171819202122232425class Solution &#123; int[][] dirs = new int[][]&#123; &#123;1, 0&#125;, &#123;0, 1&#125;&#125;; int res = Integer.MAX_VALUE; public int minPathSum(int[][] grid) &#123; int m = grid.length, n = grid[0].length; dfs(grid, m, n, 0, 0, grid[m - 1][n - 1]); // 最后一次答案没有计算，所以在遍历前加上 return res; &#125; private void dfs(int[][] grid, int m, int n, int i, int j, int sum) &#123; if(i == m - 1 &amp;&amp; j == n - 1) &#123; res = Math.min(res, sum); return; &#125; sum += grid[i][j]; if (isValid(i + 1, j, m, n)) dfs(grid, m, n, i + 1, j, sum); if (isValid(i, j + 1, m, n)) dfs(grid, m, n, i, j + 1, sum); &#125; private boolean isValid(int row, int col, int m, int n) &#123; return row &gt;= 0 &amp;&amp; col &gt;= 0 &amp;&amp; row &lt; m &amp;&amp; col &lt; n; &#125;&#125; 方法二：记忆化搜索 1234567891011121314151617181920212223242526class Solution &#123; int res = Integer.MAX_VALUE; int dp[][]; public int minPathSum(int[][] grid) &#123; int m = grid.length, n = grid[0].length; // dp[i][j]:grid[i][j]到右下角的最小距离 dp = new int[m][n]; for (int[] arr : dp) Arrays.fill(arr, -1); return dfs(grid, m - 1, n - 1); &#125; private int dfs(int[][] grid, int i, int j) &#123; if (i == 0 &amp;&amp; j == 0) return grid[0][0]; if (i &lt; 0 || j &lt; 0) return 8000000; if (dp[i][j] != -1) return dp[i][j]; return dp[i][j] = grid[i][j] + Math.min(dfs(grid, i - 1, j), dfs(grid, i, j - 1)); &#125; private boolean isValid(int row, int col) &#123; return row &gt;= 0 &amp;&amp; col &gt;= 0; &#125;&#125; 二刷记忆化搜索 12345678910111213141516171819202122232425262728class Solution &#123; public int minPathSum(int[][] grid) &#123; dp = new int[grid.length][grid[0].length]; for (int[] arr : dp) Arrays.fill(arr, -1); return dfs(grid, 0, 0); &#125; int[][] dirs = new int[][]&#123;&#123;1, 0&#125;, &#123;0, 1&#125;&#125;; int[][] dp; private int dfs(int[][] grid, int i, int j) &#123; if (i == grid.length - 1 &amp;&amp; j == grid[0].length - 1) return grid[i][j]; if (dp[i][j] != -1) return dp[i][j]; int res = 40000; for (int[] dir : dirs) &#123; int sum = grid[i][j]; int row = i + dir[0], col = j + dir[1]; if (row &lt; grid.length &amp;&amp; col &lt; grid[0].length) &#123; sum += dfs(grid, row, col); dp[i][j] = res = Math.min(res, sum); &#125; &#125; return res; &#125;&#125; 62. 不同路径 方法一：记忆化搜索 12345678910111213141516171819class Solution &#123; int[][] dp; public int uniquePaths(int m, int n) &#123; dp = new int[m + 1][n + 1]; for (int[] arr : dp) Arrays.fill(arr, -1); return dfs(m, n); &#125; private int dfs(int i, int j) &#123; if (i == 1 &amp;&amp; j == 1) return 1; if (i &lt; 1 || j &lt; 1) return 0; if (dp[i][j] != -1) return dp[i][j]; return dp[i][j] = dfs(i - 1, j) + dfs(i, j - 1); &#125;&#125; 二刷记忆化搜索 123456789101112131415161718class Solution &#123; public int uniquePaths(int m, int n) &#123; dp = new int[m + 1][n + 1]; return dfs(1, 1, m, n); &#125; int[][] dp; private int dfs(int i, int j, int m, int n) &#123; if (i == m &amp;&amp; j == n) return 1; if (i &gt; m || j &gt; n) return 0; if (dp[i][j] != 0) return dp[i][j]; return dp[i][j] = dfs(i + 1, j, m, n) + dfs(i, j + 1, m, n); &#125;&#125; 63. 不同路径 II 方法一：记忆化搜索 obstacleGrid[i][j] == 1的判断要在if (i == 0 &amp;&amp; j == 0)上面，不然会报如下错 1234567891011121314151617181920class Solution &#123; int[][] dp; public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123; int m = obstacleGrid.length, n = obstacleGrid[0].length; dp = new int[m][n]; for (int[] arr : dp) Arrays.fill(arr, -1); return dfs(obstacleGrid, m - 1, n - 1); &#125; private int dfs(int[][] obstacleGrid, int i, int j) &#123; if (i &lt; 0 || j &lt; 0 || obstacleGrid[i][j] == 1) return 0; if (i == 0 &amp;&amp; j == 0) return 1; if (dp[i][j] != -1) return dp[i][j]; return dp[i][j] = dfs(obstacleGrid,i - 1, j) + dfs(obstacleGrid, i, j - 1); &#125;&#125; 二刷记忆化搜索 1234567891011121314151617181920class Solution &#123; public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123; m = obstacleGrid.length; n = obstacleGrid[0].length; dp = new int[m][n]; return dfs(obstacleGrid, 0, 0); &#125; int[][] dp; int m, n; private int dfs(int[][] obstacleGrid, int i, int j) &#123; if (i == m || j == n || obstacleGrid[i][j] == 1) return 0; if (i == m - 1 &amp;&amp; j == n - 1) return 1; if (dp[i][j] != 0) return dp[i][j]; return dp[i][j] = dfs(obstacleGrid, i + 1, j) + dfs(obstacleGrid, i, j + 1); &#125;&#125; 139. 单词拆分 方法一：DP 1234567891011121314151617181920class Solution &#123; // dp[i]:前i个字符是否能被字典中的单词拼接出 // 状态转移：dp[i] = dp[j] &amp;&amp; set.contains(s.substring(j, i)) (j &lt; i) boolean[] dp; Set&lt;String&gt; set; public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123; dp = new boolean[s.length() + 1]; set = new HashSet&lt;&gt;(wordDict); dp[0] = true; for (int i = 1; i &lt;= s.length(); ++i) &#123; for (int j = 0; j &lt; i; ++j) &#123; if (dp[j] &amp;&amp; set.contains(s.substring(j, i))) &#123; dp[i] = true; break; &#125; &#125; &#125; return dp[s.length()]; &#125;&#125; 方法二：回溯(超时) 123456789101112131415161718class Solution &#123; Set&lt;String&gt; set; public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123; set = new HashSet&lt;&gt;(wordDict); return dfs(s, 0); &#125; private boolean dfs(String s, int index) &#123; if (index == s.length()) return true; for (int i = index; i &lt; s.length(); ++i) &#123; String str = s.substring(index, i + 1); if (set.contains(str) &amp;&amp; dfs(s, i + 1)) return true; &#125; return false; &#125;&#125; 方法二：记忆化搜索 dp[i]：从下标i到结尾，是否拼接出单词 1234567891011121314151617181920212223242526class Solution &#123; Set&lt;String&gt; set; int[] dp; public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123; set = new HashSet&lt;&gt;(wordDict); dp = new int[s.length() + 1]; Arrays.fill(dp, -1); return dfs(s, 0); &#125; private boolean dfs(String s, int index) &#123; if (index == s.length())//能走到这，说明之前的字符串全能被单词拼接 return true; if (dp[index] != -1) return dp[index] == 0 ? false : true; for (int i = index; i &lt; s.length(); ++i) &#123; String str = s.substring(index, i + 1); if (set.contains(str)) &#123; dp[i + 1] = dfs(s, i + 1) ? 1 : 0; if (dp[i + 1] == 1) return true; // 找到一个答案就返回true &#125; &#125; return false; &#125;&#125; 397. 整数替换 方法一：记忆化搜索 1234567891011121314151617181920212223class Solution &#123; Map&lt;Long, Integer&gt; map = new HashMap&lt;&gt;(); public int integerReplacement(int n) &#123; return dfs(n); &#125; private int dfs(long n) &#123; if (n == 1) return 0; if (map.containsKey(n)) return map.get(n); int count = 0; if (n % 2 == 0) &#123; count = dfs(n &gt;&gt; 1) + 1; &#125; else &#123; count = Math.min(dfs(n + 1), dfs(n - 1)) + 1; &#125; map.put(n, count); return count; &#125;&#125; 55. 跳跃游戏 方法一：记忆化搜索 12345678910111213141516171819202122class Solution &#123; int[] dp; public boolean canJump(int[] nums) &#123; dp = new int[nums.length]; return dfs(nums, 0); &#125; private boolean dfs(int[] nums, int index) &#123; if (index &gt;= nums.length - 1) return true; if (dp[index] != 0) return dp[index] == 1; for (int i = 1; i &lt;= nums[index]; ++i) &#123; if (dfs(nums, index + i)) &#123; dp[index] = 1; return true; &#125; &#125; dp[index] = -1; return false; &#125;&#125; 方法二：贪心 1234567891011121314class Solution &#123; public boolean canJump(int[] nums) &#123; int n = nums.length; int rightmost = 0; for (int i = 0; i &lt; n; ++i) &#123; if (i &lt;= rightmost) &#123; rightmost = Math.max(rightmost, i + nums[i]); if (rightmost &gt;= n - 1) return true; &#125; &#125; return false; &#125;&#125; 方法三：回溯(超时) 123456789101112131415class Solution &#123; public boolean canJump(int[] nums) &#123; return dfs(nums, 0); &#125; private boolean dfs(int[] nums, int index) &#123; if (index &gt;= nums.length - 1) return true; for (int i = 1; i &lt;= nums[index]; ++i) if (dfs(nums, index + i)) return true; return false; &#125; &#125; 二刷记忆化搜索 1234567891011121314151617181920212223class Solution &#123; int[] dp; public boolean canJump(int[] nums) &#123; dp = new int[nums.length]; return dfs(nums, 0); &#125; private boolean dfs(int[] nums, int index) &#123; if (index &gt;= nums.length - 1) return true; if (dp[index] != 0) return dp[index] == 1; for (int i = 1; i &lt;= nums[index]; ++i) &#123; dp[index] = dfs(nums, index + i) == true ? 1 : -1; if (dp[index] == 1) return true; &#125; return false; &#125; &#125; 45. 跳跃游戏 II 123456789101112131415161718192021222324class Solution &#123; public int jump(int[] nums) &#123; dp = new int[nums.length]; return dfs(nums, 0); &#125; int[] dp; int res = 10001; private int dfs(int[] nums, int index) &#123; if (index &gt;= nums.length - 1) &#123; return 0; &#125; if (dp[index] != 0) return dp[index]; int min = 10001; for (int i = 1; i &lt;= nums[index]; ++i) &#123; min = Math.min(min, dfs(nums, index + i) + 1); &#125; return dp[index] = min; &#125; &#125; 方法二：贪心 322. 零钱兑换 方法一：记忆化搜索 12345678910111213141516171819202122232425class Solution &#123; public int coinChange(int[] coins, int amount) &#123; dp = new int[amount + 1]; Arrays.fill(dp, -1); int res = dfs(coins, amount); return res == 10001 ? -1 : res; &#125; int[] dp; private int dfs(int[] coins, int amount) &#123; if (amount == 0) return 0; if (dp[amount] != -1) return dp[amount]; int min = 10001; for (int i = 0; i &lt; coins.length; ++i) &#123; if (amount - coins[i] &lt; 0) continue; min = Math.min(min, dfs(coins, amount - coins[i]) + 1); &#125; return dp[amount] = min; &#125; &#125; 方法二：完全背包 518. 零钱兑换 II 方法一：完全背包 方法二：回溯(超时) 12345678910111213141516171819202122class Solution &#123; public int change(int amount, int[] coins) &#123; Arrays.sort(coins); dfs(amount, coins, 0); return res; &#125; int res = 0; public void dfs(int amount, int[] coins, int index) &#123; if (amount == 0) &#123; ++res; return; &#125; for (int i = index; i &lt; coins.length; ++i) &#123; if (amount &lt; coins[i]) break; dfs(amount - coins[i], coins, i); &#125; &#125; &#125; 回溯另一种写法 123456789101112131415161718public int change(int amount, int[] coins) &#123; Arrays.sort(coins); return dfs(amount, coins, 0);&#125;public int dfs(int amount, int[] coins, int index) &#123; if (amount == 0) &#123; return 1; &#125; int count = 0; for (int i = index; i &lt; coins.length; ++i) &#123; if (amount &lt; coins[i]) break; count += dfs(amount - coins[i], coins, i); &#125; return count;&#125; 方法三：记忆化搜索 需要用二位数组存储当前amount，与遍历到的下标 1234567891011121314151617181920212223242526class Solution &#123; public int change(int amount, int[] coins) &#123; dp = new int[amount + 1][coins.length]; for (int[] arr : dp) Arrays.fill(arr, -1); Arrays.sort(coins); return dfs(amount, coins, 0); &#125; int[][] dp; public int dfs(int amount, int[] coins, int index) &#123; if (amount == 0) &#123; return 1; &#125; if (dp[amount][index] != -1) return dp[amount][index]; int count = 0; for (int i = index; i &lt; coins.length; ++i) &#123; if (amount &lt; coins[i]) break; count += dfs(amount - coins[i], coins, i); &#125; return dp[amount][index] = count; &#125;&#125; 343. 整数拆分 方法一：记忆化搜索 123456789101112131415161718192021222324class Solution &#123; int[] dp; public int integerBreak(int n) &#123; // dp[i]:将i拆分成若干正整数，将他们相乘的最大值 // dp[1] = 1; dp[2] = 1 dp = new int[n + 1]; dp[1] = 1; int res = dfs(n); return res; &#125; private int dfs(int n) &#123; if (n == 2) return 1; if (dp[n] != 0) return dp[n]; int max = 0; for (int i = 1; i &lt;= n - 1; ++i) &#123; int k = n - i; max = Math.max(max, Math.max(k * dfs(i), k * i)); &#125; return dp[n] = max; &#125;&#125; res = Math.max(res, Math.max(i * (n - i), dfs(n - i) * i));这一句后面为什么不是dfs(n - i) * dfs(i) 比如 如果dfs(i) * dfs(k)，那么6和2会被拆分成3， 3，1 121. 买卖股票的最佳时机 方法一：贪心 123456789101112class Solution &#123; public int maxProfit(int[] prices) &#123; int minStock = 10000, maxProfit = 0; for (int price : prices) &#123; if (price &lt; minStock) &#123; minStock = price; &#125; maxProfit = Math.max(maxProfit, price - minStock); &#125; return maxProfit; &#125;&#125; 方法二：回溯 12345678910111213141516public int maxProfit(int[] prices) &#123; this.prices = prices; return dfs(0, 0);&#125;int[] prices;private int dfs(int index, int state) &#123; if (index == prices.length || state == 2) return 0; if (state == 0) // 不操作 买入 return Math.max(dfs(index + 1, state), dfs(index + 1, state + 1) - prices[index]); // 不操作 卖出 return Math.max(dfs(index + 1, state), dfs(index + 1, state + 1) + prices[index]);&#125; 如果摸不着头脑救去debug吧！ debug版本 1234567891011121314151617181920public int maxProfit(int[] prices) &#123; this.prices = prices; return dfs(0, 0);&#125;int[] prices;private int dfs(int index, int state) &#123; if (index == prices.length || state == 2) return 0; if (state == 0) &#123; int keep0 = dfs(index + 1, state); int buy = dfs(index + 1, state + 1) - prices[index]; return Math.max(keep0, buy); &#125; else &#123; int keep1 = dfs(index + 1, state); int sell = dfs(index + 1, state + 1) + prices[index]; return Math.max(keep1, sell); &#125;&#125; 方法三：记忆化搜索 123456789101112131415161718192021222324class Solution &#123; public int maxProfit(int[] prices) &#123; this.prices = prices; dp = new int[2][prices.length]; for (int[] arr : dp) Arrays.fill(arr, -1); return dfs(0, 0); &#125; int[] prices; int[][] dp; private int dfs(int index, int state) &#123; if (index == prices.length || state == 2) return 0; if (dp[state][index] != -1) return dp[state][index]; if (state == 0) // 不操作 买入 return dp[state][index] = Math.max(dfs(index + 1, 0), dfs(index + 1, 1) - prices[index]); // 不操作 卖出 return dp[state][index] = Math.max(dfs(index + 1, 1), dfs(index + 1, 2) + prices[index]); &#125;&#125; 122. 买卖股票的最佳时机 II 记忆化搜索 123456789101112131415161718192021222324class Solution &#123; public int maxProfit(int[] prices) &#123; this.prices = prices; dp = new int[2][prices.length]; for (int[] arr : dp) Arrays.fill(arr, -1); return dfs(0, 0); &#125; int[] prices; int[][] dp; private int dfs(int index, int state) &#123; if (index == prices.length) return 0; if (dp[state][index] != -1) return dp[state][index]; if (state == 0) // 不操作 买入 return dp[state][index] = Math.max(dfs(index + 1, 0), dfs(index + 1, 1) - prices[index]); // 不操作 卖出 return dp[state][index] = Math.max(dfs(index + 1, 1), dfs(index + 1, 0) + prices[index]); &#125;&#125; 123. 买卖股票的最佳时机 III 记忆化搜索 123456789101112131415161718class Solution &#123; public int maxProfit(int[] prices) &#123; dp = new int[prices.length][4]; for (int[] arr : dp) Arrays.fill(arr, -1); return dfs(prices, 0, 0); &#125; int[][] dp; private int dfs(int[] prices, int index, int state) &#123; if (index == prices.length || state == 4) return 0; if (dp[index][state] != -1) return dp[index][state]; if (state == 0 || state == 2) // 不操作，买入 return dp[index][state] = Math.max(dfs(prices, index + 1, state), dfs(prices, index + 1, state + 1) - prices[index]); return dp[index][state] = Math.max(dfs(prices, index + 1, state), dfs(prices, index + 1, state + 1) + prices[index]); &#125;&#125; 188. 买卖股票的最佳时机 IV 记忆化搜索 1234567891011121314151617181920class Solution &#123; public int maxProfit(int k, int[] prices) &#123; dp = new int[prices.length][2 * k]; this.k = k; for (int[] arr : dp) Arrays.fill(arr, -1); return dfs(prices, 0, 0); &#125; int[][] dp; int k; private int dfs(int[] prices, int index, int state) &#123; if (index == prices.length || state == 2 * k) return 0; if (dp[index][state] != -1) return dp[index][state]; if (state % 2 == 0) // 不操作，买入 return dp[index][state] = Math.max(dfs(prices, index + 1, state), dfs(prices, index + 1, state + 1) - prices[index]); return dp[index][state] = Math.max(dfs(prices, index + 1, state), dfs(prices, index + 1, state + 1) + prices[index]); &#125;&#125; 714. 买卖股票的最佳时机含手续费 记忆化搜索 卖的时候 - fee 或者 买的时候 - fee都可以 1234567891011121314151617181920class Solution &#123; public int maxProfit(int[] prices, int fee) &#123; dp = new int[prices.length][2]; this.fee = fee; for (int[] arr : dp) Arrays.fill(arr, -1); return dfs(prices, 0, 0); &#125; int[][] dp; int fee; private int dfs(int[] prices, int index, int state) &#123; if (index == prices.length) return 0; if (dp[index][state] != -1) return dp[index][state]; if (state == 0) // 不操作，买入 return dp[index][state] = Math.max(dfs(prices, index + 1, 0), dfs(prices, index + 1, 1) - prices[index]); return dp[index][state] = Math.max(dfs(prices, index + 1, 1), dfs(prices, index + 1, 0) + prices[index] - fee); &#125;&#125; 309. 最佳买卖股票时机含冷冻期 记忆化搜索 卖出:index + 2 base case : index &gt;= prices.length 123456789101112131415161718class Solution &#123; public int maxProfit(int[] prices) &#123; dp = new int[prices.length][2]; for (int[] arr : dp) Arrays.fill(arr, -1); return dfs(prices, 0, 0); &#125; int[][] dp; private int dfs(int[] prices, int index, int state) &#123; if (index &gt;= prices.length) return 0; if (dp[index][state] != -1) return dp[index][state]; if (state == 0) // 不操作，买入 return dp[index][state] = Math.max(dfs(prices, index + 1, 0), dfs(prices, index + 1, 1) - prices[index]); return dp[index][state] = Math.max(dfs(prices, index + 1, 1), dfs(prices, index + 2, 0) + prices[index]); &#125;&#125;","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://leopol1d.github.io/categories/Algorithms/"},{"name":"Memorization Searcch","slug":"Algorithms/Memorization-Searcch","permalink":"https://leopol1d.github.io/categories/Algorithms/Memorization-Searcch/"}],"tags":[{"name":"记忆化搜索","slug":"记忆化搜索","permalink":"https://leopol1d.github.io/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"}]},{"title":"Backtracking","slug":"backtracking","date":"2023-05-20T05:46:51.857Z","updated":"2023-06-21T02:03:55.437Z","comments":true,"path":"2023/05/20/backtracking/","link":"","permalink":"https://leopol1d.github.io/2023/05/20/backtracking/","excerpt":"","text":"Backtracking 93. 复原 IP 地址 解题思路：加“.”分割字符串 注意：isValid()中，如果得到的子串str为空，说明字符串s已经有三个“.”分割，并且最后一个点在最后一个位置，比如101.0.23.， s = s.substring(0, i + 1) + \".\" + s.substring(i + 1);得到字符串s = 101.0.23. ++pointNum; 进入下一轮backtracking(s, i + 2, pointNum); i + 2为.后面一位9 此时pointNum == 3，判断ip是否合法if (isValid(s, start, s.length() - 1)) String str = s.substring(start, end + 1); 此时start为9，end + 1为9，String.subString左闭右开，所以得到的str为空 这种情况返回false 123456789101112131415161718192021222324252627282930313233343536class Solution &#123; List&lt;String&gt; res = new LinkedList&lt;&gt;(); public List&lt;String&gt; restoreIpAddresses(String s) &#123; if (s.length() &gt; 12) return res; backtracking(s, 0, 0); return res; &#125; private void backtracking(String s, int start, int pointNum) &#123; if (pointNum == 3) &#123; if (isValid(s, start, s.length() - 1)) res.add(s); return; &#125; for (int i = start; i &lt; s.length(); ++i) &#123; if (isValid(s, start, i)) &#123; s = s.substring(0, i + 1) + &quot;.&quot; + s.substring(i + 1); ++pointNum; backtracking(s, i + 2, pointNum); --pointNum; s = s.substring(0, i + 1) + s.substring(i + 2); // 删除&quot;.&quot; &#125; else break; &#125; &#125; private boolean isValid(String s, int start, int end) &#123; String str = s.substring(start, end + 1); if (str.isEmpty()) return false; return Integer.valueOf(str) &lt;= 255 &amp;&amp; (str.equals(&quot;0&quot;) ||str.charAt(0) != &#x27;0&#x27;); &#125;&#125; 方法二：回溯(StringBuilder) 需要注意很多细节 isValid 首先需要判断字符串是否为空; Integer.valueOf(s) &lt;= 255的前提是以下else需要break，不然会超出整型最大值 1234567891011for (int i = start; i &lt; s.length(); ++i) &#123; String str = s.substring(start, i + 1); if (isValid(str)) &#123; path.append(str); path.append(&quot;.&quot;); backtracking(s, i + 1, split + 1); deleteSub(); &#125; else break;&#125; 要么为0要么第一个字符不为0，s.equals(\"0\") || s.charAt(0) != '0' 删除函数 一般会做两次path.append操作，先append子串，再append .，所以删除操作先把.删除了，再删除上一个.之前的子串 12345private void deleteSub() &#123; path.deleteCharAt(path.length() - 1); while (path.length() != 0 &amp;&amp; path.charAt(path.length() - 1) != &#x27;.&#x27;) path.deleteCharAt(path.length() - 1);&#125; 注意base case，如果剩余子串满足条件，那么会将子串append到path中，再加到res中，所以在此之后需要回溯一次，将新加入的子串删掉 123456789if (split == 3) &#123; String str = s.substring(start); if (isValid(str)) &#123; path.append(str); res.add(path.toString()); deleteSub(); &#125; return;&#125; 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123; List&lt;String&gt; res = new LinkedList&lt;&gt;(); StringBuilder path = new StringBuilder(); public List&lt;String&gt; restoreIpAddresses(String s) &#123; if (s.length() &gt; 12) return res; backtracking(s, 0, 0); return res; &#125; private void backtracking(String s, int start, int split) &#123; if (split == 3) &#123; String str = s.substring(start); if (isValid(str)) &#123; path.append(str); res.add(path.toString()); deleteSub(); &#125; return; &#125; for (int i = start; i &lt; s.length(); ++i) &#123; String str = s.substring(start, i + 1); if (isValid(str)) &#123; path.append(str); path.append(&quot;.&quot;); backtracking(s, i + 1, split + 1); deleteSub(); &#125; else break; &#125; &#125; private void deleteSub() &#123; path.deleteCharAt(path.length() - 1); while (path.length() != 0 &amp;&amp; path.charAt(path.length() - 1) != &#x27;.&#x27;) path.deleteCharAt(path.length() - 1); &#125; private boolean isValid(String s) &#123; if (s.isEmpty()) return false; return Integer.valueOf(s) &lt;= 255 &amp;&amp; (s.equals(&quot;0&quot;) || s.charAt(0) != &#x27;0&#x27;); &#125;&#125; 方法三：StringBuilder + 剪枝 在方法二的基础上加入剪枝 s.length() - start表示未被选择的子串的长度，记为x吧，举例说明 如果split = 0，表示还没有进行分割，如果x &gt; 12，一定不能满足条件，return； 如果split = 1，表示分割了一段，如果x &gt; 9，一定不能满足条件，return； 12if (s.length() - start &gt; 3 * (4 - split)) return; 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123; List&lt;String&gt; res = new LinkedList&lt;&gt;(); StringBuilder path = new StringBuilder(); public List&lt;String&gt; restoreIpAddresses(String s) &#123; backtracking(s, 0, 0); return res; &#125; private void backtracking(String s, int start, int split) &#123; if (split == 3) &#123; String str = s.substring(start); if (isValid(str)) &#123; path.append(str); res.add(path.toString()); deleteSub(); &#125; return; &#125; if (s.length() - start &gt; 3 * (4 - split)) return; for (int i = start; i &lt; s.length(); ++i) &#123; String str = s.substring(start, i + 1); if (isValid(str)) &#123; path.append(str); path.append(&quot;.&quot;); backtracking(s, i + 1, split + 1); deleteSub(); &#125; else break; &#125; &#125; private void deleteSub() &#123; path.deleteCharAt(path.length() - 1); while (path.length() != 0 &amp;&amp; path.charAt(path.length() - 1) != &#x27;.&#x27;) path.deleteCharAt(path.length() - 1); &#125; private boolean isValid(String s) &#123; if (s.isEmpty()) return false; return Integer.valueOf(s) &lt;= 255 &amp;&amp; (s.equals(&quot;0&quot;) || s.charAt(0) != &#x27;0&#x27;); &#125;&#125; 131. 分割回文串 方法一：回溯 二刷 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; List&lt;List&lt;String&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;String&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;String&gt;&gt; partition(String s) &#123; backtracking(s, 0); return res; &#125; private void backtracking(String s, int start) &#123; if (start == s.length()) &#123; res.add(new LinkedList&lt;&gt;(path)); return; &#125; for (int i = start; i &lt; s.length(); ++i) &#123; String split = s.substring(start, i + 1); if (isValid(split)) &#123; path.add(split); backtracking(s, i + 1); path.pollLast(); &#125; &#125; &#125; private boolean isValid(String split) &#123; int start = 0, end = split.length() - 1; while (start &lt; end) &#123; if (split.charAt(start++) != split.charAt(end--)) return false; &#125; return true; &#125;&#125; 方法二：回溯 + DP预处理 使用动态规划得到所有子串是否是回文 状态：dp[i][j] 表示字符串s在[i,j]区间的子串是否是一个回文串。 状态转移方程：当 s[i] == s[j] &amp;&amp; (j - i &lt; 2 || dp[i + 1][j - 1]) 时，dp[i][j]=true，否则为false 这个状态转移方程是什么意思呢？ 当只有一个字符时，比如 a 自然是一个回文串。 当有两个字符时，如果是相等的，比如 aa，也是一个回文串。 当有三个及以上字符时，比如 ababa 这个字符记作串 1，把两边的 a 去掉，也就是 bab 记作串 2，可以看出只要串2是一个回文串，那么左右各多了一个 a 的串 1 必定也是回文串。所以当 s[i]==s[j] 时，自然要看 dp[i+1][j-1] 是不是一个回文串。 12345678910111213141516171819202122232425262728293031class Solution &#123; List&lt;List&lt;String&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;String&gt; path = new LinkedList&lt;&gt;(); int n; boolean[][] dp; public List&lt;List&lt;String&gt;&gt; partition(String s) &#123; n = s.length(); dp = new boolean[n][n]; for (int j = 0; j &lt; n; ++j) for (int i = 0; i &lt;= j; ++i) if (s.charAt(i) == s.charAt(j) &amp;&amp; (j - i &lt; 2 || dp[i + 1][j - 1])) dp[i][j] = true; backtracking(s, 0); return res; &#125; private void backtracking(String s, int start) &#123; if (start == s.length()) &#123; res.add(new LinkedList&lt;&gt;(path)); return; &#125; for (int i = start; i &lt; s.length(); ++i) &#123; String str = s.substring(start, i + 1); if (dp[start][i]) &#123; path.add(str); backtracking(s, i + 1); path.pollLast(); &#125; &#125; &#125;&#125; 剑指 Offer II 085. 生成匹配的括号 1234567891011121314151617181920class Solution &#123; List&lt;String&gt; res = new LinkedList&lt;&gt;(); public List&lt;String&gt; generateParenthesis(int n) &#123; backtracking(n, n, &quot;&quot;); return res; &#125; private void backtracking(int leftNum, int rightNum, String parenthesis) &#123; if (leftNum == 0 &amp;&amp; rightNum == 0) &#123; res.add(parenthesis); return; &#125; if (leftNum &gt; 0) &#123; backtracking(leftNum - 1, rightNum, parenthesis + &quot;(&quot;); &#125; if (leftNum &lt; rightNum) &#123; backtracking(leftNum, rightNum - 1, parenthesis + &quot;)&quot;); &#125; &#125;&#125; 方法二：StringBuilder 12345678910111213141516171819202122232425class Solution &#123; List&lt;String&gt; res = new LinkedList&lt;&gt;(); StringBuilder path = new StringBuilder(); public List&lt;String&gt; generateParenthesis(int n) &#123; backtracking(n, n); return res; &#125; private void backtracking(int left, int right) &#123; if (left == 0 &amp;&amp; right == 0) &#123; res.add(path.toString()); return; &#125; if (left &gt; 0) &#123; path.append(&quot;(&quot;); backtracking(left - 1, right); path.deleteCharAt(path.length() - 1); &#125; if (left &lt; right) &#123; path.append(&quot;)&quot;); backtracking(left, right - 1); path.deleteCharAt(path.length() - 1); &#125; &#125;&#125; 77. 组合 方法一： 剪枝： 当前最多用n - i + 1 当前还需要加入k - path.size()个数组 n - i + 1 &gt;= k - path.size 1234567891011121314151617181920class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; backtracking(n, k, 1); return res; &#125; private void backtracking(int n, int k, int start) &#123; if (path.size() == k) &#123; res.add(new LinkedList&lt;&gt;(path)); return; &#125; for (int i = start; i &lt;= n - (k - path.size()) + 1; ++i) &#123; path.add(i); backtracking(n, k, i + 1); path.pollLast(); &#125; &#125;&#125; 方法二： 123456789101112131415161718192021222324class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; // 防止底层扩容 Deque&lt;Integer&gt; path = new ArrayDeque&lt;&gt;(k); backtracking(path, n, k, 1); return res; &#125; private void backtracking(Deque&lt;Integer&gt; path, int n, int k, int start) &#123; if (k == 0) &#123; res.add(new LinkedList&lt;&gt;(path)); return; &#125; // 若n=3，k=2,即从[1,2,3]中选两个数，如果当前什么都没选(k=2)，n - k + 1= 2， // 说明至少要从2开始，才能满足选两个数这个要求 int bound = n - k + 1; if (start &gt; bound) return; backtracking(path, n, k, start + 1); path.addLast(start); backtracking(path, n, k - 1, start + 1); path.removeLast(); &#125;&#125; 两种方法的树形结构（求子集为例子） 216. 组合总和 III 方法一： 注意：backtracking(k - 1, n - i, i + 1);k - 1，别写成--k!!! 1234567891011121314151617181920public class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) &#123; backtracking(k, n, 1); return res; &#125; private void backtracking(int k, int n, int start) &#123; if (k == 0) &#123; if (n == 0) res.add(new LinkedList&lt;&gt;(path)); return; &#125; for (int i = start; i &lt;= 9 - (k - path.size()) + 1; ++i) &#123; path.offerLast(i); backtracking(k - 1, n - i, i + 1); path.pollLast(); &#125; &#125; 方法二： 1234567891011121314151617181920212223public class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) &#123; backtracking(k, n, 1); return res; &#125; private void backtracking(int k, int n, int start) &#123; if (k == 0) &#123; if (n == 0) res.add(new LinkedList&lt;&gt;(path)); return; &#125; int bound = 9 - k + 1; if (start &gt; bound) return; backtracking(k, n, start + 1); path.offerLast(start); backtracking(k - 1, n - start, start + 1); path.pollLast(); &#125;&#125; 39. 组合总和 无重复元素，每个元素可以无限次选取 方法一： 剪枝： 12if (target &lt; candidates[i]) break; 可重复选取，所以backtracking传入的是当前下标i 1backtracking(candidates, target - candidates[i], i); 剪枝的条件是把数组排序 1Arrays.sort(candidates); 123456789101112131415161718192021222324List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;();Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;();public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; Arrays.sort(candidates); backtracking(candidates, target, 0); return res;&#125;private void backtracking(int[] candidates, int target, int start) &#123; if (target &lt; 0) return; if (target == 0) &#123; res.add(new LinkedList&lt;&gt;(path)); return; &#125; for (int i = start; i &lt; candidates.length; ++i) &#123; if (target &lt; candidates[i]) break; path.offerLast(candidates[i]); backtracking(candidates, target - candidates[i], i); path.pollLast(); &#125;&#125; 方法二： 1234567891011121314151617181920212223class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; Arrays.sort(candidates); backtracking(candidates, target, 0); return res; &#125; private void backtracking(int[] candidates, int target, int start) &#123; if (target &lt; 0 || start == candidates.length) return; if (target == 0) &#123; res.add(new LinkedList&lt;&gt;(path)); return; &#125; backtracking(candidates, target, start + 1); path.offerLast(candidates[start]); backtracking(candidates, target - candidates[start], start); path.pollLast(); &#125;&#125; 40. 组合总和 II 数组内有重复元素，每个元素只能使用一次，解集不能包含重复组合 方法一： 剪枝 12if (candidates[i] &gt; target) break; 去重 12if (i &gt; start &amp;&amp; candidates[i] == candidates[i - 1]) continue; 1234567891011121314151617181920212223242526class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; Arrays.sort(candidates); backtracking(candidates, target, 0); return res; &#125; private void backtracking(int[] candidates, int target, int start) &#123; if (target == 0) &#123; res.add(new LinkedList&lt;&gt;(path)); return; &#125; for (int i = start; i &lt; candidates.length; ++i) &#123; if (candidates[i] &gt; target) break; if (i &gt; start &amp;&amp; candidates[i] == candidates[i - 1]) continue; path.offerLast(candidates[i]); backtracking(candidates, target - candidates[i], i + 1); path.pollLast(); &#125; &#125;&#125; 78. 子集 1234567891011121314151617181920class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; backtracking(nums, 0); return res; &#125; private void backtracking(int[] nums, int start) &#123; if (start == nums.length) &#123; res.add(new LinkedList&lt;&gt;(path)); return; &#125; backtracking(nums, start + 1); path.offerLast(nums[start]); backtracking(nums, start + 1); path.pollLast(); &#125;&#125; 491. 递增子序列 方法一：顺序DFS 注意： HashSet的位置！！！每进入一层递归，就会在for循环前创建一个HashSet，这样可以保证树层去重，并且树枝不会去重 peekLast()! 不是peek() 1234567891011121314151617181920212223class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; findSubsequences(int[] nums) &#123; backtracking(nums, 0); return res; &#125; public void backtracking(int[] nums, int start) &#123; if (path.size() &gt;= 2) res.add(new LinkedList(path)); Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int i = start; i &lt; nums.length; ++i) &#123; if ((!path.isEmpty() &amp;&amp; nums[i] &lt; path.peekLast())) continue; if (set.contains(nums[i])) continue; set.add(nums[i]); path.add(nums[i]); backtracking(nums, i + 1); path.pollLast(); &#125; &#125;&#125; 46. 全排列 把树形结构画出来就懂了 for (int i = 0; i &lt; nums.length; ++i) { if (used[i]) continue;与 for (int i = 0; i &lt; nums.length &amp;&amp; !used[i]; ++i) 的区别 这两个循环的区别在于循环终止条件的判断逻辑。 第一个循环： 12345for (int i = 0; i &lt; nums.length; ++i) &#123; if (used[i]) continue; // 其他代码逻辑&#125; 这个循环会遍历数组 nums 的所有元素，但在每次迭代中，如果当前元素已经被标记为 used[i]，则会使用 continue 跳过后续的代码逻辑，直接进入下一次迭代。 第二个循环： 123for (int i = 0; i &lt; nums.length &amp;&amp; !used[i]; ++i) &#123; // 其他代码逻辑&#125; 这个循环同样会遍历数组 nums 的所有元素，但在每次迭代中，会先检查终止条件 i &lt; nums.length &amp;&amp; !used[i]。只有当两个条件都满足时，才会执行循环体中的代码逻辑。如果其中任何一个条件不满足，循环就会终止。 12345678910111213141516171819202122232425262728class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path; boolean[] used; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; // 防止底层扩容 path = new ArrayDeque&lt;&gt;(nums.length); used = new boolean[nums.length]; backtracking(nums, 0); return res; &#125; private void backtracking(int[] nums, int start) &#123; if (path.size() == nums.length) &#123; res.add(new ArrayList&lt;&gt;(path)); return; &#125; for (int i = 0; i &lt; nums.length; ++i) &#123; if (used[i]) continue; path.offerLast(nums[i]); used[i] = true; backtracking(nums, i + 1); used[i] = false; path.pollLast(); &#125; &#125;&#125; 47. 全排列 II 为了去重，需要先将数组排序 树层去重，树枝不需要去重 上一个相同的数如果used[i - 1] == false，那么说明已经被遍历过，并且将used数组赋值回false，这个时候就不需要遍历当前nums[i]了；如果used[i - 1] == true，那么说明是在同一路径上 12if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !used[i - 1]) continue; 12345678910111213141516171819202122232425262728293031class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path; boolean[] used; public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; // 防止底层扩容 path = new ArrayDeque&lt;&gt;(nums.length); used = new boolean[nums.length]; Arrays.sort(nums); backtracking(nums, 0); return res; &#125; private void backtracking(int[] nums, int start) &#123; if (path.size() == nums.length) &#123; res.add(new ArrayList&lt;&gt;(path)); return; &#125; for (int i = 0; i &lt; nums.length; ++i) &#123; if (used[i]) continue; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !used[i - 1]) continue; path.offerLast(nums[i]); used[i] = true; backtracking(nums, i + 1); used[i] = false; path.pollLast(); &#125; &#125;&#125; 698. 划分为k个相等的子集 二刷没做出 优质题解 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); int[] bucket; public boolean canPartitionKSubsets(int[] nums, int k) &#123; int sum = Arrays.stream(nums).sum(); if (sum % k != 0) return false; int target = sum / k; bucket = new int[k]; Arrays.sort(nums); int l = 0, r = nums.length - 1; while (l &lt; r) &#123; int temp = nums[l]; nums[l] = nums[r]; nums[r] = temp; ++l; --r; &#125; return backtracking(nums, k, target, 0); &#125; private boolean backtracking(int[] nums, int k, int target, int index) &#123; if (index == nums.length) return true; for (int i = 0; i &lt; k; ++i) &#123; if (i &gt; 0 &amp;&amp; bucket[i - 1] == bucket[i]) continue; if (nums[index] + bucket[i] &gt; target) continue; bucket[i] += nums[index]; if (backtracking(nums, k, target, index + 1)) return true; bucket[i] -= nums[index]; &#125; return false; &#125;&#125; 51. N 皇后 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution &#123; List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; char[][] board = generateBoard(n); backtracking(board, n, 0); return res; &#125; private void backtracking(char[][] board, int n, int row) &#123; if (row == n) &#123; res.add(toList(board)); &#125; for (int col = 0; col &lt; n; ++col) &#123; if (isValid(board, row, col, n)) &#123; board[row][col] = &#x27;Q&#x27;; backtracking(board, n, row + 1); board[row][col] = &#x27;.&#x27;; &#125; &#125; &#125; private List&lt;String&gt; toList(char[][] board) &#123; List&lt;String&gt; path = new LinkedList&lt;&gt;(); for (char[] ch : board) &#123; path.add(new String(ch)); &#125; return path; &#125; private boolean isValid(char[][] board, int row, int col, int n) &#123; // 1.列 for (int i = 0; i &lt; row; ++i) &#123; if (board[i][col] == &#x27;Q&#x27;) return false; &#125; // 2. 45度 for (int i = row - 1, j = col - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; --i, --j) &#123; if (board[i][j] == &#x27;Q&#x27;) &#123; return false; &#125; &#125; // 3.135度 for (int i = row - 1, j = col + 1; i &gt;= 0 &amp;&amp; j &lt; n; --i, ++j) &#123; if (board[i][j] == &#x27;Q&#x27;) &#123; return false; &#125; &#125; return true; &#125; private char[][] generateBoard(int n) &#123; char[][] board = new char[n][n]; for (char[] row : board) Arrays.fill(row, &#x27;.&#x27;); return board; &#125;&#125; 473. 火柴拼正方形 与698. 划分为k个相等的子集一道题 方法一：回溯 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); int[] bucket = new int[4]; public boolean makesquare(int[] matchsticks) &#123; int sum = Arrays.stream(matchsticks).sum(); if (sum % 4 != 0) return false; int target = sum / 4, l = 0, r = matchsticks.length - 1; Arrays.sort(matchsticks); while (l &lt; r) &#123; int temp = matchsticks[l]; matchsticks[l] = matchsticks[r]; matchsticks[r] = temp; ++l; --r; &#125; return backtracking(matchsticks, 0, target); &#125; private boolean backtracking(int[] matchsticks, int index, int target) &#123; if (index == matchsticks.length) return true; for (int i = 0; i &lt; 4; ++i) &#123; if (i &gt; 0 &amp;&amp; bucket[i - 1] == bucket[i]) continue; if (matchsticks[index] + bucket[i] &gt; target) continue; bucket[i] += matchsticks[index]; if (backtracking(matchsticks, index + 1, target)) return true; bucket[i] -= matchsticks[index]; &#125; return false; &#125;&#125; 2305. 公平分发饼干 参考题解 这一题和分割数组的最大值的区别是，这里的cookies不需要连续取！！！！！ 方法一：回溯 12345678910111213141516171819202122232425262728class Solution &#123; int res = Integer.MAX_VALUE; int[] bucket; public int distributeCookies(int[] cookies, int k) &#123; Arrays.sort(cookies); bucket = new int[k]; backtracking(cookies, k, 0); return res; &#125; private void backtracking(int[] cookies, int k, int index) &#123; if (index == cookies.length) &#123; int curAns = Integer.MIN_VALUE; for (int count : bucket)&#123; curAns = Math.max(curAns, count); &#125; res = Math.min(res, curAns); return; &#125; for (int i = 0; i &lt; k; ++i) &#123; if (i &gt; 0 &amp;&amp; bucket[i - 1] == bucket[i]) continue; bucket[i] += cookies[index]; backtracking(cookies, k, index + 1); bucket[i] -= cookies[index]; &#125; &#125;&#125; 方法二：回溯 + 二分 求最小的最大值 用k个框(bucket)装一个数组，所有框统一尺寸，要求框的最小尺寸 left是数组的最大元素，right是数组元素之和，如果把框的尺寸设为left，那么大概率不能容纳所有数组元素： left = mid + 1；如果把框的尺寸设为right，肯定能装下数组所有元素：right = mid - 1 只要check(cookies, mid, k)为true，说明mid刚刚好或者选大了，框的上界可以进一步缩小， 当最后一次满足check(cookies, mid, k)为true并向左滑动右区间，之后只会向右滑动左区间， 最后left = right + 1退出while循环，left就是最小的最大值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123; int[] bucket; public int distributeCookies(int[] cookies, int k) &#123; bucket = new int[k]; Arrays.sort(cookies); int l = 0, r = cookies.length - 1, sum = 0; while (l &lt; r) &#123; int temp = cookies[l]; cookies[l] = cookies[r]; cookies[r] = temp; sum += temp + cookies[l]; ++l; --r; &#125; if (cookies.length % 2 != 0) sum += cookies[cookies.length / 2]; l = cookies[0]; // 数组最大值 r = sum; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if (check(cookies, mid, k)) // mid刚刚好或者选大了，bucket的上界可以进一步缩小 r = mid - 1; else l = mid + 1; &#125; return l; &#125; private boolean check(int[] cookies, int mid, int k) &#123; bucket = new int[k]; return backtracking(cookies, mid, k, 0); &#125; private boolean backtracking(int[] cookies, int limit, int k, int index) &#123; if (index == cookies.length) return true; // 如果能遍历到这一步，说明所有元素都被装入桶中;如果有元素不能放入任意一个桶中，会走完for循环，return false for (int i = 0; i &lt; k; ++i) &#123; if (i &gt; 0 &amp;&amp; bucket[i - 1] == bucket[i]) // 如果两个桶已装容量一致，那么把当前饼干放在哪个桶效果都一样 continue; if (bucket[i] + cookies[index] &gt; limit) continue; bucket[i] += cookies[index]; if (backtracking(cookies, limit, k, index + 1)) return true; // 如果有一种选择已经满足了，return true bucket[i] -= cookies[index]; &#125; return false; &#125;&#125; 1723. 完成所有工作的最短时间 与2305. 公平分发饼干一模一样 方法一：二分 + 回溯 这里的二分和之前做的二分不太一样 要求最小的最大值，我们用二分去测试，如果允许每个bucket的最大值为mid，是否能用k个bucket容纳下jobs的所有元素 l取jobs中最大的元素，r取jobs的和sum，比如每个bucket的最大值为sum，那么一个bucket就能容纳下jobs的所有元素，那么肯定是要取更小的bucket的最大值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123; int[] bucket; public int minimumTimeRequired(int[] jobs, int k) &#123; bucket = new int[k]; Arrays.sort(jobs); int l = 0, r = jobs.length - 1; while (l &lt; r) &#123; int temp = jobs[l]; jobs[l] = jobs[r]; jobs[r] = temp; ++l; --r; &#125; l = jobs[0]; r = Arrays.stream(jobs).sum(); while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if (check(jobs, mid, k)) // mid刚好或者选大了 r = mid - 1; else l = mid + 1; &#125; return l; &#125; private boolean check(int[] jobs, int limit, int k) &#123; bucket = new int[k]; return backtracking(jobs, limit, k, 0); &#125; private boolean backtracking(int[] jobs, int limit, int k, int index) &#123; if (index == jobs.length) return true; for (int i = 0; i &lt; k; ++i) &#123; if (i &gt; 0 &amp;&amp; bucket[i - 1] == bucket[i]) continue; if (jobs[index] + bucket[i] &gt; limit) continue; bucket[i] += jobs[index]; if (backtracking(jobs, limit, k, index + 1)) return true; bucket[i] -= jobs[index]; &#125; return false; &#125;&#125; 优化求sum部分 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution &#123; int[] bucket; public int minimumTimeRequired(int[] jobs, int k) &#123; bucket = new int[k]; Arrays.sort(jobs); int l = 0, r = jobs.length - 1, sum = 0; while (l &lt; r) &#123; int temp = jobs[l]; jobs[l] = jobs[r]; jobs[r] = temp; sum += temp + jobs[l]; ++l; --r; &#125; if (jobs.length % 2 != 0) sum += jobs[jobs.length / 2]; l = jobs[0]; // 数组最大值 r = sum; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if (check(jobs, mid, k)) // mid刚好或者选大了 r = mid - 1; else l = mid + 1; &#125; return l; &#125; private boolean check(int[] jobs, int limit, int k) &#123; bucket = new int[k]; return backtracking(jobs, limit, k, 0); &#125; private boolean backtracking(int[] jobs, int limit, int k, int index) &#123; if (index == jobs.length) return true; for (int i = 0; i &lt; k; ++i) &#123; if (i &gt; 0 &amp;&amp; bucket[i - 1] == bucket[i]) continue; if (jobs[index] + bucket[i] &gt; limit) continue; bucket[i] += jobs[index]; if (backtracking(jobs, limit, k, index + 1)) return true; bucket[i] -= jobs[index]; &#125; return false; &#125;&#125; 二刷 省略check，每次在dfs前重新初始化bucket数组 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public int minimumTimeRequired(int[] jobs, int k) &#123; bucket = new int[k]; Arrays.sort(jobs); int l = 0, r = jobs.length - 1, sum = 0; while (l &lt; r) &#123; int temp = jobs[l]; jobs[l] = jobs[r]; jobs[r] = temp; sum += temp + jobs[l]; ++l; --r; &#125; if (jobs.length % 2 == 1) sum += jobs[jobs.length / 2]; l = jobs[0]; r = sum; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if (dfs(jobs, k, mid, 0)) r = mid - 1; else l = mid + 1; &#125; return l;&#125;int[] bucket;private boolean dfs(int[] jobs, int k, int target, int index) &#123; if (index == jobs.length) &#123; bucket = new int[k]; return true; &#125; for (int i = 0; i &lt; k; ++i) &#123; if (i &gt; 0 &amp;&amp; bucket[i - 1] == bucket[i]) continue; if (bucket[i] + jobs[index] &gt; target) continue; bucket[i] += jobs[index]; if (dfs(jobs, k, target,index + 1)) return true; bucket[i] -= jobs[index]; &#125; return false;&#125;","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://leopol1d.github.io/categories/Algorithms/"},{"name":"backtracking","slug":"Algorithms/backtracking","permalink":"https://leopol1d.github.io/categories/Algorithms/backtracking/"}],"tags":[{"name":"回溯","slug":"回溯","permalink":"https://leopol1d.github.io/tags/%E5%9B%9E%E6%BA%AF/"}]},{"title":"Algorithms","slug":"Algorithms","date":"2023-04-07T08:06:11.000Z","updated":"2023-05-29T10:23:55.658Z","comments":true,"path":"2023/04/07/Algorithms/","link":"","permalink":"https://leopol1d.github.io/2023/04/07/Algorithms/","excerpt":"","text":"LeetCode Solutions Dynamic Programming debug 1234567private static void printDp(int[] dp, int i) &#123; System.out.print(i + &quot;: &quot;); for (int maxValue : dp)&#123; System.out.print(maxValue + &quot; &quot;); &#125; System.out.println();&#125; 509. 斐波那契数 方法一：DP 123456789101112class Solution &#123; public int fib(int n) &#123; if (n == 0) return 0; int[] dp = new int[n + 1]; dp[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; dp[i] = dp[i - 2] + dp[i - 1]; &#125; return dp[n]; &#125;&#125; 方法二：DP + 滚动数组 123456789101112class Solution &#123; public int fib(int n) &#123; if (n == 0) return 0; int[] dp = new int[3]; dp[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; dp[i % 3] = dp[(i - 2) % 3] + dp[(i - 1) % 3]; &#125; return dp[n % 3]; &#125;&#125; 70. 爬楼梯 方法一：DP + 滚动数组 123456789101112131415class Solution &#123; public int climbStairs(int n) &#123; // 1.dp[i]:爬上第i层楼梯的方法数 // 2.状态转移方程：dp[i] = dp[i - 1] + dp[i - 2] // 3.初始化：爬上第0层楼梯的方法数是1，dp[0] = 1,如果是0，那么dp[2] = 1！ // 爬上第一层楼梯的方法数是1,dp[1] = 1 int[] dp = new int[3]; dp[0] = 1; dp[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; dp[i % 3] = dp[(i - 1) % 3] + dp[(i - 2) % 3]; &#125; return dp[n % 3]; &#125;&#125; 746. 使用最小花费爬楼梯 注意：最后一个阶梯之后才是楼顶 image-20230512125550663 方法一：DP + 滚动数组 123456789101112131415class Solution &#123; public int minCostClimbingStairs(int[] cost) &#123; // dp[i]:爬到第i层的最小花费 // 状态转移方程：dp[i] = min(dp[i - 2] + cost[i - 2], dp[i - 1] + cost[i - 1]) // 初始化：dp[0] = 0, dp[1] = 0 int n = cost.length; int[] dp = new int[3]; dp[0] = 0; dp[1] = 0; for (int i = 2; i &lt;= n; ++i) &#123; dp[i % 3] = Math.min(dp[(i - 2) % 3] + cost[i - 2], dp[(i - 1) % 3] + cost[i - 1]); &#125; return dp[n % 3]; &#125;&#125; 剑指Offer 95 最优子结构：求最长公共子序列，求问题最优解，适合使用dp解决。 重叠子问题：求第一个字符串中位置0~\\(i\\)构成的子序列与第二个字符串中0~\\(j\\)构成的子序列的最大公共子序列\\(f(i,j)\\)，需要多次使用\\(f(i-1, j-1), f(i-1,j),f(i,j-1)\\)，拥有重叠子问题 状态转移方程： \\[ f(i,j) = \\begin{cases} f(i-1,j-1)+1, &amp; ch[i]==ch[j] \\\\ max(f(i-1,j),f(i,j-1)), &amp; else \\\\ \\end{cases} \\] 边界条件：dp[0][:] == 0, dp[:][] == 0 令两个字符串长度分别为\\(m,n\\)， 时间复杂度：双重for循环，\\(O(mn)\\) 空间复杂度：需要建立大小为(m+1)(n+1)的数组，因此空间复杂度为\\(O(mn)\\) 1234567891011121314151617class Solution &#123; public int longestCommonSubsequence(String text1, String text2) &#123; int m = text1.length(), n = text2.length(); int[][] dp = new int[m + 1][n + 1]; for (int i = 1; i &lt;= m; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; if (text1.charAt(i - 1) == text2.charAt(j - 1)) &#123; dp[i][j] = dp[i - 1][j - 1] + 1; &#125; else &#123; dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]); &#125; &#125; &#125; return dp[m][n]; &#125;&#125; 如何优化空间复杂度？ 剑指Offer 101 分割等和子集 分析：只要在数组中找到任意数等于数组累加和的一半，该数组就是等和子集，可抽象为经典0-1背包问题。 dp[i][j]:从编号0-i的物品中任选物品(可以都不选)，容量为j的背包能否正好装满 递归公式:dp[i][j] = dp[i-1][j] || j &gt;= num[i] : dp[i-1][j-nums[i]] : false 初始化: 当j==0时，即背包容量为0，不管有多少物品，只要什么都不选就能使背包总重量为0，所以f(i,0)=true 当i==0 &amp;&amp; j!= 0时，即物品数量为0，怎样都不能放满容量大于0的背包，所以f(0,i)=false 遍历顺序：先遍历物品再嵌套从头到尾遍历容量 打印dp数组验证与手写稿是否一致 空间复杂度优化：由于求第i行dp数组只需要用到第i-1行dp数组的信息，所以可以使用一维滑动dp数组代替二维dp数组。 剑指Offer 1049 最后一块石头的重量 II 从 stones数组中选择，凑成总和不超过 \\(sum/2\\) 的最大价值 1234567891011121314class Solution &#123; public int lastStoneWeightII(int[] stones) &#123; int sum = Arrays.stream(stones).sum(); int target = sum / 2; // dp[j]:容量为j的背包能装下不超过target的最大价值 int[] dp = new int[target + 1]; for (int i = 0; i &lt; stones.length; ++i) &#123; for (int j = target; j &gt;= stones[i]; --j) &#123; dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]); &#125; &#125; return sum - dp[target] * 2; &#125;&#125; 一和零 背包问题中，weight里的数据不一定要升序！比如weights=[4,1,3] 方法一：DP 12345678910111213141516171819202122232425class Solution &#123; public int findMaxForm(String[] strs, int m, int n) &#123; // dp[i][j]:最多有i个0，j个1，最多能选的字符数量 int[][][] dp = new int[strs.length + 1][m + 1][n + 1]; for (int k = 1; k &lt;= strs.length; ++k) &#123; String str = strs[k - 1]; int num0 = 0, num1 = 0; for (int x = 0; x &lt; str.length(); ++x) &#123; if (str.charAt(x) == &#x27;0&#x27;) ++num0; else ++num1; &#125; for (int i = 0; i &lt;= m; ++i) &#123; for (int j = 0; j &lt;= n; ++j) &#123; if (i &lt; num0 || j &lt; num1) dp[k][i][j] = dp[k - 1][i][j]; else dp[k][i][j] = Math.max(dp[k - 1][i][j], dp[k - 1][i - num0][j - num1] + 1); &#125; &#125; &#125; return dp[strs.length][m][n]; &#125;&#125; 方法二：DP+滚动数组 12345678910111213141516171819202122class Solution &#123; public int findMaxForm(String[] strs, int m, int n) &#123; // dp[i][j]:最多有i个0，j个1，最多能选的字符数量 int[][] dp = new int[m + 1][n + 1]; for (int k = 1; k &lt;= strs.length; ++k) &#123; String str = strs[k - 1]; int num0 = 0, num1 = 0; for (int x = 0; x &lt; str.length(); ++x) &#123; if (str.charAt(x) == &#x27;0&#x27;) ++num0; else ++num1; &#125; for (int i = m; i &gt;= num0; --i) &#123; for (int j = n; j &gt;= num1; --j) &#123; dp[i][j] = Math.max(dp[i][j], dp[i - num0][j - num1] + 1); &#125; &#125; &#125; return dp[m][n]; &#125;&#125; 518. 零钱兑换 II ​ 经典完全背包问题，解题步骤如下： dp[j]：背包容量为j时，放满背包的组合方法数 状态转移公式：dp[j] = dp[j] + dp[j - coins[i]] 初始化dp[0]：背包容量为0时，有一种方法放满背包（什么都不放） 遍历顺序：求组合数，先便利物品，再遍历容量 遍历dp数组 关于组合和排列的理解：先遍历物品后遍历背包是这样，比如，外层循环固定coins[1]，在内层循环遍历背包时，随着背包不断增加，coins[1]可以重复被添加进来，而由于外层循环固定了，因此coins[2]只能在下一次外层循环添加进不同大小的背包中，这么看的话，coins[i + 1]只能在coins[i]之后了；如果先遍历背包后遍历物品，那么外层循环先固定背包大小j，然后在大小为j的背包中循环遍历添加物品，然后在下次外层循环背包大小变为j+1，此时仍要执行内层循环遍历添加物品，也就会出现在上一轮外层循环中添加coins[2]的基础上还能再添加coins[1]的情况，那么就有了coins[1]在coins[2]之后的情况了(逆序)。 如果求组合数就是外层for循环遍历物品，内层for遍历背包。 如果求排列数就是外层for遍历背包，内层for循环遍历物品。 377. 组合总和 Ⅳ 先举个例子，nums = [1, 2, 3]，target = 35. 假设用1，2，3拼凑出35的总组合个数为y。我们可以考虑三种情况： （1）有效组合的末尾数字为1，这类组合的个数为 x1。我们把所有该类组合的末尾1去掉，那么不难发现，我们找到了一个子问题，x1即为在[1，2，3]中凑出35 - 1 = 34的总组合个数。因为我如果得到了和为34的所有组合，我只要在所有组合的最后面，拼接一个1，就得到了和为35且最后一个数字为1的组合个数了。 （2）有效组合的末尾数字为2，这类组合的个数为 x2。我们把所有该类组合的末尾2去掉，那么不难发现，我们找到了一个子问题，x2即为在[1，2，3]中凑出35 - 2 = 33的总组合个数。因为我如果得到了和为33的所有组合，我只要在所有组合的最后面，拼接一个2，就得到了和为35且最后一个数字为2的组合个数了。 （3）有效组合的末尾数字为3，这类组合的个数为 x3。我们把所有该类组合的末尾3去掉，那么不难发现，我们找到了一个子问题，x3即为在[1，2，3]中凑出35 - 3 = 32的总组合个数。因为我如果得到了和为32的所有组合，我只要在所有组合的最后面，拼接一个3，就得到了和为35且最后一个数字为3的组合个数了。 这样就简单了，y = x1 + x2 + x3。而x1，x2，x3又可以用同样的办法从子问题得到。状态转移方程get！ 全排列问题，转化为完全背包问题 dp[j]：在背包容量为j时，放满背包的排列数 状态转移公式：dp[j] = dp[j] + dp[j - nums[i]] 初始化dp[0]：在背包容量为0时，放满背包的排列数量为1（什么都不放） 遍历顺序，排列问题，先遍历背包容量(物品可以逆序放入dp[j - nums[i]])，再遍历物品 打印dp数组 70. 爬楼梯 完全背包 + 全排列问题，可以重复选择放入物品1与物品2，求放满容量为n的背包的排列数 dp[j]：在背包容量为j时，放满背包的排列数 状态转移公式：dp[j] = dp[j] + dp[j - nums[i]] 初始化dp[0]：在背包容量为0时，放满背包的排列数量为1（什么都不放） 遍历顺序，排列问题，先遍历背包容量(物品可以逆序放入dp[j - nums[i]])，再遍历物品 打印dp数组 322. 零钱兑换 完全背包问题 dp[j]：背包容量为j时，凑满背包容量所需的最少硬币数 状态转移公式：dp[j] = min(dp[j], dp[j - coins[i]] + 1) 初始化dp[0]：背包容量为0时，凑满背包容量所需的最少硬币数时0,其他初始化为Integer.MAX_VALUE 遍历顺序，无所谓 打印dp数组 1234567891011121314151617class Solution &#123; public int coinChange(int[] coins, int amount) &#123; // dp[j]: 凑成整数j所需的最少的硬币书 // 状态转移方程：dp[j] = min(dp[j], dp[j - nums[i] + 1]) // 初始化：dp[0] = 0,其他初始化为1 int[] dp = new int[amount + 1]; Arrays.fill(dp, Integer.MAX_VALUE); dp[0] = 0; for (int i = 0; i &lt; coins.length; ++i) &#123; for (int j = coins[i]; j &lt;= amount; ++j) &#123; if (dp[j - coins[i]] != Integer.MAX_VALUE) dp[j] = Math.min(dp[j], dp[j - coins[i]] + 1); &#125; &#125; return dp[amount] == Integer.MAX_VALUE ? -1 : dp[amount]; &#125;&#125; 279. 完全平方数 dp[j]：装满容量为j的背包，至少要放多少个物品 状态转移公式：dp[j] = min(dp[j], dp[j - weights[i]] + 1) 初始化dp[0]:装满容量为0的背包，至少放0个物品；其他设为Integet.MAX_VALUE 遍历顺序：无所谓 打印dp数组 123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public int numSquares(int n) &#123; // 完全背包问题 // 定义物品的weights数组，先找到小于等于n的最大完全平方数 int max_weight = (int)(Math.sqrt(n)); int[] weights = new int[max_weight]; for(int i = 1; i &lt;= max_weight; i++) weights[i-1] = i*i; // 1.dp[j]：装满容量为j的背包，至少要放多少个物品 int[] dp = new int[n + 1]; // 2.状态转移公式：dp[j] = min(dp[j], dp[j - weights[i]] + 1) // 3.初始化dp[0]:装满容量为0的背包，至少放0个物品；其他设为Integet.MAX_VALUE for(int i = 1; i &lt;= n; i++) &#123; dp[i] = Integer.MAX_VALUE; &#125; // 4.遍历顺序：无所谓 for(int i = 0; i &lt; weights.length; i++) &#123; for(int j = weights[i]; j &lt;= n; j++) &#123; if(dp[j - weights[i]] != Integer.MAX_VALUE) dp[j] = Math.min(dp[j], dp[j - weights[i]] + 1); &#125; // printDp(dp, i); &#125; return dp[n]; // 5.打印dp数组 &#125; private static void printDp(int[] dp, int i) &#123; System.out.print(i + &quot;: &quot;); for (int maxValue : dp)&#123; System.out.print(maxValue + &quot; &quot;); &#125; System.out.println(); &#125;&#125; 139. 单词拆分 背包问题 + 排列(“leetcode”由“leet”与“code”组成但不能反过来由“code”与“leet”组成 )的变种，建议不要完全抽象成背包问题，便于理解 dp[j]：长度为j的字符串，可以被字典中的单词拆分。 状态转移公式：if([j, i] 这个区间的子串出现在字典里 &amp;&amp; dp[j]是true) 那么 dp[i] = true， 其中j&lt;i。 初始化dp[0]:dp[i]依赖于前面的dp[j]，所以dp[0]要初始化为true，不然全为false 遍历顺序：先遍历背包容量，再嵌套遍历物品 打印dp数组 198. 打家劫舍 dp[j]：偷窃从标号为0到j的房屋所能获得的最大价值 状态转移公式：dp[j] = max(dp[j - 1], dp[j - 2] + nums[j]) 初始化：dp[0] = nums[0], dp[1] = max(nums[0], nums[1]) 遍历顺序：单序列问题,dp[i] 是根据dp[i - 2] 和 dp[i - 1] 推导出来的，那么一定是从前到后遍历！ 遍历dp数组 优化空间复杂度 根据状态转移公式dp[j] = max(dp[j - 1], dp[j - 2] + nums[j])，dp[j]只需要dp[j-1]以及dp[j-2]两个变量即可，可以把数组大小压缩到2。 213. 打家劫舍 II 416. 分割等和子集 dp[j]：背包容量为j时，是否能用物品装满 状态转移方程：dp[j] = dp[j] || dp[j - nums[i]] 初始化：背包容量为0时，不把物品装进去即可装满，dp[0] = true 遍历顺序：一维滑动数组，零一背包，先遍历物品后遍历背包容量 337. 打家劫舍 III 方法一：HashMap f：偷当前房屋能获得的最大价值；g：不偷当前房屋能获得的最大价值 偷当前房屋f(cur) = cur.val + g(cur.left) + g(cur.right) 不偷当前房屋g(cur) = max(f(cur.left), g(cur.left)) + max(f(cur.right), g(cur.right)) 方法二：Morris + HashMap 当作是练习题了！！ 注意事项：在访问的时候，此时需要cur.right，而这个时候已经是逆序过的，cur.right实际上指向的是自己的父节点，所以再用一个hashmap存储cur真正的右节点（或者再逆序一遍）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Solution &#123; Map&lt;TreeNode, Integer&gt; f = new HashMap&lt;&gt;(); Map&lt;TreeNode, Integer&gt; g = new HashMap&lt;&gt;(); Map&lt;TreeNode, TreeNode&gt; right = new HashMap&lt;&gt;(); public int rob(TreeNode root) &#123; // f:偷当前节点能获得的最大价值 // g:不偷当前节点能获得的最大价值 // f(cur) = cur.val + g(cur.left) + g(cur.right) // g(cur) = max(f(cur.left), g(cur.left)) + max(f(cur.right), g(cur.right)) TreeNode cur = root, mostRight = null; while (cur != null) &#123; mostRight = cur.left; if (mostRight != null) &#123; while (mostRight.right != null &amp;&amp; mostRight.right != cur) mostRight = mostRight.right; if (mostRight.right == null) &#123; mostRight.right = cur; cur = cur.left; continue; &#125; else &#123; // mostRight.right = cur mostRight.right = null; visit(cur.left); &#125; &#125; cur = cur.right; &#125; visit(root); return Math.max(f.getOrDefault(root, 0), g.getOrDefault(root, 0)); &#125; private void visit(TreeNode cur) &#123; TreeNode tail = reverse(cur); cur = tail; while (cur != null) &#123; f.put(cur, cur.val + g.getOrDefault(cur.left, 0) + g.getOrDefault(right.get(cur), 0)); int maxLeft = Math.max(f.getOrDefault(cur.left, 0), g.getOrDefault(cur.left, 0)); int maxRight = Math.max(f.getOrDefault(right.get(cur), 0), g.getOrDefault(right.get(cur), 0)); g.put(cur, maxLeft + maxRight); if (cur.right != null) right.put(cur.right, cur); cur = cur.right; &#125; reverse(tail); &#125; private TreeNode reverse(TreeNode cur) &#123; TreeNode pre = null; while (cur != null) &#123; TreeNode next = cur.right; cur.right = pre; pre = cur; cur = next; &#125; return pre; &#125;&#125; 121. 买卖股票的最佳时机 你根本没在dp！ 方法一：暴力迭代 超时咯 image-20230330094627247 方法二：贪心 从前往后遍历，使用minPrice记录最小值，使用maxProfit记录最大收益 方法三：DP DP数组的定义十分重要！ 12345678910111213141516171819class Solution &#123; public int maxProfit(int[] prices) &#123; int len = prices.length; if (len == 0 || prices == null) return 0; // 1.dp[0][j]:第j天持有股票(之前买入或者当前买入)所拥有的最大价值，dp[1][j]：第j天不持有股票(之前卖出或者当前卖出)所拥有的最大价值 int[][] dp = new int[2][len]; // 2.状态转移方程：dp[0][j] = max(dp[0][j-1], -price[j]); dp[1][j] = max(dp[1][j-1], price[j] + dp[0][j - 1]) // 3.初始化：dp[0][0]必须买入，初始化为-price[0]；dp[1][0]不能卖出任何股票，初始化为0 dp[0][0] = -prices[0]; // 4.遍历顺序：dp[j]由dp[j-1]决定，所以从前往后遍历 for (int j = 1; j &lt; len; ++j) &#123; dp[0][j] = Math.max(dp[0][j - 1], -prices[j]); dp[1][j] = Math.max(dp[1][j - 1], prices[j] + dp[0][j - 1]); // 不能当天买入当天卖出所以是dp[0][j - 1] &#125; return dp[1][len - 1]; // 5.打印dp数组 &#125;&#125; 122. 买卖股票的最佳时机 II 1234567891011121314151617class Solution &#123; public int maxProfit(int[] prices) &#123; // 1.dp[0][j]:在第j天持有(之前买入，当前买入)股票时拥有的最大现金;dp[1][j]在第j天不持有(之前卖出，当前卖出)股票拥有的最大现金 int len = prices.length; int[][] dp = new int[2][len]; // 2.状态转移方程：dp[0][j] = max(dp[0][j - 1], dp[1][j - 1] - price[j]); dp[1][j] = max(dp[1][j - 1], dp[0][j - 1] + price[j]) // 3.初始化：dp[0][0] = -price[0];dp[1][0] = 0;可以当天出售 dp[0][0] = -prices[0]; // 4.遍历顺序 for (int j = 1; j &lt; len; ++j) &#123; dp[0][j] = Math.max(dp[0][j - 1], dp[1][j - 1] - prices[j]); dp[1][j] = Math.max(dp[1][j - 1], dp[0][j - 1] + prices[j]); &#125; return dp[1][len - 1]; // 5.打印dp数组 &#125;&#125; 96. 不同的二叉搜索树 12345678910111213class Solution &#123; public int numTrees(int n) &#123; int[] dp = new int[n + 1]; dp[0] = 1; dp[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= i; ++j) &#123; dp[i] += dp[j - 1] * dp[i - j]; &#125; &#125; return dp[n]; &#125;&#125; 优化空间.. 123. 买卖股票的最佳时机 III 1372. 二叉树中的最长交错路径 1234567891011121314151617181920212223242526272829303132class Solution &#123; // f(cur)：以cur结尾，且cur是左子树的最大长度 // g(cur)：以cur结尾，且cur是右子树的最大长度 Map&lt;TreeNode, Integer&gt; f = new HashMap&lt;&gt;(); Map&lt;TreeNode, Integer&gt; g = new HashMap&lt;&gt;(); Queue&lt;TreeNode[]&gt; queue = new LinkedList&lt;&gt;(); public int longestZigZag(TreeNode root) &#123; // f.put(root, 0); // g.put(root, 0); queue.offer(new TreeNode[]&#123;root, null&#125;); while (!queue.isEmpty()) &#123; TreeNode[] sonFather = queue.poll(); f.put(sonFather[0], 0); g.put(sonFather[0], 0); if(sonFather[1] != null) &#123; if (sonFather[1].left == sonFather[0]) f.put(sonFather[0], g.get(sonFather[1]) + 1); if (sonFather[1].right == sonFather[0]) g.put(sonFather[0], f.get(sonFather[1]) + 1); &#125; if (sonFather[0].left != null) queue.offer(new TreeNode[]&#123;sonFather[0].left, sonFather[0]&#125;); if (sonFather[0].right != null) queue.offer(new TreeNode[]&#123;sonFather[0].right, sonFather[0]&#125;); &#125; int max = Integer.MIN_VALUE; for (TreeNode node : f.keySet()) &#123; max = Math.max(max, Math.max(f.get(node), g.get(node))); &#125; return max; &#125;&#125; 300. 最长递增子序列 dp[i]：以nums[i]结尾的最长递增子序列的长度 从前往后，在i的左开区间进行比较所有的j(j &lt; i)，如果nums[j]&lt;nums[i]，那么dp[i] = max(dp[i], dp[j] + 1) 初始化：令dp数组所有元素为1，最短序列是本身 遍历顺序：第二层从前往后，从后往前都可以，只要把i之前的元素全部遍历了就行 要注意的是，要输出的答案不是dp[dp.length-1]，而是dp数组中的最大值，比如序列为01234512，输出的是结果是dp[5]；所以可以用一个全局变量记录dp数组中的最大值 时间复杂度：\\(O(n^2)\\) 空间复杂度：\\(O(n)\\) 12345678910111213141516171819class Solution &#123; public int lengthOfLIS(int[] nums) &#123; int n = nums.length; if (n == 1) return 1; int[] dp = new int[n]; Arrays.fill(dp, 1); int maxLenOfSubsequence = 0; for (int i = 1; i &lt; n; ++i) &#123; for (int j = 0; j &lt; i; ++j) &#123; if (nums[i] &gt; nums[j]) &#123; dp[i] = Math.max(dp[i], dp[j] + 1); &#125; &#125; maxLenOfSubsequence = Math.max(maxLenOfSubsequence, dp[i]); &#125; return maxLenOfSubsequence; &#125;&#125; 674. 最长连续递增序列 方法一：DP dp[i]：以nums[i]结尾的最长连续递增子序列的长度 当当前数字nums[i]大于nums[i-1]，令dp[i] = dp[i - 1] + 1 初始化：令dp数组所有元素为1，最短序列是本身 时间复杂度：\\(O(n)\\) 空间复杂度：\\(O(n)\\) 1234567891011121314151617181920class Solution &#123; public int findLengthOfLCIS(int[] nums) &#123; int n = nums.length; if (n == 1) return 1; int[] dp = new int[n]; Arrays.fill(dp, 1); int maxLength = 0; for (int i = 1; i &lt; n; ++i) &#123; if (nums[i] &gt; nums[i - 1]) &#123; dp[i] = dp[i - 1] + 1; &#125; maxLength = Math.max(maxLength, dp[i]); &#125; // for (int i = 0; i &lt; dp.length; ++i) &#123; // System.out.print(dp[i] + &quot; &quot;); // &#125; return maxLength; &#125;&#125; 方法二：DP + 滑动数组 注意：当nums[i] &lt;= nums[i - 1]时，需要把dp[i%2]重置为1 1234567891011121314151617181920class Solution &#123; public int findLengthOfLCIS(int[] nums) &#123; int n = nums.length; if (n == 1) return 1; int[] dp = new int[2]; Arrays.fill(dp, 1); int maxLength = 0; for (int i = 1; i &lt; n; ++i) &#123; if (nums[i] &gt; nums[i - 1]) &#123; dp[i % 2] = dp[(i - 1) % 2] + 1; &#125; else &#123; dp[i % 2] = 1; &#125; maxLength = Math.max(maxLength, dp[i % 2]); &#125; return maxLength; &#125;&#125; 718. 最长重复子数组:warning: 方法一：暴力 时间复杂度：\\(O(m^2n)\\) 空间复杂度：\\(O(1)\\) 123456789101112131415161718class Solution &#123; public int findLength(int[] nums1, int[] nums2) &#123; int res = 0; for (int i = 0; i &lt; nums1.length; ++i) &#123; for (int j = 0; j &lt; nums2.length; ++j) &#123; int count1 = i, count2 = j; int counter = 0; while (count1 &lt; nums1.length &amp;&amp; count2 &lt; nums2.length &amp;&amp; nums1[count1] == nums2[count2]) &#123; ++counter; ++count1; ++count2; &#125; res = Math.max(res, counter); &#125; &#125; return res; &#125;&#125; 方法二：DP dp[i][j]:以nums1[i - 1]结尾与以nums2[j - 1]结尾时的最长重复子数组 状态转移公式：当nums1[i - 1] == nums2[j - 1]时，dp[i][j] = dp[i - 1][j - 1] + 1 初始化：m为nums1的长度，n为nums2的长度，初始化(m + 1) * (n + 1)的二维数组，第一行第一列初始化为0，因为任一数组为空，就不会有重复子数组 注意事项：输出结果是dp数组中的最大值，因为最长的重复子数组不一定是在两数组的结尾处，可以在循环内比较 时间复杂度：\\(O(mn)\\) 空间复杂度：\\(O(mn)\\) 12345678910111213141516class Solution &#123; public int findLength(int[] nums1, int[] nums2) &#123; int m = nums1.length, n = nums2.length; int[][] dp = new int[m + 1][n + 1]; int result = 0; for (int i = 1; i &lt;= m; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; if (nums1[i - 1] == nums2[j - 1]) &#123; dp[i][j] = dp[i - 1][j - 1] + 1; result = Math.max(result, dp[i][j]); &#125; &#125; &#125; return result; &#125;&#125; 滚动数组缩减空间复杂度 dp数组为第二个数组的长度加一 不相等时要把dp[j]赋0，不然之后会出错 此时遍历第二个数组的时候，就要从后向前遍历，这样避免重复覆盖。 比如nums1 = [1, 2, 3, 1],nums2 = [1,6,8,1,3,1,2,3] i = 1时候，dp数组为[1,0,0,1,0,1,0,0] i = 2时候，dp数组为[0,0,0,0,0,0,1,0] i = 3时候，dp数组为[0,0,0,0,1,0,0,2] i=3时，如果第二层for循环j从前往后遍历，那么dp倒数第二个位置会因为3!=2，被赋0，进而导致dp最后一个位置是1而不是2 123456789101112131415161718class Solution &#123; public int findLength(int[] nums1, int[] nums2) &#123; int[] dp = new int[nums2.length + 1]; int res = 0; for (int i = 1; i &lt;= nums1.length; ++i) &#123; for (int j = nums2.length; j &gt; 0; --j) &#123; if (nums1[i - 1] == nums2[j - 1]) &#123; dp[j] = dp[j - 1] + 1; &#125; else &#123; dp[j] = 0; &#125; res = Math.max(res, dp[j]); &#125; &#125; return res; &#125;&#125; 方法三：滑动窗口 62. 不同路径 方法一：DP O(mn) 12345678910111213141516171819class Solution &#123; public int uniquePaths(int m, int n) &#123; // dp[i][j]:走到i,j位置的路径数 // 状态转移方程：dp[i][j] = dp[i - 1][j] + dp[i][j - 1] int[][] dp = new int[m][n]; for (int i = 0; i &lt; m; ++i) &#123; dp[i][0] = 1; &#125; for (int j = 0; j &lt; n; ++j) &#123; dp[0][j] = 1; &#125; for (int i = 1; i &lt; m; ++i) &#123; for (int j = 1; j &lt; n; ++j) &#123; dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; &#125; &#125; return dp[m - 1][n - 1]; &#125;&#125; 方法二：DP+滚动数组 O(n) 2行 12345678910111213141516171819class Solution &#123; public int uniquePaths(int m, int n) &#123; // dp[i][j]:走到i,j位置的路径数 // 状态转移方程：dp[i][j] = dp[i - 1][j] + dp[i][j - 1] int[][] dp = new int[2][n]; for (int i = 0; i &lt; 2; ++i) &#123; dp[i][0] = 1; &#125; for (int j = 0; j &lt; n; ++j) &#123; dp[0][j] = 1; &#125; for (int i = 1; i &lt; m; ++i) &#123; for (int j = 1; j &lt; n; ++j) &#123; dp[i % 2][j] = dp[(i - 1) % 2][j] + dp[i % 2][j - 1]; &#125; &#125; return dp[(m - 1) % 2][n - 1]; &#125;&#125; 方法三：DP+滚动数组 O(n) 1行 12345678910111213141516class Solution &#123; public int uniquePaths(int m, int n) &#123; // dp[i][j]:走到i,j位置的路径数 // 状态转移方程：dp[j] = dp[j] + dp[j - 1] // 初始化：全部初始化为1 // 遍历顺序：dp[j]依赖dp[j - 1]，所以从左往右遍历 int[] dp = new int[n]; Arrays.fill(dp, 1); for (int i = 1; i &lt; m; ++i) &#123; for (int j = 1; j &lt; n; ++j) &#123; dp[j] += dp[j - 1]; &#125; &#125; return dp[n - 1]; &#125;&#125; 63. 不同路径 II 方法一：DP 12345678910111213141516171819202122232425class Solution &#123; public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123; int m = obstacleGrid.length, n = obstacleGrid[0].length; int[][] dp = new int[m][n]; for (int i = 0; i &lt; m; ++i) &#123; if (obstacleGrid[i][0] == 1) &#123; break; &#125; dp[i][0] = 1; &#125; for (int j = 0; j &lt; n; ++j) &#123; if (obstacleGrid[0][j] == 1) break; dp[0][j] = 1; &#125; for (int i = 1; i &lt; m; ++i) &#123; for (int j = 1; j &lt; n; ++j) &#123; if (obstacleGrid[i][j] == 1) continue; dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; &#125; &#125; return dp[m - 1][n - 1]; &#125;&#125; 343. 整数拆分:warning: 方法一：DP image-20230515170354808 123456789101112131415class Solution &#123; public int integerBreak(int n) &#123; // dp[j]:j拆分为多个数的最大乘积 int[] dp = new int[n + 1]; dp[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; for (int j = 1; j &lt; i; ++j) &#123; int k = i - j; dp[i] = Math.max(dp[i], Math.max(k * j, dp[k] * j)); &#125; &#125; return dp[n]; &#125;&#125; 96. 不同的二叉搜索树:warning: 剑指 Offer II 102. 加减的目标值 方法一：DP 12345678910111213141516171819class Solution &#123; public int findTargetSumWays(int[] nums, int target) &#123; int sum = Arrays.stream(nums).sum(); int diff = sum - target; if (diff % 2 == 1 || diff &lt; 0) return 0; target = diff / 2; // dp[j]:装满容量为j的方法数 // dp[0] = 1,装满容量为0的背包有一种 int[] dp = new int[target + 1]; dp[0] = 1; for (int i = 0; i &lt; nums.length; ++i) &#123; for (int j = target; j &gt;= nums[i]; --j) &#123; dp[j] += dp[j - nums[i]]; &#125; &#125; return dp[target]; &#125;&#125; 树形DP 左神shi'p 树形DP题目 没有上司的舞会 337. 打家劫舍 III 96. 不同的二叉搜索树 1372. 二叉树中的最长交错路径 Binary Tree 144. 二叉树的前序遍历 方法一：递归 假设树上一共有n 个节点。 时间复杂度：遍历了整棵树，\\(O(n)\\) 空间复杂度：和递归使用的栈大小相关，递归层数不超过n(一叉树)，\\(O(n)\\) 1234567891011121314class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); dfs(root, result); return result; &#125; public void dfs(TreeNode root, List&lt;Integer&gt; result) &#123; if (root == null) return; result.add(root.val); dfs(root.left, result); dfs(root.right, result); &#125;&#125; 方法二：非递归 假设树上一共有n 个节点。 时间复杂度：遍历了整棵树，\\(O(n)\\) 空间复杂度：和递归使用的栈大小相关，递归层数不超过n(一叉树)，\\(O(n)\\) 1234567891011121314151617class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode cur = root; while (cur != null || !stack.isEmpty()) &#123; while (cur != null) &#123; result.add(cur.val); stack.push(cur); cur = cur.left; &#125; cur = stack.pop(); cur = cur.right; &#125; return result; &#125;&#125; 方法三：Morris前序遍历 morris遍历利用树的大量空闲指针，实现空间开销的极限缩减。 时间复杂度：\\(O(n)\\)，其中n是二叉树的节点数。没有左子树的节点只被访问一次，有左子树的节点被访问两次 空间复杂度：\\(O(1)\\)，只操作已存在的指针（树的空闲指针），因此只需要常数的额外空间 123456789101112131415161718192021222324252627class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); TreeNode cur = root, mostRight = null; while (cur != null) &#123; mostRight = cur.left; if (mostRight != null) &#123; while (mostRight.right != null &amp;&amp; mostRight.right != cur) mostRight = mostRight.right; if (mostRight.right == null) &#123; result.add(cur.val); mostRight.right = cur; cur = cur.left; continue; &#125; else &#123; // mostRight.right == cur mostRight.right = null; &#125; &#125; else &#123; // cur.left == null result.add(cur.val); &#125; cur = cur.right; &#125; return result; &#125;&#125; 94. 二叉树的中序遍历 方法一：递归 时间复杂度：\\(O(n)\\)，其中n为树的节点数 空间复杂度：\\(O(n)\\)，和递归使用的栈大小相关，递归层数不超过n(一叉树) 123456789101112131415class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); dfs(root, result); return result; &#125; public void dfs(TreeNode root, List&lt;Integer&gt; result) &#123; if (root != null) &#123; dfs(root.left, result); result.add(root.val); dfs(root.right, result); &#125; &#125;&#125; 方法二：非递归 时间复杂度：\\(O(n)\\)，其中n为树的节点数 空间复杂度：\\(O(n)\\)，和递归使用的栈大小相关，递归层数不超过n(一叉树) 1234567891011121314151617class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new LinkedList&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode cur = root; while (cur != null || !stack.isEmpty()) &#123; while (cur != null) &#123; stack.push(cur); cur = cur.left; &#125; cur = stack.pop(); res.add(cur.val); cur = cur.right; &#125; return res; &#125;&#125; 方法三：Morris中序遍历 morris遍历利用树的大量空闲指针，实现空间开销的极限缩减。 时间复杂度：\\(O(n)\\)，其中n是二叉树的节点数。没有左子树的节点只被访问一次，有左子树的节点被访问两次 空间复杂度：\\(O(1)\\)，只操作已存在的指针（树的空闲指针），因此只需要常数的额外空间 123456789101112131415161718192021222324class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new LinkedList&lt;&gt;(); TreeNode cur = root, mostRight = null; while (cur != null) &#123; mostRight = cur.left; if (mostRight != null) &#123; while (mostRight.right != null &amp;&amp; mostRight.right != cur) mostRight = mostRight.right; if (mostRight.right == null) &#123; mostRight.right = cur; cur = cur.left; continue; &#125; else &#123; // mostRight == cur mostRight.right = null; &#125; &#125; res.add(cur.val); cur = cur.right; &#125; return res; &#125;&#125; 145. 二叉树的后序遍历 方法一：递归 方法二：非递归 123456789101112131415161718192021222324class Solution &#123; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new LinkedList&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode cur = root, pre = null; while (cur != null || !stack.isEmpty()) &#123; while (cur != null) &#123; stack.push(cur); cur = cur.left; &#125; cur = stack.peek(); if (cur.right != null &amp;&amp; cur.right != pre) &#123; cur = cur.right; &#125; else &#123; stack.pop(); res.add(cur.val); pre = cur; cur = null; &#125; &#125; return res; &#125;&#125; 方法三：Morris后序遍历 时间复杂度：\\(O(n)\\)，其中n为树的节点数 空间复杂度：\\(O(n)\\)，和递归使用的栈大小相关，递归层数不超过n(一叉树) 如果可以到达一个节点两次(有左子树)，第二次逆序打印左子树上的右边界 最后走出循环后，逆序打印根节点的右边界 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new LinkedList&lt;&gt;(); TreeNode cur = root, mostRight = null; while (cur != null) &#123; mostRight = cur.left; if (mostRight != null) &#123; while (mostRight.right != null &amp;&amp; mostRight.right != cur) mostRight = mostRight.right; if (mostRight.right == null) &#123; mostRight.right = cur; cur = cur.left; continue; &#125; else &#123; // mostRight.right = cur mostRight.right = null; visit(cur.left, res); &#125; &#125; cur = cur.right; &#125; visit(root, res); return res; &#125; private void visit(TreeNode cur, List&lt;Integer&gt; res) &#123; TreeNode tail = reverse(cur); cur = tail; while (cur != null) &#123; res.add(cur.val); cur = cur.right; &#125; reverse(tail); &#125; private TreeNode reverse(TreeNode cur) &#123; TreeNode pre = null; while (cur != null) &#123; TreeNode next = cur.right; cur.right = pre; pre = cur; cur = next; &#125; return pre; &#125;&#125; 102. 二叉树的层序遍历 借助队列实现，关键在于通过queue.size来判断下一层的节点数！ Queue.offer(null)的话，size为1！ 226. 翻转二叉树 这道题目背后有一个让程序员心酸的故事，听说 Homebrew的作者Max Howell，就是因为没在白板上写出翻转二叉树，最后被Google拒绝了。（真假不做判断，权当一个乐子哈） 要求：左右子树交换位置 方法一：bfs层级遍历 时间复杂度：所有节点都需要入队，出队一次，所以是\\(O(n)\\) 空间复杂度：在最坏的情况下，给定的树是满二叉树，所有叶节点(\\(n/2 + 1\\))都要入队，所以是\\(O(n)\\) 1234567891011121314151617181920212223class Solution &#123; public TreeNode invertTree(TreeNode root) &#123; if (root == null) return root; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); TreeNode cur; while (!queue.isEmpty()) &#123; cur = queue.poll(); reverse(cur); if (cur.left != null) queue.offer(cur.left); if (cur.right != null) queue.offer(cur.right); &#125; return root; &#125; private void reverse(TreeNode cur) &#123; TreeNode temp = cur.left; cur.left = cur.right; cur.right = temp; &#125;&#125; 方法二：dfs 12345678910111213141516171819class Solution &#123; public TreeNode invertTree(TreeNode root) &#123; // 反转所有左子树和右子树，对这棵树的所有节点 dfs(root); return root; &#125; private void dfs(TreeNode root) &#123; if (root == null) return; dfs(root.left); dfs(root.right); reverse(root); &#125; private void reverse(TreeNode root) &#123; TreeNode temp = root.left; root.left = root.right; root.right = temp; &#125;&#125; 101. 对称二叉树 方法一：拷贝+翻转+判断(高情商：刷一道，解三道！低情商：只会笨方法？还是看看远方的复杂度吧) 写了80行，一题三解！不分析复杂度了。。 方法二：BFS 假设树上一共有n 个节点。 时间复杂度：遍历了整棵树，\\(O(n)\\) 空间复杂度：和使用的队列大小相关，在最坏的情况下，给定的树是满二叉树，所有叶节点(\\(n/2 + 1\\))都要入队，所以是\\(O(n)\\) 注意：如果p,q都为空，continue！而不是return truel！！！ 1234567891011121314151617181920212223class Solution &#123; public boolean isSymmetric(TreeNode root) &#123; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root.left); queue.offer(root.right); TreeNode p, q; while (!queue.isEmpty()) &#123; p = queue.poll(); q = queue.poll(); if (p == null &amp;&amp; q == null) continue; if (p == null || q == null) return false; if (p.val != q.val) return false; queue.offer(p.left); queue.offer(q.right); queue.offer(p.right); queue.offer(q.left); &#125; return true; &#125;&#125; 方法三：DFS YYDS 假设树上一共有n 个节点。 时间复杂度：遍历了整棵树，\\(O(n)\\) 空间复杂度：和递归使用的栈大小相关，递归层数不超过n(一叉树)，\\(O(n)\\) 123456789101112class Solution &#123; public boolean isSymmetric(TreeNode root) &#123; return dfs(root.left, root.right); &#125; private boolean dfs(TreeNode left, TreeNode right) &#123; if (left == null &amp;&amp; right == null) return true; if (left == null || right == null) return false; return (left.val == right.val) &amp;&amp; dfs(left.left, right.right) &amp;&amp; dfs(left.right, right.left); &#125;&#125; 100. 相同的树 对称二叉树方法一中用到了这个笨方法，顺手做了吧。 方法一：DFS 假设树上一共有\\(n\\)个节点 时间复杂度：遍历了整棵树，\\(O(n)\\) 空间复杂度：和递归使用的栈大小相关，递归层数不超过n，\\(O(n)\\) 方法二：BFS 只是和对称二叉树BFS解法中的入队顺序改变一点。 假设树上一共有n 个节点。 时间复杂度：遍历了整棵树，\\(O(n)\\) 空间复杂度：和使用的队列大小相关，在最坏的情况下，给定的树是满二叉树，所有叶节点(\\(n/2 + 1\\))都要入队，所以是\\(O(n)\\) 104. 二叉树的最大深度 方法一：BFS 时间复杂度：遍历整棵树，\\(O(n)\\) 空间复杂度：和使用的队列大小相关，在最坏情况下，给定的二叉树是满二叉树，\\(n/2 + 1\\)个叶节点要入队，所以是\\(O(n)\\) 方法二：DFS 假设树上一共有\\(n\\)个节点 时间复杂度：遍历了整棵树，\\(O(n)\\) 空间复杂度：和递归使用的栈大小相关，递归层数不超过n，\\(O(n)\\) 559. N 叉树的最大深度 同上题二叉树的最大深度，只是在遍历子节点的时候不同。 1234for (int i = 0; i &lt; cur.children.size(); i++) &#123; if (cur.children.get(i) != null) queue.offer(cur.children.get(i));&#125; 111. 二叉树的最小深度 最小深度是从根节点到最近叶子节点的最短路径上的节点数量 方法一：DFS 首先递归左子树和右子树 如果左子树为空，那么返回右子树的高度 + 1；如果右子树为空， 那么返回左子树的高度 + 1 如果左右子树都不为空，那么返回他们最小高度 + 1 12345678910111213class Solution &#123; public int minDepth(TreeNode root) &#123; if (root == null) return 0; int leftDepth = minDepth(root.left); int rightDepth = minDepth(root.right); if (root.left == null) return rightDepth + 1; if (root.right == null) return leftDepth + 1; return Math.min(leftDepth, rightDepth) + 1; &#125;&#125; 方法二：BFS 通过队列的size知道这是第几层，上一层加入队列节点的个数就是队列的size，在得到size的同时，将记录最小深度的变量minDepth加一 遍历到第一个叶子节点的当前层数就是二叉树的最小深度 时间复杂度：遍历整棵树，\\(O(n)\\) 空间复杂度：和使用的队列大小相关，在最坏情况下，给定的二叉树是满二叉树，\\(n/2 + 1\\)个叶节点要入队，所以是\\(O(n)\\) 123456789101112131415161718192021222324class Solution &#123; public int minDepth(TreeNode root) &#123; if (root == null) return 0; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); TreeNode cur; int minDepth = 0; while (!queue.isEmpty()) &#123; int size = queue.size(); ++minDepth; while (size-- &gt; 0) &#123; cur = queue.poll(); if (cur.left == null &amp;&amp; cur.right == null) return minDepth; if (cur.left != null) queue.offer(cur.left); if (cur.right != null) queue.offer(cur.right); &#125; &#125; return minDepth; &#125;&#125; 222. 完全二叉树的节点个数 方法一：BFS 在每层开始遍历时，记录节点个数的变量加上队列里元素个数 方法二：DFS 边界：如果是空节点，返回0 递归左子树和右子树+1(当前节点) 12345678910class Solution &#123; public int countNodes(TreeNode root) &#123; return dfs(root); &#125; public int dfs(TreeNode root) &#123; if (root == null) return 0; return 1 + dfs(root.left) + dfs(root.right); &#125;&#125; 110. 平衡二叉树 方法一：先序DFS 终止条件：如果root为空，返回true 首先求当前节点左右子树高度是否&lt;=1，再判断递归左子树和右子树 时间复杂度：\\(O(n^2)\\) 空间复杂度：\\(O(n)\\) 123456789101112class Solution &#123; public boolean isBalanced(TreeNode root) &#123; if (root == null) return true; return Math.abs(height(root.left) - height(root.right)) &lt;= 1 &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right); &#125; private int height(TreeNode root) &#123; if (root == null) return 0; return Math.max(height(root.left), height(root.right)) + 1; &#125;&#125; 方法二：后序DFS:warning: 只需遍历所有节点一次 时间复杂度\\(O(n)\\) 空间复杂度\\((n)\\) 1234567891011121314151617class Solution &#123; public boolean isBalanced(TreeNode root) &#123; return height(root) &gt;= 0; &#125; public int height(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; int leftHeight = height(root.left); int rightHeight = height(root.right); if (leftHeight == -1 || rightHeight == -1 || Math.abs(leftHeight - rightHeight) &gt; 1) &#123; return -1; &#125; else &#123; return Math.max(leftHeight, rightHeight) + 1; &#125; &#125;&#125; 257. 二叉树的所有路径:warning: 方法一：BFS 1234567891011121314151617181920212223242526class Solution &#123; public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123; List&lt;String&gt; result = new LinkedList&lt;&gt;(); Queue&lt;Object&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); queue.offer(String.valueOf(root.val)); TreeNode cur; String path = &quot;&quot;; while (!queue.isEmpty()) &#123; cur = (TreeNode)queue.poll(); path = (String)queue.poll(); if (cur.left == null &amp;&amp; cur.right == null) &#123; result.add(path); &#125; if (cur.left != null) &#123; queue.offer(cur.left); queue.offer(path + &quot;-&gt;&quot; + String.valueOf(cur.left.val)); &#125; if (cur.right != null) &#123; queue.offer(cur.right); queue.offer(path + &quot;-&gt;&quot; + String.valueOf(cur.right.val)); &#125; &#125; return result; &#125;&#125; 方法二：DFS 1234567891011121314151617181920class Solution &#123; List&lt;String&gt; result = new LinkedList&lt;&gt;(); public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123; dfs(root, &quot;&quot;); return result; &#125; public void dfs(TreeNode root, String path) &#123; if (root == null) return; path += String.valueOf(root.val); if (root.left == null &amp;&amp; root.right == null) &#123; result.add(path); &#125; else &#123; path += &quot;-&gt;&quot;; dfs(root.left, path); dfs(root.right, path); &#125; &#125; &#125; 404. 左叶子之和 :warning:方法一：DFS 12345678910111213141516171819202122class Solution &#123; public int sumOfLeftLeaves(TreeNode root) &#123; if (root.left == null &amp;&amp; root.right == null) return 0; return dfs(root); &#125; private int dfs(TreeNode root) &#123; if (root == null) return 0; int sum = 0; if (root.left != null) &#123; sum += isLeaf(root.left) ? root.left.val : dfs(root.left); &#125; if (root.right != null) &#123; sum += dfs(root.right); &#125; return sum; &#125; private boolean isLeaf(TreeNode root) &#123; return root.left == null &amp;&amp; root.right == null; &#125;&#125; 513. 找树左下角的值 :warning:方法一：DFS 12345678910111213141516171819class Solution &#123; int curHeight = 0; int curValue = 0; public int findBottomLeftValue(TreeNode root) &#123; dfs(root, 0); return curValue; &#125; private void dfs(TreeNode root, int height) &#123; if (root == null) return; ++height; dfs(root.left, height); dfs(root.right, height); if (height &gt; curHeight) &#123; curHeight = height; curValue = root.val; &#125; &#125;&#125; 方法二：BFS 从右往左层次遍历，最后一个访问的节点就是树左下角的值！ 12345678910111213141516171819class Solution &#123; public int findBottomLeftValue(TreeNode root) &#123; TreeNode cur; int res = 0; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while (!queue.isEmpty()) &#123; cur = queue.poll(); if (cur.right != null) &#123; queue.offer(cur.right); &#125; if (cur.left != null) &#123; queue.offer(cur.left); &#125; res = cur.val; &#125; return res; &#125;&#125; 112. 路径总和 方法一：BFS 初始化一个Object类型队列，用于存放节点与节点的值，首先把根节点和根节点的值offer进队列 开始while循环，循环的执行条件是队列不为空 首先按顺序取出节点和节点的值，注意这里需要强转 判断当前节点是否为根节点且节点的值是否为目标值，如果满足，直接return true 如果左子树不为空，先将左子树节点offer进队列，再将左子树的值加上poll出的当前节点的值offer进队列 如果右子树不为空，先将右子树节点offer进队列，再将右子树的值加上poll出的当前节点的值offer进队列 如果有这么一条路径，那么在while循环中就会return true，不会执行到这；如果没有满足条件的路径，则返回false 1234567891011121314151617181920212223242526class Solution &#123; public boolean hasPathSum(TreeNode root, int targetSum) &#123; if (root == null) return false; Queue&lt;Object&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); queue.offer(root.val); TreeNode cur; while (!queue.isEmpty()) &#123; cur = (TreeNode)queue.poll(); int val = (int)queue.poll(); if (cur.left == null &amp;&amp; cur.right == null &amp;&amp; val == targetSum) &#123; return true; &#125; if (cur.left != null) &#123; queue.offer(cur.left); queue.offer(val + cur.left.val); &#125; if (cur.right != null) &#123; queue.offer(cur.right); queue.offer(val + cur.right.val); &#125; &#125; return false; &#125;&#125; |:warning::warning:方法二：DFS 123456789class Solution &#123; public boolean hasPathSum(TreeNode root, int targetSum) &#123; if (root == null) return false; if (root.left == null &amp;&amp; root.right == null) return targetSum == root.val; return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val); &#125;&#125; 113. 路径总和 II 方法一：BFS 使用队列存放当前节点和累加节点值 使用HashMap记录每个节点的父节点 当节点满足是叶节点且累加值等于targetSum时，通过HashMap，从该叶子节点遍历到根节点记录到list中，最后把list反转 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int targetSum) &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); if (root == null) return res; Queue&lt;Object&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); queue.offer(root.val); TreeNode cur; Map&lt;TreeNode, TreeNode&gt; sonFather = new HashMap&lt;&gt;(); while (!queue.isEmpty()) &#123; cur = (TreeNode)queue.poll(); int val = (Integer)queue.poll(); if (cur.left == null &amp;&amp; cur.right == null &amp;&amp; val == targetSum) &#123; res.add(getPath(cur, sonFather)); &#125; if (cur.left != null) &#123; queue.offer(cur.left); queue.offer(val + cur.left.val); sonFather.put(cur.left, cur); &#125; if(cur.right != null) &#123; queue.offer(cur.right); queue.offer(val + cur.right.val); sonFather.put(cur.right, cur); &#125; &#125; return res; &#125; private List&lt;Integer&gt; getPath(TreeNode node, Map&lt;TreeNode, TreeNode&gt; sonFather) &#123; List&lt;Integer&gt; path = new LinkedList&lt;&gt;(); path.add(node.val); while (node != null) &#123; node = sonFather.get(node); path.add(node.val); &#125; Collections.reverse(path); return path; &#125; :warning:方法二：DFS 使用双端队列，每次dfs将当前节点值放入双端队列队尾，并让targetSum减去当前节点元素 如果当前节点是叶子节点且targetSum等于0，那么说明这条路径满足条件，将path加入结果 每次dfs完左右，再将双端队列最后一个元素移除！！！ 1234567891011121314151617181920class Solution &#123; Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int targetSum) &#123; dfs(root, targetSum); return res; &#125; private void dfs(TreeNode root, int targetSum) &#123; if (root == null) return; path.offerLast(root.val); targetSum -= root.val; if (root.left == null &amp;&amp; root.right == null &amp;&amp; targetSum == 0) &#123; res.add(new LinkedList&lt;&gt;(path)); &#125; dfs(root.left, targetSum); dfs(root.right, targetSum); path.pollLast(); &#125;&#125; :star:方法三：回溯(其实方法二也是回溯) 递归终止条件是：节点为空 123456789101112131415161718192021222324252627282930313233343536/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int targetSum) &#123; if (root == null) return res; dfs(root, targetSum); return res; &#125; private void dfs(TreeNode root, int targetSum) &#123; if (root == null) return; path.add(root.val); if (root.left == null &amp;&amp; root.right == null &amp;&amp; targetSum == root.val) &#123; res.add(new LinkedList(path)); &#125; dfs(root.left, targetSum - root.val); dfs(root.right, targetSum - root.val); path.removeLast(); &#125;&#125; :star:106. 从中序与后序遍历序列构造二叉树 草稿构造一棵二叉树，写出中序和后序序列 确定好边界条件：左闭右闭 后序序列最后一个元素是根，通过HashMap找到根节点下标 根节点左边的长度为lenOfLeft，那么先序序列和后序序列的前lenOfLeft为根节点的左子树 12345678910111213141516171819202122232425262728class Solution &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); public TreeNode buildTree(int[] inorder, int[] postorder) &#123; if (postorder == null) return null; for (int i = 0; i &lt; inorder.length; ++i) &#123; map.put(inorder[i], i); &#125; // [start, end - 1]左闭右闭 return dfs(inorder, 0, inorder.length - 1, postorder, 0, postorder.length - 1); &#125; private TreeNode dfs(int[] inorder, int inStart, int inEnd, int[] postorder, int postStart, int postEnd) &#123; if (inStart &gt; inEnd || postStart &gt; postEnd) return null; // 找到postorder最后一个元素的下标，也就是根节点 int rootValue = postorder[postEnd]; // 找到inorder中根节点的位置 int rootIdx = map.get(rootValue); // 构造树节点 TreeNode root = new TreeNode(rootValue); // 根据inorder切割左子树的大小，那么剩下的就是右子树 int lenOfLeft = rootIdx - inStart; // 按照根节点切割成左子树和右子树 root.left = dfs(inorder, inStart, rootIdx - 1, postorder, postStart, postStart + lenOfLeft - 1); root.right = dfs(inorder, rootIdx + 1, inEnd, postorder, postStart + lenOfLeft, postEnd - 1); return root; &#125;&#125; 105. 从前序与中序遍历序列构造二叉树 注意：int lenOfLeft = rootIdx - inStart; ！！！！！！！！ 1234567891011121314151617181920212223class Solution &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); public TreeNode buildTree(int[] preorder, int[] inorder) &#123; int length = inorder.length; for (int i = 0; i &lt; length; ++i) map.put(inorder[i], i); // [)左闭右开 return dfs(inorder, 0, length, preorder, 0, length); &#125; private TreeNode dfs(int[] inorder, int inStart, int inEnd, int[] preorder, int preStart, int preEnd) &#123; if (inStart &gt;= inEnd || preStart &gt;= preEnd) return null; // 找到根节点 int rootVal = preorder[preStart]; int rootIdx = map.get(rootVal); // 中序遍历中根节点左边的长度 int lenOfLeft = rootIdx - inStart; TreeNode root = new TreeNode(rootVal); root.left = dfs(inorder, inStart, rootIdx, preorder, preStart + 1, preStart + 1 + lenOfLeft); root.right = dfs(inorder, rootIdx + 1, inEnd, preorder, preStart + 1 + lenOfLeft, preEnd); return root; &#125;&#125; :star:654. 最大二叉树 方法一：DFS 思路同106. 从中序与后序遍历序列构造二叉树 123456789101112131415161718192021class Solution &#123; public TreeNode constructMaximumBinaryTree(int[] nums) &#123; return dfs(0, nums.length, nums); &#125; private TreeNode dfs(int start, int end, int[] nums) &#123; if (start &gt;= end) return null; int index = start; int maxValue = nums[start]; for (int i = start; i &lt; end; ++i) &#123; if (maxValue &lt; nums[i]) &#123; maxValue = nums[i]; index = i; &#125; &#125; TreeNode root = new TreeNode(maxValue); root.left = dfs(start, index, nums); root.right = dfs(index + 1, end, nums); return root; &#125;&#125; 617. 合并二叉树 解题思路：当树1当前节点的左子树或右子树为空，而树2当前节点左子树或右子树不为空时：使用parentQueue存储树1树2的当前节点parent1，parent2，在遍历到下一层时，使用parent1来指向parent2的左子树或者右子树。 Debug：如果cur1左子树为空，cur2左子树不为空，将cur1,cur2加入trashQueue；同理右子树。如果cur1左右子树都为空，cur2左右子树都不为空，将cur1,cur2加入parentQueue两次！！不然之后poll的时候空指针！！ :warning:方法二：DFS 123456789101112class Solution &#123; public TreeNode mergeTrees(TreeNode root1, TreeNode root2) &#123; if (root1 == null) return root2; if (root2 == null) return root1; root1.val += root2.val; root1.left = mergeTrees(root1.left, root2.left); root1.right = mergeTrees(root1.right, root2.right); return root1; &#125;&#125; 700. 二叉搜索树中的搜索 方法一：DFS 1234567891011121314151617class Solution &#123; public TreeNode searchBST(TreeNode root, int val) &#123; TreeNode cur = root; while (cur != null) &#123; if (cur.val == val) &#123; return cur; &#125; else if (cur.val &lt; val) &#123; cur = cur.right; &#125; else &#123; cur = cur.left; &#125; &#125; return null; &#125;&#125; :star:98. 验证二叉搜索树 方法一：中序遍历 中序遍历二叉搜索树应该是升序的，只需要一个记录上一个节点的值的遍历preVal，并与当前节点比较，如果当前节点的值小于等于preVal(cur.val应该严格&gt;preVal不能等于)，则返回false;否则，遍历完所有节点返回true。 假设树有n个节点 时间复杂度：遍历所有节点，\\(O(n)\\) 空间复杂度：和使用的栈相关，在最坏情况(每个节点都只有一个子节点)下，树的高度为n，都需要压栈，所以为\\(O(n)\\) 123456789101112131415161718192021class Solution &#123; public boolean isValidBST(TreeNode root) &#123; if (root == null) return true; long preVal = Long.MIN_VALUE; TreeNode cur = root; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); while (cur != null || !stack.isEmpty()) &#123; while (cur != null) &#123; stack.push(cur); cur = cur.left; &#125; cur = stack.pop(); if (cur.val &lt;= preVal) return false; preVal = cur.val; cur = cur.right; &#125; return true; &#125;&#125; :war:方法二：递归 1234567891011121314151617class Solution &#123; public boolean isValidBST(TreeNode root) &#123; if (root == null) return true; return dfs(TreeNode root, long.MIN_VALUE, long.MAX_VALUE) &#125; public boolean dfs(TreeNode root, long pre, long post) &#123; if (root == null) return true; if (root.val &lt;= pre || root.val &gt;= post) return false; return dfs(root.left, pre, root.val) &amp;&amp; dfs(root.right, root.val, post); &#125;&#125; 方法三：Morris中序遍历 Morris遍历利用叶子节点的左右空指针，实现空间开销的极限缩减。 morris遍历的实现原则 记作当前节点为cur。 如果cur无左孩子，cur向右移动（cur=cur.right） 如果cur有左孩子，找到cur左子树上最右的节点，记为mostright 如果mostright的right指针指向空，让其指向cur，cur向左移动（cur=cur.left） 如果mostright的right指针指向cur，让其指向空，cur向右移动（cur=cur.right） 实现以上的原则，即实现了morris遍历。 morris遍历的实质 建立一种机制，对于没有左子树的节点只到达一次，对于有左子树的节点会到达两次 Morris中序遍历 如果可以到达一个节点两次(有左子树)，第二次访问 如果可以到达一个节点一次(无左子树)，直接访问 举个例子 从根节点5开始遍历，令cur = 根节点5，找到mostRight为节点1 节点1的右子树为空，将节点1的右子树指向节点5，并让cur移动到左子树(节点1) 开始遍历节点1，由于节点一无左子树，直接访问，比较节点一与preValue(初始化为最小值)， 1 &lt; Long.MIN_VALUE，将节点1的val赋值给preValue 将cur(1)移动到右子树，此时cur为之前访问过的根节点5，继续找到cur(5)左子树的最右节点1，发现节点1的右子树为当前节点cur(5)，将节点1的右子树还原为空 此时是第二次到达节点5，比较节点5与preValue(1)，并将5赋值给preValue，cur向右子树移动，此时cur到达节点4 找到cur(4)左子树的最右节点3，将节点3的右子树指向cur(4)，cur向左子树移动，此时cur到达节点3 由于节点3无左子树，直接比较节点3与preValue(5)的值，3&lt;5，返回false。 可以发现中序遍历的顺序是：15346 Morris中序遍历到达的节点顺序是：5154346，其中5和4有左子树，在到底5和4的第二次时作比较。 1234567891011121314151617181920212223242526class Solution &#123; public boolean isValidBST(TreeNode root) &#123; TreeNode cur = root, mostRight = null; long preValue = Long.MIN_VALUE; while (cur != null) &#123; mostRight = cur.left; if (mostRight != null) &#123; while (mostRight.right != null &amp;&amp; mostRight.right != cur) mostRight = mostRight.right; if (mostRight.right == null) &#123; mostRight.right = cur; cur = cur.left; continue; &#125; else if (mostRight.right == cur) &#123; mostRight.right = null; &#125; &#125; if (cur.val &lt;= preValue) return false; preValue = cur.val; cur = cur.right; &#125; return true; &#125;&#125; 时间复杂度：遍历所有节点，\\(O(n)\\) 空间复杂度：Morris遍历利用叶子节点的左右空指针，实现空间开销的极限缩减，\\(O(1)\\) 530. 二叉搜索树的最小绝对差 方法一：中序遍历 使用中序遍历二叉搜索树得到的结果是升序的。 :star::warning:方法二：双指针 双指针的思想真的很重要！！！ 初始化全局变量：pre节点初始化为空；diff存储相邻节点差值，初始化为整型最大值 中序遍历过程：第一次遍历，pre是空的，还没遇到第二个节点也就没有相邻节点之间的差值； 把当前节点(root)赋给pre，那么下一个root就是中序遍历顺序pre的下一个节点 1234567891011121314151617class Solution &#123; TreeNode pre; int diff = Integer.MAX_VALUE; public int getMinimumDifference(TreeNode root) &#123; dfs(root); return diff; &#125; private void dfs(TreeNode root) &#123; if (root == null) return; dfs(root.left); if (pre != null) diff = Math.min(diff, root.val - pre.val); pre = root; dfs(root.right); &#125;&#125; 501. 二叉搜索树中的众数 老样子，中序遍历 遍历的过程 1234567891011121314151617if (preVal == cur.val) &#123; ++counter;&#125;else &#123; counter = 1;&#125;if (!modes.contains(cur.val) &amp;&amp; counter == maxCounter) &#123; modes.add(cur.val);&#125;if (counter &gt; maxCounter) &#123; maxCounter = counter; modes.removeAll(modes); modes.add(cur.val);&#125;preVal = cur.val;cur = cur.right; 236. 二叉树的最近公共祖先 方法一：用HashMap存储所有父节点，用HashSet标记是否访问过；从p开始向上遍历，并标记访问过的父节点，再从q开始向上遍历，如果当前节点被访问过，那么这个节点就是最近公共祖先。 注意：对于p，先设置visisted，再向上移；对于q，先判断当前节点是不是已经被visited，再向上移。如果p,q任意一者先向上移再操作，都会导致在，p或q是最近公共节点时，返回的却是p或q的父节点 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; Map&lt;TreeNode, TreeNode&gt; map = new HashMap&lt;&gt;(); Set&lt;TreeNode&gt; visited = new HashSet&lt;&gt;(); dfs(root, map); while (p != null) &#123; visited.add(p); p = map.get(p); &#125; while (q != null) &#123; if (visited.contains(q)) &#123; return q; &#125; q = map.get(q); &#125; return root; &#125; public void dfs(TreeNode root, Map&lt;TreeNode, TreeNode&gt; map) &#123; if (root == null) return; if (root.left != null) &#123; map.put(root.left, root); &#125; if (root.right != null) &#123; map.put(root.right, root); &#125; dfs(root.left, map); dfs(root.right, map); &#125;&#125; :warning:方法二：DFS 题解 可以不判断非p,q的叶节点 12345678910111213141516class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; return dfs(root, p, q); &#125; public TreeNode dfs(TreeNode root, TreeNode p, TreeNode q) &#123; if (root == null || root == p || root == q) return root; TreeNode left = dfs(root.left, p, q); TreeNode right = dfs(root.right, p, q); if (left == null) return right; if (right == null) return left; return root; &#125;&#125; 235. 二叉搜索树的最近公共祖先 递归：考虑三种情况 p,q是root：return root p,q在root两侧，(p.val &lt; root.val &amp;&amp; q.val &gt; root.val) || (p.val &gt; root.val &amp;&amp; q.val &lt; root.val)， return root p,q在root同一侧 (p.val &lt; root &amp;&amp; q.val &lt; root.val) || (p.val &gt; root.val &amp;&amp; q.val &gt; root.val) p.val &lt; root &amp;&amp; q.val &lt; root.val: return dfs(left, p, q) p.val &gt; root.val &amp;&amp; q.val &gt; root.val: return dfs(right, p, q) 方法一：DFS 1234567891011class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if (root == null) return null; if (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) return lowestCommonAncestor(root.left, p, q); if (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) return lowestCommonAncestor(root.right, p, q); return root; &#125;&#125; 701. 二叉搜索树中的插入操作 要点是：如何记录要插入节点的父节点 方法一：栈 从根节点开始遍历，用栈存储每个遍历过的节点，大于向右小于向左；循环结束，判断插入最后一个被遍历的节点(栈中最顶层节点)，判断大于小于，插入，结束。 遍历过程把所有元素放进栈，空节点跳出循环后，栈顶元素就是要插入节点的父节点 1234567891011121314151617181920212223242526class Solution &#123; public TreeNode insertIntoBST(TreeNode root, int val) &#123; if (root == null) return new TreeNode(val); TreeNode cur = root; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); while (cur != null) &#123; stack.push(cur); if (val &lt; cur.val) &#123; cur = cur.left; &#125; else &#123; cur = cur.right; &#125; &#125; cur = stack.pop(); TreeNode newNode = new TreeNode(val); if (cur.val &gt; val) &#123; cur.left = newNode; &#125; else &#123; cur.right = newNode; &#125; return root; &#125;&#125; 方法二：双指针 用pre指针指向上一个节点，有两个要注意的地方 初始化pre指针时，不能初始化为null，如果根节点没有左子树，而要插入的节点小于根节点，要插入的节点会成为根节点的左子树，这种情况判断一次就会跳出while循环，此时pre还是null，所以要把pre初始化为根节点 在while循环中，用pre=cur记录cur的上一个节点，但是，最后cur等于空的时候，pre再记录cur就没有意义了，所以加上if (cur != null)判断条件 123456789101112131415161718192021class Solution &#123; public TreeNode insertIntoBST(TreeNode root, int val) &#123; TreeNode res = new TreeNode(val); if (root == null) return res; TreeNode cur = root, pre = root; while (cur != null) &#123; if (cur.val &gt; val) cur = cur.left; else if (cur.val &lt; val) cur= cur.right; if (cur != null) pre = cur; &#125; if (val &gt; pre.val) pre.right = res; else pre.left = res; return root; &#125;&#125; 方法三：DFS 当时想出来了，但是卡在怎么插入这个点上，其实这里已经用root.left或者root.right来接收 new TreeNode(val)了。==构造树==！！！ 12345678910111213class Solution &#123; public TreeNode insertIntoBST(TreeNode root, int val) &#123; if (root == null) &#123; return new TreeNode(val); &#125; if (val &lt; root.val) &#123; root.left = insertIntoBST(root.left, val); &#125; else &#123; root.right = insertIntoBST(root.right, val); &#125; return root; &#125;&#125; x450. 删除二叉搜索树中的节点 解题思路： 如果目标节点大于当前节点值，则去右子树中删除； 如果目标节点小于当前节点值，则去左子树中删除； 如果目标节点就是当前节点，分为以下三种情况： 其无左子：其右子顶替其位置，删除了该节点； 其无右子：其左子顶替其位置，删除了该节点； 其左右子节点都有：其左子树转移到其右子树的最左节点的左子树上，然后右子树顶替其位置，由此删除了该节点。 写了快100行，重构一下代码。。 方法一：迭代 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public TreeNode deleteNode(TreeNode root, int key) &#123; if (root == null) return root; TreeNode cur = root, pre = root; while (cur != null) &#123; if (cur.val == key) &#123; if (cur.left == null &amp;&amp; cur.right == null) &#123; // 叶子节点 if (pre.val &lt; key) pre.right = null; else pre.left = null; &#125; else &#123; if (cur.left != null &amp;&amp; cur.right != null) &#123; // 找到要删除节点右子树上的最左节点，再把要删除节点左子树挂上去 TreeNode left = cur.left, right = cur.right; cur = cur.right; while (cur.left != null) cur = cur.left; cur.left = left; if (pre.val &lt; key) pre.right = right; else pre.left = right; &#125; else if (cur.left == null &amp;&amp; cur.right != null) &#123; TreeNode right = cur.right; if (pre.val &lt; key) pre.right = right; else pre.left = right; &#125; else if (cur.left != null &amp;&amp; cur.right == null) &#123; TreeNode left = cur.left; if (pre.val &lt; key) pre.right = left; else pre.left = left; &#125; &#125; break; &#125; else if (cur.val &lt; key) &#123; pre = cur; cur = cur.right; &#125; else &#123; pre = cur; cur = cur.left; &#125; &#125; if (root.val == key) &#123; return root.left == null ? root.right : root.left; &#125; return root; &#125;&#125; :star:方法二：DFS 注意代码注释部分是完全冗余的！ 123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public TreeNode deleteNode(TreeNode root, int key) &#123; if (root == null) return root; if (key &lt; root.val) root.left = deleteNode(root.left, key); else if (key &gt; root.val) root.right = deleteNode(root.right, key); else &#123; //(key == root.val) &#123; if (root.left == null &amp;&amp; root.right == null) &#123; return null; &#125; else if (root.left == null &amp;&amp; root.right != null) &#123; return root.right; &#125; else if (root.left != null &amp;&amp; root.right == null) &#123; return root.left; &#125; else &#123; TreeNode cur = root.right; while (cur.left != null) cur = cur.left; cur.left = root.left; return root.right; &#125; &#125; // if (root.val == key) &#123; // if (root.left == null &amp;&amp; root.right == null) // return null; // else &#123; // return root.left == null ? root.right : root.left; // &#125; // &#125; return root; &#125;&#125; :warning:669. 修剪二叉搜索树 借上一题的思路直接速通了 108. 将有序数组转换为二叉搜索树 方法一：二分DFS[左闭右闭] 方法二：DFS[左闭右开)]，开区间元素在record的数值要--，闭区间元素在record的位置要++，开区间元素和闭区间元素都为‘a’，所以s的下标1以‘b’开始的子串“ba”也是变位词！ 1234567891011121314151617181920212223242526272829class Solution &#123; public List&lt;Integer&gt; findAnagrams(String s, String p) &#123; List&lt;Integer&gt; index = new LinkedList&lt;&gt;(); if (s.length() &lt; p.length()) return index; int[] record = new int[26]; for (int i = 0; i &lt; p.length(); ++i) &#123; ++record[p.charAt(i) - &#x27;a&#x27;]; --record[s.charAt(i) - &#x27;a&#x27;]; &#125; if (areZeros(record)) &#123; index.add(0); &#125; for (int i = p.length(); i &lt; s.length(); ++i) &#123; ++record[s.charAt(i - p.length()) - &#x27;a&#x27;]; --record[s.charAt(i) - &#x27;a&#x27;]; if (areZeros(record)) &#123; index.add(i - p.length() + 1); &#125; &#125; return index; &#125; private boolean areZeros(int[] record) &#123; for (int element : record) if (element != 0) return false; return true; &#125;&#125; 1208. 尽可能使字符串相等:warning: 方法一：滑动窗口 123456789101112131415161718class Solution &#123; public int equalSubstring(String s, String t, int maxCost) &#123; int n = s.length(); int[] diff = new int[n]; for (int i = 0; i &lt; n; ++i) &#123; diff[i] = Math.abs(s.charAt(i) - t.charAt(i)); &#125; int res = 0, start = 0, sum = 0; for (int end = 0; end &lt; n; ++end) &#123; sum += diff[end]; while (maxCost &lt; sum) &#123; sum -= diff[start++]; &#125; res = Math.max(res, end - start + 1); &#125; return res; &#125;&#125; String补充知识 String与char数组，StringBuilder之间相互转换 将String转换为char数组： 12codeString str = &quot;hello&quot;;char[] charArray = str.toCharArray(); 将char数组转换为String： 12codechar[] charArray = &#123;&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;&#125;;String str = new String(charArray); 将String转换为StringBuilder： 123456//1.codeString str = &quot;hello&quot;;StringBuilder sb = new StringBuilder(str);//2.StringBuilder sb = new StringBuilder();sb.append(str); 将StringBuilder转换为String： 123codeStringBuilder sb = new StringBuilder();sb.append(&quot;hello&quot;);String str = sb.toString(); 将char数组转换为StringBuilder： 123codechar[] charArray = &#123;&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;&#125;;StringBuilder sb = new StringBuilder();sb.append(charArray); 将StringBuilder转换为char数组： 123codeStringBuilder sb = new StringBuilder(&quot;hello&quot;);char[] charArray = new char[sb.length()];sb.getChars(0, sb.length(), charArray, 0); 需要注意的是，在将String转换为char数组或char时，如果字符串为空，或者字符串中的字符数量为0，则可能会导致越界异常或其他异常。因此，在进行这些转换操作时，需要进行有效性检查和异常处理。 单个字符char转换为String 在Java中，将单个字符（char）转换为字符串（String）有以下两种方法： 1.使用字符串连接符 您可以使用字符串连接符\"+\"来连接一个空字符串和单个字符，从而将其转换为字符串。例如： 12arduinoCopy codechar c = &#x27;a&#x27;;String s = &quot;&quot; + c; 在上面的代码中，首先创建一个空字符串，然后使用字符串连接符将其与字符\"c\"连接起来，从而将字符\"c\"转换为字符串。现在，字符串s将包含字符\"c\"的字符串。 2.使用String.valueOf()方法 另一种将单个字符转换为字符串的方法是使用String类的valueOf()方法。例如： 12arduinoCopy codechar c = &#x27;a&#x27;;String s = String.valueOf(c); 在上面的代码中，将字符\"c\"传递给valueOf()方法，并将返回的字符串分配给变量s。 无论使用哪种方法，您都可以将单个字符转换为字符串，从而可以对其进行各种字符串操作。 StringBuilder的append可以是char或者String StringBuilder的append()方法可以接受char类型和String类型的参数。append()方法的作用是在StringBuilder对象的末尾追加指定的字符序列，这可以是char、String、StringBuilder或其他CharSequence实例。 以下是使用StringBuilder的append()方法追加char和String类型参数的示例代码： 追加char类型参数： 123codeStringBuilder sb = new StringBuilder();char c = &#x27;a&#x27;;sb.append(c); 追加String类型参数： 123codeStringBuilder sb = new StringBuilder();String str = &quot;hello&quot;;sb.append(str); 需要注意的是，使用append()方法追加char类型参数时，会自动将char类型转换为String类型。因此，如果需要在StringBuilder中追加一个char类型的字符，可以直接使用append()方法，而不需要先将其转换为String类型。 KMP算法 生成next数组讲得很透彻 Array 704. 二分查找 方法一：左闭右开 区间：[left, right) 初始化：right = nums.length while循环终止条件应为left &lt; right（右开，right不能等于left） 当nums[mid] &lt; target时，nums[0]~nums[mid]都小于target，此时有效的有边界是mid - 1，又因为右边界是开区间，所以另right = mid 时间复杂度：\\(O(logn)\\)，由于每次查找都会将查找范围缩小一半，因此二分查找的时间复杂度是\\(O(logn)\\)，其中 n 是数组的长度 空间复杂度：\\(O(1)\\) 12345678910111213141516class Solution &#123; public int search(int[] nums, int target) &#123; int left = 0, right = nums.length; // [left, right) while(left &lt; right) &#123; int mid = left + ((right - left) &gt;&gt; 1); if (nums[mid] == target) return mid; else if (nums[mid] &lt; target) left = mid + 1; else right = mid; &#125; return -1; &#125;&#125; 方法二：左闭右闭 区间：[left, right] 初始化：right = nums.length - 1 while循环终止条件应为left &lt;= right 当nums[mid] &lt; target时，nums[0]~nums[mid]都小于target，另right = mid - 1 时间复杂度：\\(O(logn)\\)，由于每次查找都会将查找范围缩小一半，因此二分查找的时间复杂度是\\(O(logn)\\)，其中 n 是数组的长度 空间复杂度：\\(O(1)\\) 123456789101112131415class Solution &#123; public int search(int[] nums, int target) &#123; int left = 0, right = nums.length - 1; while (left &lt;= right) &#123; int mid = right - ((right - left) &gt;&gt; 1); if (nums[mid] &gt; target) right = mid - 1; else if (nums[mid] &lt; target) left = mid + 1; else return mid; &#125; return -1; &#125;&#125; 27. 移除元素 方法一：暴力 每当发现一个数相等，那么从当前数组的下一个数开始，全部往前移一位。 注意：因为移位后，下一个要访问的数组元素j会到当前i的位置，然后for循环结束i自增，会错过访j，所以移位后要--i。 时间复杂度：\\(O(n^2)\\) 空间复杂度：\\(O(1)\\) 12345678910111213141516171819class Solution &#123; public int removeElement(int[] nums, int val) &#123; int newLen = nums.length; if (newLen == 0) return 0; for (int i = 0; i &lt; newLen; i++) &#123; if (nums[i] == val) &#123; for (int j = i + 1; j &lt; newLen; j++) &#123; nums[j - 1] = nums[j]; &#125; --newLen; --i; &#125; &#125; return newLen; &#125;&#125; 方法二：双指针 初始化慢指针为0 for循环遍历快指针，当nums[fast] != val时，令nums[slow] = nums[fast]，slow指针往后移。也就是说，如果快指针找到了val，那么慢指针停在val位置，之后快指针遍历到非val的位置时，将该非val数据覆盖到慢指针的指向数组位置的数据。 最后返回慢指针(慢指针大小代表新数组的大小) 时间复杂度：\\(O(n)\\) 空间复杂度：\\(O(1)\\) 123456789101112class Solution &#123; public int removeElement(int[] nums, int val) &#123; int slow = 0; for (int fast = 0; fast &lt; nums.length; ++fast) &#123; if (nums[fast] != val) &#123; nums[slow] = nums[fast]; ++slow; &#125; &#125; return slow; &#125;&#125; 方法三：相向双指针 避免了需要保留的元素的重复赋值操作。 初始化：left=0, right=nums.length-1，左闭右闭区间，所以while语句的执行条件是 left &lt;= right(如果没有等于，left会少后移一次) 循环：当nums[left]不等于val时，left指针后移；当nums[left]等于val时，将nums[right]赋值给nums[left]，right指针前移；如果赋值过来的元素恰好也等于val，可以继续把右指针 right指向的元素的值赋值过来，直到左指针指向的元素的值不等于 val为止。 时间复杂度：\\(O(n)\\) 空间复杂度：\\(O(1)\\) 12345678910111213141516class Solution &#123; public int removeElement(int[] nums, int val) &#123; int left = 0, right = nums.length - 1; // [left, right] while (left &lt;= right) &#123; if (nums[left] == val) &#123; nums[left] = nums[right]; --right; &#125; else &#123; ++left; &#125; &#125; return left; &#125;&#125; 977. 有序数组的平方 双指针 left,right指针指向数组两端，将较大的平方数放入result数组里。 时间复杂度：\\(O(n)\\) 空间复杂度：\\(O(n)\\) 209. 长度最小的子数组 nums[++i]先执行自增操作还是数组寻址操作? 在Java中，表达式nums[++i]中的++i是先自增还是先寻址是有规定的。按照Java的运算符优先级规定，前置自增运算符++i的优先级高于数组下标运算符[]，因此在执行这个表达式时，先进行++i自增运算，然后再进行数组下标运算，即先自增再寻址。 因此，nums[++i]相当于先将变量i自增1，然后使用自增后的i作为数组下标去访问nums数组中的元素。如果i的初始值为0，那么nums[++i]将访问nums[1]位置上的元素，而不是nums[0]。如果数组nums越界，将会抛出ArrayIndexOutOfBoundsException异常。 nums[i++]先执行自增操作还是数组寻址操作? 在这种情况下，nums[i++]实际上会先执行数组寻址操作，然后再对i进行自增操作。这是因为数组寻址操作的优先级比自增操作的优先级高。 具体来说，这个表达式会先使用i的当前值来计算nums数组中第i个元素的地址，然后将地址作为结果返回，接着才会将i的值加1。 int a = ++i 是先赋值还是先自增 这行代码会先自增变量 i 的值，然后将自增后的结果赋值给变量 a。所以，变量 a 的值等于自增后的变量 i 的值。这个过程中，变量 i 的值会被修改，而变量 a 的值则是这个修改后的值。 可以将这行代码拆分成两步： i = i + 1； // 自增 i 的值 a = i； // 将自增后的 i 的值赋值给 a 所以，最终变量 a 的值等于自增后的变量 i 的值。 int a = i++ 是先赋值还是先自增 这行代码会先将变量 i 的值赋值给变量 a，然后再将变量 i 的值自增。所以，变量 a 的值等于变量 i 的值，而变量 i 的值会被自增。 可以将这行代码拆分成两步： a = i； // 将 i 的值赋值给 a i = i + 1； // 自增 i 的值 所以，最终变量 a 的值等于变量 i 的初始值，而变量 i 的值则是初始值加一。 while(--index) 先-- 后比较index&gt;0 1234int index = 2;while (--index &gt; 0) &#123; System.out.print(index);&#125; stdout 1 while(index--) 先比较 后-- 1234int index = 2;while (index-- &gt; 0) &#123; System.out.print(index);&#125; stdout 10 System.out.print(--index) 先-- 后打印 1234int index = 2;while (index &gt; 0) &#123; System.out.print(--index);&#125; stdout 10 滑动窗口 注意：为了确保有些案例，sum一直小于target，最后输出判断：如果 result == Integer.MAX_VALUE，就输出0。 result记录最小的长度 时间复杂度：\\(O(n)\\) 空间复杂度：\\(O(1)\\) 123456789101112131415class Solution &#123; public int minSubArrayLen(int target, int[] nums) &#123; int counter = 0, result = Integer.MAX_VALUE; int sum = 0; for (int i = 0; i &lt; nums.length; ++i) &#123; ++counter; sum += nums[i]; while (sum &gt;= target) &#123; result = Math.min(result, counter); sum -= nums[i - (--counter)]; &#125; &#125; return result == Integer.MAX_VALUE ? 0 : result; &#125;&#125; 59. 螺旋矩阵 II 遍历顺序：从左到右(左闭右开)，从上到下(上闭下开)，从右到左(右闭左开)，从下到上(下闭上开) 思路见代码注释部分 时间复杂度：\\(O(n^2)\\) 空间复杂度：\\(O(1)\\) 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public int[][] generateMatrix(int n) &#123; // 用笔画一个n=5的矩阵作为例子 // 遍历顺序：从左到右(左闭右开)，从上到下(上闭下开)，从右到左(右闭左开)，从下到上(下闭上开) // 建立n行n列的矩阵 int[][] matrix = new int[n][n]; // 遍历次数 int traverseTime = n / 2; int i, j; // 写入数组的数 int data = 1; // cur:当前遍历伦茨 for (int cur = 0; cur &lt; traverseTime; ++cur) &#123; // 从左到右(左闭右开) for (j = cur; j &lt; n - cur - 1; ++j) &#123; matrix[cur][j] = data++; &#125; // 从上到下(上闭下开) for (i = cur; i &lt; n - cur - 1; ++i) &#123; matrix[i][j] = data++; &#125; // 从右到左(右闭左开) for (; j &gt; cur; --j) &#123; matrix[i][j] = data++; &#125; // 从下到上(下闭上开) for (; i &gt; cur; --i) &#123; matrix[i][j] = data++; &#125; // debug // for (int a = 0; a &lt; n; ++a) &#123; // for (int b = 0; b &lt; n; ++b) &#123; // System.out.print(matrix[a][b]); // &#125; // &#125; &#125; if (n % 2 == 1) matrix[traverseTime][traverseTime] = n * n; return matrix; &#125;&#125; 303. 区域和检索 - 数组不可变 方法一：暴力 1234567891011121314151617181920class NumArray &#123; private int[] nums; public NumArray(int[] nums) &#123; this.nums = nums; &#125; public int sumRange(int left, int right) &#123; int sum = 0; for (int i = left; i &lt;= right; ++i) &#123; sum += nums[i]; &#125; return sum; &#125;&#125;/** * Your NumArray object will be instantiated and called as such: * NumArray obj = new NumArray(nums); * int param_1 = obj.sumRange(left,right); */ 方法二：前缀和 建立一个长度为n+1的数组preSum 初始化preSum[0] = 0; preSum[i]表示数组nums从下标0到下标i-1的和 image-20230511111212882 区间[left,right]的和为preSum[right + 1] - preSum[left]; preSum[right + 1]表示数组从下标0到right的和，preSum[left]表示数组从下标0到left-1的和 将前缀和数组preSum的长度设为n+1的目标是为了方便计算sumRange(left, right)时，不需要对left=0的情况做特殊处理 12345678910111213141516171819class NumArray &#123; private int[] preSum; public NumArray(int[] nums) &#123; preSum = new int[nums.length + 1]; for (int i = 1; i &lt; preSum.length; ++i) &#123; preSum[i] = preSum[i - 1] + nums[i - 1]; &#125; &#125; public int sumRange(int left, int right) &#123; return preSum[right + 1] - preSum[left]; &#125;&#125;/** * Your NumArray object will be instantiated and called as such: * NumArray obj = new NumArray(nums); * int param_1 = obj.sumRange(left,right); */ 前缀和：前缀和数组为n，需要对left=0时做特殊处理 1234567891011121314151617181920212223class NumArray &#123; private int[] preSum; public NumArray(int[] nums) &#123; preSum = new int[nums.length]; preSum[0] = nums[0]; for (int i = 1; i &lt; preSum.length; ++i) &#123; preSum[i] = preSum[i - 1] + nums[i]; &#125; &#125; public int sumRange(int left, int right) &#123; if (left == 0) &#123; return preSum[right]; &#125; return preSum[right] - preSum[left - 1]; &#125;&#125;/** * Your NumArray object will be instantiated and called as such: * NumArray obj = new NumArray(nums); * int param_1 = obj.sumRange(left,right); */ 304. 二维区域和检索 - 矩阵不可变 方法一：前缀和:warning: 需要重刷！ 题解 image-20230511124326460 123456789101112131415161718192021class NumMatrix &#123; int[][] preSum; public NumMatrix(int[][] matrix) &#123; preSum = new int[matrix.length + 1][matrix[0].length + 1]; for (int i = 1; i &lt;= matrix.length; ++i) &#123; for (int j = 1; j &lt;= matrix[0].length; ++j) &#123; preSum[i][j] = matrix[i - 1][j - 1] + preSum[i - 1][j] + preSum[i][j - 1] - preSum[i - 1][j - 1]; &#125; &#125; &#125; public int sumRegion(int row1, int col1, int row2, int col2) &#123; return preSum[row2 + 1][col2 + 1] - preSum[row2 + 1][col1] - preSum[row1][col2 + 1] + preSum[row1][col1]; &#125;&#125;/** * Your NumMatrix object will be instantiated and called as such: * NumMatrix obj = new NumMatrix(matrix); * int param_1 = obj.sumRegion(row1,col1,row2,col2); */ 1109. 航班预订统计 LinkedList 203. 移除链表元素 解题思路：在面对链表、树有关创建、删除操作，使用dummyHead！能省去不少边界判定的功夫。 初始化：dummyHead指向head，dummyHead赋值给pre，head赋值给cur 当cur的值等于所求val，pre指向cur的下一个节点 当cur的值不等于val，pre移动到cur，cur往后移一位 返回dummyHead的下一个节点。 707. 设计链表 注意事项：DummyHead + size 206. 反转链表 用笔模拟一下指针pre，cur，next的过程 时间复杂度：\\(O(n^2)\\) 空间复杂度：\\(O(1)\\) 24. 两两交换链表中的节点 注意要点：用纸和笔模拟一下指针pre，cur，next的过程，记得创建dummyHead 时间复杂度：\\(O(n)\\) 空间复杂度：\\(O(1)\\) 19. 删除链表的倒数第 N 个结点 使用dummyHead，从dummyHead，找到倒数第N个节点的前一个节点node，需要走链表长度size - N步，即可把node指向下一个节点的下一个节点即可完成删除操作。 但是链表的长度是未知的，可以先遍历一遍链表的长度，求出size，再走size-N步完成删除操作。 也可以使用快慢指针，fast与slow的起始点都为dummyHead，fast先走N步，再让fast与slow一起右移，当fast走到最后一个节点时(fast.next == null时)，slow右移了size - N步，到达倒数第N个节点的上一个节点，即可完成删除操作。 时间复杂度：\\(O(n)\\) 空间复杂度：\\(O(1)\\) 面试题 02.07. 链表相交 方法一：HashSet 用指针A,B分别指向两个链表头 开始循环，循环的终止条件为A,B都为空，每次循环先将A,B指向的节点放入HashSet，再向后移 当遍历到某个已经存入HashSet的节点时，这个节点就是相交节点；否则没有相交节点 时间复杂度：\\(O(m + n)\\)，其中m，n分别为两个链表的长度 空间复杂度：\\(O(m + n)\\) 方法二：双指针 解题思路：A,B分别指向headA,headB，如果有公共节点，设公共节点长度为c，链表A和B长度分别为a,b。向右遍历，如何为空，则指向另一个链表的头。如果两个链表相交，则A向右移动了a+c+b步，B向右移动了b+c+a时相交，返回A；如果两个链表不相交，则A向右移动了a+b步，B向右移动了b+a步，都为空，退出循环返回null。 用指针A,B分别指向两个链表头headA,headB 开始循环，循环的条件是A和B不都为空，如果A为空，则A指向headB，否则向后移；如果B为空，则B指向headA，否则向后移 开始循环，循环的终止条件为A,B都为空，每次循环先将A,B指向的节点放入HashSet，再向后移 当遍历到某个已经存入HashSet的节点时，这个节点就是相交节点；否则没有相交节点 时间复杂度：\\(O(m + n)\\)，其中m，n分别为两个链表的长度 空间复杂度：\\(O(m + n)\\) 一个错误代码实例 1234567891011121314public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; if (headA == null || headB == null) return null; ListNode pA = headA, pB = headB; while (pA != null || pB != null) &#123; pA = pA == null ? headB : pA.next; pB = pB == null ? headA : pB.next; if (pA == pB) return pA; &#125; return null; &#125;&#125; 错误如下，当两个链表只有公共部分节点1时，上述代码没有先判断，先向右移，结果指向A,B都为空，返回空。 所以解决方案是把判断AB相等的语句放在指针移动上面 12345678910111213public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; if (headA == null || headB == null) return null; ListNode pA = headA, pB = headB; while (pA != null || pB != null) &#123; if (pA == pB) return pA; pA = pA == null ? headB : pA.next; pB = pB == null ? headA : pB.next; &#125; return null; &#125; 成功 优化 当A,B只有公共部分时，直接返回结果 当A,B有自己的部分也相交时 当A,B公共部分前面节点数量相同时，遍历到相交节点直接返回结果 当A,B公共部分前面节点数量不同时，遍历a+b+c步也会相交，返回结果 当A,B不相交时，遍历完a+ 1(null) + b + 1(null) 步后，A和B都为null，返回的A为null，表示不相交 123456789101112public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; if (headA == null || headB == null) return null; ListNode pA = headA, pB = headB; while (pA != pB) &#123; pA = pA == null ? headB : pA.next; pB = pB == null ? headA : pB.next; &#125; return pA; &#125;&#125; 142. 环形链表 II 解题思路：快慢指针，慢指针走一步，快指针走两步，如果有环，快指针总能在环中追上慢指针。当快指针和慢指针指向同一节点时，把快节点指向头节点，慢节点不动，快慢指针一起走，再次相遇时，指向的节点就是入环的第一个节点。 时间复杂度：\\(O(m + n)\\)，其中m，n分别为两个链表的长度 空间复杂度：\\(O(m + n)\\) 1234567891011121314151617181920public class Solution &#123; public ListNode detectCycle(ListNode head) &#123; if (head == null || head.next == null) return null; ListNode fast = head.next.next, slow = head.next; while (fast != null &amp;&amp; fast.next != null) &#123; fast = fast.next.next; slow = slow.next; if (fast == slow) &#123; fast = head; while (fast != slow) &#123; fast = fast.next; slow = slow.next; &#125; return fast; &#125; &#125; return null; &#125;&#125; 剑指 Offer II 026. 重排链表 方法一：翻转合并 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public void reorderList(ListNode head) &#123; ListNode cur = head, fast = head.next; while(fast != null &amp;&amp; fast.next != null) &#123; fast = fast.next.next; cur = cur.next; &#125; ListNode mid = cur; fast = mid.next; mid.next = null; fast = reverse(fast); cur = head; while (fast != null) &#123; ListNode next1 = cur.next, next2 = fast.next; cur.next = fast; fast.next = next1; cur = next1; fast = next2; &#125; &#125; private ListNode reverse(ListNode cur) &#123; ListNode pre = null, next = null; while (cur != null) &#123; next = cur.next; cur.next = pre; pre = cur; cur = next; &#125; return pre; &#125;&#125; 剑指 Offer II 025. 链表中的两数相加 方法一：翻转三次 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; l1 = reverse(l1); l2 = reverse(l2); ListNode res = addReversedList(l1, l2); return reverse(res); &#125; private ListNode addReversedList(ListNode l1, ListNode l2) &#123; ListNode dummy = new ListNode(-1); ListNode cur = dummy; int carry = 0, sum = 0; while (l1 != null || l2 != null) &#123; l1 = l1 == null ? null : l1; l2 = l2 == null ? null : l2; sum = (l1 == null ? 0 : l1.val) + (l2 == null ? 0 : l2.val) + carry; carry = sum &gt;= 10 ? 1 : 0; sum = sum &gt;= 10 ? sum - 10 : sum; ListNode newNode = new ListNode(sum); cur.next = newNode; cur = cur.next; l1 = l1 == null ? null : l1.next; l2 = l2 == null ? null : l2.next; &#125; if (carry == 1) &#123; ListNode newNode = new ListNode(1); cur.next = newNode; &#125; return dummy.next; &#125; private ListNode reverse(ListNode cur) &#123; ListNode pre = null, next = null; while (cur != null) &#123; next = cur.next; cur.next = pre; pre = cur; cur = next; &#125; return pre; &#125;&#125; 方法二：翻转两次(最后一次不需要翻转) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; l1 = reverse(l1); l2 = reverse(l2); ListNode res = addReversedList(l1, l2); return res; &#125; private ListNode addReversedList(ListNode l1, ListNode l2) &#123; ListNode dummy = new ListNode(-1); ListNode cur = dummy; int carry = 0, sum = 0; while (l1 != null || l2 != null) &#123; l1 = l1 == null ? null : l1; l2 = l2 == null ? null : l2; sum = (l1 == null ? 0 : l1.val) + (l2 == null ? 0 : l2.val) + carry; carry = sum &gt;= 10 ? 1 : 0; sum = sum &gt;= 10 ? sum - 10 : sum; ListNode newNode = new ListNode(sum); cur = dummy.next; dummy.next = newNode; newNode.next = cur; l1 = l1 == null ? null : l1.next; l2 = l2 == null ? null : l2.next; &#125; if (carry == 1) &#123; cur = dummy.next; ListNode newNode = new ListNode(1); dummy.next = newNode; newNode.next = cur; &#125; return dummy.next; &#125; private ListNode reverse(ListNode cur) &#123; ListNode pre = null, next = null; while (cur != null) &#123; next = cur.next; cur.next = pre; pre = cur; cur = next; &#125; return pre; &#125;&#125; Hash Table 242. 有效的字母异位词 方法一：双HashMap记录词频 判断s与t的长度，若不相等，则一定不是字母异位词 建立两个HashMap&lt;Character, Integer&gt; 遍历字符串，将每个字符存入map中，并将值+1 如果map1与map2的size不相等，则一定不是字母异位词 遍历map1(我遍历的是字符串)，get字符串s，t的每一个字符出现了的次数，判断是否相同，如果不同，则一定不是字母异位词。 时间复杂度：\\(O(n)\\)，其中n为第一个字符串的长度 空间复杂度：\\(O(1)\\) 1234567891011121314151617181920212223class Solution &#123; public boolean isAnagram(String s, String t) &#123; int len = s.length(); if (len != t.length()) return false; Map&lt;Character, Integer&gt; map1 = new HashMap&lt;&gt;(), map2 = new HashMap&lt;&gt;(); for (int i = 0; i &lt; len; ++i) &#123; char sChar = s.charAt(i); char tChar = t.charAt(i); map1.put(sChar, map1.getOrDefault(sChar, 0) + 1); map2.put(tChar, map2.getOrDefault(tChar, 0) + 1); &#125; for (int i = 0; i &lt; len; ++i) &#123; int sSize = map1.get(s.charAt(i)); int tSize = map2.getOrDefault(s.charAt(i), 0); if (sSize != tSize) &#123; return false; &#125; &#125; return true; &#125;&#125; 方法二：数组 数组其实就是一个简单哈希表，而且这道题目中字符串只有小写字符，那么就可以定义一个数组，来记录字符串s里字符出现的次数。 定一个数组record，大小为26 ，初始化为0，因为字符a到字符z的ASCII也是26个连续的数值。 遍历第一个字符串s时，只需要将s.charAt(i) - ‘a’所在的元素+1，这样统计了字符串s中每个字符出现的次数。 同样，遍历第二个字符串t时，只需要将t.charAt(i) - ‘a’所在的元素-1。 如果record全部元素为0，那么s和t是字母异位词；否则不是。 时间复杂度：\\(O(n)\\)，其中n为第一个字符串的长度 空间复杂度：\\(O(1)\\)，只使用了常数大小的辅助数组。 123456789101112131415class Solution &#123; public boolean isAnagram(String s, String t) &#123; if (s.length() != t.length()) return false; int[] record = new int[26]; for (int i = 0; i &lt; s.length(); ++i) &#123; ++record[s.charAt(i) - &#x27;a&#x27;]; --record[t.charAt(i) - &#x27;a&#x27;]; &#125; for (int i = 0; i &lt; 26; ++i) if (record[i] != 0) return false; return true; &#125;&#125; 349. 两个数组的交集 解题思路：双HashSet 首先使用一个HashSet命名为set，记录第一个数组中不包含重复的所有元素 再用一个HashSet命名为intersection，遍历第二个数组，如果第二个数组中的元素在set中，则加入intersection中 最后将intersection转换为数组，并返回 1234567891011121314151617class Solution &#123; public int[] intersection(int[] nums1, int[] nums2) &#123; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); Set&lt;Integer&gt; intersection = new HashSet&lt;&gt;(); for (int i = 0; i &lt; nums1.length; ++i) set.add(nums1[i]); for (int i = 0; i &lt; nums2.length; ++i) if (set.contains(nums2[i])) intersection.add(nums2[i]); int[] result = new int[intersection.size()]; int i = 0; for (int element : intersection) &#123; result[i++] = element; &#125; return result; &#125;&#125; 202. 快乐数 求和的过程中，sum会重复出现，用HashSet记录每一次求和，如果有重复，那么必定不是快乐数。 注意：sum += (n % 10) * (n % 10);+=的优先级高于%。 12345678910111213141516171819class Solution &#123; public boolean isHappy(int n) &#123; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); while (n != 1 &amp;&amp; !set.contains(n)) &#123; set.add(n); n = getSum(n); &#125; return n == 1; &#125; private int getSum(int n) &#123; int sum = 0; while (n &gt; 0) &#123; sum += (n % 10) * (n % 10); n /= 10; &#125; return sum; &#125;&#125; 1. 两数之和 方法一：暴力 注意初始化int数组：new int[]{i, j}; 时间复杂度：\\(O(n^2)\\)，其中n为第一个字符串的长度 空间复杂度：\\(O(1)\\)，只使用了常数大小的辅助数组。 12345678910111213class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int[] result = new int[2]; for (int i = 0; i &lt; nums.length - 1; ++i) &#123; for (int j = i + 1; j &lt; nums.length; ++j) &#123; if (nums[i] + nums[j] == target) &#123; return new int[]&#123;i, j&#125;; &#125; &#125; &#125; return result; &#125;&#125; 方法二：HashMap 解题思路： 建立一个HashMap，key为数组的值，value为数组索引 遍历一遍，每次遍历判断哈希表中是否存在key为target-nums[i]，如果有，则这个key对应的value与i即为所求 时间复杂度：\\(O(n)\\) 空间复杂度：\\(O(n)\\) 1234567891011class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; ++i) &#123; if (map.containsKey(target - nums[i])) return new int[]&#123;map.get(target - nums[i]), i&#125;; map.put(nums[i], i); &#125; return new int[2]; &#125;&#125; 454. 四数相加 II 解题思路： 用HashMap用两层循环记录前两个数组每个元素之和为key，和出现的次数为value 再两次循环后两个数组，如果map.containsKey(- i - j)，那么- i - j与当前i + j之和为0，即为本题所求，则把result加上和为- i - j的数量 时间复杂度：\\(O(n^2)\\)，两层循环 空间复杂度：\\(O(n^2)\\)，在最坏情况下，前两个数组的元素各不相同，map占n * n 12345678910111213141516171819class Solution &#123; public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); int result = 0; int n = nums1.length; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; map.put(nums1[i] + nums2[j], map.getOrDefault(nums1[i] + nums2[j], 0) + 1); &#125; &#125; for (int i : nums3) &#123; for (int j : nums4) &#123; if (map.containsKey(- i - j)) result += map.get(- i - j); &#125; &#125; return result; &#125;&#125; 383. 赎金信 解题思路：字母表 如果ransomNote的长度大于magazine的长度，直接返回false 新建一个长度为26的字母表，以及一个HashMap，key为字母-‘a’，value为字母出现的次数，将magazine中的每个字符put进map 遍历ransomNote的所有字符i，如果map中key为字符i的value大于0，那么把这个value减一；如果map中key为字符i的value小于等于0，说明magazine不存在字符i或者字符i的个数小于ransomNote中字符i的个数，那么 ransomNote 能不能由 magazine 里面的字符构成，返回false 时间复杂度：\\(O(n)\\)，两层循环 空间复杂度：\\(O(1)\\)，只需要常数大小的辅助空间 12345678910111213141516171819202122class Solution &#123; public boolean canConstruct(String ransomNote, String magazine) &#123; if (ransomNote.length() &gt; magazine.length()) return false; char[] record = new char[26]; Map&lt; Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; magazine.length(); ++i) &#123; int index = magazine.charAt(i) - &#x27;a&#x27;; map.put(index, map.getOrDefault(index, 0) + 1); &#125; for (int i = 0; i &lt; ransomNote.length(); ++i) &#123; int index = ransomNote.charAt(i) - &#x27;a&#x27;; if (map.getOrDefault(index, 0) &gt; 0) &#123; map.put(index, map.get(index) - 1); &#125; else return false; &#125; return true; &#125;&#125; x15. 三数之和 题目要求： nums[i],nums[j],nums[k]中i,j,k各不相同 输出的nums[i],nums[j],nums[k]不能重复，如果结果集合中有{1,2,3}了，就不能再加入一个{1,2,3} 不能有重复的三元组，但三元组内的元素是可以重复的！{0,0,0},{-1,-1,2}是允许的 方法一：暴力 注意：{1，2，3}和{3， 2， 1}是不同的元素！ 1234set.add(Arrays.asList(1, 2, 3));set.add(Arrays.asList(3, 1, 2));[1, 2, 3][3, 1, 2] 找到符合的元素先排序，如何hashset中不存在再加入list中。 123456789101112131415161718192021class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; Set&lt;List&lt;Integer&gt;&gt; set = new HashSet&lt;&gt;(); List&lt;List&lt;Integer&gt;&gt; list = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; nums.length - 2; ++i) &#123; for (int j = i + 1; j &lt;nums.length - 1; ++j) &#123; for (int k = j + 1; k &lt; nums.length; ++k) &#123; if (nums[i] + nums[j] + nums[k] == 0) &#123; List&lt;Integer&gt; temp = Arrays.asList(nums[i], nums[j], nums[k]); Collections.sort(temp); if (!set.contains(temp)) &#123; set.add(temp); list.add(temp); &#125; &#125; &#125; &#125; &#125; return list; &#125;&#125; 超时 方法二：排序 + 双指针 去重思路 边界判断 时间复杂度：\\(O(n^2)\\)，两层循环 空间复杂度：\\(O(1)\\) 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;(); Arrays.sort(nums); // window: [nums[i], left, right] for (int i = 0; i &lt; nums.length - 2; ++i) &#123; if (nums[i] &gt; 0) break; // 去重 // 为什么不是nums[i] = nums[i + 1]? // 比如&#123;-1，-1，2&#125; // 如果是nums[i] = nums[i + 1]，那么&#123;-1，-1，2&#125;这个结果不会被选中 if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue; int left = i + 1, right = nums.length - 1; // 只能选取数组中不同下标的三个数，所以left == right时会使用同一个数，不执行 while (left &lt; right) &#123; int sum = nums[i] + nums[left] + nums[right]; if (sum &lt; 0) ++left; else if (sum &gt; 0) --right; else &#123; // sum == 0 result.add(Arrays.asList(nums[i], nums[left], nums[right])); // 去重 // 必须在添加完结果后去重，不然第一次的结果可能无法添加 while (right &gt; left &amp;&amp; nums[right] == nums[right - 1]) --right; while (right &gt; left &amp;&amp; nums[left] == nums[left + 1]) ++left; // 为什么两个指针都移动？去重之后，只移动一个，结果必定不等于0 --right; ++left; &#125; &#125; &#125; return result; &#125;&#125; 18. 四数之和 注意事项：nums[i]的范围，如果4个数都等于\\(10^9\\)， 那么将大于\\(2^{31} - 1= 2147483648 &lt; 2.15 * 10^9\\)(int最大的正数)，所以要用long记录四数之和 在三数之和的基础上，再增加一层循环， 区间为[nums[i], nums[left], nums[right], nums[j]] 时间复杂度：\\(O(n^3)\\)，三层循环 空间复杂度：\\(O(n)\\)，排序使用了额外的数组存储数组nums的副本 剪枝 第一层循环中，如果最小的四数之和大于target，那么后面的数更大，break 123\\\\ 第一层循环if ((long) nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 1] &gt; target) break; 第二层循环中，如果最大的四数之和小于target，那么前面的数更小，break 123\\\\ 第二层循环if ((long) nums[i] + nums[j] + nums[j - 1] + nums[j - 2] &lt; target) break; 完整代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;(); int length = nums.length; if (length &lt; 4) return result; Arrays.sort(nums); // window: [nums[i], nums[left], nums[right], nums[j]] for (int i = 0; i &lt; length - 3; ++i) &#123; // 去重 if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue; if ((long) nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 1] &gt; target) break; // 第4个数从尾开始遍历，举例&#123;-1, -1, 0, 2&#125;来确定j &gt; 2这个边界条件 for (int j = length - 1; j &gt; 2; --j) &#123; // 去重，如果使用nums[j] == nums[j - 1]判断，nums[j - 1]属于right的范围 // 那么&#123;-1，-1，1, 1&#125;这个结果不会被选中 if (j &lt; length - 1 &amp;&amp; nums[j] == nums[j + 1]) continue; if ((long) nums[i] + nums[j] + nums[j - 1] + nums[j - 2] &lt; target) break; int left = i + 1, right = j - 1; // 只能选取数组中不同下标的三个数，所以left == right时会使用同一个数，不执行 while (left &lt; right) &#123; long sum = (long) nums[i] + nums[left] + nums[right] + nums[j]; if (sum &lt; target) ++left; else if (sum &gt; target) --right; else &#123; // sum == target result.add(Arrays.asList(nums[i], nums[left], nums[right], nums[j])); while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) ++left; while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) --right; ++left; --right; &#125; &#125; &#125; &#125; return result; &#125;&#125; 剑指 Offer II 030. 插入、删除和随机访问都是 O(1) 的容器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class RandomizedSet &#123; List&lt;Integer&gt; list; Map&lt;Integer, Integer&gt; map; /** Initialize your data structure here. */ public RandomizedSet() &#123; list = new LinkedList&lt;&gt;(); map = new HashMap&lt;&gt;(); &#125; /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */ public boolean insert(int val) &#123; if (map.containsKey(val)) return false; list.add(val); map.put(val, list.size() - 1); return true; &#125; /** Removes a value from the set. Returns true if the set contained the specified element. */ public boolean remove(int val) &#123; if (!map.containsKey(val)) return false; int index = map.get(val); int lastVal = list.get(list.size() - 1); list.set(index, lastVal); list.remove(list.size() - 1); map.put(lastVal ,index); map.remove(val); return true; &#125; /** Get a random element from the set. */ public int getRandom() &#123; Random random = new Random(); return list.get(random.nextInt(list.size())); &#125;&#125;/** * Your RandomizedSet object will be instantiated and called as such: * RandomizedSet obj = new RandomizedSet(); * boolean param_1 = obj.insert(val); * boolean param_2 = obj.remove(val); * int param_3 = obj.getRandom(); */ 剑指 Offer II 031. 最近最少使用缓存 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class LRUCache &#123; class ListNode &#123; int key; int val; ListNode pre; ListNode next; public ListNode(int key, int val) &#123; this.val = val; this.key = key; &#125; &#125; ListNode head, tail; private int capacity; Map&lt;Integer, ListNode&gt; map; public LRUCache(int capacity) &#123; this.capacity = capacity; head = new ListNode(-1, -1); tail = new ListNode(-1, -1); head.next = tail; tail.pre = head; map = new HashMap&lt;&gt;(); &#125; public int get(int key) &#123; if (!map.containsKey(key)) return -1; moveToTail(key); return map.get(key).val; &#125; public void put(int key, int value) &#123; if (map.containsKey(key)) &#123; ListNode node = map.get(key); node.val = value; map.put(key, node); moveToTail(key); &#125; else &#123; // do not exist ListNode node = new ListNode(key, value); if (this.capacity != map.size()) &#123; // not full insertAtTail(node); map.put(key, node); &#125; else &#123; // full ListNode toDelete = head.next; delete(toDelete); map.remove(toDelete.key); insertAtTail(node); map.put(key, node); &#125; &#125; &#125; public void moveToTail(int key) &#123; ListNode node = map.get(key); if (node.next == tail) return; delete(node); insertAtTail(node); &#125; public void delete(ListNode node) &#123; node.pre.next = node.next; node.next.pre = node.pre; &#125; public void insertAtTail(ListNode node) &#123; node.pre = tail.pre; node.next = tail; node.pre.next = node; tail.pre = node; &#125;&#125;/** * Your LRUCache object will be instantiated and called as such: * LRUCache obj = new LRUCache(capacity); * int param_1 = obj.get(key); * obj.put(key,value); */ Stack and Queue 232. 用栈实现队列 解题思路：使用两个栈，inStack,outStack来实现队列。 push：直接将元素push进inStack pop：如果outStack不为空，则弹出outStack顶部元素；如果outStack为空，则将inStack中的元素全部弹入inStack，再弹出outStack顶部元素 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class MyQueue &#123; private Stack&lt;Integer&gt; inStack; private Stack&lt;Integer&gt; outStack; public MyQueue() &#123; inStack = new Stack&lt;&gt;(); outStack = new Stack&lt;&gt;(); &#125; public void push(int x) &#123; inStack.push(x); &#125; public int pop() &#123; if (outStack.isEmpty()) &#123; pushIntoOut(); &#125; return outStack.pop(); &#125; public int peek() &#123; if (outStack.isEmpty()) pushIntoOut(); return outStack.peek(); &#125; public boolean empty() &#123; return inStack.isEmpty() &amp;&amp; outStack.isEmpty(); &#125; public void pushIntoOut() &#123; while (!inStack.isEmpty()) &#123; outStack.push(inStack.pop()); &#125; &#125;&#125;/** * Your MyQueue object will be instantiated and called as such: * MyQueue obj = new MyQueue(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.peek(); * boolean param_4 = obj.empty(); */ 225. 用队列实现栈 方法一：单队列 push：直接将元素加入queue pop()：首先将队列元素移除并重新加入queue.size() - 1次，这样底部的元素就在队列首部了，poll出来即可 peek()：首先将队列元素移除并重新加入queue.size() - 1次，这样底部的元素就在队列首部了，先用result接收queue.peek()，再将这个元素移除并重新加入，最后返回result，peek()操作是不能改变内部数据的！！ 12345678910111213141516171819202122232425262728293031323334class MyStack &#123; private Queue&lt;Integer&gt; queue; public MyStack() &#123; queue = new LinkedList&lt;&gt;(); &#125; public void push(int x) &#123; queue.offer(x); &#125; public int pop() &#123; catchBottom(); return queue.poll(); &#125; public int top() &#123; catchBottom(); int result = queue.peek(); queue.offer(queue.poll()); return result; &#125; public boolean empty() &#123; return queue.isEmpty(); &#125; public void catchBottom() &#123; for (int i = 0; i &lt; queue.size() - 1; ++i) &#123; queue.offer(queue.poll()); &#125; &#125;&#125; 优化 在面对大量需要查看顶部元素业务的时候，每次都要重新出队入队n次，不如在push的时候就排好序， 123456789101112public void push(int x) &#123; queue.offer(x); for (int i = 0; i &lt; queue.size() - 1; ++i) &#123; queue.offer(queue.poll()); &#125;&#125;public int pop() &#123; return queue.poll();&#125;public int top() &#123; return queue.peek();&#125; 方法二：双队列 push：先在辅助队列supportQueue中加入目标数据，再将主队列queue中的数据全部弹出并加入到supportQueue中，这个时候supportQueue就是先进后出的排列顺序，最后将queue和support交换 12345678910111213141516171819202122232425262728293031class MyStack &#123; Queue&lt;Integer&gt; queue, supportQueue; public MyStack() &#123; queue = new LinkedList&lt;&gt;(); supportQueue = new LinkedList&lt;&gt;(); &#125; public void push(int x) &#123; supportQueue.offer(x); while (!queue.isEmpty()) &#123; supportQueue.offer(queue.poll()); &#125; Queue&lt;Integer&gt; temp = queue; queue = supportQueue; supportQueue = temp; &#125; public int pop() &#123; return queue.poll(); &#125; public int top() &#123; return queue.peek(); &#125; public boolean empty() &#123; return queue.isEmpty(); &#125;&#125; 20. 有效的括号 方法一：HashMap + Stack 注意事项：如果是左括号，直接push进栈 如果是右括号，如果栈为空那么匹配不了；如果右括号和栈顶部的左括号不匹配，也不满足 最后如果栈空，则是有效的括号；否则不是 1234567891011121314151617181920class Solution &#123; public boolean isValid(String s) &#123; Map&lt;Character, Character&gt; map = new HashMap&lt;&gt;(); map.put(&#x27;&#123;&#x27;, &#x27;&#125;&#x27;); map.put(&#x27;(&#x27;, &#x27;)&#x27;); map.put(&#x27;[&#x27;, &#x27;]&#x27;); Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); for (int i = 0; i &lt; s.length(); ++i) &#123; char c = s.charAt(i); if (map.containsKey(c)) stack.push(c); else &#123; if (stack.isEmpty() || map.get(stack.pop()) != c) &#123; return false; &#125; &#125; &#125; return stack.isEmpty(); &#125;&#125; 1047. 删除字符串中的所有相邻重复项 方法一：StringBuilder 如果当前字符和前一个字符相等，则删除当前字符；否则加入当前字符 123456789101112131415161718class Solution &#123; public String removeDuplicates(String s) &#123; StringBuilder sb = new StringBuilder(); int index = -1; for (int i = 0; i &lt; s.length(); ++i) &#123; char c = s.charAt(i); if (sb.length() == 0 || c != sb.charAt(index)) &#123; sb.append(c); ++index; &#125; else &#123; sb.deleteCharAt(index); --index; &#125; &#125; return sb.toString(); &#125;&#125; 150. 逆波兰表达式求值 解题思路： 遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中 1234567891011121314151617181920212223242526272829303132class Solution &#123; public int evalRPN(String[] tokens) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for (int i = 0; i &lt; tokens.length; ++i) &#123; String token = tokens[i]; if (isNumber(token)) stack.push(Integer.parseInt(token)); else &#123; int b = stack.pop(), a = stack.pop(); switch (token) &#123; case &quot;+&quot;: stack.push(a + b); break; case &quot;-&quot;: stack.push(a - b); break; case &quot;*&quot;: stack.push(a * b); break; case &quot;/&quot;: stack.push(a / b); break; default: &#125; &#125; &#125; return stack.pop(); &#125; public boolean isNumber(String s) &#123; return !(s.equals(&quot;+&quot;) || s.equals(&quot;-&quot;) || s.equals(&quot;*&quot;) || s.equals(&quot;/&quot;)); &#125;&#125; 注意事项： 在Java中，==和.equals()都是用于比较两个对象是否相等的操作符。但是它们之间存在着不同的用法和含义。 ==用于比较两个对象的引用是否相等，也就是判断这两个对象是否是同一个对象。当比较两个基本数据类型的值时，它们的值相等时返回true；当比较两个引用类型的对象时，如果它们所指向的内存地址相同，也就是它们是同一个对象时，返回true；否则返回false。 .equals()方法用于比较两个对象的内容是否相等。默认情况下，.equals()方法比较的是两个对象的引用是否相等，也就是使用==比较，但是我们可以通过重写.equals()方法来自定义比较规则，比如根据对象的属性值来比较是否相等。 对于字符串类型的变量来说，==和.equals()方法的区别如下： ==比较的是字符串对象的引用是否相等，也就是它们是否指向同一个内存地址。 .equals()方法比较的是字符串对象的内容是否相等，也就是它们包含的字符序列是否相同。 因为Java中字符串是一个特殊的对象类型，为了方便字符串的比较操作，Java中提供了一种特殊的机制，也就是\"字符串常量池\"，它可以缓存字符串对象，使得多个字符串对象可以共享同一个对象，也就是它们的引用相等。在这种情况下，==操作符会返回true。但是在其他情况下，如果不是使用相同的字符串字面量来创建字符串对象，==操作符会返回false，此时需要使用.equals()方法来进行字符串的内容比较。 239. 滑动窗口最大值 方法一：暴力（超时） 时间复杂度：\\(O(kn)\\) 空间复杂度：\\(O(n)\\)，存储结果的数组 1234567891011121314151617class Solution &#123; public int[] maxSlidingWindow(int[] nums, int k) &#123; int n = nums.length; int[] result = new int[n - k + 1]; if (k &gt; n) return result; // [i, i + k) for (int i = 0; i &lt; result.length; ++i) &#123; int max = Integer.MIN_VALUE; for (int j = i; j &lt; i + k; ++j) &#123; max = Math.max(max, nums[j]); &#125; result[i] = max; &#125; return result; &#125;&#125; 方法二：单调队列 1234567891011121314151617181920212223242526class Solution &#123; public int[] maxSlidingWindow(int[] nums, int k) &#123; int n = nums.length - k + 1; Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; k; ++i) &#123; while (!deque.isEmpty() &amp;&amp; nums[i] &gt; nums[deque.peekLast()]) &#123; deque.pollLast(); &#125; deque.offerLast(i); &#125; int[] result = new int[n]; result[0] = nums[deque.peekFirst()]; for (int i = k; i &lt; nums.length; ++i) &#123; while (!deque.isEmpty() &amp;&amp; nums[i] &gt; nums[deque.peekLast()]) &#123; deque.pollLast(); &#125; deque.offerLast(i); // 如果i的左区间在队首元素右边，则要移除队首元素; 用if就可以了(while也行) if (deque.peekFirst() &lt;= i - k) &#123; deque.pollFirst(); &#125; result[i - k + 1] = nums[deque.peekFirst()]; &#125; return result; &#125;&#125; 347. 前 K 个高频元素 123456789101112131415161718192021222324252627282930class Solution &#123; public int[] topKFrequent(int[] nums, int k) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; ++i) &#123; map.put(nums[i], map.getOrDefault(nums[i], 0) + 1); &#125; PriorityQueue&lt;int[]&gt; queue = new PriorityQueue&lt;&gt;(new Comparator&lt;int[]&gt;() &#123; public int compare(int[] m, int[] n) &#123; return m[1] - n[1]; &#125; &#125;); for (Map.Entry&lt;Integer, Integer&gt; entry: map.entrySet()) &#123; int num = entry.getKey(), count = entry.getValue(); if (queue.size() == k) &#123; if (count &gt; queue.peek()[1]) &#123; queue.poll(); queue.offer(new int[]&#123;num, count&#125;); &#125; &#125; else &#123; queue.offer(new int[]&#123;num, count&#125;); &#125; &#125; int[] result = new int[k]; for (int i = 0; i &lt; k; ++i) &#123; result[i] = queue.poll()[0]; &#125; return result; &#125;&#125; 优先级队列（大根堆、小根堆） Java中可以使用PriorityQueue类来创建优先级队列，它实现了一个基于优先级堆的无界优先级队列。 要创建一个大根堆，需要使用Comparator.reverseOrder()方法来创建一个反转自然顺序的比较器，示例如下： 12345PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;(Comparator.reverseOrder());maxHeap.add(5);maxHeap.add(1);maxHeap.add(10);System.out.println(maxHeap.poll()); // 输出10 要创建一个小根堆，只需要使用默认的比较器即可，示例如下： 12345PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;();minHeap.add(5);minHeap.add(1);minHeap.add(10);System.out.println(minHeap.poll()); // 输出1 在上述示例中，我们首先创建了一个空的优先级队列，然后使用add()方法向其中添加元素，使用poll()方法从队列中取出元素并删除。由于大根堆和小根堆的比较器不同，它们会按照不同的顺序取出元素。 除了示例中用到的add()和poll()方法之外，PriorityQueue类还提供了一些其他常用的方法，下面对一些常用方法进行补充说明： offer(E e): 添加元素到队列中，如果队列已满则抛出异常。 12arduinoCopy codePriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;();queue.offer(1); peek(): 获取但不删除队列的头部元素，如果队列为空则返回null。 1234arduinoCopy codePriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;();queue.offer(1);queue.offer(2);System.out.println(queue.peek()); // 输出1 remove(Object o): 从队列中删除指定的元素，如果队列中不存在该元素则返回false。 1234567arduinoCopy codePriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;();queue.offer(1);queue.offer(2);queue.offer(3);System.out.println(queue.remove(2)); // 输出trueSystem.out.println(queue.remove(4)); // 输出falseSystem.out.println(queue); // 输出[3, 1] size(): 返回队列中元素的数量。 12345arduinoCopy codePriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;();queue.offer(1);queue.offer(2);queue.offer(3);System.out.println(queue.size()); // 输出3 clear(): 删除队列中的所有元素。 123456arduinoCopy codePriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;();queue.offer(1);queue.offer(2);queue.offer(3);queue.clear();System.out.println(queue); // 输出[] 还有一些其他的方法，如toArray()、contains()、addAll()等，可以参考Java官方文档进行学习。 Greedy 455. 分发饼干 方法一：从小胃口开始喂小饼干 先把两个数组都升序排序，从左往右遍历 如果孩子满足度小于等于饼干满足度，那么++res，并让两个指针都往后移动一位 如果孩子满足度大于饼干满足度，使饼干的指针向后移动一位 直到任意一个指针超出数组范围为止 12345678910111213141516171819class Solution &#123; public int findContentChildren(int[] children, int[] cookies) &#123; int res = 0; Arrays.sort(children); Arrays.sort(cookies); int i = 0, j = 0; while (i &lt; children.length &amp;&amp; j &lt; cookies.length) &#123; if (children[i] &lt;= cookies[j]) &#123; ++res; ++i; ++j; &#125; else &#123; ++j; &#125; &#125; return res; &#125;&#125; 方法二：从大胃口开始喂大饼干 12345678910111213141516171819class Solution &#123; public int findContentChildren(int[] children, int[] cookies) &#123; int res = 0; Arrays.sort(children); Arrays.sort(cookies); int i = children.length - 1, j = cookies.length - 1; while (i &gt;= 0 &amp;&amp; j &gt;= 0) &#123; if (children[i] &lt;= cookies[j]) &#123; ++res; --i; --j; &#125; else &#123; --i; &#125; &#125; return res; &#125;&#125; 376. 摆动序列 方法一：排序+删除连续重复元素+dp(不推荐) 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; public int wiggleMaxLength(int[] nums) &#123; int n = nums.length; if (n == 1) return 1; // 1.dp[i]:以nums[i]为结尾，最长的摆动序列 List&lt;Integer&gt; list = new LinkedList&lt;&gt;(); list.add(nums[0]); for (int i = 1; i &lt; n; ++i) &#123; if (nums[i] != nums[i - 1]) list.add(nums[i]); &#125; Integer[] dummy = list.toArray(new Integer[0]); if (dummy.length == 1) return 1; if (dummy.length == 2) return 2; int[] dp = new int[dummy.length]; dp[0] = 1; dp[1] = 2; // 2.状态转移方程： // 1)nums[i] - nums[i - 1]与nums[i - 1] - nums[i- 2]异号：dp[i] = dp[i - 1] + 1 // 2)nums[i] - nums[i - 1]与nums[i - 1] - nums[i- 2]同号：dp[i] = dp[i - 1] int res = 1; for (int i = 2; i &lt; dummy.length; ++i) &#123; if ((dummy[i] - dummy[i - 1]) * (dummy[i - 1] - dummy[i - 2]) &lt; 0) &#123; dp[i] = dp[i - 1] + 1; &#125; else if ((dummy[i] - dummy[i - 1]) * (dummy[i - 1] - dummy[i - 2]) &gt; 0) &#123; dp[i] = dp[i - 1]; &#125; res = Math.max(res, dp[i]); &#125; return res; &#125;&#125; 方法二：贪心 1234567891011121314class Solution &#123; public int wiggleMaxLength(int[] nums) &#123; int preDiff = 0, postDiff = 0; int result = 1; for (int i = 0; i &lt; nums.length - 1; ++i) &#123; postDiff = nums[i + 1] - nums[i]; if ((preDiff &lt;= 0 &amp;&amp; postDiff &gt; 0) || (preDiff &gt;= 0 &amp;&amp; postDiff &lt; 0)) &#123; ++result; preDiff = postDiff; &#125; &#125; return result; &#125;&#125; 方法三：DP 12345678910111213141516171819202122232425class Solution &#123; public int wiggleMaxLength(int[] nums) &#123; int n = nums.length; if (n &lt; 2) return n; int[] up = new int[n], down = new int[n]; up[0] = 1; down[0] = 1; for (int i = 1; i &lt; n; ++i) &#123; if (nums[i] &gt; nums[i - 1]) &#123; up[i] = Math.max(up[i - 1], down[i - 1] + 1); down[i] = down[i - 1]; &#125; else if (nums[i] &lt; nums[i - 1]) &#123; up[i] = up[i - 1]; down[i] = Math.max(down[i - 1], up[i - 1] + 1); &#125; else &#123; up[i] = up[i - 1]; down[i] = down[i - 1]; &#125; &#125; return Math.max(up[n - 1], down[n - 1]); &#125;&#125; 53. 最大子数组和 方法一：DP dp[i]：以nums[i]结尾的子数组的最大数组和 状态转移方程： 当dp[i - 1] &gt;= 0 时候，dp[i] = dp[i - 1] + nums[i] 当dp[i - 1] &lt; 0时候， dp[i] = nums[i] 初始化：dp[0] = nums[0] 时间复杂度：\\(O(n)\\) 空间复杂度：\\(O(n)\\) 12345678910111213141516171819202122class Solution &#123; public int maxSubArray(int[] nums) &#123; int n = nums.length; if (n == 1) return nums[0]; // dp[i]：以nums[i]结尾的子数组的最数组和 int[] dp = new int[n]; dp[0] = nums[0]; int res = dp[0]; for (int i = 1; i &lt; n; ++i) &#123; if (dp[i - 1] &gt;= 0) &#123; dp[i] = dp[i - 1] + nums[i]; &#125; else &#123; // dp[i - 1] &lt; 0 dp[i] = nums[i]; &#125; res = Math.max(res, dp[i]); &#125; return res; &#125;&#125; 方法二：优化空间的DP 由于dp[i]只依赖dp[i - 1]，所以可以用一个长度为2的数组记录dp 123456789101112131415161718192021class Solution &#123; public int maxSubArray(int[] nums) &#123; int n = nums.length; if (n == 1) return nums[0]; // dp[i]：以nums[i]结尾的子数组的最数组和 int[] dp = new int[2]; dp[0] = nums[0]; int res = nums[0]; for (int i = 1; i &lt; n; ++i) &#123; if (dp[(i - 1) % 2] &gt;= 0) &#123; dp[i % 2] = dp[(i - 1) % 2] + nums[i]; &#125; else &#123; // dp[i - 1] &lt; 0 dp[i % 2] = nums[i]; &#125; res = Math.max(res, dp[i % 2]); &#125; return res; &#125;&#125; 贪心 首先把记录结果的result初始化为最小值，以及count=0 遍历数组，count加上当前元素，如果count大于result，讲count值赋给result 如果count等于负数了，令count等于0，从下一个数开始重新计算 1234567891011121314class Solution &#123; public int maxSubArray(int[] nums) &#123; int result = Integer.MIN_VALUE; int count = 0; for (int i = 0; i &lt; nums.length; ++i) &#123; count += nums[i]; if (count &gt; result) result = count; if (count &lt; 0) count = 0; &#125; return result; &#125;&#125; 122. 买卖股票的最佳时机 II 只要下一天股票价格高于当天，那么就买入当前股票并在下一天卖出 123456789101112class Solution &#123; public int maxProfit(int[] prices) &#123; int res = 0; for (int i = 0; i &lt; prices.length - 1; ++i) &#123; int diff = prices[i + 1] - prices[i]; if (diff &gt; 0) &#123; res += diff; &#125; &#125; return res; &#125;&#125; 55. 跳跃游戏 方法一：贪心 初始化一个available数组，available[i]表示是否可以到底数组元素i 如果当前节点是可到达的，令i=0前往后遍历，把available数组从i+1开始，后nums[i]个元素都赋true 初始化：第一个元素是肯定能到达的，初始化为true 时间复杂度：\\(O(n^2)\\)，最坏情况下，所有节点都刚好能到达数组倒数第二个元素，且倒数第二个元素的值为0，如[n - 2, n - 3, ..., 1, 0, 1]，需要遍历\\(\\frac{(n-1)(n-2)}{2}\\)次 空间复杂度：\\(O(n)\\) 1234567891011121314151617class Solution &#123; public boolean canJump(int[] nums) &#123; int n = nums.length; boolean[] available = new boolean[n]; available[0] = true; for (int i = 0; i &lt; n - 1; ++i) &#123; if (available[i]) &#123; for (int j = i + 1; j &lt; nums[i] + i + 1; ++j) &#123; if (j == n - 1) return true; available[j] = true; &#125; &#125; &#125; return available[n - 1]; &#125;&#125; 方法二：贪心（优化空间复杂度） 不必要用一个boolean数组来表示是否可以到达当前数组元素，可以用一个整数rightmost来判断 1234567891011121314class Solution &#123; public boolean canJump(int[] nums) &#123; int n = nums.length; int rightmost = 0; for (int i = 0; i &lt; n; ++i) &#123; if (i &lt;= rightmost) &#123; rightmost = Math.max(rightmost, i + nums[i]); if (rightmost &gt;= n - 1) return true; &#125; &#125; return false; &#125;&#125; 45. 跳跃游戏 II 方法一：dp 1234567891011121314151617class Solution &#123; public int jump(int[] nums) &#123; int n = nums.length; // 1.dp[i]：到达i的最小跳数 int[] dp = new int[n]; Arrays.fill(dp, Integer.MAX_VALUE); dp[0] = 0; for (int i = 0; i &lt; n - 1; ++i) &#123; for (int j = i + 1; j &lt; i + 1 + nums[i]; ++j) &#123; dp[j] = Math.min(dp[j], dp[i] + 1); if (j == n - 1) break; &#125; &#125; return dp[n - 1]; &#125;&#125; 方法二：贪心 123456789101112131415class Solution &#123; public int jump(int[] nums) &#123; int result = 0; int n = nums.length; int maxDistance = 0, end = 0; for (int i = 0; i &lt; n - 1; ++i) &#123; maxDistance = Math.max(maxDistance, i + nums[i]); if (i == end) &#123; end = maxDistance; ++result; &#125; &#125; return result; &#125;&#125; 1005. K 次取反后最大化的数组和 先创建一个小根堆，把数组所有元素都放进去 取反小根堆堆顶元素再放回小根堆，循环k次 时间复杂度：\\(O(n)\\) 空间复杂度：\\(O(n)\\) 如果小根堆堆顶是负数\\(x\\)，那么一定是最小的负数，取反后会是比较大的正数\\(-x\\)； 如果小根堆堆顶是正数\\(x\\)，那么是最小的正数，取反后是负数\\(-x\\)，由于此时只有这一个负数，所以\\(-x\\)是最小值，再放入堆顶，再取反又是最小的正数，循环到k为0为止。 12345678910111213141516171819class Solution &#123; public int largestSumAfterKNegations(int[] nums, int k) &#123; // 先创建一个小根堆，把数组所有元素都放进去 // 取反小根堆堆顶元素再放回小根堆，循环k次 PriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;(); for (int n : nums) queue.offer(n); while (!queue.isEmpty() &amp;&amp; k &gt; 0) &#123; int cur = queue.poll(); queue.offer(-1 * cur); --k; &#125; int sum = 0; while (!queue.isEmpty()) &#123; sum += queue.poll(); &#125; return sum; &#125;&#125; 方法二：优化方法一 先创建一个小根堆，把数组所有元素都放进去 首先小根堆弹出的元素\\(x\\)如果是负数，就取反(最小的负数取反是比较大的正数),再放回小根堆 小根堆弹出的元素\\(x\\)如果是是正数：此时\\(k\\)值如果能被2整除，那么重复取反堆顶元素\\(x\\)，最终\\(x\\)不变，直接将\\(x\\)加入堆中；如果\\(k\\)值如果不能被2整除，那么将-x加入堆中 123456789101112131415161718192021222324252627class Solution &#123; public int largestSumAfterKNegations(int[] nums, int k) &#123; // 先创建一个小根堆，把数组所有元素都放进去 // 要取反k次，首先小根堆弹出的元素x如果是负数，就取反(最小的负数取反是比较大的正数),再放回小根堆 // 小根堆弹出的元素x如果是是正数：此时k值如果能被2整除，那么重复取反堆顶元素x，最终x不变，直接将x加入堆中；如果k值如果不能被2整除，那么将-x加入堆中 PriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;(); for (int n : nums) queue.offer(n); while (!queue.isEmpty() &amp;&amp; k &gt; 0) &#123; int cur = queue.poll(); if (cur &lt; 0) &#123; queue.offer(-1 * cur); --k; &#125; else &#123; // cur &gt;= 0 int negPart = k % 2 == 0 ? 1 : -1; queue.offer(cur * negPart); break; &#125; &#125; int sum = 0; while (!queue.isEmpty()) &#123; sum += queue.poll(); &#125; return sum; &#125;&#125; 方法三：贪心(二刷) 首先将数组升序排序 进入for循环，注意循环的条件有两个，i &lt; nums.length || k &gt; 0 当k==0时，说明已经翻转了k次，不需要继续执行程序了，break即可 if (i == nums.length)留到最后讲解 如果，nums[i] &lt;= 0，直接翻转即可；如果nums[i] &gt; 0，那么说明此时数组里已经没有负数了，那么需要找到最小的正数，并且将剩余需要翻转的次数都对这个数使用：最小的正数只可能是当前的数或者前一个位置的数，比如数组[-5, -4, -3, 2, 3, 5]，需要翻转四次，翻转四次后数组为[5, 4, 3, 2, 3, 5]，即负数部分翻转后是降序。如果k能被2整除，那么翻转k次后这个数还是保持不变；如果不能被2整除，翻转一次即可。最后break退出for循环 如果i == nums.length，但是k的次数还没用完，这种情况只可能是数组元素全为负的情况，如果有一个正数，k都会在 if (nums[i] &gt;= 0 &amp;&amp; i &gt; 0) 语句下被消化。这种情况下，一定是最后一个数最小，如果k不能被2整除，就nums[i - 1]翻转即可。比如数组为[-4, -3, -2]，需要翻转4次，翻转3次后数组为 [4, 3, 2]，此时i == nums.length，翻转2即可 123456789101112131415161718192021class Solution &#123; public int largestSumAfterKNegations(int[] nums, int k) &#123; Arrays.sort(nums); for (int i = 0; i &lt; nums.length || k &gt; 0; ++i) &#123; if (k == 0) break; if (i == nums.length) i--; if (nums[i] &gt;= 0 &amp;&amp; i &gt; 0) &#123; i = nums[i] &gt; nums[i - 1] ? i - 1 : i; if (k % 2 == 1) &#123; nums[i] *= -1; &#125; break; &#125; nums[i] *= -1; --k; &#125; return Arrays.stream(nums).sum(); &#125;&#125; 134. 加油站:warning: 方法一：贪心 首先如果总油量减去总消耗大于等于零那么一定可以跑完一圈 12345678910111213141516class Solution &#123; public int canCompleteCircuit(int[] gas, int[] cost) &#123; int curSum = 0; int totalSum = 0; int index = 0; for (int i = 0; i &lt; gas.length; i++) &#123; curSum += gas[i] - cost[i]; totalSum += gas[i] - cost[i]; if (curSum &lt; 0) &#123; index = (i + 1) % gas.length ; curSum = 0; &#125; &#125; return (totalSum &lt; 0) ? -1 : index; &#125;&#125; 方法二：最小累计值的下一站 123456789101112131415class Solution &#123; public int canCompleteCircuit(int[] gas, int[] cost) &#123; int rest = 0; int minDiff = Integer.MAX_VALUE; int minIndex = 0; for (int i = 0; i &lt; gas.length; ++i) &#123; rest += gas[i] - cost[i]; if (rest &lt; minDiff) &#123; minDiff = rest; minIndex = i; &#125; &#125; return rest &lt; 0 ? -1 : (minIndex + 1) % gas.length; &#125;&#125; 135. 分发糖果 先从左往右，再从右往左 12345678910111213141516class Solution &#123; public int candy(int[] ratings) &#123; int[] candy = new int[ratings.length]; Arrays.fill(candy, 1); for (int i = 1; i &lt; candy.length; ++i) &#123; if (ratings[i] &gt; ratings[i - 1]) candy[i] += candy[i - 1]; &#125; for (int i = candy.length - 1; i &gt; 0; --i) &#123; if (ratings[i - 1] &gt; ratings[i]) &#123; candy[i - 1] = Math.max(candy[i - 1], candy[i] + 1); &#125; &#125; return Arrays.stream(candy).sum(); &#125;&#125; 860. 柠檬水找零 12345678910111213141516171819202122232425262728293031323334class Solution &#123; public boolean lemonadeChange(int[] bills) &#123; if (bills[0] != 5) return false; int five = 0, ten = 0; for (int i = 0; i &lt; bills.length; ++i) &#123; if (bills[i] == 5) &#123; ++five; &#125; else if (bills[i] == 10) &#123; if (five &gt; 0) &#123; --five; ++ten; &#125; else &#123; return false; &#125; &#125; else &#123; if (five &gt; 0 &amp;&amp; ten &gt; 0) &#123; --five; --ten; &#125; else if (five &gt;= 3) &#123; five -= 3; &#125; else &#123; return false; &#125; &#125; &#125; return true; &#125;&#125; 406. 根据身高重建队列 :warning: 1234567891011121314151617181920class Solution &#123; public int[][] reconstructQueue(int[][] people) &#123; // 先按照身高进行降序排序，再按照k进行升序排序 Arrays.sort(people, new Comparator&lt;int[]&gt;() &#123; public int compare(int[] person1, int[] person2) &#123; if (person1[0] != person2[0]) &#123; return person2[0] - person1[0]; &#125; else &#123; return person1[1] - person2[1]; &#125; &#125; &#125;); List&lt;int[]&gt; list = new LinkedList&lt;&gt;(); for (int[] person : people) &#123; list.add(person[1], person); &#125; return list.toArray(new int[list.size()][]); &#125;&#125; 452. 用最少数量的箭引爆气球 注意事项： compare方法用return p1[0] - p2[0]会越界！ 从左往右遍历，如果左边气球的右边界大于等于右边气球的左边界，那么可以一箭双球，此时有可能有第三个气球和前面两个气球有重合，但是把第一个气球的右边界设置为重合气球右边界的最小值 1234567891011121314151617181920class Solution &#123; public int findMinArrowShots(int[][] points) &#123; Arrays.sort(points, new Comparator&lt;int[]&gt;() &#123; public int compare(int[] point1, int[] point2) &#123; return Integer.compare(point1[0], point2[0]); &#125; &#125;); int arrow = 1; for (int i = 0, j = 1; j &lt; points.length; ++j) &#123; if (points[i][1] &gt;= points[j][0]) &#123; points[i][1] = Math.min(points[i][1], points[j][1]); &#125; else &#123; ++arrow; i = j; &#125; &#125; return arrow; &#125;&#125; 435. 无重叠区间 方法一： 比较器按以下方法来，不然容易出错！！ 12345678910Arrays.sort(intervals, new Comparator&lt;int[]&gt;() &#123; public int compare(int[] p1, int[] p2) &#123; if (p1[0] == p2[0]) &#123; return Integer.compare(p1[1], p2[1]); &#125; else &#123; return Integer.compare(p1[0], p2[0]); &#125; &#125;&#125;); 先定义比较器，如果p1, p2第一个元素不相等，则按照第一个元素升序排序；如果第一个元素相等，则按照第二个元素升序排序 双指针从前往后遍历，初始i=0，j=1 当intervals[i]与intervals[j]的第一个元素相等，那么必定要移除其中一个，由于比较器的排序，intervals[j]的区间更大，那么选择移除intervals[j]，答案只需要返回最少移除了多少个数，所以将表示删除元素个数的变量erase加一，让j后移即可 当intervals[i]与intervals[j]的第一个元素不相等时候，分两种情况讨论 如果intervals[i]的第二个元素 &gt; intervals[j]的第一个元素，此时区间重合，删除第二个元素即可，将表示删除元素个数的变量erase加一；如果此时intervals[i]的第二个元素 &gt; intervals[j]的第二个元素，说明intervals[i]包含 intervals[j]，那么此时必定删除 intervals[i]，将i指向j表示删除 intervals[i]这个元素 如果intervals[i]的第二个元素 &lt;= intervals[j]的第一个元素，那么i与j之间的元素都不重复，将i移动到j的位置 1234567891011121314151617181920212223242526272829303132class Solution &#123; public int eraseOverlapIntervals(int[][] intervals) &#123; Arrays.sort(intervals, new Comparator&lt;int[]&gt;() &#123; public int compare(int[] p1, int[] p2) &#123; if (p1[0] == p2[0]) &#123; return Integer.compare(p1[1], p2[1]); &#125; else &#123; return Integer.compare(p1[0], p2[0]); &#125; &#125; &#125;); int erase = 0, n = intervals.length; for (int i = 0, j = 1; j &lt; n; ++j) &#123; if (intervals[i][0] == intervals[j][0]) &#123; ++erase; &#125; else &#123; if (intervals[i][1] &gt; intervals[j][0]) &#123; ++erase; if (intervals[i][1] &gt;= intervals[j][1]) &#123; i = j; &#125; &#125; else &#123; // intervals[i][1] &lt;= intervals[j][0] i = j; &#125; &#125; &#125; return erase; &#125;&#125; 方法二：右边界取最小的 123456789101112131415161718192021class Solution &#123; public int eraseOverlapIntervals(int[][] intervals) &#123; Arrays.sort(intervals, (a,b)-&gt; &#123; return Integer.compare(a[0],b[0]); &#125;); int count = 0; for(int i = 1;i &lt; intervals.length;i++)&#123; if(intervals[i][0] &lt; intervals[i-1][1])&#123; ++count; intervals[i][1] = Math.min(intervals[i - 1][1], intervals[i][1]); &#125; &#125; for (int[] is : intervals) &#123; for (int i : is) &#123; System.out.print(i + &quot;,&quot;); &#125; System.out.println(); &#125; return count; &#125;&#125; 二刷：左边界升序排序 1234567891011121314151617181920212223class Solution &#123; public int eraseOverlapIntervals(int[][] intervals) &#123; Arrays.sort(intervals, new Comparator&lt;int[]&gt;() &#123; public int compare(int[] a, int[] b) &#123; if (a[0] == b[0]) return Integer.compare(a[1], b[1]); else return Integer.compare(a[0], b[0]); &#125; &#125;); int res = 0; for (int i = 0, j = 1; j &lt; intervals.length; ++j) &#123; if (intervals[i][1] &gt; intervals[j][0]) &#123; intervals[i][1] = Math.min(intervals[i][1], intervals[j][1]); ++res; &#125; else &#123; i = j; &#125; &#125; return res; &#125;&#125; 763. 划分字母区间 :warning: 方法一：贪心 首先创建一个长度为26的整型数组，统计每次字符出现的最远位置 遍历字符串，不断更新右边界的值 当当前下标i与右边界相等时，那么就将right-i+1记录 123456789101112131415161718class Solution &#123; public List&lt;Integer&gt; partitionLabels(String s) &#123; int[] ch = new int[26]; for (int i = 0; i &lt; s.length(); ++i) &#123; ch[s.charAt(i) - &#x27;a&#x27;] = i; &#125; List&lt;Integer&gt; res = new LinkedList&lt;&gt;(); int left = 0, right = -1; for (int i = 0; i &lt; s.length(); ++i) &#123; right = Math.max(right, ch[s.charAt(i) - &#x27;a&#x27;]); if (i == right) &#123; res.add(right - left + 1); left = i + 1; &#125; &#125; return res; &#125; &#125; 56. 合并区间 方法一： 遍历数组，如果后一个元素的左边界大于等于前一个元素的右边界，那么修改后一个元素的左边界为两元素左边界最小的值，修改后一个元素的右边界为两元素右边界最大的值 如果后一个元素左边界大于前一个元素的右边界，直接把前一个元素加入结果list中 最后再把最后一个元素(修改过)加入结果list中 12345678910111213141516171819202122class Solution &#123; public int[][] merge(int[][] intervals) &#123; int n = intervals.length; Arrays.sort(intervals, new Comparator&lt;int[]&gt;() &#123; public int compare(int[] p1, int[] p2) &#123; return Integer.compare(p1[0], p2[0]); &#125; &#125;); List&lt;int[]&gt; res = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; n - 1; ++i) &#123; if (intervals[i + 1][0] &lt;= intervals[i][1]) &#123; intervals[i + 1][0] = Math.min(intervals[i + 1][0], intervals[i][0]); intervals[i + 1][1] = Math.max(intervals[i + 1][1], intervals[i][1]); &#125; else &#123; res.add(new int[]&#123;intervals[i][0], intervals[i][1]&#125;); &#125; &#125; res.add(new int[]&#123;intervals[n - 1][0], intervals[n - 1][1]&#125;); return res.toArray(new int[res.size()][]); &#125;&#125; 方法二：射气球的思路 首先将数组按照左边界升序排序 当intervals[i][1] &gt;= intervals[j][0]，那么这两个元素一定是要合并的，因为是intervals数组是按照左边界升序排序的，那么合并区间[a, b]的a一定是intervals[i][0]，将intervals[i][1]赋值为intervals[i][1]与intervals[j][1]的最大值 当intervals[i][1] &lt; intervals[j][0]，那么这个两个区间是不重合的，先把上一个重合区间加入结果集，再把j赋值给i，进行下一轮循环 当j == intervals.length - 1时候， 如果intervals[i][1] &gt;= intervals[j][0]，那么会将intervals[i][1]取intervals[i][1]与intervals[j][1]的最大值 如果intervals[i][1] &lt; intervals[j][0]，那么会将之前的重合区间存入结果集，并将j赋值给i 所以出循环，只需要把intervals[i]加入结果集就好！ 12345678910111213141516171819202122232425class Solution &#123; public int[][] merge(int[][] intervals) &#123; Arrays.sort(intervals, new Comparator&lt;int[]&gt;() &#123; public int compare(int[] a, int[] b) &#123; if (a[0] == b[0]) return Integer.compare(a[1], b[1]); else return Integer.compare(a[0], b[0]); &#125; &#125;); List&lt;int[]&gt; res = new LinkedList&lt;&gt;(); int i = 0; for (int j = 1; j &lt; intervals.length; ++j) &#123; if (intervals[i][1] &gt;= intervals[j][0]) &#123; intervals[i][1] = Math.max(intervals[i][1], intervals[j][1]); &#125; else &#123; // (intervals[i][1] &lt; intervals[j][0]) res.add(new int[]&#123;intervals[i][0], intervals[i][1]&#125;); i = j; &#125; &#125; res.add(new int[]&#123;intervals[i][0], intervals[i][1]&#125;); return res.toArray(new int[res.size()][]); &#125;&#125; 738. 单调递增的数字 从后往前遍历，如果有后一个数大于前一个数，那么就用flag记录后一个数的位置，循环结束后，从flag开始，把后面的数全部赋值‘9’ 注意边界！！！ 1234567891011121314151617class Solution &#123; public int monotoneIncreasingDigits(int n) &#123; String str = String.valueOf(n); char[] ch = str.toCharArray(); int flag = ch.length; for (int i = ch.length - 1; i &gt; 0; --i) &#123; if (ch[i - 1] &gt; ch[i]) &#123; --ch[i - 1]; flag = i; &#125; &#125; for (int i = flag; i &lt; ch.length; ++i) &#123; ch[i] = &#x27;9&#x27;; &#125; return Integer.parseInt(String.valueOf(ch)); &#125; &#125; 968. 监控二叉树:star: 方法一：贪心 1234567891011121314151617181920212223242526272829303132class Solution &#123; int result = 0; public int minCameraCover(TreeNode root) &#123; // dfs后检查根节点是否被覆盖 if (dfs(root) == 404) ++result; return result; &#125; private int dfs(TreeNode root) &#123; // state 404:未覆盖 // state 200:覆盖 // state 201:有监控 //叶节点的左右空孩子需要返回被覆盖，这样才不会在叶子节点上装监控 if (root == null) return 200; // post traversal int leftState = dfs(root.left); int rightState = dfs(root.right); // 1.如果左右子树都被覆盖 if (leftState == 200 &amp;&amp; rightState == 200) return 404; // 2.如果左右子树至少有一个没被覆盖 if (leftState == 404 || rightState == 404) &#123; ++result; return 201; &#125; // 3.如果左右子树至少有一个监控 if (leftState == 201 || rightState == 201) return 200; return 666; &#125;&#125; BackTracing 开始回溯前要知道的 详细讲解 image.png 注意 如果递归终止条件是这个，那么结果回事全空 1234if (depth == len) &#123; res.add(path); return;&#125; 执行 main 方法以后输出如下： 1[[], [], [], [], [], []] 变量 path 所指向的列表 在深度优先遍历的过程中只有一份 ，深度优先遍历完成以后，回到了根结点，成为空列表。 在 Java 中，参数传递是 值传递，对象类型变量在传参的过程中，复制的是变量的地址。这些地址被添加到 res 变量，但实际上指向的是同一块内存地址，因此我们会看到 6 个空的列表对象。解决的方法很简单，在 res.add(path); 这里做一次拷贝即可。 修改的部分： 1234if (depth == len) &#123; res.add(new ArrayList&lt;&gt;(path)); return;&#125; 算法模板 123456789101112void backtracking(参数) &#123; if (终止条件) &#123; 存放结果; return; &#125; for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123; 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果 &#125;&#125; 77. 组合 方法一：回溯 由于已知结果要存放的数组大小为k，所以res使用ArrayList List没有removeLast方法，但是LinkedList中有！ 1234567891011121314151617181920class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; backtracing(n, k, 1); return res; &#125; private void backtracing (int n, int k, int start) &#123; if (path.size() == k) &#123; res.add(new LinkedList&lt;&gt;(path)); return; &#125; for (int i = start; i &lt;= n; ++i) &#123; path.add(i); backtracing(n, k, i + 1); // path.removeLast(); path.removeLast(); &#125; &#125;&#125; 方法二：方法一+剪枝 for循环横向遍历时候，i的执行条件为i &lt;= n - (k - path.size()) + 1 例如，当i = 2，path里已经有1，需要组合k=3个元素，n为4，那么 4 - (3 - 1) + 1 = 3，说明i最多等于3，组成path[1, 3, 4]，如果此时i = 4，那么就不能组成3个元素，只能组成[1,4] 1234567891011121314151617181920class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; backtracing(n, k, 1); return res; &#125; private void backtracing (int n, int k, int start) &#123; if (path.size() == k) &#123; res.add(new LinkedList&lt;&gt;(path)); return; &#125; for (int i = start; i &lt;= n - (k - path.size()) + 1; ++i) &#123; path.add(i); backtracing(n, k, i + 1); // path.removeLast(); path.removeLast(); &#125; &#125;&#125; 方法二：选或不选 防止底层扩容 1Deque&lt;Integer&gt; path = new ArrayDeque&lt;&gt;(k); 若n=3，k=2,即从[1,2,3]中选两个数，如果当前什么都没选(k=2)，n - k + 1= 2，说明至少要从2开始，才能满足选两个数这个要求 123int bound = n - k + 1;if (start &gt; bound) return; 代码如下 123456789101112131415161718192021222324class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; // 防止底层扩容 Deque&lt;Integer&gt; path = new ArrayDeque&lt;&gt;(k); backtracking(path, n, k, 1); return res; &#125; private void backtracking(Deque&lt;Integer&gt; path, int n, int k, int start) &#123; if (k == 0) &#123; res.add(new LinkedList&lt;&gt;(path)); return; &#125; // 若n=3，k=2,即从[1,2,3]中选两个数，如果当前什么都没选(k=2)，n - k + 1= 2， // 说明至少要从2开始，才能满足选两个数这个要求 int bound = n - k + 1; if (start &gt; bound) return; backtracking(path, n, k, start + 1); path.addLast(start); backtracking(path, n, k - 1, start + 1); path.removeLast(); &#125;&#125; 216. 组合总和 III 方法一：回溯+剪枝 i那里的剪枝可以这么理解，假设从i开始取，则从i到n一共有n-i+1个元素，而当前还需要k-path.size()个元素，所以必须满足n-i+1&gt;=k-path.size()，移项就可以得到i&lt;=n+1-(k-path.size()) 12345678910111213141516171819class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) &#123; backtracking(k, n, 1, new ArrayDeque&lt;&gt;(k)); return res; &#125; private void backtracking(int k, int n, int start, Deque&lt;Integer&gt; path) &#123; if (path.size() == k) &#123; if (n == 0) res.add(new LinkedList&lt;&gt;(path)); return; &#125; for (int i = start; i &lt;= 9 - (k - path.size()) + 1; ++i) &#123; path.add(i); backtracking(k, n - i, i + 1, path); path.removeLast(); &#125; &#125;&#125; 方法二：选或不选 注意：int bound = 9 - k + 1;而不是9 - (k - path.size()) + 1，因为这里的递归终止条件是k==0，==k的语义是还剩多少元素没选！！！== 123456789101112131415161718192021class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) &#123; backtracking(k, n, 1, new ArrayDeque&lt;&gt;(k)); return res; &#125; private void backtracking(int k, int n, int start, Deque&lt;Integer&gt; path) &#123; if (k == 0) &#123; if (n == 0) res.add(new LinkedList&lt;&gt;(path)); return; &#125; int bound = 9 - k + 1; if (start &gt; bound) return; backtracking(k, n, start + 1, path); path.add(start); backtracking(k - 1, n - start, start + 1, path); path.removeLast(); &#125;&#125; 17. 电话号码的字母组合 注意边界条件！ 123456789101112131415161718192021222324class Solution &#123; List&lt;String&gt; res = new LinkedList&lt;&gt;(); StringBuilder path = new StringBuilder(); String[] alphabet = &#123;&quot;&quot;, &quot;&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;&#125;; public List&lt;String&gt; letterCombinations(String digits) &#123; if (digits == null || digits.length() == 0) return res; backtracing(digits, 0); return res; &#125; private void backtracing(String digits, int start) &#123; if (path.length() == digits.length()) &#123; res.add(new String(path)); return; &#125; char num = digits.charAt(start); String str = alphabet[num - &#x27;0&#x27;]; for (int i = 0; i &lt; str.length(); ++i) &#123; path.append(str.charAt(i)); backtracing(digits, start + 1); path.deleteCharAt(path.length() - 1); &#125; &#125;&#125; 39. 组合总和 与前面两题不同的是，可以选取相同元素；以及组合不能重复，如[3，5]与[5，3]是同一个组合 同一个 数字可以 无限制重复被选取 解析 方法一：回溯 去重：遇到这一类相同元素不计算顺序的问题，我们在搜索的时候就需要 按某种顺序搜索。具体的做法是：每一次搜索的时候设置 下一轮搜索的起点 begin，请看下图。 img 123456789101112131415161718192021class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; backtracing(candidates, target, 0); return res; &#125; private void backtracing(int[] candidates, int target, int start) &#123; if (target &lt; 0) return; if (target == 0) &#123; res.add(new LinkedList&lt;&gt;(path)); return; &#125; for (int i = start; i &lt; candidates.length; ++i) &#123; path.add(candidates[i]); backtracing(candidates, target - candidates[i], i); path.removeLast(); &#125; &#125;&#125; 方法二：回溯+剪枝 注意： 是i不是start！！！ 回溯前要排序！！！ 123456789101112131415161718192021222324class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; // 排序是剪枝的前提 Arrays.sort(candidates); backtracing(candidates, target, 0); return res; &#125; private void backtracing(int[] candidates, int target, int start) &#123; if (target == 0) &#123; res.add(new LinkedList&lt;&gt;(path)); return; &#125; for (int i = start; i &lt; candidates.length; ++i) &#123; // 由于进入更深层的时候，小于 0 的部分被剪枝，因此递归终止条件值只判断等于 0 的情况 if (target - candidates[i] &lt; 0) break; path.add(candidates[i]); backtracing(candidates, target - candidates[i], i); path.removeLast(); &#125; &#125;&#125; 40. 组合总和 II 树层去重，树枝不需要去重 去重和39题(上一题)以及三数之和差不多 方法一： 注意：if判断条件是i &gt; start， 不是i &gt; 0 12345678910111213141516171819202122232425这个避免重复当思想是在是太重要了。这个方法最重要的作用是，可以让同一层级，不出现相同的元素。即 1 / \\ 2 2 这种情况不会发生 但是却允许了不同层级之间的重复即： / \\ 5 5 例2 1 / 2 这种情况确是允许的 / 2 为何会有这种神奇的效果呢？首先 cur-1 == cur 是用于判定当前元素是否和之前元素相同的语句。这个语句就能砍掉例1。可是问题来了，如果把所有当前与之前一个元素相同的都砍掉，那么例二的情况也会消失。 因为当第二个2出现的时候，他就和前一个2相同了。 那么如何保留例2呢？那么就用cur &gt; begin 来避免这种情况，你发现例1中的两个2是处在同一个层级上的，例2的两个2是处在不同层级上的。在一个for循环中，所有被遍历到的数都是属于一个层级的。我们要让一个层级中，必须出现且只出现一个2，那么就放过第一个出现重复的2，但不放过后面出现的2。第一个出现的2的特点就是 cur == begin. 第二个出现的2 特点是cur &gt; begin. 1234567891011121314151617181920212223242526class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; Arrays.sort(candidates); backtracing(candidates, target, 0); return res; &#125; private void backtracing(int[] candidates, int target, int start) &#123; if (target == 0) &#123; res.add(new LinkedList&lt;&gt;(path)); return; &#125; for (int i = start; i &lt; candidates.length; ++i) &#123; // 剪枝 if (candidates[i] &gt; target) break; // 去重 if (i &gt; start &amp;&amp; candidates[i] == candidates[i - 1]) continue; path.add(candidates[i]); backtracing(candidates, target - candidates[i], i + 1); path.removeLast(); &#125; &#125;&#125; 方法二：used数组 多debug 123456789101112131415161718192021222324252627class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; Arrays.sort(candidates); boolean[] used = new boolean[candidates.length]; backtracking(candidates, used, target, 0); return res; &#125; public void backtracking(int[] candidates, boolean[] used, int target, int start) &#123; if (target == 0) &#123; res.add(new LinkedList(path)); return; &#125; for (int i = start; i &lt; candidates.length; ++i) &#123; if (target &lt; candidates[i]) break; if (i &gt; 0 &amp;&amp; candidates[i] == candidates[i - 1] &amp;&amp; !used[i - 1]) continue; path.add(candidates[i]); used[i] = true; backtracking(candidates, used, target - candidates[i], i + 1); used[i] = false; path.removeLast(); &#125; &#125;&#125; 方法三：选或不选 1234567891011121314151617181920212223class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; Arrays.sort(candidates); backtracking(candidates, false, target, 0); return res; &#125; public void backtracking(int[] candidates, boolean choosePre, int target, int start) &#123; if (target == 0) &#123; res.add(new LinkedList(path)); return; &#125; if (target &lt; 0 || start == candidates.length) return; backtracking(candidates, false, target, start + 1); if (start &gt; 0 &amp;&amp; !choosePre &amp;&amp; candidates[start] == candidates[start - 1]) return; path.add(candidates[start]); backtracking(candidates, true, target - candidates[start], start + 1); path.removeLast(); &#125;&#125; 131. 分割回文串:warning: 12345678910111213141516171819202122232425262728class Solution &#123; List&lt;List&lt;String&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;String&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;String&gt;&gt; partition(String s) &#123; backtracking(s.toCharArray(), 0); return res; &#125; public void backtracking(char[] ch, int start) &#123; if (start == ch.length) &#123; res.add(new LinkedList(path)); return; &#125; for (int i = start; i &lt; ch.length; ++i) &#123; if (isPalindrome(ch, start, i)) &#123; path.add(new String(ch, start, i - start + 1)); backtracking(ch, i + 1); path.removeLast(); &#125; &#125; &#125; public boolean isPalindrome(char[] ch, int start, int end) &#123; while (start &lt; end) &#123; if (ch[start++] != ch[end--]) return false; &#125; return true; &#125;&#125; :star:93. 复原 IP 地址 重做 方法一：回溯 1 78. 子集 以下两种方法的区别： 方法二有横向for循环，使用i进入递归方法 方法一有两个递归方法，分别表示选与不选，用start进入递归犯法 方法一：选或不选 123456789101112131415161718class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; backtracking(nums, 0); return res; &#125; private void backtracking(int[] nums, int start) &#123; if (start == nums.length) &#123; res.add(new LinkedList(path)); return; &#125; backtracking(nums, start + 1); path.add(nums[start]); backtracking(nums, start + 1); path.removeLast(); &#125;&#125; 方法二：for循环横向顺序遍历 12345678910111213141516class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; backtracking(nums, 0); return res; &#125; private void backtracking(int[] nums, int start) &#123; res.add(new LinkedList(path)); for (int i = start; i &lt; nums.length; i++) &#123; path.add(nums[i]); backtracking(nums, i + 1); path.removeLast(); &#125; &#125;&#125; 90. 子集 II 方法一：选或不选 如果前后两个数相等，如[1,2,2]，那么只有在第一个2被选择了，才能选择第二个2，不然会重复 123456789101112131415161718192021class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; Arrays.sort(nums); backtracking(nums, false, 0); return res; &#125; public void backtracking(int[] nums, boolean choosePre, int start) &#123; if (start == nums.length) &#123; res.add(new LinkedList(path)); return; &#125; backtracking(nums, false, start + 1); if (start &gt; 0 &amp;&amp; !choosePre &amp;&amp; nums[start - 1] == nums[start]) return; path.add(nums[start]); backtracking(nums, true, start + 1); path.removeLast(); &#125;&#125; 方法二：顺序递归 注意：if判断条件是i &gt; start， 不是i &gt; 0 12345678910111213141516171819class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; Arrays.sort(nums); backtracking(nums, 0); return res; &#125; public void backtracking(int[] nums, int start) &#123; res.add(new LinkedList(path)); for (int i = start; i &lt; nums.length; ++i) &#123; if (i &gt; start &amp;&amp; nums[i - 1] == nums[i]) continue; path.add(nums[i]); backtracking(nums, i + 1); path.removeLast(); &#125; &#125;&#125; 491. 递增子序列:warning: 方法一：顺序DFS 注意：HashSet的位置！！！每进入一层递归，就会在for循环前创建一个HashSet，这样可以保证树层去重，并且树枝不会qu'chong 1234567891011121314151617181920212223class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; findSubsequences(int[] nums) &#123; backtracking(nums, 0); return res; &#125; public void backtracking(int[] nums, int start) &#123; if (path.size() &gt;= 2) res.add(new LinkedList(path)); Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int i = start; i &lt; nums.length; ++i) &#123; if ((!path.isEmpty() &amp;&amp; nums[i] &lt; path.peekLast())) continue; if (set.contains(nums[i])) continue; set.add(nums[i]); path.add(nums[i]); backtracking(nums, i + 1); path.pollLast(); &#125; &#125;&#125; 46. 全排列 12345678910111213141516171819202122232425class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); boolean[] used; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; used = new boolean[nums.length]; backtracking(nums); return res; &#125; private void backtracking(int[] nums) &#123; if (path.size() == nums.length) &#123; res.add(new LinkedList&lt;&gt;(path)); return; &#125; for (int i = 0; i &lt; nums.length; ++i) &#123; if (!used[i]) &#123; path.add(nums[i]); used[i] = true; backtracking(nums); used[i] = false; path.pollLast(); &#125; &#125; &#125;&#125; 47. 全排列 II 12345678910111213141516171819202122232425262728class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); boolean[] used; public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; Arrays.sort(nums); used = new boolean[nums.length]; backtracking(nums); return res; &#125; public void backtracking(int[] nums) &#123; if (path.size() == nums.length) &#123; res.add(new LinkedList(path)); return; &#125; for (int i = 0; i &lt; nums.length; ++i) &#123; if (i &gt; 0 &amp;&amp; !used[i - 1] &amp;&amp; nums[i - 1] == nums[i]) continue; if (!used[i]) &#123; path.add(nums[i]); used[i] = true; backtracking(nums); used[i] = false; path.pollLast(); &#125; &#125; &#125;&#125; 51. N 皇后 方法一：二维数组存表盘 时间复杂度\\(O(n^n)\\) 空间复杂度\\(O(n^2)\\) 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123; List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; char[][] chessboard = new char[n][n]; for (char[] row : chessboard) Arrays.fill(row, &#x27;.&#x27;); backtracking(0, chessboard, n); return res; &#125; private void backtracking(int row, char[][] chessboard, int n) &#123; if (row == n) &#123; res.add(toList(chessboard)); return; &#125; for (int col = 0; col &lt; n; ++col) &#123; if (isValid(row, col, chessboard, n)) &#123; chessboard[row][col] = &#x27;Q&#x27;; backtracking(row + 1, chessboard, n); chessboard[row][col] = &#x27;.&#x27;; &#125; &#125; &#125; private boolean isValid(int row, int col, char[][] chessboard, int n) &#123; for (int i = 0; i &lt; row; ++i) if (chessboard[i][col] == &#x27;Q&#x27;) return false; for (int i = row - 1, j = col - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; --i, --j) &#123; if (chessboard[i][j] == &#x27;Q&#x27;) return false; &#125; for (int i = row - 1, j = col + 1; i &gt;= 0 &amp;&amp; j &lt; n; --i, ++j) if (chessboard[i][j] == &#x27;Q&#x27;) return false; return true; &#125; private List&lt;String&gt; toList(char[][] chessboard) &#123; List&lt;String&gt; path = new ArrayList&lt;&gt;(); for (char[] ch : chessboard) &#123; path.add(String.copyValueOf(ch)); &#125; return path; &#125;&#125; 方法二：一维数组存储每行皇后的列信息 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123; List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); int[] chessboard; public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; chessboard = new int[n]; backtracking(0, n); return res; &#125; private void backtracking(int row, int n) &#123; if (row == n) &#123; res.add(generatePath(n)); return; &#125; for (int col = 0; col &lt; n; ++col) &#123; if (isValid(row, col, n)) &#123; chessboard[row] = col; backtracking(row + 1, n); chessboard[row] = 0; &#125; &#125; &#125; private boolean isValid(int row, int col, int n) &#123; for (int i = 0; i &lt; row; ++i) &#123; if (chessboard[i] == col || Math.abs(col - chessboard[i]) == Math.abs(row - i)) return false; &#125; return true; &#125; private List&lt;String&gt; generatePath(int n) &#123; List&lt;String&gt; path = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n; ++i) &#123; StringBuilder sb = new StringBuilder(); for (int j = 0; j &lt; n; ++j) &#123; if (j == chessboard[i]) sb.append(&#x27;Q&#x27;); else sb.append(&#x27;.&#x27;); &#125; path.add(sb.toString()); &#125; return path; &#125;&#125; 方法三：位运算加速 113. 路径总和 II Graph 797. 所有可能的路径 优质题解 1234567891011121314151617181920class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; allPathsSourceTarget(int[][] graph) &#123; path.offerLast(0); backtracking(0, graph); return res; &#125; private void backtracking(int start, int[][] graph) &#123; if (start == graph.length - 1) &#123; res.add(new LinkedList(path)); return; &#125; for (int x : graph[start]) &#123; path.offerLast(x); backtracking(x, graph); path.removeLast(); &#125; &#125;&#125; 200. 岛屿数量 方法一：DFS 1234567891011121314151617181920212223class Solution &#123; public int numIslands(char[][] grid) &#123; int res = 0; for (int row = 0; row &lt; grid.length; ++row) &#123; for (int col = 0; col &lt; grid[0].length; ++col) &#123; if (grid[row][col] == &#x27;1&#x27;) &#123; ++res; dfs(row, col, grid); &#125; &#125; &#125; return res; &#125; private void dfs(int row, int col, char[][] grid) &#123; if (row &lt; 0 || row &gt; grid.length - 1 || col &lt; 0 || col &gt; grid[0].length - 1 || grid[row][col] != &#x27;1&#x27;) return; grid[row][col] = &#x27;2&#x27;; dfs(row - 1, col, grid); dfs(row + 1, col, grid); dfs(row, col - 1, grid); dfs(row, col + 1, grid); &#125;&#125; 方法二：BFS 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public int numIslands(char[][] grid) &#123; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); int m = grid.length; int n = grid[0].length; int res = 0; for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (grid[i][j] == &#x27;1&#x27;) &#123; ++res; grid[i][j] = &#x27;2&#x27;; queue.offer(new int[]&#123;i, j&#125;); while (!queue.isEmpty()) &#123; int[] coor = queue.poll(); int row = coor[0], col = coor[1]; if (row - 1 &gt;= 0 &amp;&amp; grid[row - 1][col] == &#x27;1&#x27;) &#123; queue.offer(new int[]&#123;row -1, col&#125;); grid[row - 1][col] = &#x27;2&#x27;; &#125; if (row + 1 &lt; m &amp;&amp; grid[row + 1][col] == &#x27;1&#x27;) &#123; queue.offer(new int[]&#123;row + 1, col&#125;); grid[row + 1][col] = &#x27;2&#x27;; &#125; if (col - 1 &gt;= 0 &amp;&amp; grid[row][col - 1] == &#x27;1&#x27;) &#123; queue.offer(new int[]&#123;row, col - 1&#125;); grid[row][col - 1] = &#x27;2&#x27;; &#125; if (col + 1 &lt; n &amp;&amp; grid[row][col + 1] == &#x27;1&#x27;) &#123; queue.offer(new int[]&#123;row, col + 1&#125;); grid[row][col + 1] = &#x27;2&#x27;; &#125; &#125; &#125; &#125; &#125; return res; &#125;&#125; 方法三：不修改输入数据的DFSF 123456789101112131415161718192021222324class Solution &#123; public int numIslands(char[][] grid) &#123; int res = 0; boolean[][] visited = new boolean[grid.length][grid[0].length]; for (int row = 0; row &lt; grid.length; ++row) &#123; for (int col = 0; col &lt; grid[0].length; ++col) &#123; if (!visited[row][col] &amp;&amp; grid[row][col] == &#x27;1&#x27;) &#123; ++res; dfs(row, col, grid, visited); &#125; &#125; &#125; return res; &#125; private void dfs(int row, int col, char[][] grid, boolean[][] visited) &#123; if (row &gt;= 0 &amp;&amp; col &gt;= 0 &amp;&amp; row &lt; grid.length &amp;&amp; col &lt; grid[0].length &amp;&amp; !visited[row][col] &amp;&amp; grid[row][col] == &#x27;1&#x27;) &#123; visited[row][col] = true; int[][] dirs = new int[][]&#123;&#123;0, -1&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;, &#123;1, 0&#125;&#125;; for (int[] dir : dirs) &#123; dfs(row + dir[0], col + dir[1], grid, visited); &#125; &#125; &#125;&#125; 695. 岛屿的最大面积 方法一：DFS 1234567891011121314151617181920212223242526class Solution &#123; int res = 0; int size = 0; public int maxAreaOfIsland(int[][] grid) &#123; for (int i = 0; i &lt; grid.length; ++i) &#123; for (int j = 0; j &lt; grid[0].length; ++j) &#123; if (grid[i][j] == 1) &#123; size = 0; dfs(i, j, grid); System.out.println(res); &#125; &#125; &#125; return res; &#125; private void dfs(int i, int j, int[][] grid) &#123; if (i &lt; 0 || j &lt; 0 || i == grid.length || j == grid[0].length || grid[i][j] != 1) return; grid[i][j] = 2; res = Math.max(res, ++size); dfs(i - 1, j, grid); dfs(i + 1, j, grid); dfs(i, j - 1, grid); dfs(i, j + 1, grid); &#125;&#125; 不修改输入的DFS 12345678910111213141516171819202122232425class Solution &#123; public int maxAreaOfIsland(int[][] grid) &#123; int res = 0; boolean[][] visited = new boolean[grid.length][grid[0].length]; for (int i = 0; i &lt; grid.length; ++i) &#123; for (int j = 0; j &lt; grid[0].length; ++j) &#123; if (!visited[i][j] &amp;&amp; grid[i][j] == 1) &#123; res = Math.max(res, dfs(i, j, grid, visited)); &#125; &#125; &#125; return res; &#125; private int dfs(int i, int j, int[][] grid, boolean[][] visited) &#123; if (i &lt; 0 || j &lt; 0 || i == grid.length || j == grid[0].length || grid[i][j] != 1 || visited[i][j]) return 0; int res = 1; visited[i][j] = true; int[][] dirs = new int[][]&#123;&#123;0, -1&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;, &#123;1, 0&#125;&#125;; for (int[] dir : dirs) &#123; res += dfs(i + dir[0], j + dir[1], grid, visited); &#125; return res; &#125;&#125; 方法三：DFS标准写法 123456789101112131415161718192021222324252627282930class Solution &#123; public int maxAreaOfIsland(int[][] grid) &#123; int res = 0; int m = grid.length, n = grid[0].length; for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (grid[i][j] == 1) &#123; res = Math.max(res, dfs(i, j, grid)); &#125; &#125; &#125; return res; &#125; public int dfs(int i, int j, int[][] grid) &#123; int res = 1; grid[i][j] = 2; int[][] dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col, grid.length, grid[0].length) &amp;&amp; grid[row][col] == 1) &#123; grid[row][col] = 2; res += dfs(row, col, grid); &#125; &#125; return res; &#125; public boolean isValid(int i, int j, int m, int n) &#123; return (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n); &#125;&#125; 827. 最大人工岛:warning::star: 优质题解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution &#123; public int largestIsland(int[][] grid) &#123; Map&lt;Integer, Integer&gt; idToArea = new HashMap&lt;&gt;(); int id = 2; int m = grid.length, n = grid[0].length; int res = 0; for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (grid[i][j] == 1) &#123; idToArea.put(id, getSingleArea(i, j, grid, id)); ++id; &#125; &#125; &#125; for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; res = Math.max(res, dfs(i, j, grid, idToArea)); &#125; &#125; return res; &#125; private int dfs(int i, int j, int[][] grid, Map&lt;Integer,Integer&gt; idToArea) &#123; // if (i &lt; 0 || j &lt; 0 || i == grid.length || j == grid[0].length) // return 0; if (grid[i][j] &gt; 0) &#123; return idToArea.get(grid[i][j]); &#125; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); int res = 1; int[][] dirs = new int[][]&#123;&#123;0, -1&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;, &#123;1, 0&#125;&#125;; for (int[] dir : dirs) &#123; if (i + dir[0] &lt; 0 || j + dir[1] &lt; 0 || i + dir[0] == grid.length || j + dir[1] == grid[0].length) continue; set.add(grid[i + dir[0]][j + dir[1]]); &#125; for (int element : set) &#123; res += idToArea.getOrDefault(element, 0); &#125; return res; &#125; private int getSingleArea(int i, int j, int[][] grid, int id) &#123; if (i &lt; 0 || j &lt; 0 || i == grid.length || j == grid.length || grid[i][j] != 1) return 0; int res = 1; grid[i][j] = id; int[][] dirs = new int[][]&#123;&#123;0, -1&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;, &#123;1, 0&#125;&#125;; for (int[] dir : dirs) &#123; res += getSingleArea(i + dir[0], j + dir[1], grid, id); &#125; return res; &#125;&#125; 二刷 注意hashmap与hashset的使用细节 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution &#123; public int largestIsland(int[][] grid) &#123; int res = 0; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); int id = 2; for (int i = 0; i &lt; grid.length; ++i) &#123; for (int j = 0; j &lt; grid[0].length; ++j) &#123; if (grid[i][j] == 1) &#123; map.put(id, getArea(i, j, grid, id)); ++id; &#125; &#125; &#125; for (int i = 0; i &lt; grid.length; ++i) &#123; for (int j = 0; j &lt; grid[0].length; ++j) &#123; res = Math.max(res, dfs(i, j, grid, map)); &#125; &#125; return res; &#125; public int dfs(int i, int j, int[][] grid, Map&lt;Integer, Integer&gt; map) &#123; if (grid[i][j] &gt; 0) return map.get(grid[i][j]); Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); int res = 1; int[][] dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col, grid)) &#123; int id = grid[row][col]; set.add(id); &#125; &#125; for (int id : set) &#123; res += map.getOrDefault(id, 0); &#125; return res; &#125; public int getArea(int i, int j, int[][] grid, int id) &#123; grid[i][j] = id; int res = 1; int[][] dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col, grid) &amp;&amp; grid[row][col] == 1) &#123; grid[row][col] = id; res += getArea(row, col, grid, id); &#125; &#125; return res; &#125; public boolean isValid(int i, int j, int[][] grid) &#123; return (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; grid.length &amp;&amp; j &lt; grid[0].length); &#125;&#125; 463. 岛屿的周长 方法一：DFS 岛屿的上下左右如果是水域或者超出边界，那么周长加一 1234567891011121314151617181920212223242526272829303132class Solution &#123; public int islandPerimeter(int[][] grid) &#123; for (int i = 0; i &lt; grid.length; ++i) &#123; for (int j = 0; j &lt; grid[0].length; ++j) &#123; if (grid[i][j] == 1) &#123; grid[i][j] = 2; return dfs(i, j, grid); &#125; &#125; &#125; return -1; &#125; private int dfs(int i, int j, int[][] grid) &#123; int res = 0; int[][] dirs = new int[][]&#123;&#123;0, -1&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;, &#123;1, 0&#125;&#125;; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col, grid) &amp;&amp; grid[row][col] == 1) &#123; grid[row][col] = 2; res += dfs(row, col, grid); &#125; else &#123; if (!isValid(row, col, grid) || grid[row][col] == 0) ++res; &#125; &#125; return res; &#125; private boolean isValid(int i, int j, int[][] grid) &#123; return !(i &lt; 0 || j &lt; 0 || i == grid.length || j == grid[0].length); &#125;&#125; 1020. 飞地的数量:warning: 遇到一个陆地，只会返回numEnclaves进入dfs返回的值，因为相连的陆地在grid中会被修改，numEnclaves循环中不会再次fang'wen 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public int numEnclaves(int[][] grid) &#123; int res = 0; for (int i = 0; i &lt; grid.length; ++i) &#123; for (int j = 0; j &lt; grid[0].length; ++j) &#123; if (grid[i][j] == 1) &#123; grid[i][j] = 2; res += dfs(i, j, grid); &#125; &#125; &#125; return res; &#125; private int dfs(int i, int j, int[][] grid) &#123; int res = 1; int[][] dirs = new int[][]&#123;&#123;0, -1&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;, &#123;1, 0&#125;&#125;; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (!isValid(row, col, grid)) &#123; grid[i][j] = 3; &#125; else if (grid[row][col] == 1) &#123; grid[row][col] = 2; int ans = dfs(row, col, grid); if (ans == 0) &#123; grid[i][j] = 3; &#125; else res += ans; &#125; &#125; return grid[i][j] == 3 ? 0 : res; &#125; private boolean isValid(int i, int j, int[][] grid) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; grid.length &amp;&amp; j &lt; grid[0].length; &#125;&#125; 130. 被围绕的区域 从边界(第一行，最后一行以及第一列和最后一列)找到O，这些O肯定不会被围绕，把这些O都标记为# 把其他位置的O全部赋值为X，将#还原为O 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; public void solve(char[][] board) &#123; int m = board.length, n = board[0].length; if (m &lt;= 2 || n &lt;= 2) return; for (int i = 0; i &lt; m; i += m - 1) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (board[i][j] == &#x27;O&#x27;) &#123; board[i][j] = &#x27;#&#x27;; dfs(i, j, board); &#125; &#125; &#125; for (int j = 0; j &lt; n; j += n - 1) &#123; for (int i = 0; i &lt; m; ++i) &#123; if (board[i][j] == &#x27;O&#x27;) &#123; board[i][j] = &#x27;#&#x27;; dfs(i, j, board); &#125; &#125; &#125; for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (board[i][j] == &#x27;O&#x27;) board[i][j] = &#x27;X&#x27;; else if (board[i][j] == &#x27;#&#x27;) board[i][j] = &#x27;O&#x27;; &#125; &#125; &#125; private void dfs(int i, int j, char[][] board) &#123; int[][] dirs = new int[][] &#123;&#123;0, -1&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;, &#123;1, 0&#125;&#125;; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col, board) &amp;&amp; board[row][col] == &#x27;O&#x27;) &#123; board[row][col] = &#x27;#&#x27;; dfs(row, col, board); &#125; &#125; &#125; private boolean isValid(int i, int j, char[][] board) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; board[0].length &amp;&amp; i &lt; board.length; &#125;&#125; 417. 太平洋大西洋水流问题:star: 方法一：DFS 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; pacificAtlantic(int[][] heights) &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); int m = heights.length, n = heights[0].length; boolean[][] pacific = new boolean[m][n], atlantic = new boolean[m][n]; for (int j = 0; j &lt; n; ++j) dfs(0, j, heights, pacific); for (int i = 1; i &lt; m; ++i) dfs(i, 0, heights, pacific); for (int j = 0; j &lt; n; ++j) dfs(m - 1, j, heights, atlantic); for (int i = 0; i &lt; m - 1; ++i) dfs(i, n - 1, heights, atlantic); for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (pacific[i][j] &amp;&amp; atlantic[i][j]) &#123; List&lt;Integer&gt; temp = new ArrayList&lt;&gt;(2); temp.add(i); temp.add(j); res.add(temp); &#125; &#125; &#125; return res; &#125; public void dfs(int i, int j, int[][] heights, boolean[][] ocean) &#123; if (ocean[i][j]) return; ocean[i][j] = true; int[][] dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col, heights) &amp;&amp; heights[row][col] &gt;= heights[i][j]) dfs(row, col, heights, ocean); &#125; &#125; public boolean isValid(int i, int j, int[][] heights) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; heights.length &amp;&amp; j &lt; heights[0].length; &#125;&#125; 127. 单词接龙 方法一：单向广度优先搜索 需要两个队列存储邻居，第一个队列存储的邻居neighbor1距离beginWord的距离是d，将neighbor1的邻居neighbor2存储在queue2中，neighbor2距离beginWord的距离是d + 1 每当把访问完所有queue1中的neighbor1，并且将neighbor2加入到queue2中，那么需要访问新一轮邻居，于是把queue1指向queue2(queue2赋值给queue1)，queue2再新开辟一段空间，此时length(距离)需要加一 开始时需要使用一个HashSet，并将单词表直接放进去，Set&lt;String&gt; set = new HashSet&lt;&gt;(wordList)。函数getNeibours用于找到当前单词所有可能的邻居单词(只有一个字母不同)，对比set中的单词表，如果set中有对应的邻居单词x，则把x加入queue1，并且从set中移除x(如果不移除x，则会重复计算，比如hot的邻居有lot,如果不移除lot，那么下次，如下图 image-20230509162229556 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123; public int ladderLength(String beginWord, String endWord, List&lt;String&gt; wordList) &#123; Queue&lt;String&gt; queue1 = new LinkedList&lt;&gt;(); Queue&lt;String&gt; queue2 = new LinkedList&lt;&gt;(); Set&lt;String&gt; set = new HashSet&lt;&gt;(wordList); int length = 1; queue1.offer(beginWord); while (!queue1.isEmpty()) &#123; String word = queue1.poll(); if (word.equals(endWord)) return length; List&lt;String&gt; neibours = getNeibours(word); for (String str : neibours) &#123; if (set.contains(str)) &#123; queue2.offer(str); set.remove(str); &#125; &#125; if (queue1.isEmpty()) &#123; ++length; queue1 = queue2; queue2 = new LinkedList&lt;&gt;(); &#125; &#125; return 0; &#125; public List&lt;String&gt; getNeibours(String word) &#123; List&lt;String&gt; neibours = new ArrayList&lt;&gt;(); char[] ch = word.toCharArray(); for (int i = 0; i &lt; ch.length; ++i) &#123; char original = ch[i]; for (char j = &#x27;a&#x27;; j &lt;= &#x27;z&#x27;; ++j) &#123; if (j != original) &#123; ch[i] = j; neibours.add(new String(ch)); &#125; &#125; // backtracking ch[i] = original; &#125; return neibours; &#125;&#125; 剑指 Offer II 109. 开密码锁 注意visited的位置！！！同上一题，在入队时就在visited加入该邻居，避免之后的重复访问 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123; public int openLock(String[] deadends, String target) &#123; Set&lt;String&gt; deadSet = new HashSet&lt;&gt;(Arrays.asList(deadends)), visited = new HashSet&lt;&gt;(); String init = &quot;0000&quot;; if (deadSet.contains(init) || deadSet.contains(target)) return -1; visited.add(init); Queue&lt;String&gt; queue1 = new LinkedList&lt;&gt;(), queue2 = new LinkedList&lt;&gt;(); queue1.offer(init); int res = 0; while (!queue1.isEmpty()) &#123; String code = queue1.poll(); if (code.equals(target)) return res; List&lt;String&gt; neibors = getNeibors(code); for (String neibor : neibors) &#123; if (!deadSet.contains(neibor) &amp;&amp; !visited.contains(neibor)) &#123; queue2.offer(neibor); visited.add(neibor); &#125; &#125; if (queue1.isEmpty()) &#123; ++res; queue1 = queue2; queue2 = new LinkedList&lt;&gt;(); &#125; &#125; return -1; &#125; public List&lt;String&gt; getNeibors(String code) &#123; List&lt;String&gt; neibors = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; code.length(); ++i) &#123; char cur = code.charAt(i); StringBuilder sb = new StringBuilder(code); // down char changed = cur == &#x27;0&#x27; ? &#x27;9&#x27; : (char) (cur - 1); sb.setCharAt(i, changed); neibors.add(sb.toString()); // up changed = cur == &#x27;9&#x27; ? &#x27;0&#x27; : (char) (cur + 1); sb.setCharAt(i, changed); neibors.add(sb.toString()); &#125; return neibors; &#125;&#125; 剑指 Offer II 106. 二分图:warning: 方法一：DFS 染色法需要二刷 12345678910111213141516171819202122232425262728293031323334class Solution &#123; private static final int UNCOLORED = 0; private static final int RED = 1; private static final int BLUE = 2; private int[] colorArray; private boolean res = true; public boolean isBipartite(int[][] graph) &#123; colorArray = new int[graph.length]; for (int i = 0; i &lt; graph.length &amp;&amp; res; ++i) &#123; if (colorArray[i] == UNCOLORED) &#123; dfs(i, graph, RED); &#125; &#125; return res; &#125; private void dfs(int i, int[][] graph, int color) &#123; colorArray[i] = color; int neighborColor = color == RED ? BLUE : RED; for (int neibor : graph[i]) &#123; if (colorArray[neibor] == UNCOLORED) &#123; dfs(neibor, graph, neighborColor); if (!res) return; &#125; else if (colorArray[neibor] == neighborColor) &#123; continue; &#125; else &#123; res = false; return; &#125; &#125; &#125;&#125; 方法二：BFS 123456789101112131415161718192021222324252627282930class Solution &#123; private static final int UNCOLORED = 0; private static final int RED = 1; private static final int BLUE = 2; private int[] colorArray; public boolean isBipartite(int[][] graph) &#123; int n = graph.length; colorArray = new int[graph.length]; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; n; ++i) &#123; if (colorArray[i] == UNCOLORED) &#123; queue.offer(i); colorArray[i] = RED; while (!queue.isEmpty()) &#123; int cur = queue.poll(); int neiborColor = colorArray[cur] == RED ? BLUE : RED; for (int neibor : graph[cur]) &#123; if (colorArray[neibor] == UNCOLORED) &#123; queue.offer(neibor); colorArray[neibor] = neiborColor; &#125; else if (colorArray[neibor] != neiborColor) return false; &#125; &#125; &#125; &#125; return true; &#125;&#125; 剑指 Offer II 107. 矩阵中的距离 方法一：BFS 12345678910111213141516171819202122232425262728293031323334class Solution &#123; public int[][] updateMatrix(int[][] mat) &#123; int m = mat.length, n = mat[0].length; int[][] dist = new int[m][n]; boolean[][] visited = new boolean[m][n]; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; mat.length; ++i) &#123; for (int j = 0; j &lt; mat[i].length; ++j) &#123; if (mat[i][j] == 0) &#123; visited[i][j] = true; // dist[i][j] = 0; queue.offer(new int[]&#123;i, j&#125;); &#125; &#125; &#125; int[][] dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; while (!queue.isEmpty()) &#123; int[] pos = queue.poll(); int distance = dist[pos[0]][pos[1]]; for (int[] dir : dirs) &#123; int row = pos[0] + dir[0], col = pos[1] + dir[1]; if (isValid(row, col, m, n) &amp;&amp; !visited[row][col]) &#123; visited[row][col] = true; queue.offer(new int[]&#123;row, col&#125;); dist[row][col] = distance + 1; &#125; &#125; &#125; return dist; &#125; private boolean isValid(int i, int j, int m, int n) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125;&#125; 剑指 Offer II 111. 计算除法:warning: 方法一：BFS 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123; public double[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, double[] values, List&lt;List&lt;String&gt;&gt; queries) &#123; double[] res = new double[queries.size()]; Map&lt;String, Map&lt;String, Double&gt;&gt; graph = buildGraph(equations, values); for (int i = 0; i &lt; queries.size(); ++i) &#123; String from = queries.get(i).get(0); String to = queries.get(i).get(1); if (!graph.containsKey(from) || !graph.containsKey(to)) res[i] = -1; else &#123; Set&lt;String&gt; visited = new HashSet&lt;&gt;(); res[i] = dfs(graph, visited, from, to); &#125; &#125; return res; &#125; private double dfs(Map&lt;String, Map&lt;String, Double&gt;&gt; graph, Set&lt;String&gt; visited, String from, String to) &#123; if (from.equals(to)) return 1.0; visited.add(from); for (Map.Entry&lt;String, Double&gt; entry: graph.get(from).entrySet()) &#123; String key = entry.getKey(); double val = entry.getValue(); if (!visited.contains(key)) &#123; double res = dfs(graph, visited, key, to); if (res != -1) &#123; return res * val; &#125; &#125; &#125; visited.remove(from); return -1.0; &#125; private Map&lt;String, Map&lt;String, Double&gt;&gt; buildGraph(List&lt;List&lt;String&gt;&gt; equations, double[] values) &#123; Map&lt;String, Map&lt;String, Double&gt;&gt; graph = new HashMap&lt;&gt;(); for (int i = 0; i &lt; equations.size(); ++i) &#123; String var1 = equations.get(i).get(0); String var2 = equations.get(i).get(1); graph.putIfAbsent(var1, new HashMap&lt;&gt;()); graph.get(var1).put(var2, values[i]); graph.putIfAbsent(var2, new HashMap&lt;&gt;()); graph.get(var2).putIfAbsent(var1, 1.0 / values[i]); &#125; return graph; &#125;&#125; 剑指 Offer II 112. 最长递增路径:star: 方法一：DFS 1234567891011121314151617181920212223242526272829303132class Solution &#123; int[][] dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; int[][] path; public int longestIncreasingPath(int[][] matrix) &#123; int res = 0, m = matrix.length, n = matrix[0].length; path = new int[m][n]; for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; int dist = dfs(i, j, m, n, matrix); res = Math.max(res, dist); &#125; &#125; return res; &#125; public int dfs(int i, int j, int m, int n, int[][] matrix) &#123; if (path[i][j] != 0) return path[i][j]; int max = 1; for (int[] dir : dirs) &#123; int row = i + dir[0], col = j + dir[1]; if (isValid(row, col, m, n) &amp;&amp; matrix[row][col] &gt; matrix[i][j]) &#123; int dist = dfs(row, col, m, n, matrix); max = Math.max(max, dist + 1); &#125; &#125; path[i][j] = max; return max; &#125; public boolean isValid(int i, int j, int m, int n) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; &#125;&#125; 剑指 Offer II 113. 课程顺序 方法一：拓扑排序 123456789101112131415161718192021222324252627class Solution &#123; public int[] findOrder(int numCourses, int[][] prerequisites) &#123; Map&lt;Integer, List&lt;Integer&gt;&gt; graph = new HashMap&lt;&gt;(); for (int i = 0; i &lt; numCourses; ++i) graph.put(i, new LinkedList&lt;&gt;()); int[] inDegrees = new int[numCourses]; for (int i = 0; i &lt; prerequisites.length; ++i) &#123; ++inDegrees[prerequisites[i][0]]; graph.get(prerequisites[i][1]).add(prerequisites[i][0]); &#125; List&lt;Integer&gt; order = new LinkedList&lt;&gt;(); Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; numCourses; ++i) if (inDegrees[i] == 0) queue.offer(i); while (!queue.isEmpty()) &#123; int node = queue.poll(); order.add(node); for (int next : graph.get(node)) &#123; if (--inDegrees[next] == 0) &#123; queue.offer(next); &#125; &#125; &#125; return order.size() == numCourses ? order.stream().mapToInt(Integer::intValue).toArray() : new int[0]; &#125;&#125; 剑指 Offer II 114. 外星文字典 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123; public String alienOrder(String[] words) &#123; Map&lt;Character, Set&lt;Character&gt;&gt; graph = new HashMap&lt;&gt;(); Map&lt;Character, Integer&gt; inDegrees = new HashMap&lt;&gt;(); for (String word : words) &#123; for (char ch : word.toCharArray()) &#123; graph.putIfAbsent(ch, new HashSet&lt;&gt;()); inDegrees.putIfAbsent(ch, 0); &#125; &#125; for (int i = 1; i &lt; words.length; ++i) &#123; String word1 = words[i - 1]; String word2 = words[i]; if (word1.startsWith(word2) &amp;&amp; !word1.equals(word2)) return &quot;&quot;; for (int j = 0; j &lt; word1.length() &amp;&amp; j &lt; word2.length(); ++j) &#123; char ch1 = word1.charAt(j); char ch2 = word2.charAt(j); if (ch1 != ch2) &#123; if (!graph.get(ch1).contains(ch2)) &#123; graph.get(ch1).add(ch2); inDegrees.put(ch2, inDegrees.get(ch2) + 1); &#125; break; &#125; &#125; &#125; Queue&lt;Character&gt; queue = new LinkedList&lt;&gt;(); for (Map.Entry&lt;Character, Integer&gt; entry : inDegrees.entrySet()) &#123; if (entry.getValue() == 0) &#123; queue.offer(entry.getKey()); &#125; &#125; StringBuilder res = new StringBuilder(); while (!queue.isEmpty()) &#123; char ch = queue.poll(); res.append(ch); Set&lt;Character&gt; nexts = graph.get(ch); for (char next : nexts) &#123; inDegrees.put(next, inDegrees.get(next) - 1); if (inDegrees.get(next) == 0) queue.offer(next); &#125; &#125; return res.length() == graph.size() ? res.toString() : &quot;&quot;; &#125;&#125; 剑指 Offer II 115. 重建序列 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123; public boolean sequenceReconstruction(int[] nums, int[][] sequences) &#123; Map&lt;Integer, Set&lt;Integer&gt;&gt; graph = new HashMap&lt;&gt;(); Map&lt;Integer, Integer&gt; inDegrees = new HashMap&lt;&gt;(); for (int[] sequence : sequences) &#123; for (int num : sequence) &#123; graph.putIfAbsent(num, new HashSet&lt;&gt;()); inDegrees.put(num, 0); &#125; &#125; for (int i = 0; i &lt; sequences.length; ++i) &#123; for (int j = 1; j &lt; sequences[i].length; ++j) &#123; int num1 = sequences[i][j - 1], num2 = sequences[i][j]; if (!graph.get(num1).contains(num2)) &#123; graph.get(num1).add(num2); inDegrees.put(num2, inDegrees.get(num2) + 1); &#125; &#125; &#125; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); for (Map.Entry&lt;Integer, Integer&gt; entry : inDegrees.entrySet()) &#123; if (entry.getValue() == 0) &#123; queue.offer(entry.getKey()); &#125; &#125; List&lt;Integer&gt; res = new LinkedList&lt;&gt;(); while (queue.size() == 1) &#123; int num = queue.poll(); res.add(num); Set&lt;Integer&gt; nexts = graph.get(num); for (int next : nexts) &#123; inDegrees.put(next, inDegrees.get(next) - 1); if (inDegrees.get(next) == 0) queue.offer(next); &#125; &#125; int[] resToArr = res.stream().mapToInt(Integer::intValue).toArray(); return Arrays.equals(resToArr, nums); &#125;&#125; 剑指 Offer II 116. 省份数量 方法一：DFS 1234567891011121314151617181920212223class Solution &#123; public int findCircleNum(int[][] isConnected) &#123; int n = isConnected.length; int res = 0; boolean[] visited = new boolean[n]; for (int i = 0; i &lt; n; ++i) &#123; if (!visited[i]) &#123; visited[i] = true; dfs(i, n, visited, isConnected); ++res; &#125; &#125; return res; &#125; private void dfs(int i, int n, boolean[] visited, int[][] isConnected) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (isConnected[i][j] == 1 &amp;&amp; !visited[j]) &#123; visited[j] = true; dfs(j, n, visited, isConnected); &#125; &#125; &#125;&#125; 方法二：BFS 12345678910111213141516171819202122232425class Solution &#123; public int findCircleNum(int[][] isConnected) &#123; int n = isConnected.length; int res = 0; boolean[] visited = new boolean[n]; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; n; ++i) &#123; if (!visited[i]) &#123; ++res; queue.offer(i); while (!queue.isEmpty()) &#123; int province = queue.poll(); visited[province] = true; for (int j = 0; j &lt; n; ++j) &#123; if (isConnected[province][j] == 1 &amp;&amp; !visited[j]) &#123; visited[j] = true; queue.offer(j); &#125; &#125; &#125; &#125; &#125; return res; &#125;&#125; 方法三：并查集 并查集的讲解 findFather一定要return fathers[i]，而不是return i，因为当0的father是1的时候，return 1 而不是return 0！ 两层for循环第二层j = i + 1，因为首先j = i的话，是遍历两个相同的节点没意义；其次，i之前的节点在之前就已经合并过了，所以不需要再遍历了 123456789101112131415161718192021222324252627282930313233class Solution &#123; public int findCircleNum(int[][] isConnected) &#123; int n = isConnected.length; int res = n; int[] fathers = new int[n]; for (int i = 0; i &lt; n; ++i) fathers[i] = i; for (int i = 0; i &lt; n; ++i) &#123; for (int j = i + 1; j &lt; n; ++j) &#123; if (isConnected[i][j] == 1 &amp;&amp; union(i, j, fathers)) &#123; --res; &#125; &#125; &#125; return res; &#125; private boolean union(int i, int j, int[] fathers) &#123; int fatherOfI = findFather(i, fathers); int fatherOfJ = findFather(j, fathers); if (fatherOfI != fatherOfJ) &#123; fathers[fatherOfI] = fatherOfJ; return true; &#125; return false; &#125; private int findFather(int i, int[] fathers) &#123; if (i != fathers[i]) fathers[i] = findFather(fathers[i], fathers); return fathers[i]; &#125;&#125; 剑指 Offer II 117. 相似的字符串 方法一：并查集 判断是否是相似字符串的函数isAnalogical之前用的蠢方法，还要拷贝再交换，直接判断不同字符num的个数就行 如果num==0，那么相似 由于题目给出的字符串数组中，所有字符串互为 字母异位词(字母顺序不同)，所以num == 2时，是交换了两个字符，如果num &gt; 2，就不符合题意了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123; public int numSimilarGroups(String[] strs) &#123; int n = strs.length; int res = n; int[] fathers = new int[n]; for (int i = 0; i &lt; n; ++i) fathers[i] = i; for (int i = 0; i &lt; n; ++i) &#123; for (int j = i + 1; j &lt; n; ++j) &#123; String str1 = strs[i], str2 = strs[j]; if (isAnalogical(str1, str2) &amp;&amp; union(i, j, fathers)) &#123; --res; &#125; &#125; &#125; return res; &#125; private boolean union(int i, int j, int[] fathers) &#123; int fatherOfI = findFather(i, fathers); int fatherOfJ = findFather(j, fathers); if (fatherOfI != fatherOfJ) &#123; fathers[fatherOfI] = fatherOfJ; return true; &#125; return false; &#125; private int findFather(int i, int[] fathers) &#123; if (i != fathers[i]) fathers[i] = findFather(fathers[i], fathers); return fathers[i]; &#125; private boolean isAnalogical(String a, String b) &#123; int num = 0; for (int i = 0; i &lt; a.length(); i++) &#123; if (a.charAt(i) != b.charAt(i)) &#123; num++; if (num &gt; 2) &#123; return false; &#125; &#125; &#125; return true; &#125;&#125; 剑指 Offer II 118. 多余的边 方法一：并查集 image-20230515135402396 123456789101112131415161718192021222324252627282930class Solution &#123; public int[] findRedundantConnection(int[][] edges) &#123; int n = edges.length; int[] fathers = new int[n + 1]; for (int i = 0; i &lt; n; ++i) fathers[i] = i; for (int[] edge : edges) &#123; int node1 = edge[0], node2 = edge[1]; if (!union(node1, node2, fathers)) return new int[]&#123;node1, node2&#125;; &#125; return new int[2]; &#125; private boolean union(int i, int j, int[] fathers) &#123; int fatherOfI = findFather(i, fathers); int fatherOfJ = findFather(j, fathers); if (fatherOfI != fatherOfJ) &#123; fathers[fatherOfI] = fatherOfJ; return true; &#125; return false; &#125; private int findFather(int i, int[] fathers) &#123; if (i != fathers[i]) fathers[i] = findFather(fathers[i], fathers); return fathers[i]; &#125;&#125; 剑指 Offer II 119. 最长连续序列 方法一：暴力 12345678910111213141516171819202122class Solution &#123; public int longestConsecutive(int[] nums) &#123; if (nums.length == 0) return 0; Arrays.sort(nums); for (int i : nums) System.out.print(i + &quot; &quot;); int res = 1, cur = 1; for (int i = 1; i &lt; nums.length; ++i) &#123; if (nums[i] == nums[i - 1]) continue; if (nums[i] - nums[i - 1] == 1) &#123; ++cur; res = Math.max(res, cur); &#125; else &#123; cur = 1; &#125; &#125; return res; &#125;&#125; 方法二：并查集 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public int longestConsecutive(int[] nums) &#123; Map&lt;Integer, Integer&gt; fathers = new HashMap&lt;&gt;(), count = new HashMap&lt;&gt;(); Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int num : nums) &#123; fathers.put(num, num); count.put(num, 1); set.add(num); &#125; for (int num : nums) &#123; if (set.contains(num + 1)) &#123; union(num, num + 1, fathers, count); &#125; if (set.contains(num - 1)) &#123; union(num, num - 1, fathers, count); &#125; &#125; int res = 0; for (int val : count.values()) &#123; res = Math.max(res, val); &#125; return res; &#125; private void union(int i, int j, Map&lt;Integer, Integer&gt; fathers, Map&lt;Integer, Integer&gt; count) &#123; int fatherOfI = findFather(i, fathers); int fatherOfJ = findFather(j, fathers); if (fatherOfI != fatherOfJ) &#123; fathers.put(fatherOfI, fatherOfJ); count.put(fatherOfJ, count.get(fatherOfI) + count.get(fatherOfJ)); &#125; &#125; private int findFather(int i, Map&lt;Integer, Integer&gt; fathers) &#123; int fatherOfI = fathers.get(i); if (i != fatherOfI) &#123; fathers.put(i, findFather(fatherOfI, fathers)); &#125; return fathers.get(i); &#125;&#125; Binary Search 剑指 Offer II 068. 查找插入位置 方法一： 如果nums中有target，那么会被找到并被返回 如果nums中没有target，那么有三种情况，这个数应该被插入道 第一个位置 最后一个位置 中间 这三种情况的索引都是退出循环后的left！！！ 12345678910111213141516class Solution &#123; public int searchInsert(int[] nums, int target) &#123; int left = 0, right = nums.length - 1; while (left &lt;= right) &#123; int mid = right - ((right - left) &gt;&gt; 1); if (nums[mid] == target) return mid; else if (nums[mid] &gt; target) right = mid - 1; else &#123; left = mid + 1; &#125; &#125; return left; &#125;&#125; 方法二： 1234567891011121314151617class Solution &#123; public int searchInsert(int[] nums, int target) &#123; int left = 0, right = nums.length - 1; while (left &lt;= right) &#123; int mid = right - ((right - left) &gt;&gt; 1); if (nums[mid] &gt;= target) &#123; if (mid == 0 || nums[mid - 1] &lt; target) return mid; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; return nums.length; &#125;&#125; Heap 剑指 Offer II 059. 数据流的第 K 大数值 方法一：小根堆 1234567891011121314151617181920212223242526class KthLargest &#123; private PriorityQueue&lt;Integer&gt; queue; private int size; public KthLargest(int k, int[] nums) &#123; queue = new PriorityQueue&lt;&gt;(); size = k; for (int num : nums) &#123; add(num); &#125; &#125; public int add(int val) &#123; queue.offer(val); if (queue.size() &gt; size) &#123; queue.poll(); &#125; return queue.peek(); &#125;&#125;/** * Your KthLargest object will be instantiated and called as such: * KthLargest obj = new KthLargest(k, nums); * int param_1 = obj.add(val); */ 方法二：小根堆另一种写法 1234567891011121314151617181920212223242526272829class KthLargest &#123; private PriorityQueue&lt;Integer&gt; queue; private int k; public KthLargest(int k, int[] nums) &#123; queue = new PriorityQueue&lt;&gt;(); this.k = k; for (int num : nums) &#123; add(num); &#125; &#125; public int add(int val) &#123; if (queue.size() &lt; k) &#123; queue.offer(val); &#125; else if (queue.size() == k &amp;&amp; queue.peek() &lt; val) &#123; queue.poll(); queue.offer(val); &#125; return queue.peek(); &#125;&#125;/** * Your KthLargest object will be instantiated and called as such: * KthLargest obj = new KthLargest(k, nums); * int param_1 = obj.add(val); */ 剑指 Offer II 060. 出现频率最高的 k 个数字 方法一：小根堆 小根堆的比较方式 小根堆的类型是Map.Entry 123456789101112131415161718192021222324class Solution &#123; public int[] topKFrequent(int[] nums, int k) &#123; Map&lt;Integer, Integer&gt; count = new HashMap&lt;&gt;(); for (int num : nums) &#123; count.put(num, count.getOrDefault(num, 0) + 1); &#125; PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; minHeap = new PriorityQueue&lt;&gt;( (e1, e2) -&gt; e1.getValue() - e2.getValue()); for (Map.Entry&lt;Integer, Integer&gt; entry : count.entrySet()) &#123; if (minHeap.size() &lt; k) &#123; minHeap.offer(entry); &#125; else if (entry.getValue() &gt; minHeap.peek().getValue()) &#123; minHeap.poll(); minHeap.offer(entry); &#125; &#125; int[] res = new int[k]; int i = 0; while (!minHeap.isEmpty()) res[i++] = minHeap.poll().getKey(); return res; &#125;&#125; 剑指 Offer II 061. 和最小的 k 个数对 方法一：大根堆 12345678910111213141516171819202122class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; kSmallestPairs(int[] nums1, int[] nums2, int k) &#123; PriorityQueue&lt;int[]&gt; maxHeap = new PriorityQueue&lt;&gt;( (o1, o2) -&gt; o2[0] + o2[1] - o1[0] - o1[1]); for (int i = 0; i &lt; Math.min(k, nums1.length); ++i) &#123; for (int j = 0; j &lt; Math.min(k, nums2.length); ++j) &#123; if (maxHeap.size() &lt; k) maxHeap.offer(new int[]&#123;nums1[i], nums2[j]&#125;); else if (maxHeap.peek()[0] + maxHeap.peek()[1] &gt; nums1[i] + nums2[j]) &#123; maxHeap.poll(); maxHeap.offer(new int[]&#123;nums1[i], nums2[j]&#125;); &#125; &#125; &#125; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); while (!maxHeap.isEmpty()) &#123; int[] temp = maxHeap.poll(); res.add(Arrays.asList(temp[0], temp[1])); &#125; return res; &#125;&#125; 排序 快速排序 边界问题：end &gt; start。当start == end的时候，已经是排序好的一个数，不需要在进行partition 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public int[] sortArray(int[] nums) &#123; quickSort(nums, 0, nums.length - 1); return nums; &#125; private void quickSort(int[] nums, int start, int end) &#123; if (end &gt; start) &#123; int pivot = partition(nums, start, end); quickSort(nums, start, pivot - 1); quickSort(nums, pivot + 1, end); &#125; &#125; private int partition(int[] nums, int start, int end) &#123; int random = new Random().nextInt(end - start + 1) + start; swap(nums, random, end); int small = start - 1; for (int i = start; i &lt; end; ++i) &#123; if (nums[i] &lt; nums[end]) &#123; ++small; swap(nums, small, i); &#125; &#125; // 没有小于pivot的数了 ++small; swap(nums, small, end); return small; &#125; private void swap(int[] nums, int random, int end) &#123; if (random != end) &#123; int temp = nums[end]; nums[end] = nums[random]; nums[random] = temp; &#125; &#125; public static void main(String[] args) &#123; int[] nums = new int[]&#123;5, 2, 3, 1, 4&#125;; int[] clone = nums.clone(); QuickSort quickSort = new QuickSort(); quickSort.sortArray(nums); for (int num : nums) System.out.print(num + &quot; &quot;); System.out.println(); Arrays.sort(clone); for (int cl : clone) System.out.print(cl + &quot; &quot;); &#125; 剑指 Offer II 076. 数组中的第 k 大的数字 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public int findKthLargest(int[] nums, int k) &#123; int target = nums.length - k; int start = 0, end = nums.length - 1; int pivot = partition(nums, start, end); while (pivot != target) &#123; if (pivot &gt; target) &#123; end = pivot - 1; &#125; else &#123; start = pivot + 1; &#125; pivot = partition(nums, start, end); &#125; return nums[pivot]; &#125; public int partition(int[] nums, int start , int end) &#123; int random = new Random().nextInt(end - start + 1) + start; swap(nums, random, end); int small = start - 1; for (int i = start; i &lt; end; ++i) &#123; if (nums[i] &lt; nums[end]) &#123; ++small; swap(nums, small, i); &#125; &#125; ++small; swap(nums, small, end); return small; &#125; public void swap(int[] nums, int index1, int index2) &#123; if (index1 != index2) &#123; int temp = nums[index1]; nums[index1] = nums[index2]; nums[index2] = temp; &#125; &#125;&#125; 前缀树 剑指 Offer II 062. 实现前缀树 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Trie &#123; static class TrieNode &#123; TrieNode[] children; boolean isWord; public TrieNode() &#123; children = new TrieNode[26]; &#125; &#125; private TrieNode root; public Trie() &#123; root = new TrieNode(); &#125; /** Inserts a word into the trie. */ public void insert(String word) &#123; TrieNode cur = root; for (char ch : word.toCharArray()) &#123; if (cur.children[ch - &#x27;a&#x27;] == null) &#123; cur.children[ch - &#x27;a&#x27;] = new TrieNode(); &#125; cur = cur.children[ch - &#x27;a&#x27;]; &#125; cur.isWord = true; &#125; /** Returns if the word is in the trie. */ public boolean search(String word) &#123; TrieNode cur = root; for (char ch : word.toCharArray()) &#123; if (cur.children[ch - &#x27;a&#x27;] == null) return false; cur = cur.children[ch - &#x27;a&#x27;]; &#125; return cur.isWord; &#125; /** Returns if there is any word in the trie that starts with the given prefix. */ public boolean startsWith(String prefix) &#123; TrieNode cur = root; for (char ch : prefix.toCharArray()) &#123; if (cur.children[ch - &#x27;a&#x27;] == null) return false; cur = cur.children[ch - &#x27;a&#x27;]; &#125; return true; &#125;&#125; 剑指 Offer II 063. 替换单词 方法一：前缀树 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123; static class TrieNode &#123; private TrieNode[] children; private boolean isWord; public TrieNode() &#123; children = new TrieNode[26]; &#125; &#125; public String replaceWords(List&lt;String&gt; dictionary, String sentence) &#123; TrieNode root = buildTrie(dictionary); String[] words = sentence.split(&quot; &quot;); StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; words.length; ++i) &#123; String prefix = findPrefix(root, words[i]); if (!prefix.isEmpty()) &#123; words[i] = prefix; &#125; &#125; return String.join(&quot; &quot;, words); &#125; private String findPrefix(TrieNode root, String word) &#123; TrieNode cur = root; StringBuilder sb = new StringBuilder(); for (char ch : word.toCharArray()) &#123; if (cur.children[ch - &#x27;a&#x27;] == null || cur.isWord) break; sb.append(ch); cur = cur.children[ch - &#x27;a&#x27;]; &#125; return cur.isWord == true ? sb.toString() : &quot;&quot;; &#125; private TrieNode buildTrie(List&lt;String&gt; dictionary) &#123; TrieNode root = new TrieNode(); for (String str : dictionary) &#123; TrieNode cur = root; for (char ch : str.toCharArray()) &#123; if (cur.children[ch - &#x27;a&#x27;] == null) cur.children[ch - &#x27;a&#x27;] = new TrieNode(); cur = cur.children[ch - &#x27;a&#x27;]; &#125; cur.isWord = true; &#125; return root; &#125;&#125; 剑指 Offer II 064. 神奇的字典:warning: 方法一：前缀树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class MagicDictionary &#123; static class TrieNode &#123; private TrieNode[] children; private boolean isWord; public TrieNode() &#123; children = new TrieNode[26]; &#125; &#125; /** Initialize your data structure here. */ private TrieNode root; public MagicDictionary() &#123; root = new TrieNode(); &#125; public void buildDict(String[] dictionary) &#123; for (String str : dictionary) &#123; TrieNode cur = root; for (char ch : str.toCharArray()) &#123; if (cur.children[ch - &#x27;a&#x27;] == null) cur.children[ch - &#x27;a&#x27;] = new TrieNode(); cur = cur.children[ch - &#x27;a&#x27;]; &#125; cur.isWord = true; &#125; &#125; public boolean search(String searchWord) &#123; return dfs(root, searchWord, 0, 0); &#125; public boolean dfs(TrieNode root, String searchWord, int index, int modifiedNum) &#123; if (root == null) return false; if (root.isWord &amp;&amp; index == searchWord.length() &amp;&amp; modifiedNum == 1) return true; if (modifiedNum &lt;= 1 &amp;&amp; index &lt; searchWord.length()) &#123; boolean found = false; for (int j = 0; j &lt; 26 &amp;&amp; !found; ++j) &#123; int next = j == searchWord.charAt(index) - &#x27;a&#x27; ? modifiedNum : modifiedNum + 1; found = dfs(root.children[j], searchWord, index + 1, next); &#125; return found; &#125; return false; &#125;&#125;/** * Your MagicDictionary object will be instantiated and called as such: * MagicDictionary obj = new MagicDictionary(); * obj.buildDict(dictionary); * boolean param_2 = obj.search(searchWord); *///leetcode submit region end(Prohibit modification and deletion) 剑指 Offer II 065. 最短的单词编码:warning::star: 方法一：前缀树 这种DFS技巧非常重要！！！ 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123; static class TrieNode &#123; private TrieNode[] children; private boolean isEnd; public TrieNode() &#123; children = new TrieNode[26]; &#125; &#125; private int res = 0; public int minimumLengthEncoding(String[] words) &#123; TrieNode root = buildTree(words); dfs(root, 1); return res; &#125; private void dfs(TrieNode root, int length) &#123; boolean isLeaf = true; for (TrieNode child : root.children) &#123; if (child != null) &#123; isLeaf = false; dfs(child, length + 1); &#125; &#125; if (isLeaf) res += length; &#125; private TrieNode buildTree(String[] words) &#123; TrieNode root = new TrieNode(); for (int i = 0; i &lt; words.length; ++i) &#123; String word = words[i]; TrieNode cur = root; for (int j = word.length() - 1; j &gt;= 0; --j) &#123; char ch = word.charAt(j); if (cur.children[ch - &#x27;a&#x27;] == null) cur.children[ch - &#x27;a&#x27;] = new TrieNode(); cur = cur.children[ch - &#x27;a&#x27;]; &#125; cur.isEnd = true; &#125; return root; &#125;&#125; 剑指 Offer II 066. 单词之和 方法一：前缀树 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class MapSum &#123; static class TrieNode &#123; private TrieNode[] children; private int val; public TrieNode() &#123; children = new TrieNode[26]; &#125; &#125; private TrieNode root; /** Initialize your data structure here. */ public MapSum() &#123; root = new TrieNode(); &#125; public void insert(String key, int val) &#123; TrieNode cur = root; for (char ch : key.toCharArray()) &#123; if (cur.children[ch - &#x27;a&#x27;] == null) cur.children[ch - &#x27;a&#x27;] = new TrieNode(); cur = cur.children[ch - &#x27;a&#x27;]; &#125; cur.val = val; &#125; public int sum(String prefix) &#123; TrieNode cur = root; for (char ch : prefix.toCharArray()) &#123; if (cur.children[ch - &#x27;a&#x27;] == null) return 0; cur = cur.children[ch - &#x27;a&#x27;]; &#125; return dfs(cur); &#125; private int dfs(TrieNode cur) &#123; int sum = cur.val; for (TrieNode child : cur.children) &#123; if (child != null) sum += dfs(child); &#125; return sum; &#125; public static void main(String[] args) &#123; MapSum mapSum = new MapSum(); mapSum.insert(&quot;apple&quot;, 3); mapSum.sum(&quot;ap&quot;); mapSum.insert(&quot;app&quot;, 2); mapSum.sum(&quot;ap&quot;); &#125;&#125;/** * Your MapSum object will be instantiated and called as such: * MapSum obj = new MapSum(); * obj.insert(key,val); * int param_2 = obj.sum(prefix); */ 剑指 Offer II 067. 最大的异或 方法一：前缀树 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123; static class TrieNode &#123; private TrieNode[] children; public TrieNode() &#123; children = new TrieNode[2]; &#125; &#125; public int findMaximumXOR(int[] nums) &#123; TrieNode root = buildTrie(nums); int max = 0; for (int num : nums) &#123; TrieNode cur = root; int xor = 0; for (int i = 31; i &gt;= 0; --i) &#123; int bit = (num &gt;&gt; i) &amp; 1; if (cur.children[1 - bit] != null) &#123; cur = cur.children[1 - bit]; xor = (xor &lt;&lt; 1) + 1; &#125; else &#123; cur = cur.children[bit]; xor = xor &lt;&lt; 1; &#125; &#125; max = Math.max(max, xor); &#125; return max; &#125; private TrieNode buildTrie(int[] nums) &#123; TrieNode root = new TrieNode(); for (int num : nums) &#123; TrieNode cur = root; for (int i = 31; i &gt;= 0; --i) &#123; int bit = (num &gt;&gt; i) &amp; 1; if (cur.children[bit] == null) &#123; cur.children[bit] = new TrieNode(); &#125; cur = cur.children[bit]; &#125; &#125; return root; &#125;&#125; tips 新建数组时赋值 int[] array = new int[]{3, 4}； 链表转数组 方法一： 1int[] intArray = linkedList.stream().mapToInt(Integer::intValue).toArray(); 这行代码可以分解为以下几个部分： linkedList.stream(): 将LinkedList转换为Stream。 mapToInt(Integer::intValue): 将Stream中的每一个元素转换为int类型。 Integer::intValue是一个方法引用，表示调用Integer对象的intValue()方法，将其转换为对应的int值。 toArray(): 将转换后的元素放到一个int数组中。 toArray()的作用是将Stream中的所有元素转换为一个数组，返回值是一个int[]类型的数组。 综上所述，int[] intArray = linkedList.stream().mapToInt(Integer::intValue).toArray();的语义是将LinkedList中的所有元素转换为int类型，并将其放入一个int数组中。在这个过程中，我们使用了Java 8引入的Stream API，它提供了许多方便的操作，可以简化代码的编写和调试。 方法二： 1res.toArray(new int[res.size()][]); 创建长度二维数组，其中一维数组的长度不确定 1new int[][]&#123;&#123;1, 2&#125;, &#123;3&#125;, &#123;3&#125;, &#123;&#125;&#125; char转int，String转int 1234567// 将字符转换为整数char c = &#x27;8&#x27;;int num = Character.getNumericValue(c); // num = 8// 将字符串转换为整数String str = &quot;123&quot;;int num2 = Integer.parseInt(str); // num2 = 123 String转int时，什么时候用parseInt什么时候用valueOf 在Java中，parseInt和valueOf都可以将字符串转换为整数。parseInt方法将字符串转换为基本数据类型int，而valueOf方法将字符串转换为对象类型Integer。因此，使用哪个方法取决于你要使用返回的数据类型。 如果你只需要一个基本数据类型int，那么使用parseInt是最好的选择，因为它会返回一个原始类型，不会产生额外的对象开销。 例如： java Copy code String str = \"123\"; int num = Integer.parseInt(str); 如果你需要一个对象类型Integer，则使用valueOf方法是最好的选择。valueOf方法返回一个Integer对象，这在某些情况下非常有用。 例如： java Copy code String str = \"123\"; Integer num = Integer.valueOf(str); 总之，如果你只需要一个基本数据类型，那么使用parseInt方法，否则使用valueOf方法。 使用scanner.nextLine()读取行末的换行符 1234567891011public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); scanner.nextLine(); for (int i = 0; i &lt; n; ++i) &#123; String word = scanner.nextLine(); System.out.println(&quot;word: &quot; + word); Main main = new Main(); String ans = main.process(word); System.out.println(ans); &#125; 这段代码首先从标准输入中读取一个整数n，然后通过调用scanner.nextLine()读取掉n后面的换行符。接下来，通过for循环n次，读取n行字符串，每次读取一行字符串后，调用process方法进行处理，最后将处理结果打印到标准输出中。 需要注意的是，在使用Scanner读取完整行时，由于nextInt只读取整数，因此需要在nextInt后面调用nextLine读取行末的换行符。这样做是为了防止接下来的nextLine方法误读取行末的换行符。 创建长度不同的二维数组 在Java中，可以创建长度不同的二维数组。以下是创建长度不同的二维数组的示例： 1234int[][] arr = new int[3][];arr[0] = new int[2];arr[1] = new int[3];arr[2] = new int[4]; 在这个示例中，我们创建了一个3 x n的二维数组，其中n的长度不同。第一行有两个元素，第二行有三个元素，第三行有四个元素。我们可以通过以下方式访问数组的元素： 123456789arr[0][0] = 1;arr[0][1] = 2;arr[1][0] = 3;arr[1][1] = 4;arr[1][2] = 5;arr[2][0] = 6;arr[2][1] = 7;arr[2][2] = 8;arr[2][3] = 9; 请注意，当您创建长度不同的二维数组时，每行的长度必须在运行时确定。因此，您必须在运行时动态地为每行分配内存空间。 12345678910182 1 1 2 22 1 1 1 42 1 1 2 22 2 2 1 4001 1 11 1 1 数组拷贝：ch.clone与Arrays.copyOf的区别 对基础类型的拷贝都是值传递的拷贝(深拷贝)，对对象的拷贝都是拷贝的引用(浅拷贝) IDEA创建live template 在 IntelliJ IDEA 中使用 Live Template 来创建并查集的固定代码，可以按照以下步骤进行操作： 打开 IntelliJ IDEA，进入设置面板。你可以通过点击菜单栏的 \"File\" -&gt; \"Settings\" (Windows/Linux) 或 \"IntelliJ IDEA\" -&gt; \"Preferences\" (Mac) 打开设置面板。 在设置面板中，选择 \"Editor\" -&gt; \"Live Templates\"。 在左侧的面板中，选择你想要创建代码模板的语言，比如 \"Java\"。 点击右侧面板的 \"+\" 按钮，添加一个新的模板。 在 \"Abbreviation\" 输入框中输入一个简短的缩写，用于触发代码模板。 在 \"Template text\" 输入框中输入代码模板的内容，例如： 12345678910111213141516171819202122// 并查集初始化int[] parent = new int[n];for (int i = 0; i &lt; n; i++) &#123; parent[i] = i;&#125;// 并查集查找根节点private int find(int x) &#123; if (parent[x] != x) &#123; parent[x] = find(parent[x]); &#125; return parent[x];&#125;// 并查集合并两个集合private void union(int x, int y) &#123; int rootX = find(x); int rootY = find(y); if (rootX != rootY) &#123; parent[rootX] = rootY; &#125;&#125; 点击 \"Define\" 按钮，选择模板的定义范围，比如选择 \"Java\"。 点击 \"Apply\" 或 \"OK\" 完成模板的创建。 现在，你可以在代码编辑器中输入你设定的缩写，比如 \"uf\"，然后按下 Tab 键，就会自动插入你定义的并查集代码模板。你可以根据需要修改模板中的变量名和其他细节，以适应你的项目要求。 笔试面试 5.8小红书 第一题. 第二题. 123456789101112131415161718192021222324最大最小值 时间限制： 1000MS 内存限制： 65536KB 题目描述： 有一个长度为n的序列，其中第i个元素ai，你现在可以对这个序列进行最多k次操作，每次可选择一个连续的区间将其中的元素删掉，但剩余的元素个数必须大于0。 现在想让剩余元素的最小值尽可能大，求上述情况下的最大值。 输入描述 第一行两个正整数n和k，分别表示初始序列中元素的个数以及最多的操作次数。 接下来1行，n个正整数，其中第i个数为ai。 对于所有数据，1&lt;=n&lt;=10^5，0&lt;=k&lt;=10^5，1&lt;=ai &lt;=10^6。 输出描述 输出仅包含一个正整数，表示答案。 样例输入 8 1 58 57 86 89 25 26 61 42 样例输出 58 123这道题是要求给定一个序列，你可以进行最多k次操作，每次操作可以删除序列中的某个连续区间，但是最后删除后剩余元素的最小值尽可能大。你需要输出这个最大的最小值。举个例子，对于样例输入 [58, 57, 86, 89, 25, 26, 61, 42]，可以进行1次操作，比如删除区间[86,89]，剩下的序列为[58, 57, 25, 26, 61, 42]，此时剩余元素的最小值为25，最大的最小值就是25。你需要编写一个程序来自动寻找最大的最小值。 第三题. 5.10 微众银行 第一题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293```![1](https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/1.jpg) ### 第二题![第二题](https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/第二题.jpg) ```javapackage 面试题.微众银行暑期实习.第2题;import java.lang.reflect.Array;import java.util.*;public class Main &#123; public static void main(String[] args) &#123; Main main = new Main(); Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); int k = scanner.nextInt(); scanner.nextLine(); long[] energy = new long[n], score = new long[n]; for (int i = 0; i &lt; n; ++i) &#123; energy[i] = scanner.nextLong(); &#125; scanner.nextLine(); for (int i = 0; i &lt; n; ++i) &#123; score[i] = scanner.nextLong(); &#125; long[] res = main.process(n, k, energy, score); for (long i : res) System.out.print(i + &quot; &quot;); &#125; Queue&lt;Long&gt; queue = new PriorityQueue&lt;&gt;(); private long[] process(int n, int k, long[] energy, long[] score) &#123; long[] res = new long[n]; Map&lt;Long, Long&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; n; ++i) &#123; map.put(energy[i], score[i]); &#125; long[] oriEnery = new long[n]; for (int i = 0; i &lt; n; ++i) oriEnery[i] = energy[i]; Arrays.sort(energy); for (int i = 0; i &lt; k; ++i) &#123; long s = map.get(energy[i]); queue.offer(s); &#125; long sum = map.get(energy[0]); for (int i = 1; i &lt; k; ++i) &#123; res[i] = sum; sum += map.get(energy[i]); &#125; for (int i = k; i &lt; n; ++i) &#123; res[i] = getKMax(); long s = map.get(energy[i]); if (s &gt; queue.peek()) &#123; queue.poll(); queue.offer(s); &#125; &#125; long[] res2 = new long[n]; //resAsOriginalSequence for (int i = 0; i &lt; n; ++i) &#123; long e = oriEnery[i]; int index = 0; for (; index &lt; n; ++index) &#123; if (energy[index] == e) break; &#125; res2[i] = res[index]; &#125; return res2; &#125; private int getKMax() &#123; int sum = 0; Queue&lt;Long&gt; queue2 = new PriorityQueue&lt;&gt;(); while (!queue.isEmpty()) &#123; long temp = queue.poll(); sum += temp; queue2.offer(temp); &#125; queue = queue2; return sum; &#125;&#125; 第三题 第三题","categories":[],"tags":[]}],"categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://leopol1d.github.io/categories/Algorithms/"},{"name":"Dynamic Programming","slug":"Algorithms/Dynamic-Programming","permalink":"https://leopol1d.github.io/categories/Algorithms/Dynamic-Programming/"},{"name":"Sort","slug":"Algorithms/Sort","permalink":"https://leopol1d.github.io/categories/Algorithms/Sort/"},{"name":"Sliding Window","slug":"Algorithms/Sliding-Window","permalink":"https://leopol1d.github.io/categories/Algorithms/Sliding-Window/"},{"name":"Trie","slug":"Algorithms/Trie","permalink":"https://leopol1d.github.io/categories/Algorithms/Trie/"},{"name":"Binary Search","slug":"Algorithms/Binary-Search","permalink":"https://leopol1d.github.io/categories/Algorithms/Binary-Search/"},{"name":"Graph","slug":"Algorithms/Graph","permalink":"https://leopol1d.github.io/categories/Algorithms/Graph/"},{"name":"Queue && Stack","slug":"Algorithms/Queue-Stack","permalink":"https://leopol1d.github.io/categories/Algorithms/Queue-Stack/"},{"name":"Memorization Searcch","slug":"Algorithms/Memorization-Searcch","permalink":"https://leopol1d.github.io/categories/Algorithms/Memorization-Searcch/"},{"name":"backtracking","slug":"Algorithms/backtracking","permalink":"https://leopol1d.github.io/categories/Algorithms/backtracking/"}],"tags":[{"name":"动态规划,背包问题","slug":"动态规划-背包问题","permalink":"https://leopol1d.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"name":"排序","slug":"排序","permalink":"https://leopol1d.github.io/tags/%E6%8E%92%E5%BA%8F/"},{"name":"贪心","slug":"贪心","permalink":"https://leopol1d.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"滑动窗口","slug":"滑动窗口","permalink":"https://leopol1d.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"name":"前缀树","slug":"前缀树","permalink":"https://leopol1d.github.io/tags/%E5%89%8D%E7%BC%80%E6%A0%91/"},{"name":"二分查找","slug":"二分查找","permalink":"https://leopol1d.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"图","slug":"图","permalink":"https://leopol1d.github.io/tags/%E5%9B%BE/"},{"name":"迷宫问题","slug":"迷宫问题","permalink":"https://leopol1d.github.io/tags/%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98/"},{"name":"单调栈","slug":"单调栈","permalink":"https://leopol1d.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"name":"单调队列","slug":"单调队列","permalink":"https://leopol1d.github.io/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"},{"name":"最短路","slug":"最短路","permalink":"https://leopol1d.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"最小生成树","slug":"最小生成树","permalink":"https://leopol1d.github.io/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"},{"name":"并查集","slug":"并查集","permalink":"https://leopol1d.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"拓扑排序","slug":"拓扑排序","permalink":"https://leopol1d.github.io/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"name":"动态规划","slug":"动态规划","permalink":"https://leopol1d.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"记忆化搜索","slug":"记忆化搜索","permalink":"https://leopol1d.github.io/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"},{"name":"回溯","slug":"回溯","permalink":"https://leopol1d.github.io/tags/%E5%9B%9E%E6%BA%AF/"}]}