

<!DOCTYPE html>
<html lang="zh-CN" >



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/cat-64.png">
  <link rel="icon" href="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/cat-96.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Leopold">
  <meta name="keywords" content="">
  
    <meta name="description" content="基础 面向对象 编译行 解释型 扰动函数 非核心线程：避免流量突增的场景 syschronized equals hashcode  为什么说 Java 语言“编译与解释并存”？ 编译型语言通过编译器将代码一次性翻译成可执行的机器码，优点是执行速度快，缺点是开发效率低，比如C, C++, Go都是编译型语言 解释型语言通过解释器一行一行将代码解释为机器码，优点是开发效率高，缺点是执">
<meta property="og:type" content="article">
<meta property="og:title" content="java_boilerplate">
<meta property="og:url" content="https://leopol1d.github.io/2023/07/19/java-boilerplate/index.html">
<meta property="og:site_name" content="Leopold&#39;s Blog">
<meta property="og:description" content="基础 面向对象 编译行 解释型 扰动函数 非核心线程：避免流量突增的场景 syschronized equals hashcode  为什么说 Java 语言“编译与解释并存”？ 编译型语言通过编译器将代码一次性翻译成可执行的机器码，优点是执行速度快，缺点是开发效率低，比如C, C++, Go都是编译型语言 解释型语言通过解释器一行一行将代码解释为机器码，优点是开发效率高，缺点是执">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/16fcf005591a942bbc4cfb3da7f8406.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/shallow&amp;deep-copy.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/2416f335e94c34ecb7d5863c715853b.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230823093342374.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230823095213561.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230823095749113.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230826162945478.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230826165954223.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230826172941199.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230826173400466.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230826164707703.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230826174727645.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230826175123555.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230829205143922.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230829205229829.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230829205914432.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230829211445070.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230829212038428.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230829213304295.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20231028224913373.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20231028214157972.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20231028215157407.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20231028221125079.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20231028222100011.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20231028223109714.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20231028223054676.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20231003161747627.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20231005174559182.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/%E7%94%B5%E5%95%86%E8%B4%AD%E4%B9%B0%E6%B5%81%E7%A8%8B%E5%9B%BE.drawio.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/%E8%AE%A2%E5%8D%95%E6%B5%81%E7%A8%8B.drawio.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230918203715452.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230918220118475.png">
<meta property="og:image" content="c:\Users\ning\AppData\Roaming\Typora\typora-user-images\image-20230926113627299.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230925110015823.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230927202755308.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20231007211417796.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20231029213420269.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20231009221734794.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20231009222237122.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/4589c71ae88a1764ed3aa5c6885f214.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/e1835eaabadd2916221ad1642ba41ff.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/86d2e1c20821ea067b80363a9273937.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/c7d88f1120fec552b49e656de9953b5.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/47a754a0defce1878256af29fc4d888.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/2b7bf24801f5c194cedf7b7876c7b2b.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/50c65f71c00576c19fbbe12ad43a75d.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20231029111001780.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20231106144559474.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20231108145647248.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20231113133345984.png">
<meta property="article:published_time" content="2023-07-19T12:24:32.000Z">
<meta property="article:modified_time" content="2023-11-18T03:01:13.755Z">
<meta property="article:author" content="Leopold">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/16fcf005591a942bbc4cfb3da7f8406.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>java_boilerplate - Leopold&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  



  
<link rel="stylesheet" href="/css/fluid-extension.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"leopol1d.github.io","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"left","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":1},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Leopold&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="java_boilerplate"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-07-19 20:24" pubdate>
          2023年7月19日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          32k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          267 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="padding-left: 2rem; margin-right: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">java_boilerplate</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="基础">基础</h1>
<p>面向对象 编译行 解释型 扰动函数</p>
<p>非核心线程：避免流量突增的场景</p>
<p>syschronized</p>
<p><a target="_blank" rel="noopener" href="https://www.51cto.com/article/694975.html">equals hashcode</a></p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/16fcf005591a942bbc4cfb3da7f8406.png" srcset="/img/loading.gif" lazyload style="zoom:200%;" /></p>
<h3 id="为什么说-java-语言编译与解释并存">为什么说 Java 语言“编译与解释并存”？</h3>
<p><strong>编译型语言</strong>通过<strong>编译器</strong>将代码一次性翻译成可执行的<strong>机器码</strong>，优点是执行速度快，缺点是开发效率低，比如C, C++, Go都是编译型语言</p>
<p><strong>解释型语言</strong>通过<strong>解释器</strong>一行一行将代码解释为机器码，优点是开发效率高，缺点是执行速度慢</p>
<p>Java语言在编译与解释之间做了折中，先将全部代码编译成字节码，字节码是面向JVM的，再一行一行将字节码解释为机器码</p>
<h3 id="自动装箱与拆箱了解吗原理是什么">自动装箱与拆箱了解吗？原理是什么？</h3>
<ul>
<li><strong>装箱</strong>：将基本类型包装成引用类型</li>
<li><strong>拆箱</strong>：将包引用类型转换为基本数据类型；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;  <span class="hljs-comment">//装箱</span><br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> i;   <span class="hljs-comment">//拆箱</span><br></code></pre></td></tr></table></figure>
<p>从字节码中，我们发现装箱其实就是调用了 包装类的<code>valueOf()</code>方法，拆箱其实就是调用了 <code>xxxValue()</code>方法。</p>
<ul>
<li><code>Integer i = 10</code> 等价于 <code>Integer i = Integer.valueOf(10)</code></li>
<li><code>int n = i</code> 等价于 <code>int n = i.intValue()</code>;</li>
</ul>
<h3 id="什么是面向对象什么是面向过程">什么是面向对象，什么是面向过程</h3>
<p><strong>面向对象</strong>是一种编程范式，它以对象为基础，将数据和操作数据的方法封装成一个单独的单元。</p>
<ul>
<li>面向过程把解决问题的过程拆分为一个个方法，通过顺序执行这些方法来解决问题</li>
<li>面向对象会先抽象出对象，然后通过对象执行方法来解决问题</li>
</ul>
<h2 id="封装">封装</h2>
<p>向外部隐藏类的属性，但是提供一些可以被外部访问的 方法来访问或者修改属性。</p>
<h2 id="继承">继承</h2>
<p>继承（Inheritance）：继承是指一个类（子类）继承另一个类（父类）的属性和方法。通过继承，子类可以拥有父类的特性，同时可以在父类基础上进行扩展，提高了代码的复用性。</p>
<ul>
<li>子类拥有父类的所有方法和属性。但是子类不能访问父类的私有方法和属性。</li>
<li>子类可以拥有自己的方法和属性，即扩展父类</li>
<li>子类可以重写父类的方法</li>
</ul>
<h2 id="多态">多态</h2>
<p><strong>一个对象具有多种状态，具体表现为父类引用指向子类的实例。</strong></p>
<p>特点：</p>
<ol type="1">
<li>对象实例和引用的关系是继承(类)或者实现(接口)</li>
<li>多态不能调用“子类独有方法”</li>
<li>如果子类覆盖了父类的方法，则调用的是子类覆盖的方法；否则调用的是父类的方法</li>
</ol>
<h2 id="重写与重载">重写与重载</h2>
<h3 id="重载">重载</h3>
<p>重载是指在同一个类中可以有多个同名的方法，这些方法的参数列表不同。编译器会根据参数列表来决定调用哪个方法。</p>
<ol type="1">
<li>发生在编译期，方法名相同，参数类型，参数个数，参数顺序，返回类型，访问修饰符不同</li>
<li>编译器通过不同的参数列表，找到具体要执行的那个方法</li>
</ol>
<h3 id="重写">重写</h3>
<p>子类继承父类会拥有父类的所有属性和方法，子类可以通过覆盖父类的方法，提供新的实现</p>
<ol type="1">
<li>重写发生在运行期，子类重新编写可访问的(不可重写被private,final修饰的父类方法)父类方法</li>
<li>(2同)：方法名和参数列表必须相同</li>
<li>(2小)：如果返回类型是引用对象，这个引用对象可以是父类返回类的子类；抛出的异常必须比父类抛出的异常更小</li>
<li>(1大)：访问修饰符必须大于等于父类</li>
<li>构造方法无法被重写</li>
</ol>
<h2 id="接口和抽象类">接口和抽象类</h2>
<h3 id="相同">相同：</h3>
<ol type="1">
<li>都不能被实例化</li>
<li>都可以有抽象方法</li>
<li>都可以有默认的实现方法</li>
</ol>
<h3 id="不同">不同：</h3>
<ol type="1">
<li>接口用于拓展类的行为，抽象类用于代码复用</li>
<li>一个类可以实现多个接口，只能继承一个类</li>
<li>接口中的成员变量被public static final修饰，不能被修改且必须有初始值；抽象类中的成员变量默认为default，可以在子类中被重新赋值</li>
</ol>
<h2 id="引用拷贝浅拷贝和深拷贝">引用拷贝、浅拷贝和深拷贝</h2>
<p><strong>引用拷贝</strong>：两个引用指向同一个对象</p>
<p>浅拷贝：在堆上新建一个对象，如果原对象内部有引用类型的属性，浅拷贝仅仅复制引用对象的地址，也就是说浅拷贝对象和原对象共用同一个内部对象。</p>
<p><strong>深拷贝</strong>：复制完整的对象，包括内部对象</p>
<figure>
<img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/shallow&amp;deep-copy.png" srcset="/img/loading.gif" lazyload alt="浅拷贝、深拷贝、引用拷贝示意图" /><figcaption aria-hidden="true">浅拷贝、深拷贝、引用拷贝示意图</figcaption>
</figure>
<h2 id="和-equals-的区别">== 和 equals() 的区别</h2>
<p><strong><code>==</code></strong> 对于基本类型和引用类型的作用效果是不同的：</p>
<ul>
<li>对于基本数据类型来说，<code>==</code> 比较的是值。</li>
<li>对于引用数据类型来说，<code>==</code> 比较的是对象的内存地址。</li>
</ul>
<p><code>equals()</code> 方法存在两种使用情况：</p>
<ul>
<li><strong>类没有重写 <code>equals()</code>方法</strong>：通过<code>equals()</code>比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 <code>Object</code>类<code>equals()</code>方法。</li>
<li><strong>类重写了 <code>equals()</code>方法</strong>：一般我们都重写 <code>equals()</code>方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。</li>
</ul>
<h2 id="hashcode-有什么用">hashCode() 有什么用？</h2>
<p>hashcode用于获取哈希码，可以通过哈希码获取对象的内存地址</p>
<h2 id="为什么要有-hashcode">为什么要有 hashCode</h2>
<p><strong>快速查找</strong>：在使用哈希表进行查找时，通过哈希码可以快速定位到目标对象，而不需要遍历整个集合。</p>
<ol type="1">
<li>用HashSet查重来举个例子，当加入一个元素，如果不使用HashCode，会遍历整个set，通过equals比较当前元素和set中的元素，如果相同，则不加入set中；否则加入set中。因为要遍历整个hashset，所以时间复杂度为O(n)</li>
<li>如果使用HashCode，可以将时间复杂度优化为近似O(1)。当要加入一个元素，先获取它的hashcode，如果发生哈希冲突，那么将相同hashcode的元素通过equals一一比较，如果相同则不加入，否则加入。最坏的时间复杂度是O(n)，也就是要加入的元素和HashSet中的所有元素都发生哈希冲突。</li>
</ol>
<h2 id="string-为什么是不可变的">String 为什么是不可变的?</h2>
<ol type="1">
<li>用于存储string的字符数组被private和final修饰</li>
<li>String被final修饰，不能被继承</li>
</ol>
<h2 id="string-s1-new-stringabc这句话创建了几个字符串对象">String s1 = new String("abc");这句话创建了几个字符串对象？</h2>
<p>1个或者2个，如果常量池中没有“abc”那么先在常量池中创建字符串，然后在堆中创建字符串；否则只在堆中创建</p>
<h2 id="string的intern-方法有什么作用">String的intern 方法有什么作用?</h2>
<p>它是native方法，将字符串引用保存在常量池中</p>
<ul>
<li>如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。</li>
<li>如果字符串常量池中没有保存了对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回。</li>
</ul>
<h3 id="string和stringbuilder的区别">String和StringBuilder的区别</h3>
<p><code>String</code> 和 <code>StringBuilder</code> 是 Java 中用来处理字符串的两个类，它们有很大的区别：</p>
<h3 id="string">String:</h3>
<ol type="1">
<li><p><strong>不可变性</strong>：<code>String</code> 对象一旦被创建，就不可更改。任何对字符串的操作，比如连接、截取等，都会创建新的字符串对象。这种不可变性保证了字符串对象的安全性。</p></li>
<li><p><strong>线程安全</strong>：由于不可变性，<code>String</code> 是线程安全的，多个线程可以同时访问一个字符串对象而不会出现问题。</p></li>
<li><p><strong>性能问题</strong>：由于每次操作都会创建新的字符串对象，大量的字符串操作可能导致内存消耗和性能问题，尤其是在循环中。</p></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello&quot;</span>;<br>str = str + <span class="hljs-string">&quot; World&quot;</span>; <span class="hljs-comment">// 创建了一个新的字符串对象</span><br></code></pre></td></tr></table></figure>
<h3 id="stringbuilder">StringBuilder:</h3>
<ol type="1">
<li><p><strong>可变性</strong>：<code>StringBuilder</code> 是可变的，你可以修改它的内容，而不会创建新的对象。这使得它在处理大量字符串拼接时更高效。</p></li>
<li><p><strong>线程不安全</strong>：<code>StringBuilder</code> 不是线程安全的，如果多个线程同时访问一个 <code>StringBuilder</code> 对象并且其中至少一个线程会修改该对象，必须保证外部同步。</p></li>
<li><p><strong>性能优化</strong>：由于可变性，<code>StringBuilder</code> 在大量字符串拼接时性能更好。</p></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>sb.append(<span class="hljs-string">&quot; World&quot;</span>); <span class="hljs-comment">// 修改了 StringBuilder 对象，没有创建新的对象</span><br></code></pre></td></tr></table></figure>
<p>综上，如果你需要在多线程环境中操作字符串，或者你需要进行频繁的字符串拼接，推荐使用 <code>StringBuilder</code>。如果你的字符串是常量或者不需要被修改，使用 <code>String</code> 是更安全和稳定的选择。</p>
<h2 id="反射">反射</h2>
<h3 id="博客"><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chanshuyi/p/head_first_of_reflection.html">博客</a></h3>
<p><strong>反射就是在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法。</strong></p>
<h1 id="集合">集合</h1>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/2416f335e94c34ecb7d5863c715853b.png" srcset="/img/loading.gif" lazyload style="zoom:200%;" /></p>
<h2 id="list">List</h2>
<h3 id="linkedlist与arraylist有什么区别">LinkedList与ArrayList有什么区别</h3>
<ol type="1">
<li><strong>底层实现不同：</strong>LinkedList是使用双向链表实现的，ArrayList是基于数组实现的</li>
<li><strong>插入和删除元素的时间复杂度不同</strong>：ArrayList插入尾部的时间复杂度是<span class="math inline">\(O(1)\)</span>，插入到指定下标的时间复杂度是<span class="math inline">\(O(n)\)</span>，因为需要将后面的元素往后移动。LinkedList插入或者删除首尾元素的时间复杂度都是<span class="math inline">\(O(1)\)</span>，其他位置是<span class="math inline">\(O(n)\)</span>，因为需要遍历到给定下标的前一个节点，再进行插入和删除</li>
<li>ArrayList支持快速随机访问，LinkedList不支持</li>
<li><strong>内存空间占用不同：</strong>ArrayList的尾部会预留一定的空间，LinkedList单个节点需要多占用两个指针的空间</li>
</ol>
<h2 id="map-set">Map &amp; Set</h2>
<h3 id="hashset如何检查重复">HashSet如何检查重复？</h3>
<p>首先通过对象的hashcode()方法计算出哈希码，通过哈希码找到底层数组的位置，如数组没有存储头节点的信息，那么该对象不重复；如果数组存放了头节点的内存地址，那么需要使用equals()将这些冲突的对象与当前对象进行比较，如果相等，则重复；不相等，则不重复</p>
<ol type="1">
<li><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230823093342374.png" srcset="/img/loading.gif" lazyload /></p></li>
<li><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230823095213561.png" srcset="/img/loading.gif" lazyload /></p></li>
<li><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230823095749113.png" srcset="/img/loading.gif" lazyload /></p></li>
<li><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230826162945478.png" srcset="/img/loading.gif" lazyload /></p>
<p>当进行get或者put操作时，先通过hash码得到数组的位置，这个数组元素中存储的是链表或者红黑树的头节点，在链表中操作，需要O(n)的时间复杂度，所以当链表的长度大于8，且数组的长度大于等于64时(小于64时会基于2的幂次扩容)，会将链表转成红黑树，红黑树按照key进行排序，所以红黑树中的数据是具有二段性的，可以使用二分查找进行检索，将时间复杂度降低至O(logn)</p></li>
<li><h3 id="hashset-如何检查重复">HashSet 如何检查重复?</h3>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230826165954223.png" srcset="/img/loading.gif" lazyload /></p></li>
<li><h3 id="section"></h3>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230826172941199.png" srcset="/img/loading.gif" lazyload /></p>
<p>c<img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230826173400466.png" srcset="/img/loading.gif" lazyload /></p>
<ol type="1">
<li><p>为了在计算hashcode映射到数组索引时，能通过位运算来提高效率。</p>
<p>1.一般情况下，为了得到数组的索引，需要使用<code>hashcode % length</code>(length是hashmap的大小)，取模的操作效率很低。</p>
<p>2.如果将hashmap的length设置为的2的幂次方，那么取模操作等价于<code>hashcode &amp; (length - 1)</code>，因为2的幂次方-1是一段全为1的二进制</p>
<p>3.源码通过将给定的长度 - 1，再右移，最后+1来确保hashmap的长度是2的幂次方</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230826164707703.png" srcset="/img/loading.gif" lazyload /></p></li>
<li><p>hashmap的长度设定为2的幂次方，可以提高散列的均匀性，减少哈希碰撞</p></li>
</ol></li>
<li><h3 id="hashmap-多线程操作导致死循环问题">HashMap 多线程操作导致死循环问题</h3>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230826174727645.png" srcset="/img/loading.gif" lazyload /></p>
<p>1.在jdk1.7版本，HashMap在使用拉链法时，采用头插法加入新的元素，多个线程同时操作，可能会让链表形成环</p></li>
<li><h2 id="hashmap-为什么线程不安全">HashMap 为什么线程不安全？</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230826175123555.png" srcset="/img/loading.gif" lazyload /></p></li>
</ol>
<h1 id="并发编程">并发编程</h1>
<h3 id="何为进程">何为进程?</h3>
<p>进程是程序的一次执行过程。系统运行一个程序即是一个进程从创建，运行到消亡的过程。</p>
<h3 id="何为线程">何为线程?</h3>
<p>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p>
<h3 id="请简要描述线程与进程的关系区别及优缺点">请简要描述线程与进程的关系,区别及优缺点？</h3>
<p><strong>线程是进程划分成的更小的运行单位。</strong></p>
<ol type="1">
<li><strong>线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响</strong></li>
<li><strong>线程执行开销小，但不利于资源的管理和保护；而进程正相反。</strong></li>
<li>进程切换与线程切换的一个最主要区别就在于进程切换涉及到虚拟地址空间的切换而线程切换则不会。因为每个进程都有自己的虚拟地址空间，而线程是共享所在进程的虚拟地址空间的，因此同一个进程中的线程进行线程切换时不涉及虚拟地址空间的转换。</li>
</ol>
<h3 id="程序计数器为什么是私有的">程序计数器为什么是私有的?</h3>
<p>程序计数器私有主要是为了<strong>线程切换后能恢复到正确的执行位置</strong>。</p>
<p>操作系统通过程序计数器的自增逐条读入指令，来实现代码的流程控制。</p>
<p>一个线程阻塞后，重新获得cpu时间片，会根据pc知道上次运行到哪里了。</p>
<h3 id="虚拟机栈和本地方法栈为什么是私有的">虚拟机栈和本地方法栈为什么是私有的?</h3>
<ul>
<li><strong>虚拟机栈：</strong> 每个 Java 方法在执行之前会创建一个栈帧<strong>用于存储局部变量表、操作数栈</strong>、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</li>
<li><strong>本地方法栈：</strong> 和虚拟机栈所发挥的作用非常相似，区别是：<strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li>
</ul>
<p>所以，为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的。</p>
<h3 id="并发与并行的区别">并发与并行的区别</h3>
<ul>
<li><strong>并发</strong>：两个及两个以上的作业在同一 <strong>时间段</strong> 内执行。</li>
<li><strong>并行</strong>：两个及两个以上的作业在同一 <strong>时刻</strong> 执行。</li>
</ul>
<h3 id="同步和异步的区别">同步和异步的区别</h3>
<ul>
<li><strong>同步</strong>：发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待。</li>
<li><strong>异步</strong>：调用在发出之后，不用等待返回结果，该调用直接返回。</li>
</ul>
<h3 id="为什么要使用多线程">为什么要使用多线程?</h3>
<p>多线程机制可以高系统的并发能力。</p>
<h3 id="使用多线程可能带来什么问题">使用多线程可能带来什么问题?</h3>
<p>并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：内存泄漏、死锁、线程不安全等等。</p>
<h3 id="如何理解线程安全和不安全">如何理解线程安全和不安全？</h3>
<p>线程安全和不安全是在多线程环境下对于<strong>同一份数据的访问</strong>是否能够保证其<strong>正确性</strong>和<strong>一致性</strong>的描述。</p>
<p>比如同一份数据被覆盖是不安全的。</p>
<h3 id="说说线程的生命周期和状态">说说线程的生命周期和状态?</h3>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230829205143922.png" srcset="/img/loading.gif" lazyload /></p>
<p>线程状态 blocked和waiting有什么区别</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230829205229829.png" srcset="/img/loading.gif" lazyload /></p>
<h3 id="什么是线程上下文切换">什么是线程上下文切换?</h3>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230829205914432.png" srcset="/img/loading.gif" lazyload /></p>
<p>当一个线程使用完了cpu时间片，cpu会保存现场的上下文，当下次占用CPU时，再恢复线程，继续执行</p>
<h3 id="什么是线程死锁如何避免死锁">什么是线程死锁?如何避免死锁?</h3>
<p>多个线程占有资源，并互相申请其他资源</p>
<h3 id="如何预防和避免线程死锁">如何预防和避免线程死锁?</h3>
<p>多线程产生死锁的四个必要条件</p>
<ol type="1">
<li>互斥条件：该资源任意一个时刻只由一个线程占用。</li>
<li>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li>
<li>循环等待条件:若干线程之间形成一种头尾相接的循环等待资源关系。</li>
</ol>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230829211445070.png" srcset="/img/loading.gif" lazyload /></p>
<h3 id="sleep-方法和-wait-方法对比">sleep() 方法和 wait() 方法对比</h3>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230829212038428.png" srcset="/img/loading.gif" lazyload /></p>
<h3 id="为什么-wait-方法不定义在-thread-中">为什么 wait() 方法不定义在 Thread 中？</h3>
<ul>
<li>java中的锁是针对对象的锁，wait()会释放锁，所以定义在Object中</li>
<li>需要sleep的是线程而不是对象</li>
</ul>
<h3 id="可以直接调用-thread-类的-run-方法吗">可以直接调用 Thread 类的 run 方法吗？</h3>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230829213304295.png" srcset="/img/loading.gif" lazyload /></p>
<h3 id="如何保证变量的可见性">如何保证变量的可见性</h3>
<p>在 Java 中，<code>volatile</code> 关键字可以保证变量的可见性，如果我们将变量声明为 <strong><code>volatile</code></strong> ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p>
<p><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</p>
<h3 id="如何禁止指令重排序">如何禁止指令重排序？</h3>
<p><strong><code>volatile</code> 关键字除了可以保证变量的可见性，还有一个重要的作用就是防止 JVM 的指令重排序。</strong> 如果我们将变量声明为 <strong><code>volatile</code></strong> ，在对这个变量进行读写操作的时候，会通过插入特定的 <strong>内存屏障</strong> 的方式来禁止指令重排序。</p>
<h3 id="双重校验锁实现对象单例线程安全"><strong>双重校验锁实现对象单例（线程安全）</strong></h3>
<h3 id="synchronized-和-volatile-有什么区别">synchronized 和 volatile 有什么区别？</h3>
<p><code>synchronized</code> 关键字和 <code>volatile</code> 关键字是两个互补的存在，而不是对立的存在！</p>
<ul>
<li><code>volatile</code> 关键字是线程同步的轻量级实现，所以 <code>volatile</code>性能肯定比<code>synchronized</code>关键字要好 。但是 <code>volatile</code> 关键字只能用于变量而 <code>synchronized</code> 关键字可以修饰方法以及代码块 。</li>
<li><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</li>
<li><code>volatile</code>关键字主要用于解决变量在多个线程之间的可见性，而 <code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性。</li>
</ul>
<h3 id="读锁为什么不能升级为写锁">读锁为什么不能升级为写锁？</h3>
<p>写锁是独占锁，读锁是共享锁，如果读锁都申请升级为写锁，那么会引起线程的争夺，还可能会导致死锁。</p>
<h2 id="reentrantlock"><a target="_blank" rel="noopener" href="https://javaguide.cn/java/concurrent/java-concurrent-questions-02.html#reentrantlock"></a>ReentrantLock</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20231028224913373.png" srcset="/img/loading.gif" lazyload /></p>
<p>ReentrantLock可以使用newCondition方法，在特定条件下挂起或者唤醒线程，更加灵活</p>
<h2 id="synchronized">Synchronized</h2>
<p>在Java早期版本，synchronized属于重量级锁，效率低下。原因是monitor是依赖于底层操作系统的<strong>mutex lock</strong>实现的，如果要挂起或者唤醒线程(切换线程)都需要操作系统从用户态转换到内核态来处理，非常消耗时间。</p>
<h4 id="jdk1.6-之后的-synchronized-底层做了哪些优化">JDK1.6 之后的 synchronized 底层做了哪些优化？</h4>
<p>偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除(同步代码块内没有临界资源)、锁粗化(在循环内获取锁：把锁放到循环外层)等技术来减少锁操作的开销。</p>
<h4 id="讲一下synchronized锁升级">讲一下synchronized锁升级</h4>
<p>在Java中，<code>synchronized</code>锁有四个状态，它们是无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。</p>
<ol type="1">
<li><p><strong>无锁状态（Uncontended State）</strong>：当一个线程尝试获取锁时，如果该锁当前没有被其他线程持有，那么获取锁的操作是成功的，不需要进入等待状态。这是最快的情况，因为线程不需要等待。</p></li>
<li><p><strong>偏向锁状态（Biased Locking）</strong>：在无锁状态下，如果某个线程获取了锁，那么该锁会进入偏向锁状态。偏向锁意味着该锁会偏向于第一个获取它的线程。当这个线程再次请求锁时，不需要进行同步操作，提高了性能。如果有其他线程尝试获取该锁，偏向锁就会升级为轻量级锁。</p></li>
<li><p><strong>轻量级锁状态（Lightweight Locking）</strong>：当偏向锁被其他线程访问时，它就会升级为轻量级锁。轻量级锁使用CAS（Compare And Swap）操作来在竞争激烈的情况下避免传统的互斥量操作，提高了性能。如果自旋一定次数后还不能获取锁，锁就会升级为重量级锁。</p></li>
<li><p><strong>重量级锁状态（Heavyweight Locking）</strong>：如果轻量级锁尝试自旋等待仍然无法获得锁，那么锁就会升级为重量级锁。重量级锁会使得其他竞争线程进入阻塞状态，性能开销比较大。</p></li>
</ol>
<p>这种锁的升级机制保证了在低竞争情况下，锁的获取和释放非常快速（无锁、偏向锁、轻量级锁），而在高竞争情况下（重量级锁），锁的竞争和等待机制可以保证数据的安全性。</p>
<h4 id="synchronized-底层原理了解吗">synchronized 底层原理了解吗？</h4>
<p><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</p>
<ol type="1">
<li>在执行monitorenter时，线程会尝试获取锁，如果锁计数器为0，表示锁可以获取，线程在拿到锁之后，会将锁的计数器置为1；如果获取锁失败，线程会进入阻塞状态，直到锁被其他线程释放</li>
<li>持有锁的线程执行moniterexit指令时，会将锁的计数器置为0，并释放锁</li>
</ol>
<h2 id="线程池">线程池</h2>
<h3 id="拒绝策略">拒绝策略</h3>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20231028214157972.png" srcset="/img/loading.gif" lazyload /></p>
<ol type="1">
<li>抛出异常</li>
<li>调用线程(提交任务的线程)来执行任务</li>
<li>丢弃阻塞队列中最后一个线程，将当前线程加入阻塞队列</li>
<li>直接丢弃任务</li>
</ol>
<h3 id="不使用自带线程池的原因">不使用自带线程池的原因</h3>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20231028215157407.png" srcset="/img/loading.gif" lazyload /></p>
<h3 id="线程的两种创建方式">线程的两种创建方式</h3>
<ol type="1">
<li><p>使用Executors种内置的线程池</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20231028221125079.png" srcset="/img/loading.gif" lazyload /></p></li>
<li><p><strong>通过<code>ThreadPoolExecutor</code>构造函数来创建（推荐）。</strong></p>
<p>线程池的7个参数分别是</p>
<ul>
<li><code>corePoolSize</code>: 核心线程数</li>
<li><code>maximumPoolSize</code>：最大线程数</li>
<li><code>keepAliveTime</code> : 非核心线程(空闲时)存活时间</li>
<li><code>unit</code>: 等待时间的单位为 TimeUnit.SECONDS。</li>
<li><code>workQueue</code>：阻塞队列</li>
<li><code>handler</code>:拒绝策略</li>
<li>threadFactory:用于创建线程的线程工厂</li>
</ul>
<h3 id="线程池流程">线程池流程</h3>
<p>当有任务提交时</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20231028222100011.png" srcset="/img/loading.gif" lazyload /></p>
<h2 id="aqs">AQS</h2>
<p>AbstractQueuedSynchronizer（AQS）是一种基于队列的同步器框架，用于实现各种同步机制，如锁和信号量。AQS的原理可以概括为以下几个关键要点：</p>
<ol type="1">
<li><p>状态管理：AQS内部维护了一个整型的状态变量，表示共享资源的状态。通过对状态的合理定义和管理，AQS可以实现不同的同步机制。例如，对于独占锁，状态为0表示未锁定，为1表示已锁定；对于共享锁，状态可以表示当前持有锁的数量。</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20231028223109714.png" srcset="/img/loading.gif" lazyload /></p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20231028223054676.png" srcset="/img/loading.gif" lazyload /></p></li>
<li><p>队列管理：AQS使用一个FIFO（先进先出）的等待队列来管理线程的竞争和等待。当一个线程请求获取锁或资源时，如果失败了，它会被包装成一个等待节点（Node）并加入到等待队列中。(一个节点表示一个线程，它保存着线程的引用（thread）、 当前节点在队列中的状态（waitStatus）、前驱节点（prev）、后继节点（next）。)</p></li>
</ol></li>
</ol>
<h1 id="计算机网络">计算机网络</h1>
<ol type="1">
<li><h3 id="uri-和-url-的区别是什么">URI 和 URL 的区别是什么?</h3>
<ul>
<li>URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。</li>
<li>URL(Uniform Resource Locator) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。</li>
</ul>
<p>总结起来，URI是一个通用的标识符，用于唯一标识任何资源，而URL是URI的一个特定子集，用于唯一标识互联网上资源的位置和访问方式。URI可以包括URL，也可以包括URN，而URL只是一种特定类型的URI，用于定位和访问资源。</p></li>
<li><h3 id="get-和-post-的区别">GET 和 POST 的区别</h3>
<p>GET 和 POST 是 HTTP 协议中两种常用的请求方法，它们在不同的场景和目的下有不同的特点和用法。一般来说，可以从以下几个方面来区分二者（重点搞清两者在语义上的区别即可）：</p>
<ul>
<li>语义（主要区别）：GET 通常用于获取或查询资源，而 POST 通常用于创建或修改资源。</li>
<li>幂等：GET 请求是幂等的，即多次重复执行不会改变资源的状态，而 POST 请求是不幂等的，即每次执行可能会产生不同的结果或影响资源的状态。</li>
<li>格式：GET 请求的参数通常放在 URL 中，形成查询字符串（querystring），而 POST 请求的参数通常放在请求体（body）中，可以有多种编码格式，如 application/x-www-form-urlencoded、multipart/form-data、application/json 等。GET 请求的 URL 长度受到浏览器和服务器的限制，而 POST 请求的 body 大小则没有明确的限制。不过，实际上 GET 请求也可以用 body 传输数据，只是并不推荐这样做，因为这样可能会导致一些兼容性或者语义上的问题。</li>
<li>缓存：由于 <strong>GET</strong> 请求是幂等的，它<strong>可以被浏览器或其他中间节点（如代理、网关）缓存起来，以提高性能和效率</strong>。而 POST 请求则不适合被缓存，因为它可能有副作用，每次执行可能需要实时的响应。</li>
<li>安全性：GET 请求和 POST 请求如果使用 HTTP 协议的话，那都不安全，因为 HTTP 协议本身是明文传输的，必须使用 HTTPS 协议来加密传输数据。另外，GET 请求相比 POST 请求更容易泄露敏感数据，因为 GET 请求的参数通常放在 URL 中。</li>
</ul>
<p>再次提示，重点搞清两者在语义上的区别即可，实际使用过程中，也是通过语义来区分使用 GET 还是 POST。不过，也有一些项目所有的请求都用 POST，这个并不是固定的，项目组达成共识即可。</p></li>
<li><h3 id="natnetwork-address-translation-网络地址转换协议">NAT(Network Address Translation) 网络地址转换协议</h3>
<ol type="1">
<li>概念：NAT将专用网络地址转换为公用地址。只需要一个IP地址就能使专用网中所有的主机(端口号有16位，最多<span class="math inline">\(2^{16}台主机\)</span>)与公网连接，大大节省了IP地址的消耗。同时，NAT隐藏了内部网络结构，从而降低了内部网络受到攻击的风险。</li>
<li>原理：NAT路由器使用NAT转换表将本地IP地址以及端口号转换为全球IP地址以及端口号，或者将全球IP地址以及端口号转换为本地IP地址以及端口号。NAT转换表存放着{本地IP地址：端口号}到{全球IP地址：端口号}的映射，通过这个映射保证主机与外部的通信。</li>
<li>由于NAT涉及到了端口号(传输层)，所以NAT协议在网络层与传输层之间。</li>
</ol></li>
</ol>
<p>ping命令是基于<strong>ICMP协议</strong>，是“Internet Control Message Protocol”（Internet控制消息协议）的缩写，是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。 控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20231003161747627.png" srcset="/img/loading.gif" lazyload style="zoom:200%;" /></p>
<p><strong>确保被动关闭TCP连接的一端能收到第四次挥手的ACK</strong>. <strong>避免上一次TCP连接的数据包影响到下一次的TCP连接</strong></p>
<h3 id="计算机网络为什么要分层">计算机网络为什么要分层</h3>
<p><strong>分层可以将庞大复杂的问题，转化成若干个较小的局部问题，这些较小的局部问题更加容易研究和处理</strong>。</p>
<h3 id="出现大量的time_wait如何处理">出现大量的time_wait如何处理</h3>
<p>服务端：<strong>复用处于 TIME_WAIT 的 socket 为新的连接所用</strong>。</p>
<p><strong>客户端</strong>：HTTP 请求的头部，connection 设置为 keep-alive，保持存活一段时间：现在的浏览器，一般都这么进行了</p>
<h2 id="http">HTTP</h2>
<h3 id="http-基本概念">HTTP 基本概念</h3>
<p>Http是在两点之间传输文字、图片、音频、视频等超文本数据的<strong>约束和规范</strong></p>
<h3 id="http-常见的状态码有哪些">HTTP 常见的状态码有哪些？</h3>
<ol type="1">
<li><p>1开头的状态码一般表示提示信息</p></li>
<li><p>2开头的状态码一般表示服务器成功处理了客户端的请求，比如<code>200 OK</code>，<code>204 No Content</code>与200相似，只是响应头没有body数据</p></li>
<li><p>3开头的状态码一般表示重定向</p></li>
<li><p>4开头的状态码一般表示客服端发送的申请错误，比如<code>404 Not Found</code>表示请求的资源在服务器上不存在，<code>403 Forbidden</code>表示服务器上的资源禁止访问</p></li>
<li><p>5开头的状态码一般表示客户端的申请正确，但是服务器处理时内部发生了错误，比如<code>500 Internal Server Error</code>，</p>
<p><code>501 Not Implemented</code>表示客户端请求的功能还没有实现。</p></li>
</ol>
<h3 id="http常见的报文头字段有哪些">HTTP常见的(报文头)字段有哪些</h3>
<ol type="1">
<li><code>host</code>：表示域名，有了host字段，客户端就可以向同一台服务器的不同网站发出请求</li>
<li><code>connection</code>：主要用于使用长连接，需要将conneciton字段设置为<code>keep alive</code>。使用HTTP长连接，可以发出多次请求，而不用重复的创建TCP连接和释放TCP连接。HTTP长连接的特点是：只要服务器客户端没有提出断开连接，则保持TCP连接状态</li>
<li><code>Content Length</code>：表示数据的长度</li>
<li><code>Content Type</code>：数据类型，比如content type: text/html; charset=utf-8</li>
<li><code>Content Encoding</code>：数据的压缩方式，比如gzip</li>
</ol>
<h3 id="请求方式有哪些">请求方式有哪些</h3>
<ol type="1">
<li><p><strong>Get</strong>：Get的语义是客户端向服务端获取指定的资源。Get的请求参数一般写在URL中，请求参数必须是ASCII字符，并且浏览器会对请求参数的大小做限制。</p></li>
<li><p><strong>Post</strong>：Post的语义是客户端向服务端申请处理指定的资源。Post的请求参数一般是在报文的body中，请求参数可以是任意类型，并且浏览器不会对body大小做限制。</p>
<p><strong>幂等</strong>：多次执行相同的操作，会得到相同的结果。</p></li>
</ol>
<h3 id="http1.1http2http3-演变">HTTP/1.1、HTTP/2、HTTP/3 演变</h3>
<ul>
<li><strong>HTTP/1.1</strong>：
<ol type="1">
<li>使用长连接改善了性能开销</li>
<li>管道网络运输：解决了HTTP/1.0对头阻塞问题，HTTP/1.0是基于请求-响应模式的，客户端发送一个请求，必须接收到服务端的响应才能发送下一个请求。1.1使用管道网络运输，客户端发送一个请求后，无需等待服务器的响应，可以继续发送下一个请求。</li>
</ol></li>
<li><strong>HTTP/2</strong>
<ol type="1">
<li>对报头进行压缩，客户端和服务器共同维护一张头部信息表，只需要发送报头的索引而不需要发送完整的头部信息</li>
<li>采用二进制格式，相比HTTP/1采用文本格式，HTTP2采用二进制格式进行传输的效率更高</li>
<li><strong>多路复用</strong>，一个TCP连接可以复用多个Stream，每个Stream可以传输一条或者多条消息。针对不同的HTTP请求，Stream使用独一无二的ID标识，接收端可以利用这些标识拼接消息，所以HTTP/2.0可以实现乱序发送，并发地传输消息。</li>
<li>服务器可以主动发送消息，在HTTP/1中，服务器只能被动响应，不能主动发送消息。</li>
</ol></li>
</ul>
<h2 id="tcp">TCP</h2>
<h3 id="超时重传快重传选择重传">超时重传、快重传、选择重传</h3>
<p><strong>超时重传</strong>：当超过超时重传计时器指定的时间，没有收到对方的ACK报文，就会重传这个该数据。TCP会在数据包丢失、确认应答包丢失时超时重传。</p>
<p><strong>快重传：</strong>弥补超时重传太慢的缺点，每当发送方连续收到三个冗余的ACK报文，就知道该报文丢失了，并重传该报文。</p>
<p><strong>选择性确认：</strong>快重传可能需要将当前报文之后的所有报文都重传，选择性确认就是解决这个问题的。这种方式需要在TCP头部的选项部分选中<code>SACK</code>，它可以将已收到数据的信息发送给发送方，那么发送方只需要重传丢失的报文，而不是所有报文。</p>
<h3 id="流量控制">流量控制</h3>
<p><strong>TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。</strong></p>
<h3 id="拥塞控制">拥塞控制</h3>
<p>流量控制是对于接收方和发送方两点，避免发送方传输速率过快导致接收方被数据淹没。</p>
<p>拥塞控制是针对整合计算机网络全局。<strong>拥塞控制是为了避免发送方的数据填满整个网络。</strong></p>
<p><strong>慢开始：</strong>发送方每收到一个ACK报文，拥塞窗口大小加一(cwnd)，所以慢开始阶段拥塞窗口呈指数增长</p>
<p><strong>拥塞避免：</strong>当拥塞窗口大于等于门限值(ssthread)，切换为拥塞避免算法，发送方每收到一个ACK报文，拥塞窗口大小增加1 / 拥塞窗口大小，也就是说在拥塞避免阶段，拥塞窗口大小呈线性增长。</p>
<p>当发生了超时重传或者快重传，说明网络出现拥塞。</p>
<p><strong>超时重传-&gt;拥塞发生：</strong>如果发生了超时重传，那么将门限值设置为当前拥塞窗口的大小的一半，并且将拥塞窗口大小设置为1。</p>
<p><strong>快重传-&gt;快恢复：</strong>如果发生了快重传，那么发送方会收到三个连续冗余的ACK报文，既然这三个报文没有丢失，那么说明网络也不是特别拥塞，所以将门限值和拥塞窗口设置为当前拥塞窗口的一半，并且重传数据，当收到了新数据的ACK报文，将拥塞窗口大小设置为当前门限值，并且切换为拥塞避免算法。</p>
<h3 id="头格式">头格式</h3>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20231005174559182.png" srcset="/img/loading.gif" lazyload /></p>
<p>首先是源端口号和目的端口号，序列号，确认应答号，其次是首部长度，保留位，控制位，窗口大小。</p>
<p><strong>序列号可以解决数据报乱序问题，确认应答号可以解决丢包问题</strong></p>
<h3 id="什么是-tcp">什么是 TCP ？</h3>
<p>Tcp的全称是Transmission Control Protocol，<strong>tcp是基于字节流，面向连接，提供可靠传输的通信协议。</strong></p>
<h3 id="什么是tcp连接">什么是TCP连接？</h3>
<p><strong>TCP连接是为了可靠性和流量控制而维护的某些状态信息，这些状态信息的组合，包括socket，序列号和窗口大小，被称为连接</strong></p>
<h3 id="udp-和-tcp-有什么区别呢分别的应用场景是">UDP 和 TCP 有什么区别呢？分别的应用场景是？</h3>
<p>TCP（Transmission Control Protocol）和UDP（User Datagram Protocol）是两种常见的传输层协议，用于在计算机网络中传输数据。它们在以下几个方面有所区别：</p>
<ol type="1">
<li><p>连接导向 vs. 无连接：TCP是一种面向连接的协议，它在通信之前需要建立一个可靠的连接，通过三次握手确保双方的通信可靠性。而UDP是一种无连接的协议，发送数据之前不需要建立连接，每个数据报都是独立的，不与其他数据报相关联。</p></li>
<li><p>可靠性：TCP提供可靠的数据传输，通过序列号、确认应答和重传机制来确保数据的完整性和正确性。它会自动处理丢包、重复数据、乱序等问题，以保证数据的有序传输和完整性。而UDP不提供可靠性保证，它只是简单地将数据报发送出去，不关心是否到达目的地，也不进行重传。</p></li>
<li><p>消息边界：TCP是一种面向字节流的协议，它将数据视为一连串的字节流，并没有消息边界的概念。应用程序需要自行解析接收到的字节流。而UDP是基于数据报的协议，每个数据报都有固定的大小和边界，应用程序可以根据数据报的边界来解析接收到的数据。</p></li>
<li><p>延迟和带宽：由于TCP提供可靠性保证和流量控制机制，它通常具有较高的延迟。TCP会等待确认应答，以确保数据的可靠性，这可能会导致一定的延迟。而UDP没有确认机制，它具有较低的延迟，适用于实时性要求较高的应用场景。UDP也没有流量控制机制，因此可以支持更高的带宽。</p></li>
<li><p>应用场景：由于TCP的可靠性和连接导向特性，它常用于传输重要的数据，如文件传输、网页浏览、电子邮件等。UDP则常用于实时应用，如音视频传输、实时游戏、实时通信等，对于实时性要求高、丢失一些数据也可以容忍的场景。</p></li>
</ol>
<p>总体而言，TCP和UDP是两种不同的传输层协议，具有不同的特性和适用场景。选择使用哪种协议取决于应用程序的需求，需要权衡可靠性、延迟、带宽和实时性等因素。</p>
<h3 id="键入网址到网页显示期间发生了什么">键入网址到网页显示，期间发生了什么？</h3>
<p>当你在浏览器中键入网址并按下回车后，以下是发生的一些主要步骤：</p>
<ol type="1">
<li><p>URL 解析：浏览器会解析输入的网址（URL），分析其中的协议（如 HTTP、HTTPS）、主机名（例如 www.example.com）和路径等信息。</p></li>
<li><p>DNS 解析：浏览器需要将主机名解析为相应的 IP 地址，以便能够与服务器建立连接。浏览器会向本地 DNS 缓存查询，如果缓存中没有对应的 IP 地址，浏览器会发送 DNS 查询请求到 DNS 服务器，获取相应的 IP 地址。</p></li>
<li><p>建立连接：浏览器使用解析得到的 IP 地址与服务器建立 TCP 连接。这是通过进行三次握手来建立可靠的连接。</p></li>
<li><p>发起请求：建立连接后，浏览器会发送一个 HTTP 请求给服务器。该请求包括请求方法（如 GET、POST）、路径、请求头（如 Accept、User-Agent）和请求体（对于 POST 请求）等信息。</p></li>
<li><p>服务器处理请求：服务器接收到浏览器发送的请求后，会根据请求的路径和其他信息进行处理。这可能涉及到后台代码的执行、数据库查询、文件读取等操作。</p></li>
<li><p>服务器响应：服务器处理完请求后，会生成一个 HTTP 响应，包括状态码（如 200 OK、404 Not Found）、响应头（如 Content-Type、Cache-Control）和响应体（包含请求的数据或错误信息）等。</p></li>
<li><p>响应传输：服务器将生成的 HTTP 响应通过建立的 TCP 连接回传给浏览器。</p></li>
<li><p>浏览器渲染：浏览器接收到服务器的响应后，会解析响应的内容，根据 HTML、CSS 和 JavaScript 等信息进行页面的渲染，将网页呈现给用户。</p></li>
<li><p>关闭连接：页面渲染完成后，浏览器会关闭与服务器的连接，释放资源。</p></li>
</ol>
<p>这是一个简化的过程描述，实际上还涉及到更多的细节和步骤，如缓存处理、重定向、Cookie 交互等。但以上步骤概括了键入网址到网页显示期间的主要过程。</p>
<h1 id="redis">Redis</h1>
<h2 id="redis-数据结构">Redis 数据结构</h2>
<ol type="1">
<li>String :缓存对象，计数，<strong>分布式锁</strong>，共享session</li>
<li>List：消息队列</li>
<li>Hash Table：缓存对象，购物车</li>
<li>Set：<strong>点赞</strong>，共同关注，抽奖</li>
<li>zSet 有序集合：排序场景，如排行榜，电话姓名排序</li>
<li>BitMap：二值状态场景，比如签到、判断用户登录状态</li>
<li>HyperLogLog：海量数据基数统计</li>
<li>Geo：存储地理信息的场景，如嘀嘀打车</li>
<li>Stream：消息队列</li>
</ol>
<h2 id="redis-过期删除与内存淘汰">Redis 过期删除与内存淘汰</h2>
<p>Redis 中的过期删除（Expiration）和内存淘汰（Eviction）是两种不同的机制，用于管理内存中的数据。</p>
<ol type="1">
<li>过期删除（Expiration）：Redis 允许为每个键设置过期时间。一旦键过期，Redis 会自动将其删除。过期删除是基于时间的机制，Redis 会在每次访问键时检查其过期时间，并在需要时将过期的键删除。过期删除是一种主动机制，确保数据在一定时间后被自动清除。</li>
<li>内存淘汰（Eviction）：当 Redis 的内存使用达到配置的最大限制时，内存淘汰机制会启动。内存淘汰用于在 Redis 内存不足时，根据一定的策略删除一些键值对以释放内存空间。常见的内存淘汰策略包括 LRU（最近最少使用）、LFU（最少使用）、LRU-K 等。通过选择适当的淘汰策略，Redis 可以根据访问模式和键的使用频率来决定删除哪些键以释放内存。</li>
</ol>
<p>区别：</p>
<ul>
<li>过期删除是基于键的过期时间，一旦过期时间到达，键会被自动删除。</li>
<li>内存淘汰是基于内存使用情况，当 Redis 的内存达到限制时，按照指定的策略删除一些键以释放内存空间。</li>
<li>过期删除是一种主动机制，与键的过期时间相关，而内存淘汰是一种被动机制，与内存使用情况相关。</li>
<li>过期删除确保在键过期后及时删除数据，而内存淘汰用于在内存不足时选择合适的键进行删除。</li>
</ul>
<p>通常情况下，过期删除和内存淘汰结合使用可以有效地管理 Redis 中的数据，以控制内存使用并保持数据的新鲜性。</p>
<h3 id="redis-使用的过期删除策略是什么"><a target="_blank" rel="noopener" href="https://xiaolincoding.com/redis/base/redis_interview.html#redis-使用的过期删除策略是什么">#</a>Redis 使用的过期删除策略是什么？</h3>
<h1 id="项目">项目</h1>
<ol type="1">
<li><p>梳理一遍功能的业务流程，比如登录的流程，登录功能怎么做的</p></li>
<li><p>注册流程怎么做的，注册是以邮箱或者手机号为标识，如果加入手机号登录，怎么说，手机号要钱，邮箱不要钱，如何限制一个手机号登录次数，比如如何防止爬虫：前端限制，后端校验</p></li>
<li><p>下单功能，拦截器理一遍</p></li>
<li><p>浏览商品，加入购物车的逻辑</p></li>
<li><p>下单的逻辑</p></li>
<li><p>支付是不能同步的，还是异步</p></li>
<li><p>支付防止重复支付，加分布式锁</p></li>
<li><p>订单过期没支付怎么办</p></li>
<li><p>考虑秒杀场景，15个人抢10个商品，加锁</p></li>
<li><p>表设计：订单有几张表，字段，关联</p></li>
<li><p>评价表：加点赞功能，redis set做点赞</p></li>
<li><p>评价的评价怎么做：折叠评论，分层设计</p></li>
<li><p>elasticsearch新增数据怎么处理，打包成一个事务， 异步，扔到kafka, 或者用canal框架</p></li>
<li><p>订单表会越来越大，怎么分表</p></li>
<li><p>商品，redis 和mysql的一致性</p></li>
<li><p>​</p></li>
</ol>
<h2 id="注册">注册</h2>
<ol type="1">
<li><p>点击注册按钮，调用vue的register方法，对用户名、密码、确认密码进行为空校验，如果为空，提示错误信息；检查密码和确认密码是否一致</p></li>
<li><p>将vue的user对象异步发送到地址foreregister，导致controller中的register方法被调用</p></li>
<li><p>通过发送的user，获取浏览器提交的用户名和密码，将用户名的特殊符号进行转义(在恶意注册的时候，会使用诸如</p>
<script>alert('papapa')</script>
<p>这样的名称，会导致网页打开就弹出一个对话框)， 判断是否存在该用户名，如果存在，返回错误信息；<strong>否则随机生成一个盐，使用md5的加密方式进行两次迭代，得到加密后的密码，将加密后的密码和盐写入数据库中。</strong></p>
<p>加密的过程类似于炒菜，原材料相当于是原始密码，迭代的次数表示对原材料进行翻滚的次数，并在翻滚的过程中加入不同的盐，最后得到的加密后的密码。即使两个账号的初始密码是相同的，但是盐不同，得到的加密后的密码也不同。</p></li>
</ol>
<h2 id="登录">登录</h2>
<ol type="1">
<li>点击登录按钮，调用vue的login方法，对用户名和密码进行为空校验，如果为空，显示错误信息</li>
<li>将vue的user对象异步发送到forelogin路径，导致controller的login方法被调用，将用户名的特殊符号进行转义，通过用户名和密码在数据库中查询，如果查询到该用户，则把用户加入到session中；否则返回错误信息</li>
</ol>
<p>退出的话，把session中的user移除即可</p>
<h2 id="登录状态拦截器">登录状态拦截器</h2>
<p>当访问需要登录的页面时，判断是否登录，如果未登录，跳转到登录页面</p>
<p>不需要登陆的页面：首页、注册、登录、产品页、分类、查询</p>
<p>需要登陆的页面：立即购买，加入购物车，查看购物车，我的订单</p>
<p>判断访问路径是否是需要登录的路径，如果是，如“buy”，则判断是否登录，未登录跳转至登录页面</p>
<h2 id="浏览商品">浏览商品</h2>
<ol type="1">
<li>点击产品，导致controller中的product方法被调用</li>
<li>根据pid获得产品对象</li>
<li>根据产品对象获得产品对应的图片集合，属性值集合，评论集合，销量和评论数量</li>
<li>把产品，属性值，评论集合存在map(浏览器方便识别键值对)中，返回给浏览器</li>
</ol>
<h2 id="购物流程-和-订单流程">购物流程 和 订单流程</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/电商购买流程图.drawio.png" srcset="/img/loading.gif" lazyload /></p>
<figure>
<img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/订单流程.drawio.png" srcset="/img/loading.gif" lazyload alt="订单流程.drawio" /><figcaption aria-hidden="true">订单流程.drawio</figcaption>
</figure>
<h2 id="立即购买">立即购买</h2>
<ol type="1">
<li>生成新的订单项插入到数据库中</li>
<li>返回当前的订单项id</li>
<li>页面拿到订单项id，跳转到结算页面</li>
</ol>
<h2 id="加入购物车">加入购物车</h2>
<ul>
<li><p>如果商品在购物车中，那么调整商品的数量</p>
<p>查询该用户订单为空的订单项集合，如果存在一样的商品，则在购物车中</p></li>
<li><p>如果商品不在购物车中，那么生成新的订单项，插入到数据库中</p></li>
<li><p>不会跳转页面</p>
<p><strong>用redis hash的话，除了第一次加入购物车，之后加入购物车查询是否有相同商品的时间复杂度可以降至O(1)，查看购物车也可以直接从缓存中取数据，不用去数据库中查</strong></p></li>
</ul>
<h2 id="查看购物车">查看购物车</h2>
<ol type="1">
<li>通过session获得当前用户</li>
<li>拿到当前用户订单为空的订单项(未生成订单)</li>
<li>返回订单项集合给浏览器</li>
</ol>
<h2 id="结算">结算</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230918203715452.png" srcset="/img/loading.gif" lazyload /></p>
<ol type="1">
<li>通过订单项id集合，异步拿到所有产品数据，渲染在页面上</li>
<li>点击提交，会从数据库中查询出所有的订单项，计算价格总和total</li>
<li>将订单项集合与总价放入session中</li>
<li>将订单项集合与价格总和放入map中返回</li>
</ol>
<h2 id="下单">下单</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230918220118475.png" srcset="/img/loading.gif" lazyload /></p>
<h3 id="生成订单">生成订单</h3>
<ol type="1">
<li>通过购买或者购物车提交进入到结算页面，在结算页面点击提交订单导致controller中的createOrder方法被调用</li>
<li>生成一个订单号</li>
<li>将订单状态设置未等待支付</li>
<li>从session中获取user对象，订单项集合和总价，设置订单项的订单(这是事务操作，要么所有的订单项都设置订单，要么都不设置)，订单项被设置了订单后，将不能在购物车中查询到，更新订单项到数据库</li>
<li>插入订单到数据库</li>
<li>返回总金额</li>
</ol>
<h3 id="支付">支付</h3>
<p>在生成订单页面点击支付后，跳转到支付页面，显示待支付总金额，已经确认支付按钮(没有真正实现支付，点一下就算支付了)</p>
<h3 id="支付成功">支付成功</h3>
<p>确认支付后，跳转到支付成功页面</p>
<ol type="1">
<li>设置支付时间</li>
<li>修改订单的状态为待发货</li>
<li>更新到数据库</li>
<li><strong>后端订单管理发货</strong></li>
</ol>
<h3 id="我的订单页面">我的订单页面</h3>
<p>通过session获取用户，查询该用户的所有订单并渲染</p>
<h3 id="确认收货">确认收货</h3>
<ol type="1">
<li>将订单添加确认收货时间</li>
<li>将订单的状态改为待评价</li>
<li>在数据库更新订单</li>
</ol>
<h3 id="评价">评价</h3>
<ol type="1">
<li>修改订单状态为完成，在数据库更新订单</li>
<li>新建一个评价类，设置产品，评价内容，用户，日期，写入数据库</li>
</ol>
<h2 id="shiro权限验证">Shiro权限验证</h2>
<p>权限验证：账号密码是否有资格登录，没有做权限分配(vip用户可以获取更多资源)</p>
<p>用户表增加盐字段，对用户密码带盐加密</p>
<p>使用md5加密，进行2次迭代</p>
<p>加密过程类似于炒菜，对不同的原材料(原始密码)翻腾数次(迭代次数)，每次翻腾加入不同的盐，最后得到的食物口感是不同的</p>
<p>用subject.isAuthencated()判断是否登录</p>
<h2 id="redis缓存">Redis缓存</h2>
<p>Redis 缓存与分页数据不一致</p>
<h2 id="elasticsearch">Elasticsearch</h2>
<ol type="1">
<li>产品的增删改与mysql同步</li>
<li>初始化，将所有的产品写入es</li>
</ol>
<h2 id="表设计">表设计</h2>
<ol type="1">
<li><span class="citation" data-cites="requesbody">@requesbody</span> 是用来把json格式转换为java对象 2. <span class="citation" data-cites="responseBody">@responseBody</span> 是用来把 java对象转换为json格式 两个互为相反的作用。</li>
</ol>
<h1 id="多益面试">多益面试</h1>
<ul class="task-list">
<li><p><input type="checkbox" disabled="" />
TCP</p></li>
<li><p><input type="checkbox" disabled="" />
进程如何通信</p><p><img src="C:\Users\ning\AppData\Roaming\Typora\typora-user-images\image-20230926113627299.png" srcset="/img/loading.gif" lazyload /></p></li>
<li><p><input type="checkbox" disabled="" />
创建一个对象有哪几种方式</p><p>1、使用new关键字；2、使用Class类的newInstance()方法；3、使用构造方法类的newInstance()方法；4、使用clone()方法；5、使用反序列化。</p></li>
<li><p><input type="checkbox" disabled="" />
object有哪些方法</p><p>equals，hashcode, wait, notify, notifyAll</p></li>
<li><p><input type="checkbox" disabled="" />
sleep wait</p></li>
<li><p><input type="checkbox" disabled="" />
sleep和wait使用了会进行什么状态转化</p></li>
<li><p><input type="checkbox" disabled="" />
<strong>自我介绍</strong></p></li>
<li><p><input type="checkbox" disabled="" />
<strong>项目相关（10分钟）</strong></p></li>
<li><p><input type="checkbox" disabled="" checked="" />
<strong>深拷贝和浅拷贝的区别</strong></p></li>
<li><p><input type="checkbox" disabled="" checked="" />
<strong>Java中对于线程的控制方法有哪些?</strong></p><p>wait,notify,sleep,yield</p>
<p>join,其他线程必须等待被join的线程执行完，才能执行</p></li>
<li><p><input type="checkbox" disabled="" checked="" />
<strong>线程休眠（sleep）和线程让步（yield）的区别？</strong></p><p><strong>相同</strong>：都将时间片让给其他线程</p>
<p><strong>不同</strong>：</p>
<ol type="1">
<li>如果使用yield方法，会将cpu时间片让给同优先级或者高优先级的其他线程，而sleep方法不考虑优先级，可能会让低优先级的线程拿到cpu时间片</li>
<li>状态转移不同，yield：运行态-&gt;就绪态；sleep：运行态-&gt; 阻塞态，休眠结束后转移到就绪态</li>
</ol></li>
<li><p><input type="checkbox" disabled="" checked="" />
<strong>JVM常见OOM异常有哪些？</strong></p><p>JVM（Java Virtual Machine）中常见的 OutOfMemoryError（OOM）异常有多种类型，它们表示 JVM 在运行过程中耗尽了特定类型的内存资源。以下是一些常见的 OOM 异常：</p>
<ol type="1">
<li><p><strong>Java Heap Space OOM（堆内存溢出）</strong>：当 Java 堆内存无法满足对象的分配需求时，抛出此异常。可以通过增加堆内存大小来缓解，例如通过 <code>-Xmx</code> 和 <code>-Xms</code> JVM 参数。</p></li>
<li><p><strong>PermGen Space OOM（永久代内存溢出）</strong>：在 Java 7 及更早版本中，JVM 使用永久代来存储类信息和方法，当类加载过多或者有大量动态生成类时，可能触发 PermGen Space OOM。在 Java 8 及以后版本中，永久代已被元空间（Metaspace）替代。</p></li>
<li><p><strong>Metaspace OOM（元空间内存溢出）</strong>：在 Java 8 及以后版本中，永久代被元空间替代。Metaspace OOM 通常发生在加载大量类的应用程序中，可以通过增加元空间的大小来缓解，例如通过设置 <code>-XX:MaxMetaspaceSize</code> 参数。</p></li>
<li><p><strong>GC Overhead Limit Exceeded OOM（垃圾回收开销过大）</strong>：当大部分的 CPU 时间都花在垃圾回收上，而回收的内存量很小，就会触发这个异常。可以通过调整垃圾回收器的参数或者增加堆内存来解决。</p></li>
<li><p><strong>Direct Memory OOM（直接内存溢出）</strong>：Java 使用 NIO（New I/O）库时，可能会使用直接内存。如果分配的直接内存超出了系统限制，就会抛出此异常。可以通过增加直接内存的限制或者优化内存使用来解决。</p></li>
<li><p><strong>StackOverflowError（栈溢出）</strong>：当递归调用或方法调用层次太深，栈空间不足时，就会抛出此异常。可以通过减少递归深度或者增加栈大小来解决。</p></li>
<li><p><strong>OutOfMemoryError: Requested array size exceeds VM limit（数组大小超出限制）</strong>：当尝试创建一个超过 JVM 限制的大数组时，会抛出此异常。这通常是因为数组大小超过了 JVM 最大数组索引限制（通常是 <code>2^31 - 1</code>）。</p></li>
<li><p><strong>OutOfMemoryError: Requested array size exceeds 32-bit address space limit（32位地址空间限制）</strong>：在 32 位 JVM 上，由于地址空间的限制，无法分配大于一定大小的数组。通常需要在 64 位 JVM 上运行以解决此问题。</p></li>
</ol>
<p>这些都是 JVM 中常见的 OutOfMemoryError 异常类型。解决方法通常包括调整 JVM 参数、增加内存配置、优化代码以及使用更合适的数据结构等。选择合适的解决方法取决于具体的情况和异常类型。</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230925110015823.png" srcset="/img/loading.gif" lazyload /></p></li>
<li><p><input type="checkbox" disabled="" checked="" />
<strong>继承有什么作用？</strong></p><ol type="1">
<li>代码复用</li>
<li>实现多态</li>
</ol></li>
<li><p><input type="checkbox" disabled="" />
<strong>MySQL读取数据的方式有哪些？</strong></p><p>MySQL 读取数据的方式有以下几种：</p>
<ol type="1">
<li><p><strong>SELECT语句</strong>：这是最常见的方式，使用 <code>SELECT</code> 语句从数据库中检索数据。你可以选择特定的列、条件、排序方式等来获取需要的数据。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> column1, column2 <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">condition</span>;<br></code></pre></td></tr></table></figure></li>
<li><p><strong>子查询</strong>：你可以在 <code>SELECT</code> 语句中嵌套子查询来获取复杂的数据。子查询是一个在主查询中执行的查询，用于检索进一步的数据。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> column1 <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">WHERE</span> column2 <span class="hljs-operator">=</span> (<span class="hljs-keyword">SELECT</span> column2 <span class="hljs-keyword">FROM</span> another_table <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">condition</span>);<br></code></pre></td></tr></table></figure></li>
<li><p><strong>连接</strong>：使用 <code>JOIN</code> 关键字，你可以将多个表连接在一起，以便检索关联数据。这对于从多个表中获取相关信息非常有用。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> table1.column1, table2.column2 <span class="hljs-keyword">FROM</span> table1 <span class="hljs-keyword">JOIN</span> table2 <span class="hljs-keyword">ON</span> table1.id <span class="hljs-operator">=</span> table2.id;<br></code></pre></td></tr></table></figure></li>
<li><p><strong>存储过程</strong>：存储过程是一组预定义的SQL语句，可以在数据库中存储和执行。它们可以接受参数并返回结果，可用于多次执行相同的查询。</p></li>
<li><p><strong>视图</strong>：视图是虚拟的表，是一个基于 <code>SELECT</code> 查询的结果集。你可以像操作表一样查询视图，但不需要存储实际数据。视图通常用于简化复杂的查询或保护敏感数据。</p></li>
<li><p><strong>游标</strong>：游标是一个用于遍历查询结果集的数据库对象。它通常在存储过程或触发器中使用，允许逐行处理查询结果。</p></li>
<li><p><strong>全文搜索</strong>：MySQL提供了全文搜索功能，可以在文本数据中执行全文搜索，以查找包含特定关键词的记录。</p></li>
<li><p><strong>使用索引</strong>：良好设计的索引可以加速数据检索。确保你的表有适当的索引，以提高检索性能。</p></li>
</ol>
<p>这些是从MySQL中检索数据的常见方式，你可以根据需要选择合适的方法来满足你的数据查询要求。</p></li>
<li><p><input type="checkbox" disabled="" checked="" />
<strong>limit函数会带来什么问题？</strong></p><p><a target="_blank" rel="noopener" href="https://www.51cto.com/article/665898.html">博客</a></p></li>
<li><p><input type="checkbox" disabled="" />
<strong>Redis怎么解决并发竞争问题？</strong></p><p>https://cloud.tencent.com/developer/article/1536305</p>
<p>问题：秒杀活动的超卖</p>
<ol type="1">
<li>乐观锁</li>
<li>分布式锁</li>
</ol></li>
<li><p><input type="checkbox" disabled="" checked="" />
<strong>使用Redis缓存时候可能存在什么问题？</strong></p><ol type="1">
<li><p><strong>雪崩</strong></p>
<p>造成雪崩的原因：</p>
<ol type="1">
<li><p>大量缓存数据在同一时间失效，大量的请求无法在redis中得到处理，从而全部访问数据库，导致数据库的压力骤增，甚至崩溃，这就是缓存雪崩</p>
<p>处理方法:</p>
<ol type="1">
<li>可以为缓存数据的过期时间加一个随机数，那么就不会发生大量缓存数据同一时间失效的问题</li>
<li>当发现数据不在redis中时，将加一个互斥锁，保证同一时间只有一个业务线程在构建缓存，缓存构建完成后，再释放锁。未获取到锁的请求，在缓存构建完成后再重新请求。</li>
<li>不给缓存数据设置过期时间，<strong>后台更新缓存</strong>。业务线程发现缓存失效后，通过消息队列通知后台更新缓存。</li>
</ol></li>
<li><p><strong>redis宕机</strong></p>
<p>处理方法：</p>
<ol type="1">
<li><p><strong>服务熔断机制</strong></p>
<p>暂停redis服务，直接返回false，直到redis恢复再开启服务</p></li>
<li><p><strong>构建redis缓存高可用集群</strong></p>
<p>通过主从节点构建redis缓存高可用集群，如果主节点发生故障宕机，那么可以将主节点切换为从节点，继续提供缓存服务。</p></li>
</ol></li>
</ol></li>
<li><p><strong>击穿</strong></p>
<p>当热点数据失效，大量的请求无法被redis处理，这些请求会直接访问数据库，导致数据库崩溃，这就是缓存击穿</p>
<p>处理方法与雪崩类似(击穿是雪崩的子集)</p>
<ol type="1">
<li><strong>加互斥锁</strong></li>
<li>不设置失效时间，<strong>后台更新缓存</strong></li>
</ol></li>
<li><p><strong>穿透</strong></p>
<p>请求的数据既不在缓存中又不在数据库中。请求在redis中未命中后，会直接访问数据库，导致数据库压力骤增。</p>
<p>缓存穿透发生一般是因为 <strong>黑客攻击</strong></p>
<p>处理方法：</p>
<ol type="1">
<li><strong>缓存空值或者默认值</strong>：非法请求直接被redis返回，不会访问数据库</li>
<li><strong>限制非法请求</strong>：在访问redis之前，先判断请求参数是否合理，如果<strong>请求参数有非法值</strong>，或者字段不存在，直接返回false</li>
<li><strong>布隆过滤器</strong></li>
</ol></li>
</ol></li>
<li><p><input type="checkbox" disabled="" checked="" />
<strong>怎么查询redis占用空间比较大的key？</strong></p><p>什么是大key？</p>
<p>大 key 并不是指 key 的值很大，而是 key 对应的 value 很大。</p>
<p>一般而言，下面这两种情况被称为大 key：</p>
<ul>
<li>String 类型的值大于 10 KB；</li>
<li>Hash、List、Set、ZSet 类型的元素的个数超过 5000个；</li>
</ul>
<ol type="1">
<li><p><strong><em>redis-cli --bigkeys 查找大key</em></strong></p>
<ol type="1">
<li>只能查找每种数据结构中最大的bigkey，不能查找排在前n的bigkey</li>
<li>对于集合，是通过集合的大小来比较，但是这是不准确的，因为每个元素的大小差异很大</li>
</ol></li>
<li><p><strong><em>使用 SCAN 命令查找大 key</em></strong></p></li>
<li><p><strong><em>使用 RdbTools 工具查找大 key</em></strong></p>
<p>使用第三方开源工具解析redis的快照(rdb)文件来查找bigkeys。可以指定一个值，内存大于这个值的key都会被查询出来</p></li>
</ol></li>
<li><p><input type="checkbox" disabled="" checked="" />
<strong>redis发生内存溢出，该怎么处理？</strong></p><p>redis内存满了会触发内存淘汰机制。</p></li>
<li><p><input type="checkbox" disabled="" />
讲一讲多路复用</p><p>redis在使用单线程的情况下，同时存在多个监听socket和已连接socket，内核会一直监听socket的请求，一旦有请求到达，就会交给redis线程处理，这就实现了单线程处理多个IO的效果。</p></li>
<li><p><input type="checkbox" disabled="" />
<strong>在请求的时候，如何做到请求接口的重复提交？</strong></p><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/discuss/463747212967714816?sourceSSR=search">博客</a></p>
<ol type="1">
<li><p>实现幂等性接口，保证多次相同的请求不会对系统造成影响。</p></li>
<li><p>前端校验，比如disable提交按钮</p></li>
<li><p>数据库乐观锁</p>
<p>添加一个版本号字段，因为重复提交，只有在版本号不同的情况下才更新</p></li>
</ol></li>
<li><p><input type="checkbox" disabled="" />
<strong>为什么虚拟地址空间切换比较耗时？</strong></p><p><strong>每个进程都有自己的虚拟地址空间，需要通过页表将虚拟地址转换为物理地址，这是一个很慢的过程(内存与cpu速度不匹配)，所以使用快表TLB进行缓存。当进程切换，需要切换虚拟地址空间，那么快表就作废了，虚拟地址转换为物理地址需要通过页表来查询，所以比较耗时</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/G1XhdU/">博客</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2322806">简单版本</a></p>
<p>进程都有自己的虚拟地址空间，把虚拟地址转换为物理地址需要查找页表，页表查找是一个很慢的过程，因此通常使用Cache来缓存常用的地址映射，这样可以加速页表查找，这个Cache就是TLB（translation Lookaside Buffer，TLB本质上就是一个Cache，是用来加速页表查找的）。</p>
<p>由于每个进程都有自己的虚拟地址空间，那么显然每个进程都有自己的页表，那么当进程切换后页表也要进行切换，页表切换后TLB就失效了，Cache失效导致命中率降低，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢，而线程切换则不会导致TLB失效，因为线程无需切换地址空间，因此我们通常说线程切换要比较进程切换块，原因就在这里。</p></li>
<li><p><input type="checkbox" disabled="" />
<strong>web开发过程中需要注意的安全性问题？</strong></p><p>在进行Java Web开发时，需要特别关注安全性问题，以防止潜在的威胁和攻击。以下是一些Java Web开发中需要注意的安全性问题：</p>
<ol type="1">
<li><p><strong>输入验证和过滤</strong>：始终对用户输入的数据进行验证和过滤，以防止SQL注入、跨站脚本攻击（XSS）、跨站请求伪造（CSRF）等攻击。可以使用输入验证库或框架来帮助实现这些安全措施。</p></li>
<li><p><strong>密码存储</strong>：正确存储用户密码，不要明文存储密码。使用密码哈希函数（如BCrypt或PBKDF2）对密码进行安全哈希，并确保在传输密码时使用HTTPS。</p></li>
<li><p><strong>会话管理</strong>：确保正确实现会话管理，使用随机生成的会话令牌，并将会话令牌存储在HttpOnly和Secure标记的Cookie中。定期更新会话ID以减少会话劫持风险。</p></li>
<li><p><strong>授权和身份验证</strong>：使用身份验证和授权机制，确保只有经过身份验证的用户能够访问敏感资源。Spring Security等框架提供了强大的安全性选项。</p></li>
<li><p><strong>文件上传</strong>：对于文件上传功能，限制文件类型和大小，并确保文件不会被直接执行。将上传的文件存储在安全位置，并不要允许用户上传可执行文件。</p></li>
<li><p><strong>错误处理</strong>：不要在错误消息中泄露敏感信息，如堆栈跟踪。正确处理和记录错误，以便进行安全审计。</p></li>
<li><p><strong>跨站点请求伪造（CSRF）保护</strong>：使用CSRF令牌来保护用户免受CSRF攻击。确保每个关键操作都需要一个有效的CSRF令牌。</p></li>
<li><p><strong>安全头部</strong>：使用适当的HTTP安全头部，如Content Security Policy（CSP）、X-Content-Type-Options、X-Frame-Options和X-XSS-Protection，来提高应用程序的安全性。</p></li>
<li><p><strong>依赖管理</strong>：及时更新所有依赖库和框架，以修复已知的漏洞。使用依赖检查工具来监视依赖的安全漏洞。</p></li>
<li><p><strong>安全审计</strong>：实施安全审计，记录和监视潜在的攻击和不正常的活动。及时响应安全事件。</p></li>
<li><p><strong>访问控制</strong>：确保只有授权用户可以访问和执行敏感操作。实施细粒度的访问控制，以便根据角色和权限控制资源的访问。</p></li>
<li><p><strong>敏感数据保护</strong>：对于敏感数据，如个人身份信息（PII）和支付信息，采用适当的加密和保护措施，确保数据在存储和传输时受到保护。</p></li>
<li><p><strong>安全培训</strong>：培训开发人员和团队成员，使他们了解常见的安全威胁和最佳实践，以便他们能够编写安全的代码。</p></li>
<li><p><strong>持续监控和漏洞扫描</strong>：定期对应用程序进行漏洞扫描和安全评估，并建立持续监控机制，以检测和应对新的安全威胁。</p></li>
<li><p><strong>备份和灾难恢复</strong>：确保对数据进行定期备份，并制定紧急灾难恢复计划，以便在遇到安全事件时能够迅速恢复。</p></li>
</ol>
<p>总之，Java Web开发中的安全性问题需要在整个开发生命周期中得到关注。采用防御性编程和安全最佳实践，以减少潜在的安全威胁和漏洞。</p></li>
<li><p><input type="checkbox" disabled="" />
<strong>互联网工作强度持什么态度？</strong></p></li>
<li><p><input type="checkbox" disabled="" />
<strong>手撕</strong> 力扣46 全排列</p></li>
</ul>
<h3 id="如何保证缓存和数据库数据的一致性">如何保证缓存和数据库数据的一致性？</h3>
<p>细说的话可以扯很多，但是我觉得其实没太大必要（小声 BB：很多解决方案我也没太弄明白）。我个人觉得引入缓存之后，如果为了短时间的不一致性问题，选择让系统设计变得更加复杂的话，完全没必要。</p>
<p>下面单独对 <strong>Cache Aside Pattern（旁路缓存模式）</strong> 来聊聊。</p>
<p>Cache Aside Pattern 中遇到写请求是这样的：<strong>更新 DB，然后直接删除 cache 。</strong></p>
<p>如果更新数据库成功，而删除缓存这一步失败的情况的话，简单说两个解决方案：</p>
<ol type="1">
<li><strong>缓存失效时间变短（不推荐，治标不治本）</strong>：我们让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据。另外，这种解决办法对于先操作缓存后操作数据库的场景不适用。</li>
<li><strong>增加 cache 更新重试机制（常用）</strong>：如果 cache 服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将缓存中对应的 key 删除即可。</li>
</ol>
<h2 id="为什么redis这么快">为什么redis这么快</h2>
<ol type="1">
<li>redis基于内存，内存的访问速度是磁盘的上千倍</li>
<li>io多路复用</li>
<li>redis内置了优化的数据结构</li>
</ol>
<h1 id="mysql">MySql</h1>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230927202755308.png" srcset="/img/loading.gif" lazyload style="zoom:200%;" /></p>
<h2 id="基础概念">基础概念</h2>
<h3 id="mysql的作用">MySql的作用</h3>
<h3 id="mysql的组件有哪些">MySql的组件有哪些</h3>
<h3 id="优化器的作用">优化器的作用</h3>
<h3 id="存储引擎的作用">存储引擎的作用</h3>
<h2 id="索引">索引</h2>
<h3 id="索引分类">索引分类</h3>
<ol type="1">
<li>根据<strong>数据结构</strong>分类：B+树索引，全文索引，Hash索引</li>
<li>根据<strong>物理存储</strong>分类：聚簇索引(主键索引)和二级索引(辅助索引) (存所有数据和只存主键，物理存储不同)</li>
<li>根据<strong>字段个数</strong>分类：<strong>单列索引</strong>、<strong>联合索引</strong></li>
<li>根据<strong>字段特性</strong>分类：主键索引、<strong>唯一索引、普通索引、前缀索引</strong></li>
</ol>
<h3 id="什么是b树">什么是B+树</h3>
<p>B+Tree 是一种多叉树，叶子节点才存放数据，非叶子节点只存放索引，而且每个节点里的数据是<strong>按主键顺序存放</strong>的。在叶子节点中，包括了所有的索引值信息，并且每一个叶子节点都有两个指针，分别指向下一个叶子节点和上一个叶子节点，形成一个双向链表。 <img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20231007211417796.png" srcset="/img/loading.gif" lazyload /></p>
<p>数据库的索引和数据都是存放在磁盘中的，每读取一个节点就要进行一层IO操作。B+树相对于B树和二叉树，最大的优势是<strong>查询效率高，对于千万级数据量的表，只需要3-4次IO。</strong></p>
<h3 id="主键索引的b-tree与二级索引的b-tree的区别">主键索引的B+ tree与二级索引的B+ tree的区别</h3>
<p>主键索引的B+ tree的叶子节点存放的是<strong>实际数据</strong>，二级索引的B+ tree的叶子节点存放的是<strong>主键值</strong></p>
<h3 id="回表和覆盖索引">回表和覆盖索引</h3>
<p><strong>回表：</strong>先从二级索引表中查找到主键，再根据主键在主键索引表中查询整行数据，这个过程就是回表</p>
<p><strong>覆盖索引</strong>：如果要查询的数据包含在从二级索引里查询到的数据，就不需要回表操作，这个过程就是覆盖索引</p>
<h3 id="为什么-mysql-innodb-选择-btree-作为索引的数据结构而不选择b树二叉树或者hash">为什么 MySQL InnoDB 选择 B+tree 作为索引的数据结构，而不选择B树，二叉树或者hash？</h3>
<ol type="1">
<li>B树会在非叶子节点存储信息，单个节点的数据量更大，在相同I/O次数下，查询到的数据范围更小。并且B+树的叶子节点采用双向链表，适合MySql基于范围的顺序查询，而B树不能做到这一点。</li>
<li>对于相同的数据量，二叉树比B+树更深，要进行的IO次数更多</li>
<li>Hash擅长等值查询，时间复杂度近似<span class="math inline">\(O(1)\)</span>，但是不能基于范围查询</li>
</ol>
<h2 id="联合索引是什么为什么会有最左匹配原则">联合索引是什么？为什么会有最左匹配原则</h2>
<p><strong>联合索引</strong>：使用多个字段组合成一个索引，就是联合索引</p>
<p>联合索引先按照第一个字段进行比较，第一个字段相同的情况，再按照第二个字段比较，以此类推。因此使用联合索引时，存在<strong>最左匹配原则</strong>，也就是最左边的字段优先进行索引匹配。如果不遵循<strong>最左匹配原则</strong>，就无法利用到联合索引快速检索的特性。</p>
<p>遇到范围查询就会停止匹配</p>
<h2 id="什么时候需要-不需要创建索引">什么时候需要 / 不需要创建索引？</h2>
<p>使用索引可以提高<strong>查询效率</strong>，但是索引也是有缺点的</p>
<ol type="1">
<li>会降低增删改的效率，B+树为了维护索引的有序性，需要动态维护</li>
<li>索引会占用物理空间</li>
<li>创建索引和维护索引需要耗费时间</li>
</ol>
<h3 id="什么时候适用索引">什么时候适用索引？</h3>
<ol type="1">
<li>字段有唯一性限制</li>
<li>经常使用where进行查询，如果要查询条件不止一个字段，可以简历联合索引</li>
<li>经常使用group by和order by的字段适合建立索引，因为在建立索引的时候B+树已经做了排序，在查询的时候不需要排序</li>
</ol>
<h3 id="什么时候不适用索引">什么时候不适用索引？</h3>
<ol type="1">
<li>不会使用where， group by，order by操作来查询的字段，没有利用索引快速检索的特性，不适用</li>
<li>数据区分度不大时不适用索引，比如性别男和女</li>
<li>数据太少的时候没必要使用索引</li>
<li>经常要更新的数据不适用索引，因为B+树要维护索引的有序性，会增加大量的负担</li>
</ol>
<h3 id="索引失效的原因">索引失效的原因</h3>
<p>索引失效情况 模：模糊查询LIKE以%开头 型：数据类型错误 数：对索引字段使用内部函数 空：索引列是NULL 运：索引列进行四则运算 最：联合索引不遵循索引列最左匹配原则 快：优化器预估全表查找更快</p>
<h3 id="mysql执行顺序">Mysql执行顺序</h3>
<p>在 MySQL 中，查询数据的执行顺序通常按照以下顺序进行：</p>
<ol type="1">
<li>FROM：指定要查询的表名或表的联接，这是查询的起点。在这一步，MySQL 确定从哪个表或表的组合中检索数据。</li>
<li>WHERE：对 FROM 步骤中指定的表进行条件筛选。WHERE 子句用于过滤满足特定条件的行，只有满足条件的行才会进入下一步。</li>
<li>GROUP BY：根据指定的列对结果进行分组。这一步将结果按照指定的列进行分组，形成每个组的聚合结果。</li>
<li>HAVING：对 GROUP BY 步骤中分组后的结果进行条件筛选。HAVING 子句用于过滤满足特定条件的分组，只有满足条件的分组才会进入下一步。</li>
<li>SELECT：选择要返回的列，可以包括聚合函数和其他表达式。在这一步，MySQL 从前面的步骤中获取的结果集中选择指定的列。</li>
<li>ORDER BY：对结果进行排序。根据指定的列或表达式对结果集进行排序，可以按升序或降序排列。</li>
<li>LIMIT：限制返回结果的数量。通过指定偏移量和返回行数，可以限制结果集的大小。</li>
<li><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20231029213420269.png" srcset="/img/loading.gif" lazyload /></li>
</ol>
<h2 id="事务">事务</h2>
<h3 id="什么是事务">什么是事务</h3>
<p>事务是一组SQL操作，要么全部执行成功，要么全部失败。在事务中，如果所有的操作都执行成功，则提交事务，将改变永久保存在数据库中。如果中途发生中断或者错误，则回滚事务，使数据库恢复到事务开始前的状态。</p>
<h3 id="事务有什么特性">事务有什么特性</h3>
<p>原子性（Atomicity）：事务是一个原子操作，它要么完全执行，要么完全不执行。如果其中任何一个操作失败，整个事务将被回滚，以确保数据库状态不会出现不一致性。</p>
<p>一致性（Consistency）：事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。</p>
<p>隔离性（Isolation）：事务的执行应该与其他事务相互隔离，这可以防止一个事务的操作对其他事务产生干扰。</p>
<p>持久性（Durability）：一旦事务成功提交，其所做的更改应该永久保存在数据库中，即使在数据库系统崩溃后也应该如此。</p>
<h3 id="并行事务会引发什么问题">并行事务会引发什么问题？</h3>
<p>并行事务可能会出现<strong>脏读</strong>、<strong>不可重复读</strong>、<strong>幻读</strong>。</p>
<h4 id="脏读">脏读</h4>
<p>一个事务读到了另一个<strong>未提交事务修改过的数据</strong>，这就叫脏读。</p>
<p>如果这个<strong>未提交事务</strong>中途发生中断或者错误，进行回滚，那么读到的数据就是错误的。</p>
<h4 id="不可重复读">不可重复读</h4>
<p>在一个事务内多次读取同一个数据，<strong>如果读到的数据出现了不一致</strong>，这就是不可重复读</p>
<p>事务A第一次读取数据x，在第二次读取x之前，事务B修改了x并且进行了提交，那么事务A第二次读到的x与第一次读到的x是不同的，发生了<strong>不可重复读</strong></p>
<h4 id="幻读">幻读</h4>
<p>在一个事务内<strong>对同一个条件</strong>进行多次查询，前后查询到的<strong>记录数量</strong>不同</p>
<p>首先事务A按照条件X进行查询，在第二次查询之前，事务B提交了，导致事务A第二次按照条件 X查询得到的记录条数与第一次不同，发生了幻读</p>
<h3 id="事务的隔离级别有哪些">事务的隔离级别有哪些</h3>
<ul>
<li><strong>读未提交（*read uncommitted*）</strong>，指一个事务还没提交时，它做的变更就能被其他事务看到；</li>
<li><strong>读提交（*read committed*）</strong>，指一个事务提交之后，它做的变更才能被其他事务看到；</li>
<li><strong>可重复读（*repeatable read*）</strong>，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，<strong>MySQL InnoDB 引擎的默认隔离级别</strong>；</li>
<li><strong>串行化（*serializable* ）</strong>；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；</li>
</ul>
<h3 id="mysql的可重复读隔离级别是否解决了幻读问题">MySql的可重复读隔离级别是否解决了幻读问题？</h3>
<p>可重复读可以在很大程度上避免幻读现象。<strong>快照读</strong>，是通过<strong>MVCC方式</strong>解决了幻读。因为在可重复读隔离级别下，事务内读取的数据都是一致的，就算插入一条数据，这条数据也不会被查询出来，所以很好的避免了<strong>幻读</strong>问题</p>
<h3 id="read-view-在-mvcc-里如何工作的">Read View 在 MVCC 里如何工作的？</h3>
<p>首先介绍read view的四个字段(都是事务id)</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20231009221734794.png" srcset="/img/loading.gif" lazyload /></p>
<ol type="1">
<li>creator_id：创建read view的事务id</li>
<li>m_id：<strong>未提交</strong>的事务id</li>
<li>min_id：<strong>最小未提交</strong>事务的id</li>
<li>max_id：下一个新建事务的id</li>
</ol>
<p>介绍innodb聚簇(主键)索引的两个隐藏列</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20231009222237122.png" srcset="/img/loading.gif" lazyload /></p>
<ol type="1">
<li>事务id：第一个隐藏列记录<strong>改动当前索引的事务id</strong></li>
<li>指针：第二个隐藏列记录<strong>undo日志中旧版本记录</strong></li>
</ol>
<p><strong>MVCC(Multi Version Concurrent Control)</strong>：<strong>多版本并发控制</strong>，<strong>通过版本链控制并发事务访问同一条数据</strong>。</p>
<h3 id="mvcc流程"><strong>MVCC流程</strong>：</h3>
<p>一个事务去访问一条记录首先查询这条记录的第一个隐藏列--上一个修改这条记录的事务id，</p>
<ol type="1">
<li>如果这个事务id 小于read view中的min_id字段，说明这个事务已经提交，那么这条记录就是可见的</li>
<li>如果这个事务的id大于等于read view中的max_id，说明这个事务是在当前事务后创建的事务，可能没有提交，当前记录是不可见的</li>
<li>如果这个事务的id在read view中min_id到max_id之间，那么就去read view中的m_ids字段查询，如果事务id在m_ids中，说明这个事务是活跃未提交的，当前记录不可见；否则这条记录是可见的</li>
</ol>
<h3 id="读提交与可重复读">读提交与可重复读</h3>
<p><strong>[读提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View，而「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View</strong>。</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/4589c71ae88a1764ed3aa5c6885f214.png" srcset="/img/loading.gif" lazyload style="zoom:200%;" /></p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/e1835eaabadd2916221ad1642ba41ff.png" srcset="/img/loading.gif" lazyload alt="e1835eaabadd2916221ad1642ba41ff" style="zoom:200%;" /></p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/86d2e1c20821ea067b80363a9273937.png" srcset="/img/loading.gif" lazyload alt="86d2e1c20821ea067b80363a9273937" style="zoom:200%;" /></p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/c7d88f1120fec552b49e656de9953b5.png" srcset="/img/loading.gif" lazyload alt="c7d88f1120fec552b49e656de9953b5" style="zoom:200%;" /></p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/47a754a0defce1878256af29fc4d888.png" srcset="/img/loading.gif" lazyload alt="47a754a0defce1878256af29fc4d888" style="zoom:200%;" /></p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/2b7bf24801f5c194cedf7b7876c7b2b.png" srcset="/img/loading.gif" lazyload alt="2b7bf24801f5c194cedf7b7876c7b2b" style="zoom:200%;" />b</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/50c65f71c00576c19fbbe12ad43a75d.png" srcset="/img/loading.gif" lazyload alt="50c65f71c00576c19fbbe12ad43a75d" style="zoom:200%;" /></p>
<h2 id="cvte面试">CVTE面试</h2>
<ol type="1">
<li><strong>AQS的原理：</strong>
<ul>
<li>AQS（AbstractQueuedSynchronizer）是Java中用于构建同步器的框架。它的核心思想是基于FIFO等待队列的阻塞同步器。</li>
<li>AQS维护了一个等待队列，当线程需要获取同步资源时，如果资源被占用，线程将被加入到等待队列中。</li>
<li>AQS提供了两种资源共享方式：独占模式（如ReentrantLock）和共享模式（如Semaphore）。</li>
<li>在AQS的内部，使用了volatile修饰的state变量来表示同步状态，基于CAS（Compare-And-Swap）操作来实现原子性的状态修改，以及Unsafe类的底层操作。</li>
</ul></li>
<li><strong>乐观锁CAS的弊端：</strong>
<ul>
<li>CAS（Compare-And-Swap）是一种乐观锁的实现方式，但它存在ABA问题。如果一个值在开始时是A，后来被改成了B，最后又被改回A，那么使用CAS进行比较时会发现它没有被修改，虽然实际上已经发生了变化。ABA问题可能导致程序不稳定和错误。</li>
<li>为了解决ABA问题，可以使用带版本号的CAS，即在每次修改时增加版本号，这样就能够正确地识别出ABA问题。</li>
</ul></li>
<li><strong>HTTPS安全的具体实现：</strong>
<ul>
<li>HTTPS（Hypertext Transfer Protocol Secure）是在HTTP基础上加入了SSL/TLS协议来进行加密通信的协议。</li>
<li>具体实现包括以下步骤：
<ul>
<li>客户端发起HTTPS请求，服务端返回公钥证书。</li>
<li>客户端验证证书的合法性，生成随机对称密钥，并使用服务端的公钥加密这个密钥，发送给服务端。</li>
<li>服务端使用自己的私钥解密得到对称密钥。</li>
<li>双方使用对称密钥进行加密通信，保证通信数据的机密性和完整性。</li>
</ul></li>
</ul></li>
<li><strong>Redo Log的实现：</strong>
<ul>
<li>Redo Log是MySQL中的一种日志文件，用于持久化事务的修改操作。</li>
<li>当事务进行数据修改时，先将修改的数据记录到Redo Log中，然后再进行实际的数据修改。这样即使数据库崩溃，系统可以根据Redo Log进行数据恢复。</li>
<li>Redo Log通常包括两个文件，一个是日志文件本身，一个是索引文件，用于加速Redo Log的查找。</li>
</ul></li>
<li><strong>MySQL的执行顺序：</strong>
<ul>
<li>MySQL的执行顺序一般是：FROM -&gt; WHERE -&gt; GROUP BY -&gt; HAVING -&gt; SELECT -&gt; ORDER BY。</li>
<li>查询语句会依次经过这些阶段，数据会被不断地筛选和处理，最终得到最终结果。</li>
</ul></li>
<li><strong>MySQL的数据在磁盘上的存储：</strong>
<ul>
<li>MySQL的数据存储采用了页（Page）的概念，一个页的大小通常是16KB。</li>
<li>数据库表的数据按行存储在页中，每行的数据组织成记录。</li>
<li>表的索引数据也存储在页中，MySQL使用B+树作为索引结构，保证了索引的快速查找性能。</li>
</ul></li>
<li><strong>Ping用到的协议：</strong>
<ul>
<li>Ping命令使用的是ICMP（Internet Control Message Protocol）协议。ICMP是用于在IP网络上发送控制消息的协议，通常用于网络故障诊断和网络性能分析。</li>
</ul></li>
</ol>
<p>当回答这些问题时，确保简洁明了，用自己的话语解释，同时如果不确定可以诚实地表示自己的不确定，而不是随便瞎猜。</p>
<h3 id="hashset-用到了-hashmap中的什么会出现什么问题">hashset 用到了 hashmap中的什么？会出现什么问题</h3>
<h3 id="synchronized锁升级">synchronized锁升级</h3>
<h3 id="redis处理同步">redis处理同步</h3>
<h3 id="concurrentmap">concurrentmap</h3>
<h3 id="线程池-单例线程池">线程池， 单例线程池</h3>
<h3 id="redis-hash与java-hashredis数据结构">redis hash与java hash，redis数据结构</h3>
<h1 id="宝马领悦">宝马领悦</h1>
<h3 id="git代码提交的过程以及用到哪些命令说一下">git代码提交的过程以及用到哪些命令说一下？</h3>
<p>在Git中，代码的提交过程通常包括以下几个步骤，涉及到的命令如下：</p>
<ol type="1">
<li><p><strong>初始化仓库：</strong> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git init<br></code></pre></td></tr></table></figure> 这个命令会在当前目录下创建一个新的Git仓库。</p></li>
<li><p><strong>将文件添加到暂存区：</strong> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add filename<br></code></pre></td></tr></table></figure> 或者添加所有文件： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add .<br></code></pre></td></tr></table></figure> 这个命令将文件的当前状态添加到暂存区，准备提交。</p></li>
<li><p><strong>提交到本地仓库：</strong> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit -m <span class="hljs-string">&quot;Commit message&quot;</span><br></code></pre></td></tr></table></figure> 这个命令会将暂存区的文件提交到本地仓库，并附上一条提交信息。</p></li>
<li><p><strong>连接到远程仓库（如果是在第一次提交到远程仓库的话）：</strong> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote add origin &lt;远程仓库URL&gt;<br></code></pre></td></tr></table></figure> 这个命令会将本地仓库与远程仓库建立连接。</p></li>
<li><p><strong>将本地提交推送到远程仓库：</strong> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push -u origin &lt;分支名&gt;<br></code></pre></td></tr></table></figure> 这个命令将当前分支的提交推送到远程仓库。</p></li>
<li><p><strong>拉取远程仓库的变化（如果需要同步远程仓库的变化到本地）：</strong> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git pull origin &lt;分支名&gt;<br></code></pre></td></tr></table></figure> 这个命令将远程仓库的变化拉取到本地。</p></li>
</ol>
<p>以上是基本的Git提交过程，你可以根据实际需求使用这些命令的不同参数和选项。例如，可以使用<code>git branch</code>命令创建和切换分支，使用<code>git merge</code>命令合并分支，以及使用<code>git log</code>查看提交日志等。Git提供了丰富的命令集，以支持代码版本控制的各种操作。</p>
<h3 id="binlogredo-log和undo-log的作用">binlog、redo log和undo log的作用</h3>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20231029111001780.png" srcset="/img/loading.gif" lazyload /></p>
<h3 id="设计模式了解哪些工厂模式应用场景策略模式应用场景">设计模式了解哪些？工厂模式应用场景，策略模式应用场景</h3>
<p>我了解许多常见的设计模式，包括但不限于以下几种：</p>
<ol type="1">
<li>工厂模式（Factory Pattern）：
<ul>
<li>应用场景：工厂模式适用于需要根据不同的条件创建对象实例的情况。它可以隐藏对象的创建细节，并提供统一的接口供客户端使用。常见的应用场景包括：
<ul>
<li>当对象的创建逻辑比较复杂，客户端不需要关心具体的创建过程。</li>
<li>当需要根据不同的条件返回不同类型的对象实例。</li>
<li>当希望通过扩展工厂类来创建新类型的对象，而无需修改客户端代码。</li>
</ul></li>
</ul></li>
<li>策略模式（Strategy Pattern）：
<ul>
<li>应用场景：策略模式适用于需要在运行时根据不同的情况选择不同算法或行为的情况。它将算法封装成独立的策略类，使得策略可以独立于客户端而变化。常见的应用场景包括：
<ul>
<li>当有多个类似的算法，客户端需要根据不同情况动态选择其中之一。</li>
<li>当希望避免使用大量的条件语句来管理不同的行为。</li>
<li>当希望将算法的具体实现和使用者解耦，使得算法可以独立演化和复用。</li>
</ul></li>
</ul></li>
</ol>
<p>除了工厂模式和策略模式，还有许多其他常见的设计模式，例如单例模式、观察者模式、适配器模式、装饰器模式、代理模式等。每种设计模式都有不同的应用场景和优势，可以根据具体的需求选择合适的模式来提高代码的可维护性和灵活性。</p>
<h3 id="mysql相关怎么解决慢查询">mysql相关怎么解决慢查询</h3>
<ol type="1">
<li>使用索引：确保查询涉及的列上有适当的索引。通过使用合适的索引，MySQL 可以更快地定位和检索数据。可以通过 <code>EXPLAIN</code> 关键字来分析查询计划，查看是否正确使用了索引。</li>
<li>优化查询语句：检查查询语句，确保它们被写得高效。避免不必要的连接和子查询，使用合适的比较操作符和函数，避免在 WHERE 子句中进行数据类型转换。使用 LIMIT 来限制返回结果的数量，以减少查询的负载。</li>
<li>分析和优化表结构：审查表结构，确保它们符合数据模型和查询需求。适当地使用主键、外键和索引。根据实际使用情况调整表的设计，避免过度规范化或冗余设计。</li>
<li>优化配置参数：调整 MySQL 的配置参数以适应服务器的硬件资源和负载。例如，增加缓冲区大小、调整并发连接数、优化查询缓存等。</li>
<li>使用查询缓存：对于经常执行的查询，可以启用查询缓存，这样结果可以在内存中缓存，从而提高查询性能。但请注意，查询缓存的使用也可能带来一些副作用，因此在具体情况下要谨慎评估是否使用查询缓存。</li>
<li>监控和分析工具：使用 MySQL 的性能监控和分析工具，如慢查询日志、性能模式、查询分析器等，以识别慢查询和瓶颈，并定位问题所在。这些工具可以提供有关查询执行时间、锁定情况、索引使用等方面的信息。</li>
<li>数据库优化和调整：对于大型数据库或高负载环境，可能需要进行更深入的数据库优化和调整，如分区表、垂直和水平分片、主从复制等，以提高性能和可扩展性。</li>
</ol>
<h3 id="mq幂等性">MQ幂等性</h3>
<p>关于消息队列的幂等性设计，幂等性是指对同一个操作的多次执行能够产生相同的结果，而不会有副作用。在消息队列中，为了确保消息的可靠性和正确处理，可以采取以下策略来设计幂等性：</p>
<ol type="1">
<li>消费者端实现幂等性：消费者在接收到消息后，可以在处理消息之前检查该消息的唯一标识（如消息ID）。消费者可以维护一个已处理消息的记录，通过比较消息ID来判断是否已经处理过该消息，避免对同一消息进行重复处理。</li>
<li>消息去重：消息队列中可以使用消息去重的机制，确保同一消息不会被重复投递给消费者。消息队列可以根据消息的唯一标识进行去重操作，在消息投递之前检查是否已存在相同的消息，避免重复处理。</li>
<li>幂等性操作设计：对于需要执行幂等操作的消息，可以在业务逻辑层面设计幂等性。例如，将操作的唯一标识作为消息的一部分，在消费者端执行操作前先检查该标识是否已存在，避免对同一操作进行重复处理。</li>
</ol>
<h3 id="q怎么保证消息不丢失怎么避免消息被重复消费">Q怎么保证消息不丢失？怎么避免消息被重复消费？</h3>
<p>消息队列（MQ）系统可以采取以下措施来保证消息不丢失和避免消息被重复消费：</p>
<ol type="1">
<li><p>持久化消息：消息队列可以提供消息的持久化功能，将消息存储到持久化介质（如磁盘）上，确保即使在系统故障或重启后消息不会丢失。通过将消息标记为持久化，即使在消息队列重启后，仍然可以将消息恢复并重新投递给消费者。</p></li>
<li><p>确认机制：消息队列可以引入确认机制，确保消息在被消费之前不会被立即删除。消费者在处理消息之后发送确认（ACK）给消息队列，消息队列收到确认后才会将消息标记为已消费，并删除消息。如果消费者在处理消息时发生故障，消息队列会重新投递该消息给其他消费者。</p></li>
<li><p>重试机制：当消费者无法成功处理消息时，消息队列可以支持自动的重试机制。如果消费者抛出异常或返回处理失败的结果，消息队列可以将消息重新投递给消费者，直到消息被成功消费或达到最大重试次数。</p></li>
<li><p>幂等性设计：为了避免消息被重复消费，消费者端可以实现幂等性。消费者在处理消息时，通过检查消息的唯一标识或状态，判断是否已经处理过该消息，避免对同一消息的重复处理。通过状态的判断：消费者在处理消息之前，先在缓存中查找是否处理过该消息，如果有，则丢弃这条消息，否则处理这条消息，并将消息加入到缓存种</p></li>
<li><p>消息去重：消息队列可以提供消息去重的机制，避免重复投递相同的消息给消费者。消息队列会对消息进行唯一标识的判重操作，在消息投递前检查是否已存在相同的消息，避免重复消费。</p></li>
<li><p>事务支持：一些消息队列系统支持事务机制，消费者可以在处理消息时使用事务来保证消息的原子性。如果消费者在事务提交之前发生故障，消息队列可以回滚事务并将消息重新投递给其他消费者。</p></li>
</ol>
<p>综上所述，通过持久化消息、确认机制、重试机制、幂等性设计、消息去重和事务支持等手段，消息队列可以保证消息不丢失，并避免消息被重复消费。具体的实现方式和特性取决于所使用的消息队列系统和业务需求。</p>
<h1 id="spring-spring-boot">Spring &amp;&amp; Spring Boot</h1>
<h2 id="如何解决循环依赖">如何解决循环依赖</h2>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/84267654">博客</a></p>
<h2 id="transactional失效的原因"><span class="citation" data-cites="Transactional失效的原因">@Transactional失效的原因</span></h2>
<p><span class="citation" data-cites="Transactional">@Transactional</span> 失效的原因可能有多种情况，以下是一些常见的原因：</p>
<ol type="1">
<li>错误的事务配置：可能存在错误的事务配置，如将 <span class="citation" data-cites="Transactional">@Transactional</span> 注解放在了不应该被事务管理的方法上，或者事务的传播行为（Propagation）配置不正确。确保 <span class="citation" data-cites="Transactional">@Transactional</span> 注解应用于正确的方法，并且传播行为与预期一致。</li>
<li>未被 Spring 管理的对象：默认情况下，Spring 只会对由容器管理的 Bean 执行事务管理。如果 <span class="citation" data-cites="Transactional">@Transactional</span> 注解应用于非由 Spring 管理的对象或方法上，事务将不会生效。确保目标对象是由 Spring 管理的 Bean，并且通过依赖注入方式使用。</li>
<li>异常处理：如果在事务方法中捕获了异常并进行了处理，可能会导致事务失效。默认情况下，Spring 只会对未捕获的 RuntimeException 及其子类进行事务回滚。如果捕获了异常并进行了处理，事务可能不会回滚。可以考虑将异常重新抛出或使用 <code>TransactionAspectSupport.currentTransactionStatus().setRollbackOnly()</code> 进行手动回滚。</li>
<li>事务方法调用：如果在同一个类中的一个方法调用了另一个方法，且两个方法都带有 <span class="citation" data-cites="Transactional">@Transactional</span> 注解，事务可能会失效。这是因为 Spring 使用基于代理的 AOP 实现事务，同一类中的方法调用不会触发代理的切面逻辑。可以将方法移动到不同的类中，或者通过使用 AspectJ 代理模式来解决该问题。</li>
<li>事务的作用域：Spring 的事务默认只对 public 方法生效。如果 <span class="citation" data-cites="Transactional">@Transactional</span> 注解应用于非 public 方法上，事务将不会生效。确保事务注解应用于 public 方法上。</li>
<li>配置问题：可能存在配置问题，如事务管理器配置错误、数据源配置错误等。确保正确配置了事务管理器和数据源，并与 Spring 的事务管理机制进行正确集成。</li>
</ol>
<p>以上是一些常见的导致 <span class="citation" data-cites="Transactional">@Transactional</span> 失效的原因，需要仔细检查代码和配置，确保事务注解正确应用并满足预期的事务行为。如有需要，可以结合日志和调试工具来进一步排查问题。</p>
<h3 id="用redis是怎么察觉到缓存的数据更改了呢">用Redis是怎么察觉到缓存的数据更改了呢?</h3>
<h3 id="两个类一个里面有十个属性另一个有20个属性其中10个属性是相同的怎么实现属性拷贝">两个类，一个里面有十个属性，另一个有20个属性，其中10个属性是相同的，怎么实现属性拷贝？</h3>
<h3 id="springboot相对于ssm的你觉得有什么优势">SpringBoot相对于SSM的你觉得有什么优势?</h3>
<p>Spring Boot 和 SSM（Spring + Spring MVC + MyBatis）都是常见的 Java Web 开发框架，它们各自有一些优势和特点。</p>
<p>下面是 Spring Boot 相对于 SSM 的一些优势：</p>
<ol type="1">
<li><p>快速启动和简化配置：Spring Boot 提供了自动配置的能力，大大简化了项目的配置过程。它可以根据项目的依赖自动配置各种组件，减少了开发人员手动配置的工作量。同时，Spring Boot 提供了一个快速启动的特性，能够快速启动应用程序并运行。</p></li>
<li><p>微服务支持：Spring Boot 非常适合构建微服务架构。它提供了丰富的开箱即用的功能和组件，如集成了 Spring Cloud、Netflix OSS 等微服务相关的组件，使得开发人员能够更轻松地构建和管理微服务应用。</p></li>
<li><p>内嵌容器：Spring Boot 内置了常见的 Servlet 容器（如 Tomcat、Jetty），可以将应用程序打包为可执行的 JAR 文件并直接运行，无需独立安装和配置外部容器，简化了部署和运行的过程。</p></li>
<li><p>自动化依赖管理：Spring Boot 提供了一套强大的依赖管理机制，通过 Maven 或 Gradle 的自动化依赖管理，可以简化项目的依赖管理和版本冲突解决，降低了依赖管理的复杂性。</p></li>
<li><p>生态系统和社区支持：Spring Boot 是 Spring 生态系统的一部分，可以充分利用 Spring 生态系统的各种功能和组件，如 Spring Security、Spring Data 等。同时，Spring Boot 拥有庞大的开源社区支持，可以获得丰富的文档、教程和问题解答。</p></li>
</ol>
<p>需要注意的是，SSM 作为传统的 Java Web 开发框架，也有其优势，例如对于特定的项目需求、团队的熟悉程度、现有代码基础等情况下可能更适合使用 SSM。</p>
<p>综上所述，Spring Boot 相对于 SSM 提供了更快速的启动和配置、更适合微服务架构、内置容器、自动化依赖管理以及强大的生态系统和社区支持等优势。这些特点使得 Spring Boot 成为现代 Java Web 开发中的热门选择。</p>
<h1 id="docker">Docker</h1>
<figure>
<img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20231106144559474.png" srcset="/img/loading.gif" lazyload alt="image-20231106144559474" /><figcaption aria-hidden="true">image-20231106144559474</figcaption>
</figure>
<h1 id="elastic">Elastic</h1>
<h1 id="新闻头条">新闻头条</h1>
<h2 id="项目背景">项目背景</h2>
<h2 id="业务功能">业务功能</h2>
<h2 id="技术栈">技术栈</h2>
<h2 id="解决方案">解决方案</h2>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20231108145647248.png" srcset="/img/loading.gif" lazyload /></p>
<ul>
<li><p>文章表的拆分</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20231113133345984.png" srcset="/img/loading.gif" lazyload /></p></li>
<li><p>MiniIO封装为starter使用</p></li>
<li><p>异步调用不能使用当前线程来获取用户id</p></li>
<li><p>文章id精度丢失(long) p132</p></li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>java_boilerplate</div>
      <div>https://leopol1d.github.io/2023/07/19/java-boilerplate/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Leopold</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年7月19日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="waline"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#waline', function() {
      Fluid.utils.createCssLink('https://lib.baomitu.com/waline/2.14.1/waline.min.css')
      Fluid.utils.createScript('https://lib.baomitu.com/waline/2.14.1/waline.min.js', function() {
        var options = Object.assign(
          {"serverURL":"comment-plugin.vercel.app","path":"window.location.pathname","meta":["nick","mail","link"],"requiredMeta":["nick"],"lang":"zh-CN","emoji":["https://cdn.jsdelivr.net/gh/walinejs/emojis/weibo"],"dark":"html[data-user-color-scheme=\"dark\"]","wordLimit":0,"pageSize":10},
          {
            el: '#waline',
            path: window.location.pathname
          }
        )
        Waline.init(options);
        Fluid.utils.waitElementVisible('#waline .vcontent', () => {
          var imgSelector = '#waline .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
