<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/cat-96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/cat-96.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"leopol1d.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="马士兵算法视频链接 第一课 认识复杂度和简单排序算法 java中异或符号^（二进制） 1a &#x3D; 4 ^ 10  选择排序    冒泡排序   其中swap方法的小技巧，使用前提：地址空间不同   arr[i] &#x3D; 11001010 ^ arr[j] &#x3D; 01000110 arr[i] &#x3D; arr[i] ^ arr[j] 10001100 (1) arr[j] &amp;#x3">
<meta property="og:type" content="article">
<meta property="og:title" content="Leopold&#39;s Blog">
<meta property="og:url" content="https://leopol1d.github.io/2023/04/07/Algorithms%20Course/index.html">
<meta property="og:site_name" content="Leopold&#39;s Blog">
<meta property="og:description" content="马士兵算法视频链接 第一课 认识复杂度和简单排序算法 java中异或符号^（二进制） 1a &#x3D; 4 ^ 10  选择排序    冒泡排序   其中swap方法的小技巧，使用前提：地址空间不同   arr[i] &#x3D; 11001010 ^ arr[j] &#x3D; 01000110 arr[i] &#x3D; arr[i] ^ arr[j] 10001100 (1) arr[j] &amp;#x3">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230107203100552.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230107205027199.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230107205748556.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230107212513460.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230107212744089.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230107213739059.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230110154902763.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230110162125648.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230318210753861.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230318210708505.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230318210647601.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230318210620287.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230320095545766.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230327183302703.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230328192555408.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230328164702918.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230329142700228.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230330094627247.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230330101656109.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230330105858903.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230330112546180.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230320111737785.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230320113039413.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230320115618376.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230320152504462.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230320161332491.png">
<meta property="og:image" content="c:\Users\ning\AppData\Roaming\Typora\typora-user-images\image-20230321093745686.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230321100900158.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230321102148975.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230321103126806.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230321110400024.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230321111653023.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230321142849628.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230321144735136.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230321150754544.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230321155140257.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230322110219397.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230322155627326.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230323100510481.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230323103301262.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230323104721968.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230323142204001.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230323142217741.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230323144126141.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230323150830325.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230323154603928.png">
<meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/20210203154720326.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230330140341816.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230330144646861.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230330143640861.png">
<meta property="og:image" content="c:\Users\ning\AppData\Roaming\Typora\typora-user-images\image-20230331103348908.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230331113629971.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230331144402361.png">
<meta property="og:image" content="c:\Users\ning\AppData\Roaming\Typora\typora-user-images\image-20230331155507374.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230331154846428.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230331154918879.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230331154948941.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230404143208023.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230404144826280.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230404150129398.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230404180957539.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230324132148361.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230404130939535.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230324143753280.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230324150110004.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230406132631275.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230406142256924.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230406151317898.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230406150937452.png">
<meta property="article:published_time" content="2023-04-07T07:31:50.079Z">
<meta property="article:modified_time" content="2023-04-06T07:16:13.377Z">
<meta property="article:author" content="Leopold">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230107203100552.png">

<link rel="canonical" href="https://leopol1d.github.io/2023/04/07/Algorithms%20Course/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title> | Leopold's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Leopold's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://leopol1d.github.io/2023/04/07/Algorithms%20Course/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Leopold">
      <meta itemprop="description" content="For offers">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leopold's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-07 15:31:50" itemprop="dateCreated datePublished" datetime="2023-04-07T15:31:50+08:00">2023-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-06 15:16:13" itemprop="dateModified" datetime="2023-04-06T15:16:13+08:00">2023-04-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="马士兵算法"><a href="#马士兵算法" class="headerlink" title="马士兵算法"></a>马士兵算法</h1><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV13g41157hK/?p=3&spm_id_from=444.41.top_right_bar_window_history.content.click&vd_source=d0a01265c4f3d5026b4e06c76cce4fe9">视频链接</a></p>
<h2 id="第一课-认识复杂度和简单排序算法"><a href="#第一课-认识复杂度和简单排序算法" class="headerlink" title="第一课 认识复杂度和简单排序算法"></a>第一课 认识复杂度和简单排序算法</h2><ol>
<li><p>java中异或符号^（二进制）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">4</span> ^ <span class="number">10</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>选择排序</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230107203100552.png" alt="image-20230107203100552"> </p>
</li>
<li><p>冒泡排序</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230107205027199.png" alt="image-20230107205027199"> </p>
<p>其中swap方法的小技巧，使用前提：地址空间不同</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230107205748556.png" alt="image-20230107205748556"> </p>
<p>arr[i] &#x3D; 11001010</p>
<p>^</p>
<p>arr[j] &#x3D; 01000110</p>
<p>arr[i] &#x3D; arr[i] ^ arr[j] 10001100 (1)</p>
<p>arr[j] &#x3D; arr[i] ^ arr[j] 11001010 (2)</p>
<p>arr[i] &#x3D; arr[i] ^ arr[j] 01000110 (3)</p>
<p>原理：内存地址空间位运算</p>
<p>首先合并 (1)(2)</p>
<p>arr[j] &#x3D; arr[i] ^ arr[j] ^ arr[j] &#x3D; arr[i] ^ (arr[j] ^ arr[j] ) </p>
<p>&#x3D; arr[i] ^ 00000000 &#x3D; 11001010 ^ 00000000</p>
<p>&#x3D; arr[i]</p>
<p>再合并(1)(2)(3), </p>
<p>arr[i]  &#x3D; (arr[i] ^ arr[j]) ^ <strong>(arr[i])</strong> &#x3D; (arr[i] ^ <strong>arr[i]</strong>) ^ arr[j]</p>
<p>&#x3D; 00000000 ^ arr[j]</p>
<p>&#x3D; arr[j]</p>
</li>
<li><p>异或quiz1：在一个整形数组中，一种数出现了奇数次，其他所有数出现了偶数次，要求找到这个出现奇数次的数。</p>
<p>eg. 1 2 2 1 3 3 1</p>
<p>​          1  1 0 1 1 0       4</p>
<p>求解思路：从数组第0位开始遍历，与其他所有数组元素进行异或操作，并将异或的结果累加起来，直到找到累加结果是偶数时，此时遍历的这个数组元素就是出现奇数次的数。</p>
<p>时间复杂度：$O(n^2)$</p>
<p>标准答案：</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230107212513460.png" alt="image-20230107212513460"> </p>
<p>int eor &#x3D; 0，用eor与所有数组元素进行异或操作，遍历完成eor是什么数，要找的就是什么数。因为异或操作与数组元素顺序无关，出现偶数个的数，比如2^2&#x3D;0抵消了。</p>
<p>时间复杂度：$O(n)$</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230107212744089.png" alt="image-20230107212744089"> </p>
<p>算法：</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230107213739059.png" alt="image-20230107213739059"> </p>
</li>
<li><p>异或quiz2：在一个整形数组中，两种数出现了奇数次，其他所有数出现了偶数次，要求找到这两种数。</p>
<p>eg. arr &#x3D; <strong>1</strong> 2 2 <strong>1</strong> <strong>3</strong> <strong>1</strong> 4 4 4 4 5 5 (arr.len &#x3D; 12)</p>
<p>1 :9</p>
<p>2:10</p>
<p>3:11</p>
<p>求解思路：从数组第0位开始遍历，与其他所有数组元素进行异或操作，并将异或的结果累加起来，当两个不同的数得到的异或累加结果都是偶数时，这两个数就是要找的数。</p>
<p>时间复杂度：$O(n^2)$</p>
<p>标准答案：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV13g41157hK/?p=3&spm_id_from=444.41.top_right_bar_window_history.content.click&vd_source=d0a01265c4f3d5026b4e06c76cce4fe9">视频讲解更清楚</a></p>
</li>
</ol>
<h2 id="第二课-认识-O-NlogN-的排序"><a href="#第二课-认识-O-NlogN-的排序" class="headerlink" title="第二课 认识$O(NlogN)$的排序"></a>第二课 认识$O(NlogN)$的排序</h2><ol>
<li><p>二分查找时，找中点时，为了防止溢出，不能使用mid &#x3D;  (left + right) &#x2F; 2，而是用</p>
<p>mid &#x3D; left + (right - left) &#x2F; 2，不过使用位运算更快，可以把除操作替换成右移操作</p>
<p>mid &#x3D; left + (right - left)  &gt;&gt; 1</p>
</li>
<li><p>master公式(递归算法)求解时间复杂度</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230110154902763.png" alt="image-20230110154902763"> </p>
</li>
<li><p>归并排序 </p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230110162125648.png" alt="image-20230110162125648"> </p>
</li>
<li><p>堆排序空间复杂度</p>
</li>
</ol>
<h1 id="LeetCode题解"><a href="#LeetCode题解" class="headerlink" title="LeetCode题解"></a>LeetCode题解</h1><h2 id="Dynamic-Programming"><a href="#Dynamic-Programming" class="headerlink" title="Dynamic Programming"></a>Dynamic Programming</h2><h3 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printDp</span><span class="params">(<span class="type">int</span>[] dp, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    System.out.print(i + <span class="string">&quot;: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> maxValue : dp)&#123;</span><br><span class="line">        System.out.print(maxValue + <span class="string">&quot;   &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="剑指Offer-95"><a href="#剑指Offer-95" class="headerlink" title="剑指Offer 95"></a>剑指Offer 95</h3><ol>
<li><p>最优子结构：求<strong>最长</strong>公共子序列，求问题最优解，适合使用dp解决。</p>
</li>
<li><p>重叠子问题：求第一个字符串中位置0~$i$构成的子序列与第二个字符串中0~$j$构成的子序列的最大公共子序列$f(i,j)$，需要多次使用$f(i-1, j-1), f(i-1,j),f(i,j-1)$，拥有重叠子问题</p>
</li>
<li><p>状态转移方程：<br>$$<br>f(i,j) &#x3D;<br>\begin{cases}<br>f(i-1,j-1)+1, &amp; ch[i]&#x3D;&#x3D;ch[j] \<br>max(f(i-1,j),f(i,j-1)), &amp; else \<br>\end{cases}<br>$$</p>
</li>
<li><p>边界条件：dp[0][:] &#x3D;&#x3D; 0,  dp[:][] &#x3D;&#x3D; 0</p>
</li>
</ol>
<p>令两个字符串长度分别为$m,n$，</p>
<p><strong>时间复杂度</strong>：双重for循环，$O(mn)$</p>
<p><strong>空间复杂度</strong>：需要建立大小为(m+1)(n+1)的数组，因此空间复杂度为$O(mn)$</p>
<p><strong>如何优化空间复杂度？</strong></p>
<h3 id="剑指Offer-101-分割等和子集"><a href="#剑指Offer-101-分割等和子集" class="headerlink" title="剑指Offer 101 分割等和子集"></a>剑指Offer 101 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-equal-subset-sum/">分割等和子集</a></h3><p><strong>分析</strong>：只要在数组中找到任意数等于数组累加和的一半，该数组就是等和子集，可抽象为经典0-1背包问题。</p>
<ol>
<li>dp[i][j]:从编号0-i的物品中任选物品(可以都不选)，容量为j的背包能否正好装满</li>
<li>递归公式:dp[i][j] &#x3D; dp[i-1][j] || j &gt;&#x3D; num[i] : dp[i-1][j-nums[i]] : false</li>
<li>初始化:<ol>
<li>当j&#x3D;&#x3D;0时，即背包容量为0，不管有多少物品，只要什么都不选就能使背包总重量为0，所以f(i,0)&#x3D;true</li>
<li>当i&#x3D;&#x3D;0 &amp;&amp; j!&#x3D; 0时，即物品数量为0，怎样都不能放满容量大于0的背包，所以f(0,i)&#x3D;false</li>
</ol>
</li>
<li>遍历顺序：先遍历物品再嵌套从头到尾遍历容量</li>
<li>打印dp数组验证与手写稿是否一致</li>
</ol>
<p><strong>空间复杂度优化</strong>：由于求第i行dp数组只需要用到第i-1行dp数组的信息，所以可以使用一维滑动dp数组代替二维dp数组。</p>
<h3 id="剑指Offer-1049最后一块石头的重量-II"><a href="#剑指Offer-1049最后一块石头的重量-II" class="headerlink" title="剑指Offer 1049最后一块石头的重量 II"></a>剑指Offer 1049<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/last-stone-weight-ii/">最后一块石头的重量 II</a></h3><p><strong>从 stones数组中选择，凑成总和不超过 $sum&#x2F;2$ 的最大价值</strong></p>
<h3 id="518-零钱兑换-II"><a href="#518-零钱兑换-II" class="headerlink" title="518. 零钱兑换 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change-ii/">518. 零钱兑换 II</a></h3><p>​	经典完全背包问题，解题步骤如下：</p>
<ol>
<li>dp[j]：背包容量为j时，放满背包的组合方法数</li>
<li>状态转移公式：dp[j] &#x3D; dp[j] + dp[j - coins[i]]</li>
<li>初始化dp[0]：背包容量为0时，有一种方法放满背包（什么都不放）</li>
<li>遍历顺序：求组合数，先便利物品，再遍历容量</li>
<li>遍历dp数组</li>
</ol>
<img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230318210753861.png" alt="image-20230318210753861" style="zoom:50%;" /> 

<p><strong>关于组合和排列的理解</strong>：先遍历物品后遍历背包是这样，比如，外层循环固定coins[1]，在内层循环遍历背包时，随着背包不断增加，coins[1]可以重复被添加进来，而由于外层循环固定了，因此coins[2]只能在下一次外层循环添加进不同大小的背包中，这么看的话，coins[i + 1]只能在coins[i]之后了；如果先遍历背包后遍历物品，那么外层循环先固定背包大小j，然后在大小为j的背包中循环遍历添加物品，然后在下次外层循环背包大小变为j+1，此时仍要执行内层循环遍历添加物品，也就会出现在上一轮外层循环中添加coins[2]的基础上还能再添加coins[1]的情况，那么就有了coins[1]在coins[2]之后的情况了(逆序)。</p>
<p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包。</strong></p>
<p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品。</strong></p>
<h3 id="377-组合总和-Ⅳ"><a href="#377-组合总和-Ⅳ" class="headerlink" title="377. 组合总和 Ⅳ"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-iv/">377. 组合总和 Ⅳ</a></h3><p>全排列问题，转化为完全背包问题</p>
<ol>
<li>dp[j]：在背包容量为j时，放满背包的排列数</li>
<li>状态转移公式：dp[j] &#x3D; dp[j] + dp[j - nums[i]]</li>
<li>初始化dp[0]：在背包容量为0时，放满背包的排列数量为1（什么都不放）</li>
<li>遍历顺序，排列问题，先遍历背包容量(物品可以逆序放入dp[j - nums[i]])，再遍历物品</li>
<li>打印dp数组</li>
</ol>
<img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230318210708505.png" alt="image-20230318210708505" style="zoom:50%;" /> 	

<h3 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a></h3><p> <strong>完全背包</strong> + 全排列问题，可以重复选择放入物品1与物品2，求放满容量为n的背包的排列数</p>
<ol>
<li>dp[j]：在背包容量为j时，放满背包的排列数</li>
<li>状态转移公式：dp[j] &#x3D; dp[j] + dp[j - nums[i]]</li>
<li>初始化dp[0]：在背包容量为0时，放满背包的排列数量为1（什么都不放）</li>
<li>遍历顺序，排列问题，先遍历背包容量(物品可以逆序放入dp[j - nums[i]])，再遍历物品</li>
<li>打印dp数组</li>
</ol>
<img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230318210647601.png" alt="image-20230318210647601" style="zoom:50%;" /> 

<h3 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换</a></h3><p><strong>完全背包问题</strong></p>
<ol>
<li>dp[j]：背包容量为j时，凑满背包容量所需的<strong>最少硬币数</strong></li>
<li>状态转移公式：dp[j] &#x3D; min(dp[j], dp[j - coins[i]] + 1)</li>
<li>初始化dp[0]：背包容量为0时，凑满背包容量所需的最少硬币数时0,其他初始化为Integer.MAX_VALUE</li>
<li>遍历顺序，无所谓</li>
<li>打印dp数组</li>
</ol>
<p>	</p>
<img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230318210620287.png" alt="image-20230318210620287" style="zoom:50%;" /> 

<p>前天晚上你告诉我你最近经常有分手的念头，我很诧异，我以为一切都很顺利，感情也好，以后要去的城市也好。我觉得遗憾的是，我们不能经常见面，我不擅长表达我的感情，我感受到太久不见生疏了，所以上周急着想去找你。我前天晚上确实过分了，抱歉，之前吵架也是，每次吵架都是在我身体状态不好的时候，情绪比较激动，昨天本来想提醒你学习的，不过看定位你好像去了图书馆(后来你关闭了共享)；还有分享我同学带牙套4个月的效果这件事，不过我状态有点恶化，去了医院，就没来找你了，怕控制不住情绪。12号的时候我其实非常开心，之前两年你都不记得这档事，今年居然记得了，去实验室的路上都在笑。对了，没有送花，没有合照也挺遗憾的，抱歉，我也很拖延，喜欢推到下次。我知道在一段感情中，有一方有分手的想法， 就已经结束了。祝你5月考试顺利，工作没有那么多烦恼。</p>
<h3 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279. 完全平方数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/perfect-squares/">279. 完全平方数</a></h3><ol>
<li><p>dp[j]：装满容量为j的背包，至少要放多少个物品</p>
</li>
<li><p>状态转移公式：dp[j] &#x3D; min(dp[j], dp[j - weights[i]] + 1)</p>
</li>
<li><p>初始化dp[0]:装满容量为0的背包，至少放0个物品；其他设为Integet.MAX_VALUE</p>
</li>
<li><p>遍历顺序：无所谓</p>
</li>
<li><p>打印dp数组</p>
</li>
</ol>
<h3 id="x139-单词拆分"><a href="#x139-单词拆分" class="headerlink" title="x139. 单词拆分"></a>x<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-break/">139. 单词拆分</a></h3><p><strong>背包问题</strong> + <strong>排列</strong>(“leetcode”由“leet”与“code”组成但不能反过来由“code”与“leet”组成 )的变种，建议不要完全抽象成背包问题，便于理解</p>
<ol>
<li>dp[j]：长度为j的字符串，<strong>可以被字典中的单词拆分</strong>。</li>
<li>状态转移公式：if([j, i] 这个区间的子串出现在字典里 &amp;&amp; dp[j]是true) 那么 dp[i] &#x3D; true， 其中j&lt;i。</li>
<li>初始化dp[0]:dp[i]依赖于前面的dp[j]，所以dp[0]要初始化为true，不然全为false</li>
<li>遍历顺序：先遍历背包容量，再嵌套遍历物品</li>
<li>打印dp数组</li>
</ol>
<img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230320095545766.png" alt="image-20230320095545766" style="zoom:50%;" /> 

<h3 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber/">198. 打家劫舍</a></h3><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230327183302703.png" alt="image-20230327183302703" style="zoom:50%;" /> 

<ol>
<li>dp[j]：偷窃从标号为0到j的房屋所能获得的最大价值</li>
<li>状态转移公式：dp[j] &#x3D; max(dp[j - 1], dp[j - 2] + nums[j])</li>
<li>初始化：dp[0] &#x3D; nums[0], dp[1] &#x3D; max(nums[0], nums[1])</li>
<li>遍历顺序：单序列问题,dp[i] 是根据dp[i - 2] 和 dp[i - 1] 推导出来的，那么一定是从前到后遍历！</li>
<li>遍历dp数组</li>
</ol>
<h4 id="优化空间复杂度"><a href="#优化空间复杂度" class="headerlink" title="优化空间复杂度"></a>优化空间复杂度</h4><p>根据状态转移公式dp[j] &#x3D; max(dp[j - 1], dp[j - 2] + nums[j])，dp[j]只需要dp[j-1]以及dp[j-2]两个变量即可，可以把数组大小压缩到2。</p>
<h3 id="213-打家劫舍-II"><a href="#213-打家劫舍-II" class="headerlink" title="213. 打家劫舍 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber-ii/">213. 打家劫舍 II</a></h3><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230328192555408.png" alt="image-20230328192555408" style="zoom:50%;" /> 

<h3 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-equal-subset-sum/">416. 分割等和子集</a></h3><ol>
<li>dp[j]：背包容量为j时，是否能用物品装满</li>
<li>状态转移方程：dp[j] &#x3D; dp[j] || dp[j - nums[i]] </li>
<li>初始化：背包容量为0时，不把物品装进去即可装满，dp[0] &#x3D; true</li>
<li>遍历顺序：一维滑动数组，零一背包，先遍历物品后遍历背包容量</li>
</ol>
<img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230328164702918.png" alt="image-20230328164702918" style="zoom:50%;" /> 

<h3 id="x337-打家劫舍-III"><a href="#x337-打家劫舍-III" class="headerlink" title="x337. 打家劫舍 III"></a>x<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber-iii/">337. 打家劫舍 III</a></h3><p>f：偷当前房屋能获得的最大价值；g：不偷当前房屋能获得的最大价值</p>
<ol>
<li>偷当前房屋f(cur) &#x3D; cur.val + g(cur.left) + g(cur.right)</li>
<li>不偷当前房屋g(cur) &#x3D; max(f(cur.left), g(cur.left)) + max(f(cur.right), g(cur.right))</li>
</ol>
<img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230329142700228.png" alt="image-20230329142700228" style="zoom:50%;" /> 

<h3 id="x121-买卖股票的最佳时机"><a href="#x121-买卖股票的最佳时机" class="headerlink" title="x121. 买卖股票的最佳时机"></a>x<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h3><h4 id="你根本没在dp！"><a href="#你根本没在dp！" class="headerlink" title="你根本没在dp！"></a>你根本没在dp！</h4><h4 id="方法一：暴力迭代"><a href="#方法一：暴力迭代" class="headerlink" title="方法一：暴力迭代"></a>方法一：暴力迭代</h4><p>超时咯</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230330094627247.png" alt="image-20230330094627247"> </p>
<h4 id="方法二：贪心"><a href="#方法二：贪心" class="headerlink" title="方法二：贪心"></a>方法二：贪心</h4><p>从前往后遍历，使用minPrice记录最小值，使用maxProfit记录最大收益</p>
<img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230330101656109.png" alt="image-20230330101656109" style="zoom:50%;" /> 

<h4 id="方法三：DP"><a href="#方法三：DP" class="headerlink" title="方法三：DP"></a>方法三：DP</h4><p><strong>DP数组的定义十分重要！</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span> || prices == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 1.dp[0][j]:第j天持有股票(之前买入或者当前买入)所拥有的最大价值，dp[1][j]：第j天不持有股票(之前卖出或者当前卖出)所拥有的最大价值</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][len];</span><br><span class="line">        <span class="comment">// 2.状态转移方程：dp[0][j] = max(dp[0][j-1], -price[j]); dp[1][j] = max(dp[1][j-1], price[j] + dp[0][j - 1])</span></span><br><span class="line">        <span class="comment">// 3.初始化：dp[0][0]必须买入，初始化为-price[0]；dp[1][0]不能卖出任何股票，初始化为0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 4.遍历顺序：dp[j]由dp[j-1]决定，所以从前往后遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; len; ++j) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = Math.max(dp[<span class="number">0</span>][j - <span class="number">1</span>], -prices[j]);</span><br><span class="line">            dp[<span class="number">1</span>][j] = Math.max(dp[<span class="number">1</span>][j - <span class="number">1</span>], prices[j] + dp[<span class="number">0</span>][j - <span class="number">1</span>]); <span class="comment">// 不能当天买入当天卖出所以是dp[0][j - 1]</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>][len - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 5.打印dp数组</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230330105858903.png" alt="image-20230330105858903" style="zoom:50%;" /> 

<h3 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.dp[0][j]:在第j天持有(之前买入，当前买入)股票时拥有的最大现金;dp[1][j]在第j天不持有(之前卖出，当前卖出)股票拥有的最大现金</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][len];</span><br><span class="line">        <span class="comment">// 2.状态转移方程：dp[0][j] = max(dp[0][j - 1], dp[1][j - 1] - price[j]); dp[1][j] = max(dp[1][j - 1], dp[0][j - 1] + price[j])</span></span><br><span class="line">        <span class="comment">// 3.初始化：dp[0][0] = -price[0];dp[1][0] = 0;可以当天出售</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 4.遍历顺序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; len; ++j) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = Math.max(dp[<span class="number">0</span>][j - <span class="number">1</span>], dp[<span class="number">1</span>][j - <span class="number">1</span>] - prices[j]);</span><br><span class="line">            dp[<span class="number">1</span>][j] = Math.max(dp[<span class="number">1</span>][j - <span class="number">1</span>], dp[<span class="number">0</span>][j - <span class="number">1</span>] + prices[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>][len - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 5.打印dp数组</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230330112546180.png" alt="image-20230330112546180" style="zoom:50%;" /> 

<h4 id="优化空间"><a href="#优化空间" class="headerlink" title="优化空间.."></a>优化空间..</h4><h2 id="Binary-Tree"><a href="#Binary-Tree" class="headerlink" title="Binary Tree"></a>Binary Tree</h2><h3 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></h3><p>递归与非递归</p>
<img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230320111737785.png" alt="image-20230320111737785" style="zoom:50%;" />  

<h3 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h3><p>递归与非递归</p>
<img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230320113039413.png" alt="image-20230320113039413" style="zoom:50%;" /> 

<h3 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></h3><p>递归与非递归</p>
<p><strong>非递归中，需要利用一个pre指针来判断当前节点的右子树有没有被访问过。</strong></p>
<img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230320115618376.png" alt="image-20230320115618376" style="zoom:50%;" /> 

<h3 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h3><p>借助队列实现，<strong>关键在于通过queue.size来判断下一层的节点数！</strong></p>
<p><em>Queue.offer(null)的话，size为1！</em></p>
<img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230320152504462.png" alt="image-20230320152504462" style="zoom:50%;" /> 

<h3 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树</a></h3><p>这道题目背后有一个让程序员心酸的故事，听说 Homebrew的作者Max Howell，就是因为没在白板上写出翻转二叉树，最后被Google拒绝了。（真假不做判断，权当一个乐子哈）</p>
<p>要求：左右子树交换位置</p>
<p>解法：<strong>bfs层级遍历</strong></p>
<p><strong>时间复杂度</strong>：所有节点都需要入队，出队一次，所以是$O(n)$</p>
<p><strong>空间复杂度</strong>：在最坏的情况下，给定的树是满二叉树，所有叶节点($n&#x2F;2 + 1$)都要入队，所以是$O(n)$</p>
<img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230320161332491.png" alt="image-20230320161332491" style="zoom:50%;" /> 

<h3 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树</a></h3><h4 id="方法一：拷贝-翻转-判断-高情商：刷一道，解三道！低情商：只会笨方法？还是看看远方的复杂度吧"><a href="#方法一：拷贝-翻转-判断-高情商：刷一道，解三道！低情商：只会笨方法？还是看看远方的复杂度吧" class="headerlink" title="方法一：拷贝+翻转+判断(高情商：刷一道，解三道！低情商：只会笨方法？还是看看远方的复杂度吧)"></a>方法一：拷贝+翻转+判断(高情商：刷一道，解三道！低情商：只会笨方法？还是看看远方的复杂度吧)</h4><p><img src="C:\Users\ning\AppData\Roaming\Typora\typora-user-images\image-20230321093745686.png" alt="image-20230321093745686" style="zoom:50%;" /> 写了80行，一题三解！不分析复杂度了。。</p>
<h4 id="方法二：BFS"><a href="#方法二：BFS" class="headerlink" title="方法二：BFS"></a>方法二：BFS</h4><p>假设树上一共有<em>n</em> 个节点。</p>
<p><strong>时间复杂度</strong>：遍历了整棵树，$O(n)$</p>
<p><strong>空间复杂度</strong>：和使用的队列大小相关，在最坏的情况下，给定的树是满二叉树，所有叶节点($n&#x2F;2 + 1$)都要入队，所以是$O(n)$</p>
<h4 id="方法三：DFS"><a href="#方法三：DFS" class="headerlink" title="方法三：DFS"></a>方法三：DFS</h4><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230321100900158.png" alt="image-20230321100900158" style="zoom:50%;" /> YYDS</p>
<p>假设树上一共有<em>n</em> 个节点。</p>
<p><strong>时间复杂度</strong>：遍历了整棵树，$O(n)$</p>
<p><strong>空间复杂度</strong>：和递归使用的栈大小相关，递归层数不超过n(一叉树)，$O(n)$</p>
<h3 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100. 相同的树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/same-tree/">100. 相同的树</a></h3><p><strong>对称二叉树</strong>方法一中用到了这个笨方法，顺手做了吧。</p>
<h4 id="方法一：DFS"><a href="#方法一：DFS" class="headerlink" title="方法一：DFS"></a>方法一：DFS</h4><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230321102148975.png" alt="image-20230321102148975" style="zoom:50%;" /> 

<p>假设树上一共有$n$个节点</p>
<p><strong>时间复杂度</strong>：遍历了整棵树，$O(n)$</p>
<p><strong>空间复杂度</strong>：和递归使用的栈大小相关，递归层数不超过n，$O(n)$</p>
<h4 id="方法二：BFS-1"><a href="#方法二：BFS-1" class="headerlink" title="方法二：BFS"></a>方法二：BFS</h4><p>只是和<strong>对称二叉树</strong>BFS解法中的入队顺序改变一点。</p>
<img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230321103126806.png" alt="image-20230321103126806" style="zoom:50%;" /> 

<p>假设树上一共有<em>n</em> 个节点。</p>
<p><strong>时间复杂度</strong>：遍历了整棵树，$O(n)$</p>
<p><strong>空间复杂度</strong>：和使用的队列大小相关，在最坏的情况下，给定的树是满二叉树，所有叶节点($n&#x2F;2 + 1$)都要入队，所以是$O(n)$</p>
<h3 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h3><h4 id="方法一：BFS"><a href="#方法一：BFS" class="headerlink" title="方法一：BFS"></a>方法一：BFS</h4><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230321110400024.png" alt="image-20230321110400024" style="zoom:50%;" /> 

<p>假设树上有$n$个节点</p>
<p><strong>时间复杂度</strong>：遍历整棵树，$O(n)$</p>
<p><strong>空间复杂度</strong>：和使用的队列大小相关，在最坏情况下，给定的二叉树是满二叉树，$n&#x2F;2 + 1$个叶节点要入队，所以是$O(n)$</p>
<h4 id="方法二：DFS"><a href="#方法二：DFS" class="headerlink" title="方法二：DFS"></a>方法二：DFS</h4><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230321111653023.png" alt="image-20230321111653023" style="zoom:50%;" /> 

<p>假设树上一共有$n$个节点</p>
<p><strong>时间复杂度</strong>：遍历了整棵树，$O(n)$</p>
<p><strong>空间复杂度</strong>：和递归使用的栈大小相关，递归层数不超过n，$O(n)$</p>
<h3 id="559-N-叉树的最大深度"><a href="#559-N-叉树的最大深度" class="headerlink" title="559. N 叉树的最大深度"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/">559. N 叉树的最大深度</a></h3><p>同上题<strong>二叉树的最大深度</strong>，只是在遍历子节点的时候不同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cur.children.size(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cur.children.get(i) != <span class="literal">null</span>)</span><br><span class="line">        queue.offer(cur.children.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230321142849628.png" alt="image-20230321142849628" style="zoom:50%;" /> 

<h3 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="!111. 二叉树的最小深度"></a>!<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></h3><p><strong>最小深度是从根节点到最近叶子节点的最短路径上的节点数量</strong></p>
<h4 id="方法一：DFS-1"><a href="#方法一：DFS-1" class="headerlink" title="方法一：DFS"></a>方法一：DFS</h4><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230321144735136.png" alt="image-20230321144735136" style="zoom:50%;" /> 

<h4 id="方法二：BFS-2"><a href="#方法二：BFS-2" class="headerlink" title="方法二：BFS"></a>方法二：BFS</h4><p>想太复杂了！！</p>
<p>只需在遍历节点的时候考虑当前节点是不是叶节点，是叶节点直接return depth!</p>
<img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230321150754544.png" alt="image-20230321150754544" style="zoom:50%;" /> 

<h3 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222. 完全二叉树的节点个数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数</a></h3><h4 id="BFS：在每层开始遍历时，记录节点个数的变量加上队列里元素个数"><a href="#BFS：在每层开始遍历时，记录节点个数的变量加上队列里元素个数" class="headerlink" title="BFS：在每层开始遍历时，记录节点个数的变量加上队列里元素个数"></a>BFS：在每层开始遍历时，记录节点个数的变量加上队列里元素个数</h4><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230321155140257.png" alt="image-20230321155140257" style="zoom:50%;" /> 

<h3 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617. 合并二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-binary-trees/">617. 合并二叉树</a></h3><p><strong>解题思路</strong>：当树1当前节点的左子树或右子树为空，而树2当前节点左子树或右子树不为空时：使用parentQueue存储树1树2的当前节点parent1，parent2，在遍历到下一层时，使用parent1来指向parent2的左子树或者右子树。</p>
<p><strong>Debug</strong>：如果cur1左子树为空，cur2左子树不为空，将cur1,cur2加入trashQueue；同理右子树。<strong>如果cur1左右子树都为空，cur2左右子树都不为空，将cur1,cur2加入parentQueue两次！！不然之后poll的时候空指针！！</strong></p>
<img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230322110219397.png" alt="image-20230322110219397" style="zoom:50%;" /> 

<h3 id="x98-验证二叉搜索树"><a href="#x98-验证二叉搜索树" class="headerlink" title="x98. 验证二叉搜索树"></a>x<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h3><h4 id="方法一：中序遍历"><a href="#方法一：中序遍历" class="headerlink" title="方法一：中序遍历"></a>方法一：中序遍历</h4><p>中序遍历二叉搜索树应该是升序的，只需要一个记录上一个节点的值的遍历preVal，并与当前节点比较，如果当前节点的值<strong>小于等于</strong>preVal(cur.val应该严格&gt;preVal不能等于)，则返回false;否则，遍历完所有节点返回true。</p>
<p>假设树有n个节点</p>
<p><strong>时间复杂度</strong>：遍历所有节点，$O(n)$</p>
<p><strong>空间复杂度</strong>：和使用的栈相关，在最坏情况(每个节点都只有一个子节点)下，树的高度为n，都需要压栈，所以为$O(n)$</p>
<h4 id="x方法二：递归"><a href="#x方法二：递归" class="headerlink" title="x方法二：递归"></a>x方法二：递归</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(TreeNode root, <span class="type">long</span>.MIN_VALUE, <span class="type">long</span>.MAX_VALUE)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">long</span> pre, <span class="type">long</span> post)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.val &lt;= pre || root.val &gt;= post)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(root.left, pre, root.val) &amp;&amp; dfs(root.right, root.val, post);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="530-二叉搜索树的最小绝对差"><a href="#530-二叉搜索树的最小绝对差" class="headerlink" title="530. 二叉搜索树的最小绝对差"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">530. 二叉搜索树的最小绝对差</a></h3><h4 id="中序遍历："><a href="#中序遍历：" class="headerlink" title="中序遍历："></a>中序遍历：</h4><p>使用中序遍历二叉搜索树得到的结果是升序的。</p>
<img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230322155627326.png" alt="image-20230322155627326" style="zoom:50%;" /> 

<h3 id="501-二叉搜索树中的众数"><a href="#501-二叉搜索树中的众数" class="headerlink" title="501. 二叉搜索树中的众数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/">501. 二叉搜索树中的众数</a></h3><p>老样子，中序遍历</p>
<p>遍历的过程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (preVal == cur.val) &#123;</span><br><span class="line">	++counter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">	counter = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!modes.contains(cur.val) &amp;&amp; counter == maxCounter) &#123;</span><br><span class="line">	modes.add(cur.val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (counter &gt; maxCounter) &#123;</span><br><span class="line">    maxCounter = counter;</span><br><span class="line">    modes.removeAll(modes);</span><br><span class="line">    modes.add(cur.val);</span><br><span class="line">&#125;</span><br><span class="line">preVal = cur.val;</span><br><span class="line">cur = cur.right;</span><br></pre></td></tr></table></figure>

<h3 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h3><h4 id="方法一：用HashMap存储所有父节点，用HashSet标记是否访问过；从p开始向上遍历，并标记访问过的父节点，再从q开始向上遍历，如果当前节点被访问过，那么这个节点就是最近公共祖先。"><a href="#方法一：用HashMap存储所有父节点，用HashSet标记是否访问过；从p开始向上遍历，并标记访问过的父节点，再从q开始向上遍历，如果当前节点被访问过，那么这个节点就是最近公共祖先。" class="headerlink" title="方法一：用HashMap存储所有父节点，用HashSet标记是否访问过；从p开始向上遍历，并标记访问过的父节点，再从q开始向上遍历，如果当前节点被访问过，那么这个节点就是最近公共祖先。"></a>方法一：用HashMap存储所有父节点，用HashSet标记是否访问过；从p开始向上遍历，并标记访问过的父节点，再从q开始向上遍历，如果当前节点被访问过，那么这个节点就是最近公共祖先。</h4><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230323100510481.png" alt="image-20230323100510481" style="zoom:50%;" /> 

<h3 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235. 二叉搜索树的最近公共祖先"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先</a></h3><h4 id="递归：考虑三种情况"><a href="#递归：考虑三种情况" class="headerlink" title="递归：考虑三种情况"></a>递归：考虑三种情况</h4><ol>
<li>p,q是root：return root</li>
<li>p,q在root两侧，(p.val &lt; root.val &amp;&amp; q.val &gt; root.val) || (p.val &gt; root.val &amp;&amp; q.val &lt; root.val)， return root</li>
<li>p,q在root同一侧 (p.val &lt; root &amp;&amp; q.val &lt; root.val) || (p.val &gt; root.val &amp;&amp; q.val &gt; root.val)<ol>
<li>p.val &lt; root &amp;&amp; q.val &lt; root.val: return dfs(left, p, q)</li>
<li>p.val &gt; root.val &amp;&amp; q.val &gt; root.val: return dfs(right, p, q)</li>
</ol>
</li>
</ol>
<img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230323103301262.png" alt="image-20230323103301262" style="zoom:50%;" /> 

<h3 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701. 二叉搜索树中的插入操作"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">701. 二叉搜索树中的插入操作</a></h3><p>Easy middle task!</p>
<h4 id="方法一：遍历"><a href="#方法一：遍历" class="headerlink" title="方法一：遍历"></a>方法一：遍历</h4><p>从根节点开始遍历，用栈存储每个遍历过的节点，大于向右小于向左；循环结束，判断插入最后一个被遍历的节点(栈中最顶层节点)，判断大于小于，插入，结束。</p>
<img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230323104721968.png" alt="image-20230323104721968" style="zoom:50%;" /> 

<h4 id="方法二：递归"><a href="#方法二：递归" class="headerlink" title="方法二：递归"></a>方法二：递归</h4><p>当时想出来了，但是卡在怎么插入这个点上<strong>，其实这里已经用root.left或者root.right来接收 new TreeNode(val)了。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">insertIntoBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (val &lt; root.val) &#123;</span><br><span class="line">            root.left = insertIntoBST(root.left, val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root.right = insertIntoBST(root.right, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="x450-删除二叉搜索树中的节点"><a href="#x450-删除二叉搜索树中的节点" class="headerlink" title="x450. 删除二叉搜索树中的节点"></a>x<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点</a></h3><p><strong>解题思路</strong>：</p>
<ol>
<li><p>如果目标节点大于当前节点值，则去右子树中删除；</p>
</li>
<li><p>如果目标节点小于当前节点值，则去左子树中删除；</p>
</li>
<li><p>如果目标节点就是当前节点，分为以下三种情况：</p>
<ol>
<li>其无左子：其右子顶替其位置，删除了该节点；</li>
<li>其无右子：其左子顶替其位置，删除了该节点；</li>
<li>其左右子节点都有：其左子树转移到其右子树的最左节点的左子树上，然后右子树顶替其位置，由此删除了该节点。</li>
</ol>
</li>
</ol>
<img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230323142204001.png" alt="image-20230323142204001" style="zoom:50%;" /> 

<p>写了快100行，重构一下代码。。	</p>
<img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230323142217741.png" alt="image-20230323142217741" style="zoom:50%;" /> 

<h3 id="669-修剪二叉搜索树"><a href="#669-修剪二叉搜索树" class="headerlink" title="669. 修剪二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/trim-a-binary-search-tree/">669. 修剪二叉搜索树</a></h3><p>借上一题的思路直接速通了</p>
<img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230323144126141.png" alt="image-20230323144126141" style="zoom:50%;" /> 

<h3 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108. 将有序数组转换为二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树</a></h3><p>二分速通</p>
<img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230323150830325.png" alt="image-20230323150830325" style="zoom:50%;" /> 

<h3 id="538-把二叉搜索树转换为累加树"><a href="#538-把二叉搜索树转换为累加树" class="headerlink" title="538. 把二叉搜索树转换为累加树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树</a></h3><h4 id="右根左中序遍历！-LeetCode官方叫它反序中序遍历"><a href="#右根左中序遍历！-LeetCode官方叫它反序中序遍历" class="headerlink" title="右根左中序遍历！ LeetCode官方叫它反序中序遍历"></a>右根左中序遍历！ LeetCode官方叫它反序中序遍历</h4><p>87654321从前往后累加。</p>
<img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230323154603928.png" alt="image-20230323154603928" style="zoom:50%;" /> 

<h3 id="x-106-从中序与后序遍历序列构造二叉树"><a href="#x-106-从中序与后序遍历序列构造二叉树" class="headerlink" title="x[106. 从中序与后序遍历序列构造二叉树"></a>x[106. 从中序与后序遍历序列构造二叉树</h3><h3 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="[105. 从前序与中序遍历序列构造二叉树]"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">[105. 从前序与中序遍历序列构造二叉树]</a></h3><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/0106.%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.html#java"> 106.从中序与后序遍历序列构造二叉树</a></p>
<p>前序和中序可以唯一确定一棵二叉树。</p>
<p>后序和中序可以唯一确定一棵二叉树。</p>
<p>那么前序和后序可不可以唯一确定一棵二叉树呢？</p>
<p><strong>前序和后序不能唯一确定一棵二叉树！</strong>，因为没有中序遍历无法确定左右部分，也就是无法分割。</p>
<p>举一个例子：</p>
<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210203154720326.png" alt="106.从中序与后序遍历序列构造二叉树2" style="zoom:50%;" /> 

<p>tree1 的前序遍历是[1 2 3]， 后序遍历是[3 2 1]。</p>
<p>tree2 的前序遍历是[1 2 3]， 后序遍历是[3 2 1]。</p>
<p>那么tree1 和 tree2 的前序和后序完全相同，这是一棵树么，很明显是两棵树！</p>
<p>所以前序和后序不能唯一确定一棵二叉树！</p>
<h3 id="剑指-Offer-II-047-二叉树剪枝"><a href="#剑指-Offer-II-047-二叉树剪枝" class="headerlink" title="剑指 Offer II 047. 二叉树剪枝"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/pOCWxh/">剑指 Offer II 047. 二叉树剪枝</a></h3><h4 id="方法一：笨方法！非递归后序DFS-HashMap存储父节点"><a href="#方法一：笨方法！非递归后序DFS-HashMap存储父节点" class="headerlink" title="方法一：笨方法！非递归后序DFS + HashMap存储父节点"></a>方法一：笨方法！非递归后序DFS + HashMap存储父节点</h4><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230330140341816.png" alt="image-20230330140341816" style="zoom:50%;" /> 

<h4 id="方法二：非递归后续DFS，根本不用Hash-Map！"><a href="#方法二：非递归后续DFS，根本不用Hash-Map！" class="headerlink" title="方法二：非递归后续DFS，根本不用Hash Map！"></a>方法二：非递归后续DFS，根本不用Hash Map！</h4><p>遍历部分如下，<strong>不管当前节点是左子树还是右子树，stack.peek()一定是父节点！</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// traverse</span></span><br><span class="line"><span class="keyword">if</span> (cur.val == <span class="number">0</span> &amp;&amp; cur.left == <span class="literal">null</span> &amp;&amp; cur.right == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">parent</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">        <span class="keyword">if</span> (parent.left == cur) &#123;</span><br><span class="line">            parent.left = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            parent.right = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230330144646861.png" alt="image-20230330144646861" style="zoom:50%;" /> 

<h4 id="方法三：递归"><a href="#方法三：递归" class="headerlink" title="方法三：递归"></a>方法三：递归</h4><p>切记后续遍历的顺序， if (root.val &#x3D;&#x3D; 0 &amp;&amp; root.left &#x3D;&#x3D; null &amp;&amp; root.right &#x3D;&#x3D; null)一定写在遍历左子树右子树后面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">pruneTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;    </span><br><span class="line">        root.left = pruneTree(root.left);</span><br><span class="line">        root.right = pruneTree(root.right);</span><br><span class="line">        <span class="keyword">if</span> (root.val == <span class="number">0</span> &amp;&amp; root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230330143640861.png" alt="image-20230330143640861" style="zoom:50%;" /> 

<h3 id="x剑指-Offer-II-048-序列化与反序列化二叉树"><a href="#x剑指-Offer-II-048-序列化与反序列化二叉树" class="headerlink" title="x剑指 Offer II 048. 序列化与反序列化二叉树"></a>x<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/h54YBf/">剑指 Offer II 048. 序列化与反序列化二叉树</a></h3><p>“#”表示null；反序列化时，用整数数组int[] i &#x3D; {0}来遍历字符串，因为i[0]++可以让调用函数知道下标增加了；时使用int j &#x3D; 0，在函数体内修改j的值，修改之后的值也不能传递给调用者。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node.left = dfs(strs, i);</span><br><span class="line">node.right = dfs(strs, i);</span><br></pre></td></tr></table></figure>

<img src="C:\Users\ning\AppData\Roaming\Typora\typora-user-images\image-20230331103348908.png" alt="image-202303311033 48908" style="zoom:50%;" />  

<h3 id="剑指-Offer-II-049-从根节点到叶节点的路径数字之和"><a href="#剑指-Offer-II-049-从根节点到叶节点的路径数字之和" class="headerlink" title="剑指 Offer II 049. 从根节点到叶节点的路径数字之和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3Etpl5/">剑指 Offer II 049. 从根节点到叶节点的路径数字之和</a></h3><h4 id="方法一：HashMap存储父节点"><a href="#方法一：HashMap存储父节点" class="headerlink" title="方法一：HashMap存储父节点"></a>方法一：HashMap存储父节点</h4><ol>
<li>遍历树，使用HashMap存储所有子节点的父节点</li>
<li>遍历树，如果是叶子节点，利用HashMap向上寻找父节点</li>
</ol>
<img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230331113629971.png" alt="image-20230331113629971" style="zoom:50%;" /> 

<h4 id="方法二：BFS-3"><a href="#方法二：BFS-3" class="headerlink" title="方法二：BFS"></a>方法二：BFS</h4><p>双队列，一个队列存节点，一个队列存累加和，每遍历到叶节点，把累加和记录到result中。</p>
<img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230331144402361.png" alt="image-20230331144402361" style="zoom:50%;" /> 

<h4 id="用一个队列也可以实现，offer两次，poll两次，不过要注意Queue的类型是Object，以及使用变量接受TreeNode和Integer时要强转。"><a href="#用一个队列也可以实现，offer两次，poll两次，不过要注意Queue的类型是Object，以及使用变量接受TreeNode和Integer时要强转。" class="headerlink" title="用一个队列也可以实现，offer两次，poll两次，不过要注意Queue的类型是Object，以及使用变量接受TreeNode和Integer时要强转。"></a>用一个队列也可以实现，offer两次，poll两次，不过要注意Queue的类型是Object，以及使用变量接受TreeNode和Integer时要强转。</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Object&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> (TreeNode)queue.poll();</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> (<span class="type">int</span>)queue.poll();</span><br></pre></td></tr></table></figure>

<h3 id="x剑指-Offer-II-050-向下的路径节点之和"><a href="#x剑指-Offer-II-050-向下的路径节点之和" class="headerlink" title="x剑指 Offer II 050. 向下的路径节点之和"></a>x<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/6eUYwP/">剑指 Offer II 050. 向下的路径节点之和</a></h3><h4 id="方法一：暴力"><a href="#方法一：暴力" class="headerlink" title="方法一：暴力"></a>方法一：暴力</h4><p>双重dfs。</p>
<img src="C:\Users\ning\AppData\Roaming\Typora\typora-user-images\image-20230331155507374.png" alt=" " style="zoom:50%;" /> 

<h4 id="注意！！！"><a href="#注意！！！" class="headerlink" title="注意！！！"></a>注意！！！</h4><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230331154846428.png" alt="image-20230331154846428" style="zoom:50%;" /> <img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230331154918879.png" alt="image-20230331154918879" style="zoom:50%;" /></p>
<p>int只有32位，只能表示$-2^{31}到2^{31} - 1$，虽然范围大于$-10^9 到 10^9$，但是节点数最多1000个！$-2^{31}到2^{31} - 1$区间范围是小于${-10^{12}}到10^{12}$的！所以要用long来求和。</p>
<img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230331154948941.png" alt="image-20230331154948941" style="zoom:50%;" /> 

<h4 id="注意！！！-1"><a href="#注意！！！-1" class="headerlink" title="注意！！！"></a>注意！！！</h4><p>树只要往下走就行，可以转弯，不是只能向左或者向右！！</p>
<h4 id="方法二：前缀和"><a href="#方法二：前缀和" class="headerlink" title="方法二：前缀和"></a>方法二：前缀和</h4><h3 id="剑指-Offer-II-053-二叉搜索树中的中序后继"><a href="#剑指-Offer-II-053-二叉搜索树中的中序后继" class="headerlink" title="剑指 Offer II 053. 二叉搜索树中的中序后继"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/P5rCT8/">剑指 Offer II 053. 二叉搜索树中的中序后继</a></h3><h4 id="方法一：中序遍历二叉树"><a href="#方法一：中序遍历二叉树" class="headerlink" title="方法一：中序遍历二叉树"></a>方法一：中序遍历二叉树</h4><p>创建一个boolean变量flag初始为false，当当前节点为目标节点p，则令flag为true，返回下一个从栈中弹出的节点；如果无右继节点，那么cur已经为空且栈空，返回null。</p>
<img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230404143208023.png" alt="image-20230404143208023" style="zoom:50%;" />

<h4 id="方法二：利用搜索二叉树的特性"><a href="#方法二：利用搜索二叉树的特性" class="headerlink" title="方法二：利用搜索二叉树的特性"></a>方法二：利用搜索二叉树的特性</h4><h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230404144826280.png" alt="image-20230404144826280" style="zoom:50%;" /></h4><h3 id="剑指-Offer-II-054-所有大于等于节点的值之和"><a href="#剑指-Offer-II-054-所有大于等于节点的值之和" class="headerlink" title="剑指 Offer II 054. 所有大于等于节点的值之和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/w6cpku/">剑指 Offer II 054. 所有大于等于节点的值之和</a></h3><h4 id="方法一：中序遍历：右根左"><a href="#方法一：中序遍历：右根左" class="headerlink" title="方法一：中序遍历：右根左"></a>方法一：中序遍历：右根左</h4><p>使用一个变量记录上一个节点的值</p>
<img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230404150129398.png" alt="image-20230404150129398" style="zoom:50%;" /> 

<h3 id="剑指-Offer-II-055-二叉搜索树迭代器"><a href="#剑指-Offer-II-055-二叉搜索树迭代器" class="headerlink" title="剑指 Offer II 055. 二叉搜索树迭代器"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kTOapQ/">剑指 Offer II 055. 二叉搜索树迭代器</a></h3><h4 id="方法一：扁平化"><a href="#方法一：扁平化" class="headerlink" title="方法一：扁平化"></a>方法一：扁平化</h4><p>先中序遍历一次，使用LinkedList存储val</p>
<img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230404180957539.png" alt="image-20230404180957539" style="zoom:50%;" /> 

<h4 id="方法二：迭代"><a href="#方法二：迭代" class="headerlink" title="方法二：迭代"></a>方法二：迭代</h4><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-string/">344. 反转字符串</a></h3><p>for循环遍历n&#x2F;2次，使用一个临时变量记录左边的值，然后首尾交换</p>
<p><strong>Trik</strong>:使用位运算进行swap操作，前提是进行交换的a与b在内存空间不同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = a ^ b;</span><br><span class="line">b = a ^ b;</span><br><span class="line">a = a ^ b;</span><br><span class="line"><span class="comment">// 简化</span></span><br><span class="line">a ^= b;</span><br><span class="line">b ^= a;</span><br><span class="line">a ^= b;</span><br></pre></td></tr></table></figure>

<img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230324132148361.png" alt="image-20230324132148361" style="zoom:50%;" /> 

<h4 id="X剑指-Offer-II-051-节点之和最大的路径"><a href="#X剑指-Offer-II-051-节点之和最大的路径" class="headerlink" title="X剑指 Offer II 051. 节点之和最大的路径"></a>X<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/jC7MId/">剑指 Offer II 051. 节点之和最大的路径</a></h4><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230404130939535.png" alt="image-20230404130939535" style="zoom:50%;" /> 

<h3 id="x541-反转字符串-II"><a href="#x541-反转字符串-II" class="headerlink" title="x541. 反转字符串 II"></a>x<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-string-ii/">541. 反转字符串 II</a></h3><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230324143753280.png" alt="image-20230324143753280" style="zoom:50%;" /> 

<h3 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格</a></h3><p>Java中String只读，所以使用StringBuilder来动态append“%20”</p>
<img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230324150110004.png" alt="image-20230324150110004" style="zoom:50%;" /> 

<h3 id="x151-反转字符串中的单词"><a href="#x151-反转字符串中的单词" class="headerlink" title="x151. 反转字符串中的单词"></a>x<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-words-in-a-string/">151. 反转字符串中的单词</a></h3><p><strong>StringBuilder 末尾有额外分隔符！！！</strong></p>
<p>可使用以下方法解决！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sb.setLength(sb.length() - <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><h3 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-search/">704. 二分查找</a></h3><h4 id="方法一：左闭右开"><a href="#方法一：左闭右开" class="headerlink" title="方法一：左闭右开"></a>方法一：左闭右开</h4><ol>
<li>区间：[left, right)</li>
<li>初始化：right &#x3D; nums.length</li>
<li>while循环终止条件应为left &lt; right（右开，right不能等于left）</li>
<li>当nums[mid]  &lt; target时，nums[0]~nums[mid]都小于target，此时有效的有边界是mid - 1，又因为右边界是开区间，所以另right &#x3D; mid</li>
<li>时间复杂度：$O(logn)$，由于每次查找都会将查找范围缩小一半，因此二分查找的时间复杂度是$O(logn)$，其中 <em>n</em> 是数组的长度</li>
<li>空间复杂度：$O(1)$</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length;</span><br><span class="line">        <span class="comment">// [left, right)</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法二：左闭右闭"><a href="#方法二：左闭右闭" class="headerlink" title="方法二：左闭右闭"></a>方法二：左闭右闭</h4><ol>
<li>区间：[left, right]</li>
<li>初始化：right &#x3D; nums.length - 1</li>
<li>while循环终止条件应为left &lt;&#x3D; right</li>
<li>当nums[mid]  &lt; target时，nums[0]~nums[mid]都小于target，另right &#x3D; mid - 1</li>
<li>时间复杂度：$O(logn)$，由于每次查找都会将查找范围缩小一半，因此二分查找的时间复杂度是$O(logn)$，其中 <em>n</em> 是数组的长度</li>
<li>空间复杂度：$O(1)$</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> right - ((right - left) &gt;&gt; <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) </span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-element/">27. 移除元素</a></h3><h3 id="方法一：暴力-1"><a href="#方法一：暴力-1" class="headerlink" title="方法一：暴力"></a>方法一：暴力</h3><ol>
<li>每当发现一个数相等，那么从当前数组的下一个数开始，全部往前移一位。</li>
<li><strong>注意</strong>：因为移位后，下一个要访问的数组元素j会到当前i的位置，然后for循环结束i自增，会错过访j，所以移位后要–i。</li>
<li>时间复杂度：$O(n^2)$</li>
<li>空间复杂度：$O(1)$</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newLen</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (newLen == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; newLen; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == val) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; newLen; j++) &#123;</span><br><span class="line">                    nums[j - <span class="number">1</span>] = nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">                --newLen;</span><br><span class="line">                --i;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newLen;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法二：双指针"><a href="#方法二：双指针" class="headerlink" title="方法二：双指针"></a>方法二：双指针</h4><ol>
<li>初始化慢指针为0</li>
<li>for循环遍历快指针，当nums[fast] !&#x3D; val时，令nums[slow] &#x3D; nums[fast]，slow指针往后移。也就是说，如果快指针找到了val，那么慢指针停在val位置，之后快指针遍历到非val的位置时，将该非val数据覆盖到慢指针的指向数组位置的数据。</li>
<li>最后返回慢指针(慢指针大小代表新数组的大小)</li>
<li>时间复杂度：$O(n)$</li>
<li>空间复杂度：$O(1)$</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>; fast &lt; nums.length; ++fast) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[fast] != val) &#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                ++slow;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法三：相向双指针"><a href="#方法三：相向双指针" class="headerlink" title="方法三：相向双指针"></a>方法三：相向双指针</h4><p><strong>避免了需要保留的元素的重复赋值操作</strong>。</p>
<ol>
<li><p>初始化：left&#x3D;0, right&#x3D;nums.length-1，左闭右闭区间，所以while语句的执行条件是</p>
<p>left &lt;&#x3D; right(如果没有等于，left会少后移一次)</p>
</li>
<li><p>循环：当nums[left]不等于val时，left指针后移；当nums[left]等于val时，将nums[right]赋值给nums[left]，right指针前移；如果赋值过来的元素恰好也等于val，可以继续把右指针 right指向的元素的值赋值过来，直到左指针指向的元素的值不等于 val为止。</p>
</li>
<li><p>时间复杂度：$O(n)$</p>
</li>
<li><p>空间复杂度：$O(1)$</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// [left, right]</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[left] == val) &#123;</span><br><span class="line">                nums[left] = nums[right];</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977. 有序数组的平方"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977. 有序数组的平方</a></h3><h4 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h4><p>left,right指针指向数组两端，将较大的平方数放入result数组里。</p>
<ol>
<li>时间复杂度：$O(n)$</li>
<li>空间复杂度：$O(n)$</li>
</ol>
<img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230406132631275.png" alt="image-20230406132631275" style="zoom:50%;" /> 

<h3 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a></h3><h4 id="nums-i-先执行自增操作还是数组寻址操作"><a href="#nums-i-先执行自增操作还是数组寻址操作" class="headerlink" title="nums[i++]先执行自增操作还是数组寻址操作?"></a>nums[i++]先执行自增操作还是数组寻址操作?</h4><p>在这种情况下，nums[i++]实际上会先执行数组寻址操作，然后再对i进行自增操作。这是因为数组寻址操作的优先级比自增操作的优先级高。</p>
<p>具体来说，这个表达式会先使用i的当前值来计算nums数组中第i个元素的地址，然后将地址作为结果返回，接着才会将i的值加1。</p>
<h4 id="int-a-x3D-i-是先赋值还是先自增"><a href="#int-a-x3D-i-是先赋值还是先自增" class="headerlink" title="int a &#x3D; ++i 是先赋值还是先自增"></a>int a &#x3D; ++i 是先赋值还是先自增</h4><p>这行代码会先自增变量 i 的值，然后将自增后的结果赋值给变量 a。所以，变量 a 的值等于自增后的变量 i 的值。这个过程中，变量 i 的值会被修改，而变量 a 的值则是这个修改后的值。</p>
<p>可以将这行代码拆分成两步：</p>
<ol>
<li>i &#x3D; i + 1； &#x2F;&#x2F; 自增 i 的值</li>
<li>a &#x3D; i； &#x2F;&#x2F; 将自增后的 i 的值赋值给 a</li>
</ol>
<p>所以，最终变量 a 的值等于自增后的变量 i 的值。</p>
<h4 id="int-a-x3D-i-是先赋值还是先自增-1"><a href="#int-a-x3D-i-是先赋值还是先自增-1" class="headerlink" title="int a &#x3D; i++ 是先赋值还是先自增"></a>int a &#x3D; i++ 是先赋值还是先自增</h4><p>这行代码会先将变量 i 的值赋值给变量 a，然后再将变量 i 的值自增。所以，变量 a 的值等于变量 i 的值，而变量 i 的值会被自增。</p>
<p>可以将这行代码拆分成两步：</p>
<ol>
<li>a &#x3D; i； &#x2F;&#x2F; 将 i 的值赋值给 a</li>
<li>i &#x3D; i + 1； &#x2F;&#x2F; 自增 i 的值</li>
</ol>
<p>所以，最终变量 a 的值等于变量 i 的初始值，而变量 i 的值则是初始值加一。</p>
<h4 id="滑动数组"><a href="#滑动数组" class="headerlink" title="滑动数组"></a>滑动数组</h4><ol>
<li>时间复杂度：$O(n)$</li>
<li>空间复杂度：$O(1)$</li>
</ol>
<img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230406142256924.png" alt="image-20230406142256924" style="zoom:50%;" /> 

<h3 id="59-螺旋矩阵-II"><a href="#59-螺旋矩阵-II" class="headerlink" title="59. 螺旋矩阵 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/spiral-matrix-ii/">59. 螺旋矩阵 II</a></h3><ol>
<li><p>遍历顺序：从左到右(左闭右开)，从上到下(上闭下开)，从右到左(右闭左开)，从下到上(下闭上开)</p>
<img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230406151317898.png" alt="image-20230406151317898" style="zoom: 25%;" /> 
</li>
<li><p>思路见代码注释部分</p>
</li>
<li><p>时间复杂度：$O(n^2)$</p>
</li>
<li><p>空间复杂度：$O(1)$</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="comment">// 用笔画一个n=5的矩阵作为例子</span></span><br><span class="line">        <span class="comment">// 遍历顺序：从左到右(左闭右开)，从上到下(上闭下开)，从右到左(右闭左开)，从下到上(下闭上开)</span></span><br><span class="line">        <span class="comment">// 建立n行n列的矩阵</span></span><br><span class="line">        <span class="type">int</span>[][] matrix = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="comment">// 遍历次数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">traverseTime</span> <span class="operator">=</span> n / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> i, j;</span><br><span class="line">        <span class="comment">// 写入数组的数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// cur:当前遍历伦茨</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">0</span>; cur &lt; traverseTime; ++cur) &#123;</span><br><span class="line">            <span class="comment">// 从左到右(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span> (j = cur; j &lt; n - cur - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">                matrix[cur][j] = data++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从上到下(上闭下开)</span></span><br><span class="line">            <span class="keyword">for</span> (i = cur; i &lt; n - cur - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">                matrix[i][j] = data++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从右到左(右闭左开)</span></span><br><span class="line">            <span class="keyword">for</span> (; j &gt; cur; --j) &#123;</span><br><span class="line">                matrix[i][j] = data++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从下到上(下闭上开)</span></span><br><span class="line">            <span class="keyword">for</span> (; i &gt; cur; --i) &#123;</span><br><span class="line">                matrix[i][j] = data++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// debug</span></span><br><span class="line">            <span class="comment">// for (int a = 0; a &lt; n; ++a) &#123;</span></span><br><span class="line">            <span class="comment">//     for (int b = 0; b &lt; n; ++b) &#123;</span></span><br><span class="line">            <span class="comment">//         System.out.print(matrix[a][b]);</span></span><br><span class="line">            <span class="comment">//     &#125;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">            matrix[traverseTime][traverseTime] = n * n;</span><br><span class="line">        <span class="keyword">return</span> matrix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230406150937452.png" alt="image-20230406150937452" style="zoom:50%;" /> 


    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/04/07/test-blog/" rel="prev" title="test blog">
      <i class="fa fa-chevron-left"></i> test blog
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/04/07/ttt/" rel="next" title="ttt">
      ttt <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%A9%AC%E5%A3%AB%E5%85%B5%E7%AE%97%E6%B3%95"><span class="nav-number">1.</span> <span class="nav-text">马士兵算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E8%AF%BE-%E8%AE%A4%E8%AF%86%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="nav-number">1.1.</span> <span class="nav-text">第一课 认识复杂度和简单排序算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E8%AF%BE-%E8%AE%A4%E8%AF%86-O-NlogN-%E7%9A%84%E6%8E%92%E5%BA%8F"><span class="nav-number">1.2.</span> <span class="nav-text">第二课 认识$O(NlogN)$的排序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#LeetCode%E9%A2%98%E8%A7%A3"><span class="nav-number">2.</span> <span class="nav-text">LeetCode题解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Dynamic-Programming"><span class="nav-number">2.1.</span> <span class="nav-text">Dynamic Programming</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#debug"><span class="nav-number">2.1.1.</span> <span class="nav-text">debug</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%91%E6%8C%87Offer-95"><span class="nav-number">2.1.2.</span> <span class="nav-text">剑指Offer 95</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%91%E6%8C%87Offer-101-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86"><span class="nav-number">2.1.3.</span> <span class="nav-text">剑指Offer 101 分割等和子集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%91%E6%8C%87Offer-1049%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F-II"><span class="nav-number">2.1.4.</span> <span class="nav-text">剑指Offer 1049最后一块石头的重量 II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#518-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2-II"><span class="nav-number">2.1.5.</span> <span class="nav-text">518. 零钱兑换 II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#377-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-%E2%85%A3"><span class="nav-number">2.1.6.</span> <span class="nav-text">377. 组合总和 Ⅳ</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#70-%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="nav-number">2.1.7.</span> <span class="nav-text">70. 爬楼梯</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2"><span class="nav-number">2.1.8.</span> <span class="nav-text">322. 零钱兑换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#279-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0"><span class="nav-number">2.1.9.</span> <span class="nav-text">279. 完全平方数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#x139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86"><span class="nav-number">2.1.10.</span> <span class="nav-text">x139. 单词拆分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="nav-number">2.1.11.</span> <span class="nav-text">198. 打家劫舍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">2.1.11.1.</span> <span class="nav-text">优化空间复杂度</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#213-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-II"><span class="nav-number">2.1.12.</span> <span class="nav-text">213. 打家劫舍 II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86"><span class="nav-number">2.1.13.</span> <span class="nav-text">416. 分割等和子集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#x337-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-III"><span class="nav-number">2.1.14.</span> <span class="nav-text">x337. 打家劫舍 III</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#x121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA"><span class="nav-number">2.1.15.</span> <span class="nav-text">x121. 买卖股票的最佳时机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%A0%E6%A0%B9%E6%9C%AC%E6%B2%A1%E5%9C%A8dp%EF%BC%81"><span class="nav-number">2.1.15.1.</span> <span class="nav-text">你根本没在dp！</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E6%9A%B4%E5%8A%9B%E8%BF%AD%E4%BB%A3"><span class="nav-number">2.1.15.2.</span> <span class="nav-text">方法一：暴力迭代</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E8%B4%AA%E5%BF%83"><span class="nav-number">2.1.15.3.</span> <span class="nav-text">方法二：贪心</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%89%EF%BC%9ADP"><span class="nav-number">2.1.15.4.</span> <span class="nav-text">方法三：DP</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-II"><span class="nav-number">2.1.16.</span> <span class="nav-text">122. 买卖股票的最佳时机 II</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E7%A9%BA%E9%97%B4"><span class="nav-number">2.1.16.1.</span> <span class="nav-text">优化空间..</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Binary-Tree"><span class="nav-number">2.2.</span> <span class="nav-text">Binary Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">2.2.1.</span> <span class="nav-text">144. 二叉树的前序遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">2.2.2.</span> <span class="nav-text">94. 二叉树的中序遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">2.2.3.</span> <span class="nav-text">145. 二叉树的后序遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">2.2.4.</span> <span class="nav-text">102. 二叉树的层序遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">2.2.5.</span> <span class="nav-text">226. 翻转二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">2.2.6.</span> <span class="nav-text">101. 对称二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E6%8B%B7%E8%B4%9D-%E7%BF%BB%E8%BD%AC-%E5%88%A4%E6%96%AD-%E9%AB%98%E6%83%85%E5%95%86%EF%BC%9A%E5%88%B7%E4%B8%80%E9%81%93%EF%BC%8C%E8%A7%A3%E4%B8%89%E9%81%93%EF%BC%81%E4%BD%8E%E6%83%85%E5%95%86%EF%BC%9A%E5%8F%AA%E4%BC%9A%E7%AC%A8%E6%96%B9%E6%B3%95%EF%BC%9F%E8%BF%98%E6%98%AF%E7%9C%8B%E7%9C%8B%E8%BF%9C%E6%96%B9%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%90%A7"><span class="nav-number">2.2.6.1.</span> <span class="nav-text">方法一：拷贝+翻转+判断(高情商：刷一道，解三道！低情商：只会笨方法？还是看看远方的复杂度吧)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9ABFS"><span class="nav-number">2.2.6.2.</span> <span class="nav-text">方法二：BFS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%89%EF%BC%9ADFS"><span class="nav-number">2.2.6.3.</span> <span class="nav-text">方法三：DFS</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91"><span class="nav-number">2.2.7.</span> <span class="nav-text">100. 相同的树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9ADFS"><span class="nav-number">2.2.7.1.</span> <span class="nav-text">方法一：DFS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9ABFS-1"><span class="nav-number">2.2.7.2.</span> <span class="nav-text">方法二：BFS</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="nav-number">2.2.8.</span> <span class="nav-text">104. 二叉树的最大深度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9ABFS"><span class="nav-number">2.2.8.1.</span> <span class="nav-text">方法一：BFS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9ADFS"><span class="nav-number">2.2.8.2.</span> <span class="nav-text">方法二：DFS</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#559-N-%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="nav-number">2.2.9.</span> <span class="nav-text">559. N 叉树的最大深度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6"><span class="nav-number">2.2.10.</span> <span class="nav-text">!111. 二叉树的最小深度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9ADFS-1"><span class="nav-number">2.2.10.1.</span> <span class="nav-text">方法一：DFS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9ABFS-2"><span class="nav-number">2.2.10.2.</span> <span class="nav-text">方法二：BFS</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#222-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0"><span class="nav-number">2.2.11.</span> <span class="nav-text">222. 完全二叉树的节点个数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#BFS%EF%BC%9A%E5%9C%A8%E6%AF%8F%E5%B1%82%E5%BC%80%E5%A7%8B%E9%81%8D%E5%8E%86%E6%97%B6%EF%BC%8C%E8%AE%B0%E5%BD%95%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0%E7%9A%84%E5%8F%98%E9%87%8F%E5%8A%A0%E4%B8%8A%E9%98%9F%E5%88%97%E9%87%8C%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0"><span class="nav-number">2.2.11.1.</span> <span class="nav-text">BFS：在每层开始遍历时，记录节点个数的变量加上队列里元素个数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">2.2.12.</span> <span class="nav-text">617. 合并二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#x98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">2.2.13.</span> <span class="nav-text">x98. 验证二叉搜索树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">2.2.13.1.</span> <span class="nav-text">方法一：中序遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#x%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E9%80%92%E5%BD%92"><span class="nav-number">2.2.13.2.</span> <span class="nav-text">x方法二：递归</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#530-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE"><span class="nav-number">2.2.14.</span> <span class="nav-text">530. 二叉搜索树的最小绝对差</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%9A"><span class="nav-number">2.2.14.1.</span> <span class="nav-text">中序遍历：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#501-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0"><span class="nav-number">2.2.15.</span> <span class="nav-text">501. 二叉搜索树中的众数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-number">2.2.16.</span> <span class="nav-text">236. 二叉树的最近公共祖先</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E7%94%A8HashMap%E5%AD%98%E5%82%A8%E6%89%80%E6%9C%89%E7%88%B6%E8%8A%82%E7%82%B9%EF%BC%8C%E7%94%A8HashSet%E6%A0%87%E8%AE%B0%E6%98%AF%E5%90%A6%E8%AE%BF%E9%97%AE%E8%BF%87%EF%BC%9B%E4%BB%8Ep%E5%BC%80%E5%A7%8B%E5%90%91%E4%B8%8A%E9%81%8D%E5%8E%86%EF%BC%8C%E5%B9%B6%E6%A0%87%E8%AE%B0%E8%AE%BF%E9%97%AE%E8%BF%87%E7%9A%84%E7%88%B6%E8%8A%82%E7%82%B9%EF%BC%8C%E5%86%8D%E4%BB%8Eq%E5%BC%80%E5%A7%8B%E5%90%91%E4%B8%8A%E9%81%8D%E5%8E%86%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%BD%93%E5%89%8D%E8%8A%82%E7%82%B9%E8%A2%AB%E8%AE%BF%E9%97%AE%E8%BF%87%EF%BC%8C%E9%82%A3%E4%B9%88%E8%BF%99%E4%B8%AA%E8%8A%82%E7%82%B9%E5%B0%B1%E6%98%AF%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E3%80%82"><span class="nav-number">2.2.16.1.</span> <span class="nav-text">方法一：用HashMap存储所有父节点，用HashSet标记是否访问过；从p开始向上遍历，并标记访问过的父节点，再从q开始向上遍历，如果当前节点被访问过，那么这个节点就是最近公共祖先。</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#235-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-number">2.2.17.</span> <span class="nav-text">235. 二叉搜索树的最近公共祖先</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%92%E5%BD%92%EF%BC%9A%E8%80%83%E8%99%91%E4%B8%89%E7%A7%8D%E6%83%85%E5%86%B5"><span class="nav-number">2.2.17.1.</span> <span class="nav-text">递归：考虑三种情况</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#701-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="nav-number">2.2.18.</span> <span class="nav-text">701. 二叉搜索树中的插入操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E9%81%8D%E5%8E%86"><span class="nav-number">2.2.18.1.</span> <span class="nav-text">方法一：遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E9%80%92%E5%BD%92"><span class="nav-number">2.2.18.2.</span> <span class="nav-text">方法二：递归</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#x450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="nav-number">2.2.19.</span> <span class="nav-text">x450. 删除二叉搜索树中的节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#669-%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">2.2.20.</span> <span class="nav-text">669. 修剪二叉搜索树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">2.2.21.</span> <span class="nav-text">108. 将有序数组转换为二叉搜索树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#538-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91"><span class="nav-number">2.2.22.</span> <span class="nav-text">538. 把二叉搜索树转换为累加树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%B3%E6%A0%B9%E5%B7%A6%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%81-LeetCode%E5%AE%98%E6%96%B9%E5%8F%AB%E5%AE%83%E5%8F%8D%E5%BA%8F%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">2.2.22.1.</span> <span class="nav-text">右根左中序遍历！ LeetCode官方叫它反序中序遍历</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#x-106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">2.2.23.</span> <span class="nav-text">x[106. 从中序与后序遍历序列构造二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">2.2.24.</span> <span class="nav-text">[105. 从前序与中序遍历序列构造二叉树]</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-II-047-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%AA%E6%9E%9D"><span class="nav-number">2.2.25.</span> <span class="nav-text">剑指 Offer II 047. 二叉树剪枝</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E7%AC%A8%E6%96%B9%E6%B3%95%EF%BC%81%E9%9D%9E%E9%80%92%E5%BD%92%E5%90%8E%E5%BA%8FDFS-HashMap%E5%AD%98%E5%82%A8%E7%88%B6%E8%8A%82%E7%82%B9"><span class="nav-number">2.2.25.1.</span> <span class="nav-text">方法一：笨方法！非递归后序DFS + HashMap存储父节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E9%9D%9E%E9%80%92%E5%BD%92%E5%90%8E%E7%BB%ADDFS%EF%BC%8C%E6%A0%B9%E6%9C%AC%E4%B8%8D%E7%94%A8Hash-Map%EF%BC%81"><span class="nav-number">2.2.25.2.</span> <span class="nav-text">方法二：非递归后续DFS，根本不用Hash Map！</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%89%EF%BC%9A%E9%80%92%E5%BD%92"><span class="nav-number">2.2.25.3.</span> <span class="nav-text">方法三：递归</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#x%E5%89%91%E6%8C%87-Offer-II-048-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">2.2.26.</span> <span class="nav-text">x剑指 Offer II 048. 序列化与反序列化二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-II-049-%E4%BB%8E%E6%A0%B9%E8%8A%82%E7%82%B9%E5%88%B0%E5%8F%B6%E8%8A%82%E7%82%B9%E7%9A%84%E8%B7%AF%E5%BE%84%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C"><span class="nav-number">2.2.27.</span> <span class="nav-text">剑指 Offer II 049. 从根节点到叶节点的路径数字之和</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9AHashMap%E5%AD%98%E5%82%A8%E7%88%B6%E8%8A%82%E7%82%B9"><span class="nav-number">2.2.27.1.</span> <span class="nav-text">方法一：HashMap存储父节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9ABFS-3"><span class="nav-number">2.2.27.2.</span> <span class="nav-text">方法二：BFS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E4%B8%80%E4%B8%AA%E9%98%9F%E5%88%97%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%EF%BC%8Coffer%E4%B8%A4%E6%AC%A1%EF%BC%8Cpoll%E4%B8%A4%E6%AC%A1%EF%BC%8C%E4%B8%8D%E8%BF%87%E8%A6%81%E6%B3%A8%E6%84%8FQueue%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%98%AFObject%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F%E6%8E%A5%E5%8F%97TreeNode%E5%92%8CInteger%E6%97%B6%E8%A6%81%E5%BC%BA%E8%BD%AC%E3%80%82"><span class="nav-number">2.2.27.3.</span> <span class="nav-text">用一个队列也可以实现，offer两次，poll两次，不过要注意Queue的类型是Object，以及使用变量接受TreeNode和Integer时要强转。</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#x%E5%89%91%E6%8C%87-Offer-II-050-%E5%90%91%E4%B8%8B%E7%9A%84%E8%B7%AF%E5%BE%84%E8%8A%82%E7%82%B9%E4%B9%8B%E5%92%8C"><span class="nav-number">2.2.28.</span> <span class="nav-text">x剑指 Offer II 050. 向下的路径节点之和</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E6%9A%B4%E5%8A%9B"><span class="nav-number">2.2.28.1.</span> <span class="nav-text">方法一：暴力</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%EF%BC%81%EF%BC%81%EF%BC%81"><span class="nav-number">2.2.28.2.</span> <span class="nav-text">注意！！！</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%EF%BC%81%EF%BC%81%EF%BC%81-1"><span class="nav-number">2.2.28.3.</span> <span class="nav-text">注意！！！</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%89%8D%E7%BC%80%E5%92%8C"><span class="nav-number">2.2.28.4.</span> <span class="nav-text">方法二：前缀和</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-II-053-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%B8%AD%E5%BA%8F%E5%90%8E%E7%BB%A7"><span class="nav-number">2.2.29.</span> <span class="nav-text">剑指 Offer II 053. 二叉搜索树中的中序后继</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">2.2.29.1.</span> <span class="nav-text">方法一：中序遍历二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%88%A9%E7%94%A8%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-number">2.2.29.2.</span> <span class="nav-text">方法二：利用搜索二叉树的特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.2.29.3.</span> <span class="nav-text"></span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-II-054-%E6%89%80%E6%9C%89%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E%E8%8A%82%E7%82%B9%E7%9A%84%E5%80%BC%E4%B9%8B%E5%92%8C"><span class="nav-number">2.2.30.</span> <span class="nav-text">剑指 Offer II 054. 所有大于等于节点的值之和</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%9A%E5%8F%B3%E6%A0%B9%E5%B7%A6"><span class="nav-number">2.2.30.1.</span> <span class="nav-text">方法一：中序遍历：右根左</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-II-055-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">2.2.31.</span> <span class="nav-text">剑指 Offer II 055. 二叉搜索树迭代器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E6%89%81%E5%B9%B3%E5%8C%96"><span class="nav-number">2.2.31.1.</span> <span class="nav-text">方法一：扁平化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E8%BF%AD%E4%BB%A3"><span class="nav-number">2.2.31.2.</span> <span class="nav-text">方法二：迭代</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String"><span class="nav-number">2.3.</span> <span class="nav-text">String</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#344-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">2.3.1.</span> <span class="nav-text">344. 反转字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#X%E5%89%91%E6%8C%87-Offer-II-051-%E8%8A%82%E7%82%B9%E4%B9%8B%E5%92%8C%E6%9C%80%E5%A4%A7%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="nav-number">2.3.1.1.</span> <span class="nav-text">X剑指 Offer II 051. 节点之和最大的路径</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#x541-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2-II"><span class="nav-number">2.3.2.</span> <span class="nav-text">x541. 反转字符串 II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-05-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC"><span class="nav-number">2.3.3.</span> <span class="nav-text">剑指 Offer 05. 替换空格</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#x151-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D"><span class="nav-number">2.3.4.</span> <span class="nav-text">x151. 反转字符串中的单词</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Array"><span class="nav-number">2.4.</span> <span class="nav-text">Array</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#704-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-number">2.4.1.</span> <span class="nav-text">704. 二分查找</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E5%B7%A6%E9%97%AD%E5%8F%B3%E5%BC%80"><span class="nav-number">2.4.1.1.</span> <span class="nav-text">方法一：左闭右开</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%B7%A6%E9%97%AD%E5%8F%B3%E9%97%AD"><span class="nav-number">2.4.1.2.</span> <span class="nav-text">方法二：左闭右闭</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0"><span class="nav-number">2.4.2.</span> <span class="nav-text">27. 移除元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E6%9A%B4%E5%8A%9B-1"><span class="nav-number">2.4.3.</span> <span class="nav-text">方法一：暴力</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%8F%8C%E6%8C%87%E9%92%88"><span class="nav-number">2.4.3.1.</span> <span class="nav-text">方法二：双指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%89%EF%BC%9A%E7%9B%B8%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88"><span class="nav-number">2.4.3.2.</span> <span class="nav-text">方法三：相向双指针</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#977-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9"><span class="nav-number">2.4.4.</span> <span class="nav-text">977. 有序数组的平方</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88"><span class="nav-number">2.4.4.1.</span> <span class="nav-text">双指针</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#209-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-number">2.4.5.</span> <span class="nav-text">209. 长度最小的子数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#nums-i-%E5%85%88%E6%89%A7%E8%A1%8C%E8%87%AA%E5%A2%9E%E6%93%8D%E4%BD%9C%E8%BF%98%E6%98%AF%E6%95%B0%E7%BB%84%E5%AF%BB%E5%9D%80%E6%93%8D%E4%BD%9C"><span class="nav-number">2.4.5.1.</span> <span class="nav-text">nums[i++]先执行自增操作还是数组寻址操作?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#int-a-x3D-i-%E6%98%AF%E5%85%88%E8%B5%8B%E5%80%BC%E8%BF%98%E6%98%AF%E5%85%88%E8%87%AA%E5%A2%9E"><span class="nav-number">2.4.5.2.</span> <span class="nav-text">int a &#x3D; ++i 是先赋值还是先自增</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#int-a-x3D-i-%E6%98%AF%E5%85%88%E8%B5%8B%E5%80%BC%E8%BF%98%E6%98%AF%E5%85%88%E8%87%AA%E5%A2%9E-1"><span class="nav-number">2.4.5.3.</span> <span class="nav-text">int a &#x3D; i++ 是先赋值还是先自增</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%BB%91%E5%8A%A8%E6%95%B0%E7%BB%84"><span class="nav-number">2.4.5.4.</span> <span class="nav-text">滑动数组</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#59-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5-II"><span class="nav-number">2.4.6.</span> <span class="nav-text">59. 螺旋矩阵 II</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Leopold</p>
  <div class="site-description" itemprop="description">For offers</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">4</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Leopold</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
