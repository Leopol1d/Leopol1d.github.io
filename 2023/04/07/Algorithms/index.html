<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/cat-96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/cat-96.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"leopol1d.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="LeetCode Solutions Dynamic Programming debug 1234567private static void printDp(int[] dp, int i) &amp;#123;    System.out.print(i + &quot;: &quot;);    for (int maxValue : dp)&amp;#123;        System.out.p">
<meta property="og:type" content="article">
<meta property="og:title" content="Algorithms">
<meta property="og:url" content="https://leopol1d.github.io/2023/04/07/Algorithms/index.html">
<meta property="og:site_name" content="Leopold&#39;s Blog">
<meta property="og:description" content="LeetCode Solutions Dynamic Programming debug 1234567private static void printDp(int[] dp, int i) &amp;#123;    System.out.print(i + &quot;: &quot;);    for (int maxValue : dp)&amp;#123;        System.out.p">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230318210753861.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230318210708505.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230318210647601.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230318210620287.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230320095545766.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230327183302703.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230328192555408.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230328164702918.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230329142700228.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230330094627247.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230330101656109.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230330105858903.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230330112546180.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230320111737785.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230320113039413.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230320115618376.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230320152504462.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230320161332491.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230321093745686.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230321100900158.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230321102148975.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230321103126806.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230321110400024.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230321111653023.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230321142849628.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230321144735136.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230321150754544.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230321155140257.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230322110219397.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230322155627326.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230323100510481.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230323103301262.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230323104721968.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230323142204001.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230323142217741.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230323144126141.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230323150830325.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230323154603928.png">
<meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/20210203154720326.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230330140341816.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230330144646861.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230330143640861.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230331103348908.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230331113629971.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230331144402361.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230331155507374.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230331154846428.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230331154918879.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230331154948941.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230404143208023.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230404144826280.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230404150129398.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230404180957539.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230324132148361.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230404130939535.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230324143753280.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230324150110004.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230406132631275.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230406142256924.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230406151317898.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230406150937452.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230407173513851.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230407211111582.png">
<meta property="og:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230407213816337.png">
<meta property="article:published_time" content="2023-04-07T08:06:11.000Z">
<meta property="article:modified_time" content="2023-04-07T13:43:15.771Z">
<meta property="article:author" content="Leopold">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230318210753861.png">

<link rel="canonical" href="https://leopol1d.github.io/2023/04/07/Algorithms/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Algorithms | Leopold's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Leopold's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Algorithms</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://leopol1d.github.io/2023/04/07/Algorithms/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Leopold">
      <meta itemprop="description" content="For offers">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leopold's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Algorithms
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-04-07 16:06:11 / 修改时间：21:43:15" itemprop="dateCreated datePublished" datetime="2023-04-07T16:06:11+08:00">2023-04-07</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="leetcode-solutions">LeetCode Solutions</h1>
<h2 id="dynamic-programming">Dynamic Programming</h2>
<h3 id="debug">debug</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printDp</span><span class="params">(<span class="type">int</span>[] dp, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    System.out.print(i + <span class="string">&quot;: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> maxValue : dp)&#123;</span><br><span class="line">        System.out.print(maxValue + <span class="string">&quot;   &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="剑指offer-95">剑指Offer 95</h3>
<ol type="1">
<li><p>最优子结构：求<strong>最长</strong>公共子序列，求问题最优解，适合使用dp解决。</p></li>
<li><p>重叠子问题：求第一个字符串中位置0~<span class="math inline">\(i\)</span>构成的子序列与第二个字符串中0~<span class="math inline">\(j\)</span>构成的子序列的最大公共子序列<span class="math inline">\(f(i,j)\)</span>，需要多次使用<span class="math inline">\(f(i-1, j-1), f(i-1,j),f(i,j-1)\)</span>，拥有重叠子问题</p></li>
<li><p>状态转移方程： <span class="math display">\[
f(i,j) = 
\begin{cases}
f(i-1,j-1)+1, &amp; ch[i]==ch[j] \\
max(f(i-1,j),f(i,j-1)), &amp; else \\
\end{cases}
\]</span></p></li>
<li><p>边界条件：dp[0][:] == 0, dp[:][] == 0</p></li>
</ol>
<p>令两个字符串长度分别为<span class="math inline">\(m,n\)</span>，</p>
<p><strong>时间复杂度</strong>：双重for循环，<span class="math inline">\(O(mn)\)</span></p>
<p><strong>空间复杂度</strong>：需要建立大小为(m+1)(n+1)的数组，因此空间复杂度为<span class="math inline">\(O(mn)\)</span></p>
<p><strong>如何优化空间复杂度？</strong></p>
<h3 id="剑指offer-101-分割等和子集">剑指Offer 101 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-equal-subset-sum/">分割等和子集</a></h3>
<p><strong>分析</strong>：只要在数组中找到任意数等于数组累加和的一半，该数组就是等和子集，可抽象为经典0-1背包问题。</p>
<ol type="1">
<li>dp[i][j]:从编号0-i的物品中任选物品(可以都不选)，容量为j的背包能否正好装满</li>
<li>递归公式:dp[i][j] = dp[i-1][j] || j &gt;= num[i] : dp[i-1][j-nums[i]] : false</li>
<li>初始化:
<ol type="1">
<li>当j==0时，即背包容量为0，不管有多少物品，只要什么都不选就能使背包总重量为0，所以f(i,0)=true</li>
<li>当i==0 &amp;&amp; j!= 0时，即物品数量为0，怎样都不能放满容量大于0的背包，所以f(0,i)=false</li>
</ol></li>
<li>遍历顺序：先遍历物品再嵌套从头到尾遍历容量</li>
<li>打印dp数组验证与手写稿是否一致</li>
</ol>
<p><strong>空间复杂度优化</strong>：由于求第i行dp数组只需要用到第i-1行dp数组的信息，所以可以使用一维滑动dp数组代替二维dp数组。</p>
<h3 id="剑指offer-1049最后一块石头的重量-ii">剑指Offer 1049<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/last-stone-weight-ii/">最后一块石头的重量 II</a></h3>
<p><strong>从 stones数组中选择，凑成总和不超过 <span class="math inline">\(sum/2\)</span> 的最大价值</strong></p>
<h3 id="零钱兑换-ii"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change-ii/">518. 零钱兑换 II</a></h3>
<p>​ 经典完全背包问题，解题步骤如下：</p>
<ol type="1">
<li>dp[j]：背包容量为j时，放满背包的组合方法数</li>
<li>状态转移公式：dp[j] = dp[j] + dp[j - coins[i]]</li>
<li>初始化dp[0]：背包容量为0时，有一种方法放满背包（什么都不放）</li>
<li>遍历顺序：求组合数，先便利物品，再遍历容量</li>
<li>遍历dp数组</li>
</ol>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230318210753861.png" alt="image-20230318210753861" style="zoom:50%;" /></p>
<p><strong>关于组合和排列的理解</strong>：先遍历物品后遍历背包是这样，比如，外层循环固定coins[1]，在内层循环遍历背包时，随着背包不断增加，coins[1]可以重复被添加进来，而由于外层循环固定了，因此coins[2]只能在下一次外层循环添加进不同大小的背包中，这么看的话，coins[i + 1]只能在coins[i]之后了；如果先遍历背包后遍历物品，那么外层循环先固定背包大小j，然后在大小为j的背包中循环遍历添加物品，然后在下次外层循环背包大小变为j+1，此时仍要执行内层循环遍历添加物品，也就会出现在上一轮外层循环中添加coins[2]的基础上还能再添加coins[1]的情况，那么就有了coins[1]在coins[2]之后的情况了(逆序)。</p>
<p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包。</strong></p>
<p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品。</strong></p>
<h3 id="组合总和-ⅳ"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-iv/">377. 组合总和 Ⅳ</a></h3>
<p>全排列问题，转化为完全背包问题</p>
<ol type="1">
<li>dp[j]：在背包容量为j时，放满背包的排列数</li>
<li>状态转移公式：dp[j] = dp[j] + dp[j - nums[i]]</li>
<li>初始化dp[0]：在背包容量为0时，放满背包的排列数量为1（什么都不放）</li>
<li>遍历顺序，排列问题，先遍历背包容量(物品可以逆序放入dp[j - nums[i]])，再遍历物品</li>
<li>打印dp数组</li>
</ol>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230318210708505.png" alt="image-20230318210708505" style="zoom:50%;" /></p>
<h3 id="爬楼梯"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a></h3>
<p><strong>完全背包</strong> + 全排列问题，可以重复选择放入物品1与物品2，求放满容量为n的背包的排列数</p>
<ol type="1">
<li>dp[j]：在背包容量为j时，放满背包的排列数</li>
<li>状态转移公式：dp[j] = dp[j] + dp[j - nums[i]]</li>
<li>初始化dp[0]：在背包容量为0时，放满背包的排列数量为1（什么都不放）</li>
<li>遍历顺序，排列问题，先遍历背包容量(物品可以逆序放入dp[j - nums[i]])，再遍历物品</li>
<li>打印dp数组</li>
</ol>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230318210647601.png" alt="image-20230318210647601" style="zoom:50%;" /></p>
<h3 id="零钱兑换"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换</a></h3>
<p><strong>完全背包问题</strong></p>
<ol type="1">
<li>dp[j]：背包容量为j时，凑满背包容量所需的<strong>最少硬币数</strong></li>
<li>状态转移公式：dp[j] = min(dp[j], dp[j - coins[i]] + 1)</li>
<li>初始化dp[0]：背包容量为0时，凑满背包容量所需的最少硬币数时0,其他初始化为Integer.MAX_VALUE</li>
<li>遍历顺序，无所谓</li>
<li>打印dp数组</li>
</ol>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230318210620287.png" alt="image-20230318210620287" style="zoom:50%;" /></p>
<p>前天晚上你告诉我你最近经常有分手的念头，我很诧异，我以为一切都很顺利，感情也好，以后要去的城市也好。我觉得遗憾的是，我们不能经常见面，我不擅长表达我的感情，我感受到太久不见生疏了，所以上周急着想去找你。我前天晚上确实过分了，抱歉，之前吵架也是，每次吵架都是在我身体状态不好的时候，情绪比较激动，昨天本来想提醒你学习的，不过看定位你好像去了图书馆(后来你关闭了共享)；还有分享我同学带牙套4个月的效果这件事，不过我状态有点恶化，去了医院，就没来找你了，怕控制不住情绪。12号的时候我其实非常开心，之前两年你都不记得这档事，今年居然记得了，去实验室的路上都在笑。对了，没有送花，没有合照也挺遗憾的，抱歉，我也很拖延，喜欢推到下次。我知道在一段感情中，有一方有分手的想法， 就已经结束了。祝你5月考试顺利，工作没有那么多烦恼。</p>
<h3 id="完全平方数"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/perfect-squares/">279. 完全平方数</a></h3>
<ol type="1">
<li><p>dp[j]：装满容量为j的背包，至少要放多少个物品</p></li>
<li><p>状态转移公式：dp[j] = min(dp[j], dp[j - weights[i]] + 1)</p></li>
<li><p>初始化dp[0]:装满容量为0的背包，至少放0个物品；其他设为Integet.MAX_VALUE</p></li>
<li><p>遍历顺序：无所谓</p></li>
<li><p>打印dp数组</p></li>
</ol>
<h3 id="x139.-单词拆分">x<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-break/">139. 单词拆分</a></h3>
<p><strong>背包问题</strong> + <strong>排列</strong>(“leetcode”由“leet”与“code”组成但不能反过来由“code”与“leet”组成 )的变种，建议不要完全抽象成背包问题，便于理解</p>
<ol type="1">
<li>dp[j]：长度为j的字符串，<strong>可以被字典中的单词拆分</strong>。</li>
<li>状态转移公式：if([j, i] 这个区间的子串出现在字典里 &amp;&amp; dp[j]是true) 那么 dp[i] = true， 其中j&lt;i。</li>
<li>初始化dp[0]:dp[i]依赖于前面的dp[j]，所以dp[0]要初始化为true，不然全为false</li>
<li>遍历顺序：先遍历背包容量，再嵌套遍历物品</li>
<li>打印dp数组</li>
</ol>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230320095545766.png" alt="image-20230320095545766" style="zoom:50%;" /></p>
<h3 id="打家劫舍"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber/">198. 打家劫舍</a></h3>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230327183302703.png" alt="image-20230327183302703" style="zoom:50%;" /></p>
<ol type="1">
<li>dp[j]：偷窃从标号为0到j的房屋所能获得的最大价值</li>
<li>状态转移公式：dp[j] = max(dp[j - 1], dp[j - 2] + nums[j])</li>
<li>初始化：dp[0] = nums[0], dp[1] = max(nums[0], nums[1])</li>
<li>遍历顺序：单序列问题,dp[i] 是根据dp[i - 2] 和 dp[i - 1] 推导出来的，那么一定是从前到后遍历！</li>
<li>遍历dp数组</li>
</ol>
<h4 id="优化空间复杂度">优化空间复杂度</h4>
<p>根据状态转移公式dp[j] = max(dp[j - 1], dp[j - 2] + nums[j])，dp[j]只需要dp[j-1]以及dp[j-2]两个变量即可，可以把数组大小压缩到2。</p>
<h3 id="打家劫舍-ii"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber-ii/">213. 打家劫舍 II</a></h3>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230328192555408.png" alt="image-20230328192555408" style="zoom:50%;" /></p>
<h3 id="分割等和子集"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-equal-subset-sum/">416. 分割等和子集</a></h3>
<ol type="1">
<li>dp[j]：背包容量为j时，是否能用物品装满</li>
<li>状态转移方程：dp[j] = dp[j] || dp[j - nums[i]]</li>
<li>初始化：背包容量为0时，不把物品装进去即可装满，dp[0] = true</li>
<li>遍历顺序：一维滑动数组，零一背包，先遍历物品后遍历背包容量</li>
</ol>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230328164702918.png" alt="image-20230328164702918" style="zoom:50%;" /></p>
<h3 id="x337.-打家劫舍-iii">x<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber-iii/">337. 打家劫舍 III</a></h3>
<p>f：偷当前房屋能获得的最大价值；g：不偷当前房屋能获得的最大价值</p>
<ol type="1">
<li>偷当前房屋f(cur) = cur.val + g(cur.left) + g(cur.right)</li>
<li>不偷当前房屋g(cur) = max(f(cur.left), g(cur.left)) + max(f(cur.right), g(cur.right))</li>
</ol>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230329142700228.png" alt="image-20230329142700228" style="zoom:50%;" /></p>
<h3 id="x121.-买卖股票的最佳时机">x<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h3>
<h4 id="你根本没在dp">你根本没在dp！</h4>
<h4 id="方法一暴力迭代">方法一：暴力迭代</h4>
<p>超时咯</p>
<figure>
<img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230330094627247.png" alt="image-20230330094627247" /><figcaption aria-hidden="true">image-20230330094627247</figcaption>
</figure>
<h4 id="方法二贪心">方法二：贪心</h4>
<p>从前往后遍历，使用minPrice记录最小值，使用maxProfit记录最大收益</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230330101656109.png" alt="image-20230330101656109" style="zoom:50%;" /></p>
<h4 id="方法三dp">方法三：DP</h4>
<p><strong>DP数组的定义十分重要！</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span> || prices == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 1.dp[0][j]:第j天持有股票(之前买入或者当前买入)所拥有的最大价值，dp[1][j]：第j天不持有股票(之前卖出或者当前卖出)所拥有的最大价值</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][len];</span><br><span class="line">        <span class="comment">// 2.状态转移方程：dp[0][j] = max(dp[0][j-1], -price[j]); dp[1][j] = max(dp[1][j-1], price[j] + dp[0][j - 1])</span></span><br><span class="line">        <span class="comment">// 3.初始化：dp[0][0]必须买入，初始化为-price[0]；dp[1][0]不能卖出任何股票，初始化为0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 4.遍历顺序：dp[j]由dp[j-1]决定，所以从前往后遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; len; ++j) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = Math.max(dp[<span class="number">0</span>][j - <span class="number">1</span>], -prices[j]);</span><br><span class="line">            dp[<span class="number">1</span>][j] = Math.max(dp[<span class="number">1</span>][j - <span class="number">1</span>], prices[j] + dp[<span class="number">0</span>][j - <span class="number">1</span>]); <span class="comment">// 不能当天买入当天卖出所以是dp[0][j - 1]</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>][len - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 5.打印dp数组</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230330105858903.png" alt="image-20230330105858903" style="zoom:50%;" /></p>
<h3 id="买卖股票的最佳时机-ii"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.dp[0][j]:在第j天持有(之前买入，当前买入)股票时拥有的最大现金;dp[1][j]在第j天不持有(之前卖出，当前卖出)股票拥有的最大现金</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][len];</span><br><span class="line">        <span class="comment">// 2.状态转移方程：dp[0][j] = max(dp[0][j - 1], dp[1][j - 1] - price[j]); dp[1][j] = max(dp[1][j - 1], dp[0][j - 1] + price[j])</span></span><br><span class="line">        <span class="comment">// 3.初始化：dp[0][0] = -price[0];dp[1][0] = 0;可以当天出售</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 4.遍历顺序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; len; ++j) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = Math.max(dp[<span class="number">0</span>][j - <span class="number">1</span>], dp[<span class="number">1</span>][j - <span class="number">1</span>] - prices[j]);</span><br><span class="line">            dp[<span class="number">1</span>][j] = Math.max(dp[<span class="number">1</span>][j - <span class="number">1</span>], dp[<span class="number">0</span>][j - <span class="number">1</span>] + prices[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>][len - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 5.打印dp数组</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230330112546180.png" alt="image-20230330112546180" style="zoom:50%;" /></p>
<h4 id="优化空间..">优化空间..</h4>
<h2 id="binary-tree">Binary Tree</h2>
<h3 id="二叉树的前序遍历"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></h3>
<p>递归与非递归</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230320111737785.png" alt="image-20230320111737785" style="zoom:50%;" /></p>
<h3 id="二叉树的中序遍历"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h3>
<p>递归与非递归</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230320113039413.png" alt="image-20230320113039413" style="zoom:50%;" /></p>
<h3 id="二叉树的后序遍历"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></h3>
<p>递归与非递归</p>
<p><strong>非递归中，需要利用一个pre指针来判断当前节点的右子树有没有被访问过。</strong></p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230320115618376.png" alt="image-20230320115618376" style="zoom:50%;" /></p>
<h3 id="二叉树的层序遍历"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h3>
<p>借助队列实现，<strong>关键在于通过queue.size来判断下一层的节点数！</strong></p>
<p><em>Queue.offer(null)的话，size为1！</em></p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230320152504462.png" alt="image-20230320152504462" style="zoom:50%;" /></p>
<h3 id="翻转二叉树"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树</a></h3>
<p>这道题目背后有一个让程序员心酸的故事，听说 Homebrew的作者Max Howell，就是因为没在白板上写出翻转二叉树，最后被Google拒绝了。（真假不做判断，权当一个乐子哈）</p>
<p>要求：左右子树交换位置</p>
<p>解法：<strong>bfs层级遍历</strong></p>
<p><strong>时间复杂度</strong>：所有节点都需要入队，出队一次，所以是<span class="math inline">\(O(n)\)</span></p>
<p><strong>空间复杂度</strong>：在最坏的情况下，给定的树是满二叉树，所有叶节点(<span class="math inline">\(n/2 + 1\)</span>)都要入队，所以是<span class="math inline">\(O(n)\)</span></p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230320161332491.png" alt="image-20230320161332491" style="zoom:50%;" /></p>
<h3 id="对称二叉树"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树</a></h3>
<h4 id="方法一拷贝翻转判断高情商刷一道解三道低情商只会笨方法还是看看远方的复杂度吧">方法一：拷贝+翻转+判断(高情商：刷一道，解三道！低情商：只会笨方法？还是看看远方的复杂度吧)</h4>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230321093745686.png" alt="image-20230321093745686" style="zoom:50%;" /> 写了80行，一题三解！不分析复杂度了。。</p>
<h4 id="方法二bfs">方法二：BFS</h4>
<p>假设树上一共有<em>n</em> 个节点。</p>
<p><strong>时间复杂度</strong>：遍历了整棵树，<span class="math inline">\(O(n)\)</span></p>
<p><strong>空间复杂度</strong>：和使用的队列大小相关，在最坏的情况下，给定的树是满二叉树，所有叶节点(<span class="math inline">\(n/2 + 1\)</span>)都要入队，所以是<span class="math inline">\(O(n)\)</span></p>
<h4 id="方法三dfs">方法三：DFS</h4>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230321100900158.png" alt="image-20230321100900158" style="zoom:50%;" /> YYDS</p>
<p>假设树上一共有<em>n</em> 个节点。</p>
<p><strong>时间复杂度</strong>：遍历了整棵树，<span class="math inline">\(O(n)\)</span></p>
<p><strong>空间复杂度</strong>：和递归使用的栈大小相关，递归层数不超过n(一叉树)，<span class="math inline">\(O(n)\)</span></p>
<h3 id="相同的树"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/same-tree/">100. 相同的树</a></h3>
<p><strong>对称二叉树</strong>方法一中用到了这个笨方法，顺手做了吧。</p>
<h4 id="方法一dfs">方法一：DFS</h4>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230321102148975.png" alt="image-20230321102148975" style="zoom:50%;" /></p>
<p>假设树上一共有<span class="math inline">\(n\)</span>个节点</p>
<p><strong>时间复杂度</strong>：遍历了整棵树，<span class="math inline">\(O(n)\)</span></p>
<p><strong>空间复杂度</strong>：和递归使用的栈大小相关，递归层数不超过n，<span class="math inline">\(O(n)\)</span></p>
<h4 id="方法二bfs-1">方法二：BFS</h4>
<p>只是和<strong>对称二叉树</strong>BFS解法中的入队顺序改变一点。</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230321103126806.png" alt="image-20230321103126806" style="zoom:50%;" /></p>
<p>假设树上一共有<em>n</em> 个节点。</p>
<p><strong>时间复杂度</strong>：遍历了整棵树，<span class="math inline">\(O(n)\)</span></p>
<p><strong>空间复杂度</strong>：和使用的队列大小相关，在最坏的情况下，给定的树是满二叉树，所有叶节点(<span class="math inline">\(n/2 + 1\)</span>)都要入队，所以是<span class="math inline">\(O(n)\)</span></p>
<h3 id="二叉树的最大深度"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h3>
<h4 id="方法一bfs">方法一：BFS</h4>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230321110400024.png" alt="image-20230321110400024" style="zoom:50%;" /></p>
<p>假设树上有<span class="math inline">\(n\)</span>个节点</p>
<p><strong>时间复杂度</strong>：遍历整棵树，<span class="math inline">\(O(n)\)</span></p>
<p><strong>空间复杂度</strong>：和使用的队列大小相关，在最坏情况下，给定的二叉树是满二叉树，<span class="math inline">\(n/2 + 1\)</span>个叶节点要入队，所以是<span class="math inline">\(O(n)\)</span></p>
<h4 id="方法二dfs">方法二：DFS</h4>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230321111653023.png" alt="image-20230321111653023" style="zoom:50%;" /></p>
<p>假设树上一共有<span class="math inline">\(n\)</span>个节点</p>
<p><strong>时间复杂度</strong>：遍历了整棵树，<span class="math inline">\(O(n)\)</span></p>
<p><strong>空间复杂度</strong>：和递归使用的栈大小相关，递归层数不超过n，<span class="math inline">\(O(n)\)</span></p>
<h3 id="n-叉树的最大深度"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/">559. N 叉树的最大深度</a></h3>
<p>同上题<strong>二叉树的最大深度</strong>，只是在遍历子节点的时候不同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cur.children.size(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cur.children.get(i) != <span class="literal">null</span>)</span><br><span class="line">        queue.offer(cur.children.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230321142849628.png" alt="image-20230321142849628" style="zoom:50%;" /></p>
<h3 id="二叉树的最小深度">!<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></h3>
<p><strong>最小深度是从根节点到最近叶子节点的最短路径上的节点数量</strong></p>
<h4 id="方法一dfs-1">方法一：DFS</h4>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230321144735136.png" alt="image-20230321144735136" style="zoom:50%;" /></p>
<h4 id="方法二bfs-2">方法二：BFS</h4>
<p>想太复杂了！！</p>
<p>只需在遍历节点的时候考虑当前节点是不是叶节点，是叶节点直接return depth!</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230321150754544.png" alt="image-20230321150754544" style="zoom:50%;" /></p>
<h3 id="完全二叉树的节点个数"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数</a></h3>
<h4 id="bfs在每层开始遍历时记录节点个数的变量加上队列里元素个数">BFS：在每层开始遍历时，记录节点个数的变量加上队列里元素个数</h4>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230321155140257.png" alt="image-20230321155140257" style="zoom:50%;" /></p>
<h3 id="合并二叉树"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-binary-trees/">617. 合并二叉树</a></h3>
<p><strong>解题思路</strong>：当树1当前节点的左子树或右子树为空，而树2当前节点左子树或右子树不为空时：使用parentQueue存储树1树2的当前节点parent1，parent2，在遍历到下一层时，使用parent1来指向parent2的左子树或者右子树。</p>
<p><strong>Debug</strong>：如果cur1左子树为空，cur2左子树不为空，将cur1,cur2加入trashQueue；同理右子树。<strong>如果cur1左右子树都为空，cur2左右子树都不为空，将cur1,cur2加入parentQueue两次！！不然之后poll的时候空指针！！</strong></p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230322110219397.png" alt="image-20230322110219397" style="zoom:50%;" /></p>
<h3 id="x98.-验证二叉搜索树">x<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h3>
<h4 id="方法一中序遍历">方法一：中序遍历</h4>
<p>中序遍历二叉搜索树应该是升序的，只需要一个记录上一个节点的值的遍历preVal，并与当前节点比较，如果当前节点的值<strong>小于等于</strong>preVal(cur.val应该严格&gt;preVal不能等于)，则返回false;否则，遍历完所有节点返回true。</p>
<p>假设树有n个节点</p>
<p><strong>时间复杂度</strong>：遍历所有节点，<span class="math inline">\(O(n)\)</span></p>
<p><strong>空间复杂度</strong>：和使用的栈相关，在最坏情况(每个节点都只有一个子节点)下，树的高度为n，都需要压栈，所以为<span class="math inline">\(O(n)\)</span></p>
<h4 id="x方法二递归">x方法二：递归</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(TreeNode root, <span class="type">long</span>.MIN_VALUE, <span class="type">long</span>.MAX_VALUE)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">long</span> pre, <span class="type">long</span> post)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.val &lt;= pre || root.val &gt;= post)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(root.left, pre, root.val) &amp;&amp; dfs(root.right, root.val, post);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉搜索树的最小绝对差"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">530. 二叉搜索树的最小绝对差</a></h3>
<h4 id="中序遍历">中序遍历：</h4>
<p>使用中序遍历二叉搜索树得到的结果是升序的。</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230322155627326.png" alt="image-20230322155627326" style="zoom:50%;" /></p>
<h3 id="二叉搜索树中的众数"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/">501. 二叉搜索树中的众数</a></h3>
<p>老样子，中序遍历</p>
<p>遍历的过程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (preVal == cur.val) &#123;</span><br><span class="line">	++counter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">	counter = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!modes.contains(cur.val) &amp;&amp; counter == maxCounter) &#123;</span><br><span class="line">	modes.add(cur.val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (counter &gt; maxCounter) &#123;</span><br><span class="line">    maxCounter = counter;</span><br><span class="line">    modes.removeAll(modes);</span><br><span class="line">    modes.add(cur.val);</span><br><span class="line">&#125;</span><br><span class="line">preVal = cur.val;</span><br><span class="line">cur = cur.right;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树的最近公共祖先"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h3>
<h4 id="方法一用hashmap存储所有父节点用hashset标记是否访问过从p开始向上遍历并标记访问过的父节点再从q开始向上遍历如果当前节点被访问过那么这个节点就是最近公共祖先">方法一：用HashMap存储所有父节点，用HashSet标记是否访问过；从p开始向上遍历，并标记访问过的父节点，再从q开始向上遍历，如果当前节点被访问过，那么这个节点就是最近公共祖先。</h4>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230323100510481.png" alt="image-20230323100510481" style="zoom:50%;" /></p>
<h3 id="二叉搜索树的最近公共祖先"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先</a></h3>
<h4 id="递归考虑三种情况">递归：考虑三种情况</h4>
<ol type="1">
<li>p,q是root：return root</li>
<li>p,q在root两侧，(p.val &lt; root.val &amp;&amp; q.val &gt; root.val) || (p.val &gt; root.val &amp;&amp; q.val &lt; root.val)， return root</li>
<li>p,q在root同一侧 (p.val &lt; root &amp;&amp; q.val &lt; root.val) || (p.val &gt; root.val &amp;&amp; q.val &gt; root.val)
<ol type="1">
<li>p.val &lt; root &amp;&amp; q.val &lt; root.val: return dfs(left, p, q)</li>
<li>p.val &gt; root.val &amp;&amp; q.val &gt; root.val: return dfs(right, p, q)</li>
</ol></li>
</ol>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230323103301262.png" alt="image-20230323103301262" style="zoom:50%;" /></p>
<h3 id="二叉搜索树中的插入操作"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">701. 二叉搜索树中的插入操作</a></h3>
<p>Easy middle task!</p>
<h4 id="方法一遍历">方法一：遍历</h4>
<p>从根节点开始遍历，用栈存储每个遍历过的节点，大于向右小于向左；循环结束，判断插入最后一个被遍历的节点(栈中最顶层节点)，判断大于小于，插入，结束。</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230323104721968.png" alt="image-20230323104721968" style="zoom:50%;" /></p>
<h4 id="方法二递归">方法二：递归</h4>
<p>当时想出来了，但是卡在怎么插入这个点上<strong>，其实这里已经用root.left或者root.right来接收 new TreeNode(val)了。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">insertIntoBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (val &lt; root.val) &#123;</span><br><span class="line">            root.left = insertIntoBST(root.left, val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root.right = insertIntoBST(root.right, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="x450.-删除二叉搜索树中的节点">x<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点</a></h3>
<p><strong>解题思路</strong>：</p>
<ol type="1">
<li><p>如果目标节点大于当前节点值，则去右子树中删除；</p></li>
<li><p>如果目标节点小于当前节点值，则去左子树中删除；</p></li>
<li><p>如果目标节点就是当前节点，分为以下三种情况：</p>
<ol type="1">
<li>其无左子：其右子顶替其位置，删除了该节点；</li>
<li>其无右子：其左子顶替其位置，删除了该节点；</li>
<li>其左右子节点都有：其左子树转移到其右子树的最左节点的左子树上，然后右子树顶替其位置，由此删除了该节点。</li>
</ol></li>
</ol>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230323142204001.png" alt="image-20230323142204001" style="zoom:50%;" /></p>
<p>写了快100行，重构一下代码。。</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230323142217741.png" alt="image-20230323142217741" style="zoom:50%;" /></p>
<h3 id="修剪二叉搜索树"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/trim-a-binary-search-tree/">669. 修剪二叉搜索树</a></h3>
<p>借上一题的思路直接速通了</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230323144126141.png" alt="image-20230323144126141" style="zoom:50%;" /></p>
<h3 id="将有序数组转换为二叉搜索树"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树</a></h3>
<p>二分速通</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230323150830325.png" alt="image-20230323150830325" style="zoom:50%;" /></p>
<h3 id="把二叉搜索树转换为累加树"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树</a></h3>
<h4 id="右根左中序遍历-leetcode官方叫它反序中序遍历">右根左中序遍历！ LeetCode官方叫它反序中序遍历</h4>
<p>87654321从前往后累加。</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230323154603928.png" alt="image-20230323154603928" style="zoom:50%;" /></p>
<h3 id="x106.-从中序与后序遍历序列构造二叉树">x[106. 从中序与后序遍历序列构造二叉树</h3>
<h3 id="从前序与中序遍历序列构造二叉树"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">[105. 从前序与中序遍历序列构造二叉树]</a></h3>
<p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/0106.%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.html#java">106.从中序与后序遍历序列构造二叉树</a></p>
<p>前序和中序可以唯一确定一棵二叉树。</p>
<p>后序和中序可以唯一确定一棵二叉树。</p>
<p>那么前序和后序可不可以唯一确定一棵二叉树呢？</p>
<p><strong>前序和后序不能唯一确定一棵二叉树！</strong>，因为没有中序遍历无法确定左右部分，也就是无法分割。</p>
<p>举一个例子：</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210203154720326.png" alt="106.从中序与后序遍历序列构造二叉树2" style="zoom:50%;" /></p>
<p>tree1 的前序遍历是[1 2 3]， 后序遍历是[3 2 1]。</p>
<p>tree2 的前序遍历是[1 2 3]， 后序遍历是[3 2 1]。</p>
<p>那么tree1 和 tree2 的前序和后序完全相同，这是一棵树么，很明显是两棵树！</p>
<p>所以前序和后序不能唯一确定一棵二叉树！</p>
<h3 id="剑指-offer-ii-047.-二叉树剪枝"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/pOCWxh/">剑指 Offer II 047. 二叉树剪枝</a></h3>
<h4 id="方法一笨方法非递归后序dfs-hashmap存储父节点">方法一：笨方法！非递归后序DFS + HashMap存储父节点</h4>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230330140341816.png" alt="image-20230330140341816" style="zoom:50%;" /></p>
<h4 id="方法二非递归后续dfs根本不用hash-map">方法二：非递归后续DFS，根本不用Hash Map！</h4>
<p>遍历部分如下，<strong>不管当前节点是左子树还是右子树，stack.peek()一定是父节点！</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// traverse</span></span><br><span class="line"><span class="keyword">if</span> (cur.val == <span class="number">0</span> &amp;&amp; cur.left == <span class="literal">null</span> &amp;&amp; cur.right == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">parent</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">        <span class="keyword">if</span> (parent.left == cur) &#123;</span><br><span class="line">            parent.left = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            parent.right = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230330144646861.png" alt="image-20230330144646861" style="zoom:50%;" /></p>
<h4 id="方法三递归">方法三：递归</h4>
<p>切记后续遍历的顺序， if (root.val == 0 &amp;&amp; root.left == null &amp;&amp; root.right == null)一定写在遍历左子树右子树后面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">pruneTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;    </span><br><span class="line">        root.left = pruneTree(root.left);</span><br><span class="line">        root.right = pruneTree(root.right);</span><br><span class="line">        <span class="keyword">if</span> (root.val == <span class="number">0</span> &amp;&amp; root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230330143640861.png" alt="image-20230330143640861" style="zoom:50%;" /></p>
<h3 id="x剑指-offer-ii-048.-序列化与反序列化二叉树">x<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/h54YBf/">剑指 Offer II 048. 序列化与反序列化二叉树</a></h3>
<p>“#”表示null；反序列化时，用整数数组int[] i = {0}来遍历字符串，因为i[0]++可以让调用函数知道下标增加了；时使用int j = 0，在函数体内修改j的值，修改之后的值也不能传递给调用者。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node.left = dfs(strs, i);</span><br><span class="line">node.right = dfs(strs, i);</span><br></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230331103348908.png" alt="image-202303311033 48908" style="zoom:50%;" /></p>
<h3 id="剑指-offer-ii-049.-从根节点到叶节点的路径数字之和"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3Etpl5/">剑指 Offer II 049. 从根节点到叶节点的路径数字之和</a></h3>
<h4 id="方法一hashmap存储父节点">方法一：HashMap存储父节点</h4>
<ol type="1">
<li>遍历树，使用HashMap存储所有子节点的父节点</li>
<li>遍历树，如果是叶子节点，利用HashMap向上寻找父节点</li>
</ol>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230331113629971.png" alt="image-20230331113629971" style="zoom:50%;" /></p>
<h4 id="方法二bfs-3">方法二：BFS</h4>
<p>双队列，一个队列存节点，一个队列存累加和，每遍历到叶节点，把累加和记录到result中。</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230331144402361.png" alt="image-20230331144402361" style="zoom:50%;" /></p>
<h4 id="用一个队列也可以实现offer两次poll两次不过要注意queue的类型是object以及使用变量接受treenode和integer时要强转">用一个队列也可以实现，offer两次，poll两次，不过要注意Queue的类型是Object，以及使用变量接受TreeNode和Integer时要强转。</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Object&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> (TreeNode)queue.poll();</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> (<span class="type">int</span>)queue.poll();</span><br></pre></td></tr></table></figure>
<h3 id="x剑指-offer-ii-050.-向下的路径节点之和">x<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/6eUYwP/">剑指 Offer II 050. 向下的路径节点之和</a></h3>
<h4 id="方法一暴力">方法一：暴力</h4>
<p>双重dfs。</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230331155507374.png" alt=" " style="zoom:50%;" /></p>
<h4 id="注意">注意！！！</h4>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230331154846428.png" alt="image-20230331154846428" style="zoom:50%;" /> <img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230331154918879.png" alt="image-20230331154918879" style="zoom:50%;" /></p>
<p>int只有32位，只能表示<span class="math inline">\(-2^{31}到2^{31} - 1\)</span>，虽然范围大于<span class="math inline">\(-10^9 到 10^9\)</span>，但是节点数最多1000个！<span class="math inline">\(-2^{31}到2^{31} - 1\)</span>区间范围是小于<span class="math inline">\({-10^{12}}到10^{12}\)</span>的！所以要用long来求和。</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230331154948941.png" alt="image-20230331154948941" style="zoom:50%;" /></p>
<h4 id="注意-1">注意！！！</h4>
<p>树只要往下走就行，可以转弯，不是只能向左或者向右！！</p>
<h4 id="方法二前缀和">方法二：前缀和</h4>
<h3 id="剑指-offer-ii-053.-二叉搜索树中的中序后继"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/P5rCT8/">剑指 Offer II 053. 二叉搜索树中的中序后继</a></h3>
<h4 id="方法一中序遍历二叉树">方法一：中序遍历二叉树</h4>
<p>创建一个boolean变量flag初始为false，当当前节点为目标节点p，则令flag为true，返回下一个从栈中弹出的节点；如果无右继节点，那么cur已经为空且栈空，返回null。</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230404143208023.png" alt="image-20230404143208023" style="zoom:50%;" /></p>
<h4 id="方法二利用搜索二叉树的特性">方法二：利用搜索二叉树的特性</h4>
<h4 id="section"><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230404144826280.png" alt="image-20230404144826280" style="zoom:50%;" /></h4>
<h3 id="剑指-offer-ii-054.-所有大于等于节点的值之和"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/w6cpku/">剑指 Offer II 054. 所有大于等于节点的值之和</a></h3>
<h4 id="方法一中序遍历右根左">方法一：中序遍历：右根左</h4>
<p>使用一个变量记录上一个节点的值</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230404150129398.png" alt="image-20230404150129398" style="zoom:50%;" /></p>
<h3 id="剑指-offer-ii-055.-二叉搜索树迭代器"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kTOapQ/">剑指 Offer II 055. 二叉搜索树迭代器</a></h3>
<h4 id="方法一扁平化">方法一：扁平化</h4>
<p>先中序遍历一次，使用LinkedList存储val</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230404180957539.png" alt="image-20230404180957539" style="zoom:50%;" /></p>
<h4 id="方法二迭代">方法二：迭代</h4>
<h2 id="string">String</h2>
<h3 id="反转字符串"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-string/">344. 反转字符串</a></h3>
<p>for循环遍历n/2次，使用一个临时变量记录左边的值，然后首尾交换</p>
<p><strong>Trik</strong>:使用位运算进行swap操作，前提是进行交换的a与b在内存空间不同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = a ^ b;</span><br><span class="line">b = a ^ b;</span><br><span class="line">a = a ^ b;</span><br><span class="line"><span class="comment">// 简化</span></span><br><span class="line">a ^= b;</span><br><span class="line">b ^= a;</span><br><span class="line">a ^= b;</span><br></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230324132148361.png" alt="image-20230324132148361" style="zoom:50%;" /></p>
<h4 id="x剑指-offer-ii-051.-节点之和最大的路径">X<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/jC7MId/">剑指 Offer II 051. 节点之和最大的路径</a></h4>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230404130939535.png" alt="image-20230404130939535" style="zoom:50%;" /></p>
<h3 id="x541.-反转字符串-ii">x<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-string-ii/">541. 反转字符串 II</a></h3>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230324143753280.png" alt="image-20230324143753280" style="zoom:50%;" /></p>
<h3 id="剑指-offer-05.-替换空格"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格</a></h3>
<p>Java中String只读，所以使用StringBuilder来动态append“%20”</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230324150110004.png" alt="image-20230324150110004" style="zoom:50%;" /></p>
<h3 id="x151.-反转字符串中的单词">x<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-words-in-a-string/">151. 反转字符串中的单词</a></h3>
<p><strong>StringBuilder 末尾有额外分隔符！！！</strong></p>
<p>可使用以下方法解决！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sb.setLength(sb.length() - <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h2 id="array">Array</h2>
<h3 id="二分查找"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-search/">704. 二分查找</a></h3>
<h4 id="方法一左闭右开">方法一：左闭右开</h4>
<ol type="1">
<li>区间：[left, right)</li>
<li>初始化：right = nums.length</li>
<li>while循环终止条件应为left &lt; right（右开，right不能等于left）</li>
<li>当nums[mid] &lt; target时，nums[0]~nums[mid]都小于target，此时有效的有边界是mid - 1，又因为右边界是开区间，所以另right = mid</li>
<li>时间复杂度：<span class="math inline">\(O(logn)\)</span>，由于每次查找都会将查找范围缩小一半，因此二分查找的时间复杂度是<span class="math inline">\(O(logn)\)</span>，其中 <em>n</em> 是数组的长度</li>
<li>空间复杂度：<span class="math inline">\(O(1)\)</span></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length;</span><br><span class="line">        <span class="comment">// [left, right)</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法二左闭右闭">方法二：左闭右闭</h4>
<ol type="1">
<li>区间：[left, right]</li>
<li>初始化：right = nums.length - 1</li>
<li>while循环终止条件应为left &lt;= right</li>
<li>当nums[mid] &lt; target时，nums[0]~nums[mid]都小于target，另right = mid - 1</li>
<li>时间复杂度：<span class="math inline">\(O(logn)\)</span>，由于每次查找都会将查找范围缩小一半，因此二分查找的时间复杂度是<span class="math inline">\(O(logn)\)</span>，其中 <em>n</em> 是数组的长度</li>
<li>空间复杂度：<span class="math inline">\(O(1)\)</span></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> right - ((right - left) &gt;&gt; <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) </span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="移除元素"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-element/">27. 移除元素</a></h3>
<h3 id="方法一暴力-1">方法一：暴力</h3>
<ol type="1">
<li>每当发现一个数相等，那么从当前数组的下一个数开始，全部往前移一位。</li>
<li><strong>注意</strong>：因为移位后，下一个要访问的数组元素j会到当前i的位置，然后for循环结束i自增，会错过访j，所以移位后要--i。</li>
<li>时间复杂度：<span class="math inline">\(O(n^2)\)</span></li>
<li>空间复杂度：<span class="math inline">\(O(1)\)</span></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newLen</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (newLen == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; newLen; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == val) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; newLen; j++) &#123;</span><br><span class="line">                    nums[j - <span class="number">1</span>] = nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">                --newLen;</span><br><span class="line">                --i;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newLen;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法二双指针">方法二：双指针</h4>
<ol type="1">
<li>初始化慢指针为0</li>
<li>for循环遍历快指针，当nums[fast] != val时，令nums[slow] = nums[fast]，slow指针往后移。也就是说，如果快指针找到了val，那么慢指针停在val位置，之后快指针遍历到非val的位置时，将该非val数据覆盖到慢指针的指向数组位置的数据。</li>
<li>最后返回慢指针(慢指针大小代表新数组的大小)</li>
<li>时间复杂度：<span class="math inline">\(O(n)\)</span></li>
<li>空间复杂度：<span class="math inline">\(O(1)\)</span></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>; fast &lt; nums.length; ++fast) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[fast] != val) &#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                ++slow;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法三相向双指针">方法三：相向双指针</h4>
<p><strong>避免了需要保留的元素的重复赋值操作</strong>。</p>
<ol type="1">
<li><p>初始化：left=0, right=nums.length-1，左闭右闭区间，所以while语句的执行条件是</p>
<p>left &lt;= right(如果没有等于，left会少后移一次)</p></li>
<li><p>循环：当nums[left]不等于val时，left指针后移；当nums[left]等于val时，将nums[right]赋值给nums[left]，right指针前移；如果赋值过来的元素恰好也等于val，可以继续把右指针 right指向的元素的值赋值过来，直到左指针指向的元素的值不等于 val为止。</p></li>
<li><p>时间复杂度：<span class="math inline">\(O(n)\)</span></p></li>
<li><p>空间复杂度：<span class="math inline">\(O(1)\)</span></p></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// [left, right]</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[left] == val) &#123;</span><br><span class="line">                nums[left] = nums[right];</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="有序数组的平方"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977. 有序数组的平方</a></h3>
<h4 id="双指针">双指针</h4>
<p>left,right指针指向数组两端，将较大的平方数放入result数组里。</p>
<ol type="1">
<li>时间复杂度：<span class="math inline">\(O(n)\)</span></li>
<li>空间复杂度：<span class="math inline">\(O(n)\)</span></li>
</ol>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230406132631275.png" alt="image-20230406132631275" style="zoom:50%;" /></p>
<h3 id="长度最小的子数组"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a></h3>
<h4 id="numsi先执行自增操作还是数组寻址操作">nums[i++]先执行自增操作还是数组寻址操作?</h4>
<p>在这种情况下，nums[i++]实际上会先执行数组寻址操作，然后再对i进行自增操作。这是因为数组寻址操作的优先级比自增操作的优先级高。</p>
<p>具体来说，这个表达式会先使用i的当前值来计算nums数组中第i个元素的地址，然后将地址作为结果返回，接着才会将i的值加1。</p>
<h4 id="int-a-i-是先赋值还是先自增">int a = ++i 是先赋值还是先自增</h4>
<p>这行代码会先自增变量 i 的值，然后将自增后的结果赋值给变量 a。所以，变量 a 的值等于自增后的变量 i 的值。这个过程中，变量 i 的值会被修改，而变量 a 的值则是这个修改后的值。</p>
<p>可以将这行代码拆分成两步：</p>
<ol type="1">
<li>i = i + 1； // 自增 i 的值</li>
<li>a = i； // 将自增后的 i 的值赋值给 a</li>
</ol>
<p>所以，最终变量 a 的值等于自增后的变量 i 的值。</p>
<h4 id="int-a-i-是先赋值还是先自增-1">int a = i++ 是先赋值还是先自增</h4>
<p>这行代码会先将变量 i 的值赋值给变量 a，然后再将变量 i 的值自增。所以，变量 a 的值等于变量 i 的值，而变量 i 的值会被自增。</p>
<p>可以将这行代码拆分成两步：</p>
<ol type="1">
<li>a = i； // 将 i 的值赋值给 a</li>
<li>i = i + 1； // 自增 i 的值</li>
</ol>
<p>所以，最终变量 a 的值等于变量 i 的初始值，而变量 i 的值则是初始值加一。</p>
<h4 id="while--index-先---后比较index0">while(--index) 先-- 后比较index&gt;0</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span> (--index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    System.out.print(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>stdout</p>
<p>1</p>
<h4 id="whileindex---先比较-后--">while(index--) 先比较 后--</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span> (index-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    System.out.print(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>stdout</p>
<p>10</p>
<h4 id="system.out.print--index-先---后打印">System.out.print(--index) 先-- 后打印</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    System.out.print(--index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>stdout</p>
<p>10</p>
<h4 id="滑动数组">滑动数组</h4>
<ol type="1">
<li>时间复杂度：<span class="math inline">\(O(n)\)</span></li>
<li>空间复杂度：<span class="math inline">\(O(1)\)</span></li>
</ol>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230406142256924.png" alt="image-20230406142256924" style="zoom:50%;" /></p>
<h3 id="螺旋矩阵-ii"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/spiral-matrix-ii/">59. 螺旋矩阵 II</a></h3>
<ol type="1">
<li><p>遍历顺序：从左到右(左闭右开)，从上到下(上闭下开)，从右到左(右闭左开)，从下到上(下闭上开)</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230406151317898.png" alt="image-20230406151317898" style="zoom: 25%;" /></p></li>
<li><p>思路见代码注释部分</p></li>
<li><p>时间复杂度：<span class="math inline">\(O(n^2)\)</span></p></li>
<li><p>空间复杂度：<span class="math inline">\(O(1)\)</span></p></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="comment">// 用笔画一个n=5的矩阵作为例子</span></span><br><span class="line">        <span class="comment">// 遍历顺序：从左到右(左闭右开)，从上到下(上闭下开)，从右到左(右闭左开)，从下到上(下闭上开)</span></span><br><span class="line">        <span class="comment">// 建立n行n列的矩阵</span></span><br><span class="line">        <span class="type">int</span>[][] matrix = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="comment">// 遍历次数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">traverseTime</span> <span class="operator">=</span> n / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> i, j;</span><br><span class="line">        <span class="comment">// 写入数组的数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// cur:当前遍历伦茨</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">0</span>; cur &lt; traverseTime; ++cur) &#123;</span><br><span class="line">            <span class="comment">// 从左到右(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span> (j = cur; j &lt; n - cur - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">                matrix[cur][j] = data++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从上到下(上闭下开)</span></span><br><span class="line">            <span class="keyword">for</span> (i = cur; i &lt; n - cur - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">                matrix[i][j] = data++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从右到左(右闭左开)</span></span><br><span class="line">            <span class="keyword">for</span> (; j &gt; cur; --j) &#123;</span><br><span class="line">                matrix[i][j] = data++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从下到上(下闭上开)</span></span><br><span class="line">            <span class="keyword">for</span> (; i &gt; cur; --i) &#123;</span><br><span class="line">                matrix[i][j] = data++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// debug</span></span><br><span class="line">            <span class="comment">// for (int a = 0; a &lt; n; ++a) &#123;</span></span><br><span class="line">            <span class="comment">//     for (int b = 0; b &lt; n; ++b) &#123;</span></span><br><span class="line">            <span class="comment">//         System.out.print(matrix[a][b]);</span></span><br><span class="line">            <span class="comment">//     &#125;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">            matrix[traverseTime][traverseTime] = n * n;</span><br><span class="line">        <span class="keyword">return</span> matrix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230406150937452.png" alt="image-20230406150937452" style="zoom:50%;" /></p>
<h2 id="linkedlist">LinkedList</h2>
<h3 id="移除链表元素"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-linked-list-elements/">203. 移除链表元素</a></h3>
<h4 id="解题思路在面对链表树有关创建删除操作使用dummyhead能省去不少边界判定的功夫">解题思路：在面对链表、树有关创建、删除操作，使用dummyHead！能省去不少边界判定的功夫。</h4>
<ol type="1">
<li>初始化：dummyHead指向head，dummyHead赋值给pre，head赋值给cur</li>
<li>当cur的值等于所求val，pre指向cur的下一个节点</li>
<li>当cur的值不等于val，pre移动到cur，cur往后移一位</li>
<li>返回dummyHead的下一个节点。</li>
</ol>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230407173513851.png" alt="image-20230407173513851" style="zoom:50%;" /></p>
<h3 id="设计链表"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/design-linked-list/">707. 设计链表</a></h3>
<h4 id="注意事项dummyhead-size"><strong>注意事项：DummyHead + size</strong></h4>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230407211111582.png" alt="image-20230407211111582" style="zoom:50%;" /></p>
<h3 id="反转链表"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></h3>
<p>用笔模拟一下指针pre，cur，next的过程</p>
<p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230407213816337.png" alt="image-20230407213816337" style="zoom:50%;" /></p>
<ol type="1">
<li><p>时间复杂度：<span class="math inline">\(O(n^2)\)</span></p></li>
<li><p>空间复杂度：<span class="math inline">\(O(1)\)</span></p></li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">

        


        
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#leetcode-solutions"><span class="nav-number">1.</span> <span class="nav-text">LeetCode Solutions</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#dynamic-programming"><span class="nav-number">1.1.</span> <span class="nav-text">Dynamic Programming</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#debug"><span class="nav-number">1.1.1.</span> <span class="nav-text">debug</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%91%E6%8C%87offer-95"><span class="nav-number">1.1.2.</span> <span class="nav-text">剑指Offer 95</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%91%E6%8C%87offer-101-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86"><span class="nav-number">1.1.3.</span> <span class="nav-text">剑指Offer 101 分割等和子集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%91%E6%8C%87offer-1049%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F-ii"><span class="nav-number">1.1.4.</span> <span class="nav-text">剑指Offer 1049最后一块石头的重量 II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2-ii"><span class="nav-number">1.1.5.</span> <span class="nav-text">518. 零钱兑换 II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-%E2%85%B3"><span class="nav-number">1.1.6.</span> <span class="nav-text">377. 组合总和 Ⅳ</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="nav-number">1.1.7.</span> <span class="nav-text">70. 爬楼梯</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2"><span class="nav-number">1.1.8.</span> <span class="nav-text">322. 零钱兑换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0"><span class="nav-number">1.1.9.</span> <span class="nav-text">279. 完全平方数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#x139.-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86"><span class="nav-number">1.1.10.</span> <span class="nav-text">x139. 单词拆分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="nav-number">1.1.11.</span> <span class="nav-text">198. 打家劫舍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">1.1.11.1.</span> <span class="nav-text">优化空间复杂度</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-ii"><span class="nav-number">1.1.12.</span> <span class="nav-text">213. 打家劫舍 II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86"><span class="nav-number">1.1.13.</span> <span class="nav-text">416. 分割等和子集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#x337.-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-iii"><span class="nav-number">1.1.14.</span> <span class="nav-text">x337. 打家劫舍 III</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#x121.-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA"><span class="nav-number">1.1.15.</span> <span class="nav-text">x121. 买卖股票的最佳时机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%A0%E6%A0%B9%E6%9C%AC%E6%B2%A1%E5%9C%A8dp"><span class="nav-number">1.1.15.1.</span> <span class="nav-text">你根本没在dp！</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E6%9A%B4%E5%8A%9B%E8%BF%AD%E4%BB%A3"><span class="nav-number">1.1.15.2.</span> <span class="nav-text">方法一：暴力迭代</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E8%B4%AA%E5%BF%83"><span class="nav-number">1.1.15.3.</span> <span class="nav-text">方法二：贪心</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%89dp"><span class="nav-number">1.1.15.4.</span> <span class="nav-text">方法三：DP</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-ii"><span class="nav-number">1.1.16.</span> <span class="nav-text">122. 买卖股票的最佳时机 II</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E7%A9%BA%E9%97%B4.."><span class="nav-number">1.1.16.1.</span> <span class="nav-text">优化空间..</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#binary-tree"><span class="nav-number">1.2.</span> <span class="nav-text">Binary Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">1.2.1.</span> <span class="nav-text">144. 二叉树的前序遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">1.2.2.</span> <span class="nav-text">94. 二叉树的中序遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">1.2.3.</span> <span class="nav-text">145. 二叉树的后序遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">1.2.4.</span> <span class="nav-text">102. 二叉树的层序遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">1.2.5.</span> <span class="nav-text">226. 翻转二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">1.2.6.</span> <span class="nav-text">101. 对称二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E6%8B%B7%E8%B4%9D%E7%BF%BB%E8%BD%AC%E5%88%A4%E6%96%AD%E9%AB%98%E6%83%85%E5%95%86%E5%88%B7%E4%B8%80%E9%81%93%E8%A7%A3%E4%B8%89%E9%81%93%E4%BD%8E%E6%83%85%E5%95%86%E5%8F%AA%E4%BC%9A%E7%AC%A8%E6%96%B9%E6%B3%95%E8%BF%98%E6%98%AF%E7%9C%8B%E7%9C%8B%E8%BF%9C%E6%96%B9%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%90%A7"><span class="nav-number">1.2.6.1.</span> <span class="nav-text">方法一：拷贝+翻转+判断(高情商：刷一道，解三道！低情商：只会笨方法？还是看看远方的复杂度吧)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8Cbfs"><span class="nav-number">1.2.6.2.</span> <span class="nav-text">方法二：BFS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%89dfs"><span class="nav-number">1.2.6.3.</span> <span class="nav-text">方法三：DFS</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91"><span class="nav-number">1.2.7.</span> <span class="nav-text">100. 相同的树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80dfs"><span class="nav-number">1.2.7.1.</span> <span class="nav-text">方法一：DFS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8Cbfs-1"><span class="nav-number">1.2.7.2.</span> <span class="nav-text">方法二：BFS</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="nav-number">1.2.8.</span> <span class="nav-text">104. 二叉树的最大深度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80bfs"><span class="nav-number">1.2.8.1.</span> <span class="nav-text">方法一：BFS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8Cdfs"><span class="nav-number">1.2.8.2.</span> <span class="nav-text">方法二：DFS</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#n-%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="nav-number">1.2.9.</span> <span class="nav-text">559. N 叉树的最大深度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6"><span class="nav-number">1.2.10.</span> <span class="nav-text">!111. 二叉树的最小深度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80dfs-1"><span class="nav-number">1.2.10.1.</span> <span class="nav-text">方法一：DFS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8Cbfs-2"><span class="nav-number">1.2.10.2.</span> <span class="nav-text">方法二：BFS</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0"><span class="nav-number">1.2.11.</span> <span class="nav-text">222. 完全二叉树的节点个数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#bfs%E5%9C%A8%E6%AF%8F%E5%B1%82%E5%BC%80%E5%A7%8B%E9%81%8D%E5%8E%86%E6%97%B6%E8%AE%B0%E5%BD%95%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0%E7%9A%84%E5%8F%98%E9%87%8F%E5%8A%A0%E4%B8%8A%E9%98%9F%E5%88%97%E9%87%8C%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0"><span class="nav-number">1.2.11.1.</span> <span class="nav-text">BFS：在每层开始遍历时，记录节点个数的变量加上队列里元素个数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">1.2.12.</span> <span class="nav-text">617. 合并二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#x98.-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">1.2.13.</span> <span class="nav-text">x98. 验证二叉搜索树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">1.2.13.1.</span> <span class="nav-text">方法一：中序遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#x%E6%96%B9%E6%B3%95%E4%BA%8C%E9%80%92%E5%BD%92"><span class="nav-number">1.2.13.2.</span> <span class="nav-text">x方法二：递归</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE"><span class="nav-number">1.2.14.</span> <span class="nav-text">530. 二叉搜索树的最小绝对差</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">1.2.14.1.</span> <span class="nav-text">中序遍历：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0"><span class="nav-number">1.2.15.</span> <span class="nav-text">501. 二叉搜索树中的众数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-number">1.2.16.</span> <span class="nav-text">236. 二叉树的最近公共祖先</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E7%94%A8hashmap%E5%AD%98%E5%82%A8%E6%89%80%E6%9C%89%E7%88%B6%E8%8A%82%E7%82%B9%E7%94%A8hashset%E6%A0%87%E8%AE%B0%E6%98%AF%E5%90%A6%E8%AE%BF%E9%97%AE%E8%BF%87%E4%BB%8Ep%E5%BC%80%E5%A7%8B%E5%90%91%E4%B8%8A%E9%81%8D%E5%8E%86%E5%B9%B6%E6%A0%87%E8%AE%B0%E8%AE%BF%E9%97%AE%E8%BF%87%E7%9A%84%E7%88%B6%E8%8A%82%E7%82%B9%E5%86%8D%E4%BB%8Eq%E5%BC%80%E5%A7%8B%E5%90%91%E4%B8%8A%E9%81%8D%E5%8E%86%E5%A6%82%E6%9E%9C%E5%BD%93%E5%89%8D%E8%8A%82%E7%82%B9%E8%A2%AB%E8%AE%BF%E9%97%AE%E8%BF%87%E9%82%A3%E4%B9%88%E8%BF%99%E4%B8%AA%E8%8A%82%E7%82%B9%E5%B0%B1%E6%98%AF%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-number">1.2.16.1.</span> <span class="nav-text">方法一：用HashMap存储所有父节点，用HashSet标记是否访问过；从p开始向上遍历，并标记访问过的父节点，再从q开始向上遍历，如果当前节点被访问过，那么这个节点就是最近公共祖先。</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-number">1.2.17.</span> <span class="nav-text">235. 二叉搜索树的最近公共祖先</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E8%80%83%E8%99%91%E4%B8%89%E7%A7%8D%E6%83%85%E5%86%B5"><span class="nav-number">1.2.17.1.</span> <span class="nav-text">递归：考虑三种情况</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="nav-number">1.2.18.</span> <span class="nav-text">701. 二叉搜索树中的插入操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E9%81%8D%E5%8E%86"><span class="nav-number">1.2.18.1.</span> <span class="nav-text">方法一：遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E9%80%92%E5%BD%92"><span class="nav-number">1.2.18.2.</span> <span class="nav-text">方法二：递归</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#x450.-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="nav-number">1.2.19.</span> <span class="nav-text">x450. 删除二叉搜索树中的节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">1.2.20.</span> <span class="nav-text">669. 修剪二叉搜索树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">1.2.21.</span> <span class="nav-text">108. 将有序数组转换为二叉搜索树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91"><span class="nav-number">1.2.22.</span> <span class="nav-text">538. 把二叉搜索树转换为累加树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%B3%E6%A0%B9%E5%B7%A6%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86-leetcode%E5%AE%98%E6%96%B9%E5%8F%AB%E5%AE%83%E5%8F%8D%E5%BA%8F%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">1.2.22.1.</span> <span class="nav-text">右根左中序遍历！ LeetCode官方叫它反序中序遍历</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#x106.-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">1.2.23.</span> <span class="nav-text">x[106. 从中序与后序遍历序列构造二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">1.2.24.</span> <span class="nav-text">[105. 从前序与中序遍历序列构造二叉树]</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%91%E6%8C%87-offer-ii-047.-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%AA%E6%9E%9D"><span class="nav-number">1.2.25.</span> <span class="nav-text">剑指 Offer II 047. 二叉树剪枝</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E7%AC%A8%E6%96%B9%E6%B3%95%E9%9D%9E%E9%80%92%E5%BD%92%E5%90%8E%E5%BA%8Fdfs-hashmap%E5%AD%98%E5%82%A8%E7%88%B6%E8%8A%82%E7%82%B9"><span class="nav-number">1.2.25.1.</span> <span class="nav-text">方法一：笨方法！非递归后序DFS + HashMap存储父节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E9%9D%9E%E9%80%92%E5%BD%92%E5%90%8E%E7%BB%ADdfs%E6%A0%B9%E6%9C%AC%E4%B8%8D%E7%94%A8hash-map"><span class="nav-number">1.2.25.2.</span> <span class="nav-text">方法二：非递归后续DFS，根本不用Hash Map！</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%89%E9%80%92%E5%BD%92"><span class="nav-number">1.2.25.3.</span> <span class="nav-text">方法三：递归</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#x%E5%89%91%E6%8C%87-offer-ii-048.-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">1.2.26.</span> <span class="nav-text">x剑指 Offer II 048. 序列化与反序列化二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%91%E6%8C%87-offer-ii-049.-%E4%BB%8E%E6%A0%B9%E8%8A%82%E7%82%B9%E5%88%B0%E5%8F%B6%E8%8A%82%E7%82%B9%E7%9A%84%E8%B7%AF%E5%BE%84%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C"><span class="nav-number">1.2.27.</span> <span class="nav-text">剑指 Offer II 049. 从根节点到叶节点的路径数字之和</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80hashmap%E5%AD%98%E5%82%A8%E7%88%B6%E8%8A%82%E7%82%B9"><span class="nav-number">1.2.27.1.</span> <span class="nav-text">方法一：HashMap存储父节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8Cbfs-3"><span class="nav-number">1.2.27.2.</span> <span class="nav-text">方法二：BFS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E4%B8%80%E4%B8%AA%E9%98%9F%E5%88%97%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0offer%E4%B8%A4%E6%AC%A1poll%E4%B8%A4%E6%AC%A1%E4%B8%8D%E8%BF%87%E8%A6%81%E6%B3%A8%E6%84%8Fqueue%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%98%AFobject%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F%E6%8E%A5%E5%8F%97treenode%E5%92%8Cinteger%E6%97%B6%E8%A6%81%E5%BC%BA%E8%BD%AC"><span class="nav-number">1.2.27.3.</span> <span class="nav-text">用一个队列也可以实现，offer两次，poll两次，不过要注意Queue的类型是Object，以及使用变量接受TreeNode和Integer时要强转。</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#x%E5%89%91%E6%8C%87-offer-ii-050.-%E5%90%91%E4%B8%8B%E7%9A%84%E8%B7%AF%E5%BE%84%E8%8A%82%E7%82%B9%E4%B9%8B%E5%92%8C"><span class="nav-number">1.2.28.</span> <span class="nav-text">x剑指 Offer II 050. 向下的路径节点之和</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E6%9A%B4%E5%8A%9B"><span class="nav-number">1.2.28.1.</span> <span class="nav-text">方法一：暴力</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F"><span class="nav-number">1.2.28.2.</span> <span class="nav-text">注意！！！</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F-1"><span class="nav-number">1.2.28.3.</span> <span class="nav-text">注意！！！</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E5%89%8D%E7%BC%80%E5%92%8C"><span class="nav-number">1.2.28.4.</span> <span class="nav-text">方法二：前缀和</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%91%E6%8C%87-offer-ii-053.-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%B8%AD%E5%BA%8F%E5%90%8E%E7%BB%A7"><span class="nav-number">1.2.29.</span> <span class="nav-text">剑指 Offer II 053. 二叉搜索树中的中序后继</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">1.2.29.1.</span> <span class="nav-text">方法一：中序遍历二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E5%88%A9%E7%94%A8%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-number">1.2.29.2.</span> <span class="nav-text">方法二：利用搜索二叉树的特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section"><span class="nav-number">1.2.29.3.</span> <span class="nav-text"></span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%91%E6%8C%87-offer-ii-054.-%E6%89%80%E6%9C%89%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E%E8%8A%82%E7%82%B9%E7%9A%84%E5%80%BC%E4%B9%8B%E5%92%8C"><span class="nav-number">1.2.30.</span> <span class="nav-text">剑指 Offer II 054. 所有大于等于节点的值之和</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%8F%B3%E6%A0%B9%E5%B7%A6"><span class="nav-number">1.2.30.1.</span> <span class="nav-text">方法一：中序遍历：右根左</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%91%E6%8C%87-offer-ii-055.-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">1.2.31.</span> <span class="nav-text">剑指 Offer II 055. 二叉搜索树迭代器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E6%89%81%E5%B9%B3%E5%8C%96"><span class="nav-number">1.2.31.1.</span> <span class="nav-text">方法一：扁平化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E8%BF%AD%E4%BB%A3"><span class="nav-number">1.2.31.2.</span> <span class="nav-text">方法二：迭代</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#string"><span class="nav-number">1.3.</span> <span class="nav-text">String</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.3.1.</span> <span class="nav-text">344. 反转字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#x%E5%89%91%E6%8C%87-offer-ii-051.-%E8%8A%82%E7%82%B9%E4%B9%8B%E5%92%8C%E6%9C%80%E5%A4%A7%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">X剑指 Offer II 051. 节点之和最大的路径</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#x541.-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2-ii"><span class="nav-number">1.3.2.</span> <span class="nav-text">x541. 反转字符串 II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%91%E6%8C%87-offer-05.-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC"><span class="nav-number">1.3.3.</span> <span class="nav-text">剑指 Offer 05. 替换空格</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#x151.-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D"><span class="nav-number">1.3.4.</span> <span class="nav-text">x151. 反转字符串中的单词</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#array"><span class="nav-number">1.4.</span> <span class="nav-text">Array</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-number">1.4.1.</span> <span class="nav-text">704. 二分查找</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E5%B7%A6%E9%97%AD%E5%8F%B3%E5%BC%80"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">方法一：左闭右开</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E5%B7%A6%E9%97%AD%E5%8F%B3%E9%97%AD"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">方法二：左闭右闭</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0"><span class="nav-number">1.4.2.</span> <span class="nav-text">27. 移除元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E6%9A%B4%E5%8A%9B-1"><span class="nav-number">1.4.3.</span> <span class="nav-text">方法一：暴力</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E5%8F%8C%E6%8C%87%E9%92%88"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">方法二：双指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%89%E7%9B%B8%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">方法三：相向双指针</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9"><span class="nav-number">1.4.4.</span> <span class="nav-text">977. 有序数组的平方</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88"><span class="nav-number">1.4.4.1.</span> <span class="nav-text">双指针</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-number">1.4.5.</span> <span class="nav-text">209. 长度最小的子数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#numsi%E5%85%88%E6%89%A7%E8%A1%8C%E8%87%AA%E5%A2%9E%E6%93%8D%E4%BD%9C%E8%BF%98%E6%98%AF%E6%95%B0%E7%BB%84%E5%AF%BB%E5%9D%80%E6%93%8D%E4%BD%9C"><span class="nav-number">1.4.5.1.</span> <span class="nav-text">nums[i++]先执行自增操作还是数组寻址操作?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#int-a-i-%E6%98%AF%E5%85%88%E8%B5%8B%E5%80%BC%E8%BF%98%E6%98%AF%E5%85%88%E8%87%AA%E5%A2%9E"><span class="nav-number">1.4.5.2.</span> <span class="nav-text">int a &#x3D; ++i 是先赋值还是先自增</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#int-a-i-%E6%98%AF%E5%85%88%E8%B5%8B%E5%80%BC%E8%BF%98%E6%98%AF%E5%85%88%E8%87%AA%E5%A2%9E-1"><span class="nav-number">1.4.5.3.</span> <span class="nav-text">int a &#x3D; i++ 是先赋值还是先自增</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#while--index-%E5%85%88---%E5%90%8E%E6%AF%94%E8%BE%83index0"><span class="nav-number">1.4.5.4.</span> <span class="nav-text">while(--index) 先-- 后比较index&gt;0</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#whileindex---%E5%85%88%E6%AF%94%E8%BE%83-%E5%90%8E--"><span class="nav-number">1.4.5.5.</span> <span class="nav-text">while(index--) 先比较 后--</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#system.out.print--index-%E5%85%88---%E5%90%8E%E6%89%93%E5%8D%B0"><span class="nav-number">1.4.5.6.</span> <span class="nav-text">System.out.print(--index) 先-- 后打印</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%BB%91%E5%8A%A8%E6%95%B0%E7%BB%84"><span class="nav-number">1.4.5.7.</span> <span class="nav-text">滑动数组</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5-ii"><span class="nav-number">1.4.6.</span> <span class="nav-text">59. 螺旋矩阵 II</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#linkedlist"><span class="nav-number">1.5.</span> <span class="nav-text">LinkedList</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0"><span class="nav-number">1.5.1.</span> <span class="nav-text">203. 移除链表元素</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E5%9C%A8%E9%9D%A2%E5%AF%B9%E9%93%BE%E8%A1%A8%E6%A0%91%E6%9C%89%E5%85%B3%E5%88%9B%E5%BB%BA%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%E4%BD%BF%E7%94%A8dummyhead%E8%83%BD%E7%9C%81%E5%8E%BB%E4%B8%8D%E5%B0%91%E8%BE%B9%E7%95%8C%E5%88%A4%E5%AE%9A%E7%9A%84%E5%8A%9F%E5%A4%AB"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">解题思路：在面对链表、树有关创建、删除操作，使用dummyHead！能省去不少边界判定的功夫。</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8"><span class="nav-number">1.5.2.</span> <span class="nav-text">707. 设计链表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9dummyhead-size"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">注意事项：DummyHead + size</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-number">1.5.3.</span> <span class="nav-text">206. 反转链表</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Leopold</p>
  <div class="site-description" itemprop="description">For offers</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">1</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Leopold</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
