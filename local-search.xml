<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Dynamic Programming</title>
    <link href="/2023/05/24/dynamic-programming/"/>
    <url>/2023/05/24/dynamic-programming/</url>
    
    <content type="html"><![CDATA[<h1 id="自顶向下的动态规划记忆化搜索">自顶向下的动态规划——记忆化搜索</h1><div class="note note-success">            <p><strong>记忆化搜索好解决不常见状态转移方程的dp问题</strong></p>          </div><h3 id="打家劫舍"><a href="https://leetcode.cn/problems/house-robber/">198. 打家劫舍</a></h3><h3 id="方法一dp">方法一：DP</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 1.dp[j]: 到达标号为j的房屋可获得的最大价值</span><br>        <span class="hljs-comment">// 2.状态转移：dp[j] = max(dp[j - 1], dp[j - 2] + nums[j])</span><br>        <span class="hljs-comment">// 3.初始化：dp[0] = nums[0], dp[1] = max(nums[0], nums[1])</span><br>        <span class="hljs-comment">// 4.遍历顺序：从前往后</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">1</span>] = Math.max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; nums.length; ++i) &#123;<br>            dp[i] = Math.max(dp[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>] + nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[nums.length - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法二dp-滚动数组">方法二：DP + 滚动数组</h3><p><strong>由状态转移方程可以看出，dp[i]由前面两个状态得出，所以dp数组的长度只需要为3</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 1.dp[j]: 到达标号为j的房屋可获得的最大价值</span><br>        <span class="hljs-comment">// 2.状态转移：dp[j] = max(dp[j - 1], dp[j - 2] + nums[j])</span><br>        <span class="hljs-comment">// 3.初始化：dp[0] = nums[0], dp[1] = max(nums[0], nums[1])</span><br>        <span class="hljs-comment">// 4.遍历顺序：从前往后</span><br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">1</span>] = Math.max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; nums.length; ++i) &#123;<br>            dp[i % <span class="hljs-number">3</span>] = Math.max(dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">3</span>], dp[(i - <span class="hljs-number">2</span>) % <span class="hljs-number">3</span>] + nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[(nums.length - <span class="hljs-number">1</span>) % <span class="hljs-number">3</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法三记忆化搜索">方法三：记忆化搜索</h3><p><strong>自顶向下，举个例子nums=[1,2,3,1]</strong></p><ol type="1"><li><hr /><p><strong>返回的答案为dfs(3, nums)</strong></p></li><li><p><strong>要求，需要知道dfs(3-1,nums)与dfs(3-2,nums)+nums[3]，然后取最大值</strong></p></li><li><p><strong>求dfs(2,nums)，需要知道dfs(2-1,nums)与dfs(2-2,nums)+nums[2]，然后取最大值</strong></p><p>.......</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[] dp;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        Arrays.fill(dp, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(nums.length -  <span class="hljs-number">1</span>, nums);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (dp[index] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[index];<br><span class="hljs-comment">//        int dont = dfs(index - 1, nums);</span><br><span class="hljs-comment">//        int steal = dfs(index - 2, nums) + nums[index];</span><br><span class="hljs-comment">//        return dp[index] = Math.max(dont, steal);</span><br>        <span class="hljs-keyword">return</span> dp[index] = Math.max(dfs(index - <span class="hljs-number">1</span>, nums), dfs(index - <span class="hljs-number">2</span>, nums) + nums[index]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="打家劫舍-ii"><a href="https://leetcode.cn/problems/house-robber-ii/">213. 打家劫舍 II</a></h2><h3 id="方法一dp-1">方法一：DP</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">2</span>) <br>            <span class="hljs-keyword">return</span> Math.max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">return</span> Math.max(process(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>), process(nums, <span class="hljs-number">1</span>, nums.length));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">process</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[end - start];<br>        dp[<span class="hljs-number">0</span>] = nums[start];<br>        dp[<span class="hljs-number">1</span>] = Math.max(nums[start], nums[start + <span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; end - start; ++i) &#123;<br>            dp[i] = Math.max(dp[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>] + nums[i + start]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[end - start - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法二dp-滚动数组-1">方法二：DP + 滚动数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">2</span>) <br>            <span class="hljs-keyword">return</span> Math.max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">return</span> Math.max(process(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>), process(nums, <span class="hljs-number">1</span>, nums.length));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">process</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<br>        dp[<span class="hljs-number">0</span>] = nums[start];<br>        dp[<span class="hljs-number">1</span>] = Math.max(nums[start], nums[start + <span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; end - start; ++i) &#123;<br>            dp[i % <span class="hljs-number">3</span>] = Math.max(dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">3</span>], dp[(i - <span class="hljs-number">2</span>) % <span class="hljs-number">3</span>] + nums[i + start]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[(end - start - <span class="hljs-number">1</span>) % <span class="hljs-number">3</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法三记忆化搜索-1">方法三：记忆化搜索</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[] dp;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> Math.max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        Arrays.fill(dp, -<span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res1</span> <span class="hljs-operator">=</span> dfs(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">2</span>);<br>        Arrays.fill(dp, -<span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res2</span> <span class="hljs-operator">=</span> dfs(nums, <span class="hljs-number">1</span>,  nums.length - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> Math.max(res1, res2);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &lt; start)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (dp[index] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[index];<br>       <span class="hljs-keyword">return</span> dp[index] = Math.max(dfs(nums, start, index - <span class="hljs-number">1</span>), dfs(nums, start, index - <span class="hljs-number">2</span>) + nums[index]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230524134911876.png" style="zoom:50%;" /></p><div class="note note-danger">            <h2 id="打家劫舍-iii"><a href="https://leetcode.cn/problems/house-robber-iii/">337. 打家劫舍 III</a></h2>          </div><h3 id="方法一dp-2">方法一：DP</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// steal: 偷当前节点能获得的最大金额</span><br>    <span class="hljs-comment">// pass: 不偷当前节点能获得的最大金额</span><br>    <span class="hljs-comment">// steal(cur) = cur.val + pass(cur.left) + pass(cur.right)</span><br>    <span class="hljs-comment">// pass(cur) = max(steal(cur.left), pass(steal.right)) + max(steal(cur.right), pass(steal.right))</span><br>    Map&lt;TreeNode, Integer&gt; steal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    Map&lt;TreeNode, Integer&gt; pass = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        dfs(root);<br>        <span class="hljs-keyword">return</span> Math.max(steal.getOrDefault(root, <span class="hljs-number">0</span>), pass.getOrDefault(root, <span class="hljs-number">0</span>));<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span>;<br>        dfs(root.left);<br>        dfs(root.right);<br>        steal.put(root, root.val + pass.getOrDefault(root.left, <span class="hljs-number">0</span>) + pass.getOrDefault(root.right, <span class="hljs-number">0</span>));<br>        pass.put(root, Math.max(steal.getOrDefault(root.left, <span class="hljs-number">0</span>), pass.getOrDefault(root.left, <span class="hljs-number">0</span>)) + Math.max(steal.getOrDefault(root.right, <span class="hljs-number">0</span>), pass.getOrDefault(root.right, <span class="hljs-number">0</span>)));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方法二记忆化搜索">方法二：记忆化搜索</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// steal: 偷当前节点能获得的最大金额</span><br>    <span class="hljs-comment">// pass: 不偷当前节点能获得的最大金额</span><br>    <span class="hljs-comment">// steal(cur) = cur.val + pass(cur.left) + pass(cur.right)</span><br>    <span class="hljs-comment">// pass(cur) = max(steal(cur.left), pass(steal.right)) + max(steal(cur.right), pass(steal.right))</span><br>    Map&lt;TreeNode, Integer&gt; steal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    Map&lt;TreeNode, Integer&gt; pass = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">steal</span> <span class="hljs-operator">=</span> dfs(root, <span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pass</span> <span class="hljs-operator">=</span> dfs(root, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> Math.max(steal, pass);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> flag)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">1</span> &amp;&amp; pass.get(root) != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> pass.get(root);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">0</span> &amp;&amp; steal.get(root) != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> steal.get(root);<br>        &#125;<br>        steal.put(root, root.val + pass.getOrDefault(root.left, dfs(root.left, <span class="hljs-number">1</span>)) + pass.getOrDefault(root.right, dfs(root.right, <span class="hljs-number">1</span>)));<br>        pass.put(root, Math.max(steal.getOrDefault(root.left, dfs(root.left, <span class="hljs-number">0</span>)), pass.getOrDefault(root.left, dfs(root.left, <span class="hljs-number">1</span>))) + Math.max(steal.getOrDefault(root.right, dfs(root.right, <span class="hljs-number">0</span>)), pass.getOrDefault(root.right, dfs(root.right, <span class="hljs-number">1</span>))));<br>        <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> steal.getOrDefault(root, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">else</span> <br>            <span class="hljs-keyword">return</span> pass.getOrDefault(root, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="目标和"><a href="https://leetcode.cn/problems/target-sum/">494. 目标和</a></h2><h3 id="方法一01背包">方法一：01背包</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findTargetSumWays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> Arrays.stream(nums).sum();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">diff</span> <span class="hljs-operator">=</span> sum - target;<br>        <span class="hljs-keyword">if</span> (diff % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> || diff &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        target = diff / <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// dp[j]:装满容量为j的方法数</span><br>        <span class="hljs-comment">// dp[0] = 1,装满容量为0的背包有一种</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[target + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> target; j &gt;= nums[i]; --j) &#123;<br>                dp[j] += dp[j - nums[i]];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[target];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230524153905004.png" alt="image-20230524153905004" style="zoom:50%;" /></p><h3 id="方法二回溯">方法二：回溯</h3><p>使用sum，对sum作加操作，相当于对target作减操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findTargetSumWays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        backtracking(nums, target, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-keyword">if</span> (start == nums.length) &#123;<br>            <span class="hljs-keyword">if</span> (target == <span class="hljs-number">0</span>)<br>                ++res;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        backtracking(nums, target + nums[start], start + <span class="hljs-number">1</span>);<br>        backtracking(nums, target - nums[start], start + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法三回溯的另一种写法">方法三：回溯的另一种写法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findTargetSumWays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">return</span> dfs(nums, target, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> sum)</span> &#123;<br>        <span class="hljs-keyword">if</span> (start == nums.length) &#123;<br>            <span class="hljs-keyword">return</span> target == sum ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dfs(nums, target, start + <span class="hljs-number">1</span>, sum - nums[start]) + dfs(nums, target, start + <span class="hljs-number">1</span>, sum + nums[start]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-danger">            <h3 id="方法四记忆化搜索">方法四：记忆化搜索</h3>          </div><ol type="1"><li><strong>相比回溯，使用数组记录已经计算过的结果，return前先赋值给数组memo</strong></li><li><strong>每次遍历时，首先检查memo中是否已经有结果(已经计算过了)，有结果直接返回结果</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[][] memo;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findTargetSumWays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length][<span class="hljs-number">2001</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] m : memo)<br>            Arrays.fill(m, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(nums, target, nums.length - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> sum)</span> &#123;<br>        <span class="hljs-keyword">if</span> (start &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> target == sum ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (memo[start][sum + <span class="hljs-number">1000</span>] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> memo[start][sum + <span class="hljs-number">1000</span>];<br>        <span class="hljs-keyword">return</span> memo[start][sum + <span class="hljs-number">1000</span>] = dfs(nums, target, start - <span class="hljs-number">1</span>, sum - nums[start]) + dfs(nums, target, start - <span class="hljs-number">1</span>, sum + nums[start]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-danger">            <h2 id="最小路径和"><a href="https://leetcode.cn/problems/minimum-path-sum/">64. 最小路径和</a></h2>          </div><h3 id="方法一回溯超时">方法一：回溯超时</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123; &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minPathSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length, n = grid[<span class="hljs-number">0</span>].length;<br>        dfs(grid, m, n, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, grid[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>]); <span class="hljs-comment">// 最后一次答案没有计算，所以在遍历前加上</span><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> sum)</span> &#123;<br>        <span class="hljs-keyword">if</span>(i == m - <span class="hljs-number">1</span> &amp;&amp; j == n - <span class="hljs-number">1</span>) &#123;<br>            res = Math.min(res, sum);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        sum += grid[i][j];<br>        <span class="hljs-keyword">if</span> (isValid(i + <span class="hljs-number">1</span>, j, m, n))<br>            dfs(grid, m, n, i + <span class="hljs-number">1</span>, j, sum);<br>        <span class="hljs-keyword">if</span> (isValid(i, j + <span class="hljs-number">1</span>, m, n))<br>            dfs(grid, m, n, i, j + <span class="hljs-number">1</span>, sum);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">return</span> row &gt;= <span class="hljs-number">0</span> &amp;&amp; col &gt;= <span class="hljs-number">0</span> &amp;&amp; row &lt; m &amp;&amp; col &lt; n;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法二记忆化搜索-1">方法二：记忆化搜索</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>    <span class="hljs-type">int</span> dp[][];<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minPathSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length, n = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-comment">// dp[i][j]:grid[i][j]到右下角的最小距离</span><br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dp)<br>            Arrays.fill(arr, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(grid, m - <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> &amp;&amp; j == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">8000000</span>;<br>        <span class="hljs-keyword">if</span> (dp[i][j] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[i][j];<br>        <span class="hljs-keyword">return</span> dp[i][j] = grid[i][j] + Math.min(dfs(grid, i - <span class="hljs-number">1</span>, j), dfs(grid, i, j - <span class="hljs-number">1</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col)</span> &#123;<br>        <span class="hljs-keyword">return</span> row &gt;= <span class="hljs-number">0</span> &amp;&amp; col &gt;= <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230524183253622.png" alt="" style="zoom:50%;" /></p><h2 id="不同路径"><a href="https://leetcode.cn/problems/unique-paths/">62. 不同路径</a></h2><h3 id="方法一记忆化搜索">方法一：记忆化搜索</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[][] dp;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dp)<br>            Arrays.fill(arr, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(m, n);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span> &amp;&amp; j == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">1</span> || j &lt; <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (dp[i][j] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[i][j];<br>        <span class="hljs-keyword">return</span> dp[i][j] = dfs(i - <span class="hljs-number">1</span>, j) + dfs(i, j - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230524185318223.png" alt="" style="zoom:50%;" /></p><h2 id="不同路径-ii"><a href="https://leetcode.cn/problems/unique-paths-ii/">63. 不同路径 II</a></h2><h3 id="方法一记忆化搜索-1">方法一：记忆化搜索</h3><p><strong>obstacleGrid[i][j] == 1的判断要在if (i == 0 &amp;&amp; j == 0)上面，不然会报如下错</strong></p><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230524190519092.png" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[][] dp;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePathsWithObstacles</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] obstacleGrid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> obstacleGrid.length, n = obstacleGrid[<span class="hljs-number">0</span>].length;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr : dp)<br>            Arrays.fill(arr, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(obstacleGrid, m - <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] obstacleGrid, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || obstacleGrid[i][j] == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> &amp;&amp; j == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (dp[i][j] != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> dp[i][j];<br>        <span class="hljs-keyword">return</span> dp[i][j] = dfs(obstacleGrid,i - <span class="hljs-number">1</span>, j) + dfs(obstacleGrid, i, j - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230524190551578.png" alt="image-20230524190551578" style="zoom:50%;" /></p><h1 id="自底向上的动态规划">自底向上的动态规划</h1>]]></content>
    
    
    <categories>
      
      <category>Algorithms</category>
      
      <category>dynamic programming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Backtracking</title>
    <link href="/2023/05/20/backtracking/"/>
    <url>/2023/05/20/backtracking/</url>
    
    <content type="html"><![CDATA[<h1 id="backtracking">Backtracking</h1><div class="note note-danger">            <h2 id="复原-ip-地址"><a href="https://leetcode.cn/problems/restore-ip-addresses/">93. 复原 IP 地址</a></h2>          </div><h2 id="section"><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230523092346721.png" /></h2><p><strong>解题思路</strong>：加“.”分割字符串</p><p><strong>注意</strong>：isValid()中，如果得到的子串str为空，说明字符串s已经有三个“.”分割，并且最后一个点在最后一个位置，比如<code>101.0.23.</code>，</p><ol type="1"><li>s = s.substring(0, i + 1) + "." + s.substring(i + 1);得到字符串s = <code>101.0.23.</code></li><li>++pointNum;</li><li>进入下一轮backtracking(s, i + 2, pointNum); i + 2为<code>.</code>后面一位9</li><li>此时pointNum == 3，判断ip是否合法if (isValid(s, start, s.length() - 1))</li><li>String str = s.substring(start, end + 1); 此时start为9，end + 1为9，String.subString左闭右开，所以得到的str为空</li><li>这种情况返回false</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">restoreIpAddresses</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">if</span> (s.length() &gt; <span class="hljs-number">12</span>)<br>            <span class="hljs-keyword">return</span> res;<br>        backtracking(s, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> pointNum)</span> &#123;<br>        <span class="hljs-keyword">if</span> (pointNum == <span class="hljs-number">3</span>) &#123;<br>            <span class="hljs-keyword">if</span> (isValid(s, start, s.length() - <span class="hljs-number">1</span>))<br>                res.add(s);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; s.length(); ++i) &#123;<br>            <span class="hljs-keyword">if</span> (isValid(s, start, i)) &#123;<br>                s = s.substring(<span class="hljs-number">0</span>, i + <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;.&quot;</span> + s.substring(i + <span class="hljs-number">1</span>);<br>                ++pointNum;<br>                backtracking(s, i + <span class="hljs-number">2</span>, pointNum);<br>                --pointNum;<br>                s = s.substring(<span class="hljs-number">0</span>, i + <span class="hljs-number">1</span>) + s.substring(i + <span class="hljs-number">2</span>); <span class="hljs-comment">// 删除&quot;.&quot;</span><br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> s.substring(start, end + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (str.isEmpty())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> Integer.valueOf(str) &lt;= <span class="hljs-number">255</span> &amp;&amp; (str.equals(<span class="hljs-string">&quot;0&quot;</span>) ||str.charAt(<span class="hljs-number">0</span>) != <span class="hljs-string">&#x27;0&#x27;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230522100005351.png" alt="" style="zoom:50%;" /></p><h2 id="分割回文串"><a href="https://leetcode.cn/problems/palindrome-partitioning/">131. 分割回文串</a></h2><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230522184615639.png" /></p><p><strong>二刷</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    List&lt;List&lt;String&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    Deque&lt;String&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">partition</span><span class="hljs-params">(String s)</span> &#123;<br>        backtracking(s, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-keyword">if</span> (start == s.length()) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; s.length(); ++i) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">split</span> <span class="hljs-operator">=</span> s.substring(start, i + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (isValid(split)) &#123;<br>                path.add(s.substring(start, i + <span class="hljs-number">1</span>));<br>                backtracking(s, i + <span class="hljs-number">1</span>);<br>                path.pollLast();<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String split)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, end = split.length() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (start &lt; end) &#123;<br>            <span class="hljs-keyword">if</span> (split.charAt(start++) != split.charAt(end--))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230522132532968.png" alt="" style="zoom:50%;" /></p><div class="note note-danger">            <h2 id="剑指-offer-ii-085.-生成匹配的括号"><a href="https://leetcode.cn/problems/IDBivT/">剑指 Offer II 085. 生成匹配的括号</a></h2>          </div><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230522184630657.png" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        backtracking(n, n, <span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> leftNum, <span class="hljs-type">int</span> rightNum, String parenthesis)</span> &#123;<br>        <span class="hljs-keyword">if</span> (leftNum == <span class="hljs-number">0</span> &amp;&amp; rightNum == <span class="hljs-number">0</span>) &#123;<br>            res.add(parenthesis);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (leftNum &gt; <span class="hljs-number">0</span>) &#123;<br>            backtracking(leftNum - <span class="hljs-number">1</span>, rightNum, parenthesis + <span class="hljs-string">&quot;(&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (leftNum &lt; rightNum) &#123;<br>            backtracking(leftNum, rightNum - <span class="hljs-number">1</span>, parenthesis + <span class="hljs-string">&quot;)&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230522140516243.png" alt="" style="zoom:50%;" /></p><h2 id="组合"><a href="https://leetcode.cn/problems/combinations/">77. 组合</a></h2><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230522184648467.png" /></p><h3 id="方法一">方法一：</h3><p><strong>剪枝：</strong></p><ol type="1"><li><strong>当前最多用n - i + 1</strong></li><li><strong>当前还需要加入k - path.size()个数组</strong></li></ol><p><strong>n - i + 1 &gt;= k - path.size</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combine</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>        backtracking(n, k, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-keyword">if</span> (path.size() == k) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt;= n - (k - path.size()) + <span class="hljs-number">1</span>; ++i) &#123;<br>            path.add(i);<br>            backtracking(n, k, i + <span class="hljs-number">1</span>);<br>            path.pollLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法二">方法二：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combine</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-comment">// 防止底层扩容</span><br>        Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;(k);<br>        backtracking(path, n, k, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(Deque&lt;Integer&gt; path, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 若n=3，k=2,即从[1,2,3]中选两个数，如果当前什么都没选(k=2)，n - k + 1= 2，</span><br>        <span class="hljs-comment">// 说明至少要从2开始，才能满足选两个数这个要求</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">bound</span> <span class="hljs-operator">=</span> n - k + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (start &gt; bound)<br>            <span class="hljs-keyword">return</span>;<br>        backtracking(path, n, k, start + <span class="hljs-number">1</span>);<br>        path.addLast(start);<br>        backtracking(path, n, k - <span class="hljs-number">1</span>, start + <span class="hljs-number">1</span>);<br>        path.removeLast();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="两种方法的树形结构求子集为例子">两种方法的树形结构（求子集为例子）</h3><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/841d34959b843a14f5c19b937c9c2e1.jpg" /></p><h2 id="组合总和-iii"><a href="https://leetcode.cn/problems/combination-sum-iii/">216. 组合总和 III</a></h2><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230522184744833.png" /></p><h3 id="方法一-1">方法一：</h3><p><strong>注意：backtracking(k - 1, n - i, i + 1);k - 1，别写成--k!!!</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum3</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n)</span> &#123;<br>        backtracking(k, n, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)<br>                res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt;= <span class="hljs-number">9</span> - (k - path.size()) + <span class="hljs-number">1</span>; ++i) &#123;<br>            path.offerLast(i);<br>            backtracking(k - <span class="hljs-number">1</span>, n - i, i + <span class="hljs-number">1</span>);<br>            path.pollLast();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="方法二-1">方法二：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum3</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n)</span> &#123;<br>        backtracking(k, n, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)<br>                res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">bound</span> <span class="hljs-operator">=</span> <span class="hljs-number">9</span> - k + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (start &gt; bound)<br>            <span class="hljs-keyword">return</span>;<br>        backtracking(k, n, start + <span class="hljs-number">1</span>);<br>        path.offerLast(start);<br>        backtracking(k - <span class="hljs-number">1</span>, n - start, start + <span class="hljs-number">1</span>);<br>        path.pollLast();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="组合总和"><a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></h2><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230522184803338.png" /></p><p><strong>无重复元素，每个元素可以无限次选取</strong></p><h3 id="方法一-2">方法一：</h3><p><strong>剪枝：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (target &lt; candidates[i])<br>   <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><p><strong>可重复选取，所以backtracking传入的是当前下标i</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">backtracking(candidates, target - candidates[i], i);<br></code></pre></td></tr></table></figure><p><strong>剪枝的条件是把数组排序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Arrays.sort(candidates);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>    Arrays.sort(candidates);<br>    backtracking(candidates, target, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> start)</span> &#123;<br>    <span class="hljs-keyword">if</span> (target &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (target == <span class="hljs-number">0</span>) &#123;<br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(path));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; candidates.length; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (target &lt; candidates[i])<br>            <span class="hljs-keyword">break</span>;<br>        path.offerLast(candidates[i]);<br>        backtracking(candidates, target - candidates[i], i);<br>        path.pollLast();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法二-2">方法二：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>        Arrays.sort(candidates);<br>        backtracking(candidates, target, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-keyword">if</span> (target &lt; <span class="hljs-number">0</span> || start == candidates.length)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (target == <span class="hljs-number">0</span>) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        backtracking(candidates, target, start + <span class="hljs-number">1</span>);<br>        path.offerLast(candidates[start]);<br>        backtracking(candidates, target - candidates[start], start);<br>        path.pollLast();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="组合总和-ii"><a href="https://leetcode.cn/problems/combination-sum-ii/">40. 组合总和 II</a></h2><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230522194233770.png" /></p><p><strong>数组内有重复元素，每个元素只能使用一次，解集不能包含重复组合</strong></p><h3 id="方法一-3">方法一：</h3><p><strong>剪枝</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (candidates[i] &gt; target)<br>    <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><p><strong>去重</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (i &gt; start &amp;&amp; candidates[i] == candidates[i - <span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">continue</span>;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>        Arrays.sort(candidates);<br>        backtracking(candidates, target, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-keyword">if</span> (target == <span class="hljs-number">0</span>) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; candidates.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (candidates[i] &gt; target)<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">if</span> (i &gt; start &amp;&amp; candidates[i] == candidates[i - <span class="hljs-number">1</span>])<br>                <span class="hljs-keyword">continue</span>;<br>            path.offerLast(candidates[i]);<br>            backtracking(candidates, target - candidates[i], i + <span class="hljs-number">1</span>);<br>            path.pollLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="子集"><a href="https://leetcode.cn/problems/subsets/">78. 子集</a></h2><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230523090841520.png" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        backtracking(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-keyword">if</span> (start == nums.length) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        backtracking(nums, start + <span class="hljs-number">1</span>);<br>        path.offerLast(nums[start]);<br>        backtracking(nums, start + <span class="hljs-number">1</span>);<br>        path.pollLast();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-danger">            <h2 id="递增子序列"><a href="https://leetcode.cn/problems/non-decreasing-subsequences/">491. 递增子序列</a></h2>          </div><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230523090901456.png" /></p><h4 id="方法一顺序dfs">方法一：顺序DFS</h4><p><strong>注意：</strong></p><ol type="1"><li><strong>HashSet的位置！！！每进入一层递归，就会在for循环前创建一个HashSet，这样可以保证树层去重，并且树枝不会去重</strong></li><li><strong>peekLast()! 不是peek()</strong></li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> Solution &#123;<br>    List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; res = <span class="hljs-built_in">new</span> LinkedList&lt;&gt;();<br>    Deque&lt;<span class="hljs-type">Integer</span>&gt; <span class="hljs-type">path</span> = <span class="hljs-built_in">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-built_in">public</span> List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; findSubsequences(<span class="hljs-type">int</span>[] nums) &#123;<br>        backtracking(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> backtracking(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> <span class="hljs-keyword">start</span>) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-type">path</span>.size() &gt;= <span class="hljs-number">2</span>)<br>            res.<span class="hljs-keyword">add</span>(<span class="hljs-built_in">new</span> LinkedList(<span class="hljs-type">path</span>));<br>        <span class="hljs-keyword">Set</span>&lt;<span class="hljs-type">Integer</span>&gt; <span class="hljs-keyword">set</span> = <span class="hljs-built_in">new</span> HashSet&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-keyword">start</span>; i &lt; nums.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> ((!<span class="hljs-type">path</span>.isEmpty() &amp;&amp; nums[i] &lt; <span class="hljs-type">path</span>.peekLast()))<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">set</span>.contains(nums[i]))<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">set</span>.<span class="hljs-keyword">add</span>(nums[i]);<br>            <span class="hljs-type">path</span>.<span class="hljs-keyword">add</span>(nums[i]);<br>            backtracking(nums, i + <span class="hljs-number">1</span>);<br>            <span class="hljs-type">path</span>.pollLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="全排列"><a href="https://leetcode.cn/problems/permutations/">46. 全排列</a></h2><p><strong>把树形结构画出来就懂了</strong></p><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/20201209174225145.png" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    Deque&lt;Integer&gt; path;<br>    <span class="hljs-type">boolean</span>[] used;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permute</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 防止底层扩容</span><br>        path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;(nums.length);<br>        used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[nums.length];<br>        backtracking(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-keyword">if</span> (path.size() == nums.length) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (used[i])<br>                <span class="hljs-keyword">continue</span>;<br>            path.offerLast(nums[i]);<br>            used[i] = <span class="hljs-literal">true</span>;<br>            backtracking(nums, i + <span class="hljs-number">1</span>);<br>            used[i] = <span class="hljs-literal">false</span>;<br>            path.pollLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="全排列-ii"><a href="https://leetcode.cn/problems/permutations-ii/">47. 全排列 II</a></h2><ol type="1"><li><strong>为了去重，需要先将数组排序</strong></li><li><strong>树层去重，树枝不需要去重</strong></li><li><strong>上一个相同的数如果used[i - 1] == false，那么说明已经被遍历过，并且将used数组赋值回false，这个时候就不需要遍历当前nums[i]了；如果used[i - 1] == true，那么说明是在同一路径上</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; !used[i - <span class="hljs-number">1</span>])<br>               <span class="hljs-keyword">continue</span>;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    Deque&lt;Integer&gt; path;<br>    <span class="hljs-type">boolean</span>[] used;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permuteUnique</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 防止底层扩容</span><br>        path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;(nums.length);<br>        used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[nums.length];<br>        Arrays.sort(nums);<br>        backtracking(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-keyword">if</span> (path.size() == nums.length) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (used[i])<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; !used[i - <span class="hljs-number">1</span>])<br>                <span class="hljs-keyword">continue</span>;<br>            path.offerLast(nums[i]);<br>            used[i] = <span class="hljs-literal">true</span>;<br>            backtracking(nums, i + <span class="hljs-number">1</span>);<br>            used[i] = <span class="hljs-literal">false</span>;<br>            path.pollLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-danger">            <h2 id="划分为k个相等的子集"><a href="https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/">698. 划分为k个相等的子集</a></h2>          </div><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230524095514759.png" /></p><p><a href="https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/solution/by-lfool-d9o7/">优质题解</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canPartitionKSubsets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> Arrays.stream(nums).sum();<br>        <span class="hljs-keyword">if</span> (sum % k != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> sum / k;<br>        <span class="hljs-type">int</span>[] bucket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k];<br>        <span class="hljs-keyword">return</span> backtracking(nums, k, bucket, <span class="hljs-number">0</span>, target);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span>[] bucket, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == nums.length) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; bucket[i] == bucket[i - <span class="hljs-number">1</span>])<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (nums[index] + bucket[i] &gt; target)<br>                <span class="hljs-keyword">continue</span>;<br>            bucket[i] += nums[index];<br>            <span class="hljs-keyword">if</span> (backtracking(nums, k, bucket, index + <span class="hljs-number">1</span>, target))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            bucket[i] -= nums[index];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="n-皇后"><a href="https://leetcode.cn/problems/n-queens/">51. N 皇后</a></h2><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230524095532469.png" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;String&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">solveNQueens</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">char</span>[][] board = generateBoard(n);<br>        backtracking(board, n, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> row)</span> &#123;<br>        <span class="hljs-keyword">if</span> (row == n) &#123;<br>            res.add(toList(board));<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; col &lt; n; ++col) &#123;<br>            <span class="hljs-keyword">if</span> (isValid(board, row, col, n)) &#123;<br>                board[row][col] = <span class="hljs-string">&#x27;Q&#x27;</span>;<br>                backtracking(board, n, row + <span class="hljs-number">1</span>);<br>                board[row][col] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> List&lt;String&gt; <span class="hljs-title function_">toList</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board)</span> &#123;<br>        List&lt;String&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span>[] ch : board) &#123;<br>            path.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(ch));<br>        &#125;<br>        <span class="hljs-keyword">return</span> path;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// 1.列</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; row; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (board[i][col] == <span class="hljs-string">&#x27;Q&#x27;</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 2. 45度</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> row - <span class="hljs-number">1</span>, j = col - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>; --i, --j) &#123;<br>            <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 3.135度</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> row - <span class="hljs-number">1</span>, j = col + <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; n; --i, ++j) &#123;<br>            <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">char</span>[][] generateBoard(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-type">char</span>[][] board = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span>[] row : board)<br>            Arrays.fill(row, <span class="hljs-string">&#x27;.&#x27;</span>);<br>        <span class="hljs-keyword">return</span> board;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithms</category>
      
      <category>backtracking</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>quiz1</title>
    <link href="/2023/05/19/2023_5_19/"/>
    <url>/2023/05/19/2023_5_19/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数</a></p><p>BFS</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countNodes</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.offer(root);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> queue.poll();<br>            ++count;<br>            <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-literal">null</span>) &#123;<br>                queue.offer(cur.left);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-literal">null</span>) &#123;<br>                queue.offer(cur.right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/restore-ip-addresses/">93. 复原 IP 地址</a></p><p>回溯，没想出来</p><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">123. 买卖股票的最佳时机 III</a></p><p>DP</p><p><a href="https://leetcode.cn/problems/partition-equal-subset-sum/">416. 分割等和子集</a></p><p>0-1背包</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canPartition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 是否可以在数组中凑出sum / 2 -&gt; 0-1背包</span><br>        <span class="hljs-comment">// dp[j]: 是否能恰好装满j</span><br>        <span class="hljs-comment">// 状态转移：dp[j] = dp[j] || dp[j - nums[i]]</span><br>        <span class="hljs-comment">// dp[0] = true, 什么都不选，即可装满容量为0的背包</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> Arrays.stream(nums).sum();<br>        <span class="hljs-keyword">if</span> (sum % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> sum / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">boolean</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[target + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> target; j &gt;= nums[i]; --j) &#123;<br>                dp[j] |= dp[j - nums[i]];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[target];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/">329. 矩阵中的最长递增路径</a></p><p>BFS</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-type">int</span>[][] path;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestIncreasingPath</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix.length, n = matrix[<span class="hljs-number">0</span>].length;<br>        path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                res = Math.max(res, dfs(i, j, m, n, matrix));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-keyword">if</span> (path[i][j] != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> path[i][j];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxPath</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], col = j + dir[<span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (isValid(row, col, m, n) &amp;&amp; matrix[row][col] &gt; matrix[i][j]) &#123;<br>                path += dfs(row, col, m, n, matrix);<br>            &#125;<br>            maxPath = Math.max(maxPath, path);<br>        &#125;<br>        path[i][j] = maxPath;<br>        <span class="hljs-keyword">return</span> maxPath;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">return</span> row &gt;= <span class="hljs-number">0</span> &amp;&amp; col &gt;= <span class="hljs-number">0</span> &amp;&amp; row &lt; m &amp;&amp; col &lt; n;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/get-equal-substrings-within-budget/">1208. 尽可能使字符串相等</a></p><p>滑动窗口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">equalSubstring</span><span class="hljs-params">(String s, String t, <span class="hljs-type">int</span> maxCost)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span>[] diff = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            diff[i] = Math.abs(s.charAt(i) - t.charAt(i));<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, start = <span class="hljs-number">0</span>, sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; end &lt; n; ++end) &#123;<br>            sum += diff[end];<br>            <span class="hljs-keyword">while</span> (maxCost &lt; sum) &#123;<br>                sum -= diff[start++];<br>            &#125;<br>            res = Math.max(res, end - start + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/split-array-largest-sum/">410. 分割数组的最大值</a></p><p>感觉要用二分</p><p><a href="https://leetcode.cn/problems/next-greater-element-ii/">503. 下一个更大元素 II</a></p><p>还没刷单调栈</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Algorithms</title>
    <link href="/2023/04/07/Algorithms/"/>
    <url>/2023/04/07/Algorithms/</url>
    
    <content type="html"><![CDATA[<h1 id="leetcode-solutions">LeetCode Solutions</h1><!-- toc --><h2 id="dynamic-programming">Dynamic Programming</h2><h3 id="debug">debug</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printDp</span><span class="hljs-params">(<span class="hljs-type">int</span>[] dp, <span class="hljs-type">int</span> i)</span> &#123;<br>    System.out.print(i + <span class="hljs-string">&quot;: &quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> maxValue : dp)&#123;<br>        System.out.print(maxValue + <span class="hljs-string">&quot;   &quot;</span>);<br>    &#125;<br>    System.out.println();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="斐波那契数"><a href="https://leetcode.cn/problems/fibonacci-number/">509. 斐波那契数</a></h3><h4 id="方法一dp">方法一：DP</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;<br>            dp[i] = dp[i - <span class="hljs-number">2</span>] + dp[i - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230512102141368.png" alt="image-20230512102141368" style="zoom:50%;" /></p><h4 id="方法二dp-滚动数组">方法二：DP + 滚动数组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;<br>            dp[i % <span class="hljs-number">3</span>] = dp[(i - <span class="hljs-number">2</span>) % <span class="hljs-number">3</span>] + dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">3</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n % <span class="hljs-number">3</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230512102424611.png" alt="image-20230512102424611" style="zoom:50%;" /></p><h3 id="爬楼梯"><a href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a></h3><h4 id="方法一dp-滚动数组">方法一：DP + 滚动数组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// 1.dp[i]:爬上第i层楼梯的方法数</span><br>        <span class="hljs-comment">// 2.状态转移方程：dp[i] = dp[i - 1] + dp[i - 2]</span><br>        <span class="hljs-comment">// 3.初始化：爬上第0层楼梯的方法数是1，dp[0] = 1,如果是0，那么dp[2] = 1！</span><br>        <span class="hljs-comment">// 爬上第一层楼梯的方法数是1,dp[1] = 1</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;<br>            dp[i % <span class="hljs-number">3</span>] = dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">3</span>] + dp[(i - <span class="hljs-number">2</span>) % <span class="hljs-number">3</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n % <span class="hljs-number">3</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230512103518672.png" alt="image-20230512103518672" style="zoom:50%;" /></p><h3 id="使用最小花费爬楼梯"><a href="https://leetcode.cn/problems/min-cost-climbing-stairs/">746. 使用最小花费爬楼梯</a></h3><p><strong>注意：最后一个阶梯之后才是楼顶</strong></p><figure><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230512125550663.png" alt="image-20230512125550663" /><figcaption aria-hidden="true">image-20230512125550663</figcaption></figure><h4 id="方法一dp-滚动数组-1">方法一：DP + 滚动数组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCostClimbingStairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] cost)</span> &#123;<br>        <span class="hljs-comment">// dp[i]:爬到第i层的最小花费</span><br>        <span class="hljs-comment">// 状态转移方程：dp[i] = min(dp[i - 2] + cost[i - 2], dp[i - 1] + cost[i - 1])</span><br>        <span class="hljs-comment">// 初始化：dp[0] = 0, dp[1] = 0</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> cost.length;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;<br>            dp[i % <span class="hljs-number">3</span>] = Math.min(dp[(i - <span class="hljs-number">2</span>) % <span class="hljs-number">3</span>] + cost[i - <span class="hljs-number">2</span>], dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">3</span>] + cost[i - <span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n % <span class="hljs-number">3</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230512123419045.png" alt="image-20230512123419045" style="zoom:50%;" /></p><h3 id="剑指offer-95">剑指Offer 95</h3><ol type="1"><li><p>最优子结构：求<strong>最长</strong>公共子序列，求问题最优解，适合使用dp解决。</p></li><li><p>重叠子问题：求第一个字符串中位置0~<span class="math inline">\(i\)</span>构成的子序列与第二个字符串中0~<span class="math inline">\(j\)</span>构成的子序列的最大公共子序列<span class="math inline">\(f(i,j)\)</span>，需要多次使用<span class="math inline">\(f(i-1, j-1), f(i-1,j),f(i,j-1)\)</span>，拥有重叠子问题</p></li><li><p>状态转移方程： <span class="math display">\[f(i,j) = \begin{cases}f(i-1,j-1)+1, &amp; ch[i]==ch[j] \\max(f(i-1,j),f(i,j-1)), &amp; else \\\end{cases}\]</span></p></li><li><p>边界条件：dp[0][:] == 0, dp[:][] == 0</p></li></ol><p>令两个字符串长度分别为<span class="math inline">\(m,n\)</span>，</p><p><strong>时间复杂度</strong>：双重for循环，<span class="math inline">\(O(mn)\)</span></p><p><strong>空间复杂度</strong>：需要建立大小为(m+1)(n+1)的数组，因此空间复杂度为<span class="math inline">\(O(mn)\)</span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestCommonSubsequence</span><span class="hljs-params">(String text1, String text2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> text1.length(), n = text2.length();<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (text1.charAt(i - <span class="hljs-number">1</span>) == text2.charAt(j - <span class="hljs-number">1</span>)) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = Math.max(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230418182108971.png" alt="image-20230418182108971" style="zoom:50%;" /></p><p><strong>如何优化空间复杂度？</strong></p><h3 id="剑指offer-101-分割等和子集"><a href="https://leetcode.cn/problems/partition-equal-subset-sum/">剑指Offer 101 分割等和子集</a></h3><p><strong>分析</strong>：只要在数组中找到任意数等于数组累加和的一半，该数组就是等和子集，可抽象为经典0-1背包问题。</p><ol type="1"><li>dp[i][j]:从编号0-i的物品中任选物品(可以都不选)，容量为j的背包能否正好装满</li><li>递归公式:dp[i][j] = dp[i-1][j] || j &gt;= num[i] : dp[i-1][j-nums[i]] : false</li><li>初始化:<ol type="1"><li>当j==0时，即背包容量为0，不管有多少物品，只要什么都不选就能使背包总重量为0，所以f(i,0)=true</li><li>当i==0 &amp;&amp; j!= 0时，即物品数量为0，怎样都不能放满容量大于0的背包，所以f(0,i)=false</li></ol></li><li>遍历顺序：先遍历物品再嵌套从头到尾遍历容量</li><li>打印dp数组验证与手写稿是否一致</li></ol><p><strong>空间复杂度优化</strong>：由于求第i行dp数组只需要用到第i-1行dp数组的信息，所以可以使用一维滑动dp数组代替二维dp数组。</p><h3 id="剑指offer-1049-最后一块石头的重量-ii"><a href="https://leetcode.cn/problems/last-stone-weight-ii/">剑指Offer 1049 最后一块石头的重量 II</a></h3><p><strong>从 stones数组中选择，凑成总和不超过 <span class="math inline">\(sum/2\)</span> 的最大价值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lastStoneWeightII</span><span class="hljs-params">(<span class="hljs-type">int</span>[] stones)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> Arrays.stream(stones).sum();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> sum / <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// dp[j]:容量为j的背包能装下不超过target的最大价值</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[target + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; stones.length; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> target; j &gt;= stones[i]; --j) &#123;<br>                dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum - dp[target] * <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="一和零"><a href="https://leetcode.cn/problems/ones-and-zeroes/">一和零</a></h3><p><strong>背包问题中，weight里的数据不一定要升序！比如weights=[4,1,3]</strong></p><h4 id="方法一dp-1">方法一：DP</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMaxForm</span><span class="hljs-params">(String[] strs, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// dp[i][j]:最多有i个0，j个1，最多能选的字符数量</span><br>        <span class="hljs-type">int</span>[][][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[strs.length + <span class="hljs-number">1</span>][m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; k &lt;= strs.length; ++k) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> strs[k - <span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num0</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, num1 = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; x &lt; str.length(); ++x) &#123;<br>                <span class="hljs-keyword">if</span> (str.charAt(x) == <span class="hljs-string">&#x27;0&#x27;</span>)<br>                    ++num0;<br>                <span class="hljs-keyword">else</span> <br>                    ++num1;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= m; ++i) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= n; ++j) &#123;<br>                    <span class="hljs-keyword">if</span> (i &lt; num0 || j &lt; num1)<br>                        dp[k][i][j] = dp[k - <span class="hljs-number">1</span>][i][j];<br>                    <span class="hljs-keyword">else</span> <br>                        dp[k][i][j] = Math.max(dp[k - <span class="hljs-number">1</span>][i][j], dp[k - <span class="hljs-number">1</span>][i - num0][j - num1] + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[strs.length][m][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230516173459566.png" alt="image-20230516173459566" style="zoom:50%;" /></p><h4 id="方法二dp滚动数组">方法二：DP+滚动数组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMaxForm</span><span class="hljs-params">(String[] strs, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// dp[i][j]:最多有i个0，j个1，最多能选的字符数量</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; k &lt;= strs.length; ++k) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> strs[k - <span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num0</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, num1 = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; x &lt; str.length(); ++x) &#123;<br>                <span class="hljs-keyword">if</span> (str.charAt(x) == <span class="hljs-string">&#x27;0&#x27;</span>)<br>                    ++num0;<br>                <span class="hljs-keyword">else</span> <br>                    ++num1;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> m; i &gt;= num0; --i) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> n; j &gt;= num1; --j) &#123;<br>                    dp[i][j] = Math.max(dp[i][j], dp[i - num0][j - num1] + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230516175116922.png" alt="image-20230516175116922" style="zoom:50%;" /></p><h3 id="零钱兑换-ii"><a href="https://leetcode.cn/problems/coin-change-ii/">518. 零钱兑换 II</a></h3><p>​ 经典完全背包问题，解题步骤如下：</p><ol type="1"><li>dp[j]：背包容量为j时，放满背包的组合方法数</li><li>状态转移公式：dp[j] = dp[j] + dp[j - coins[i]]</li><li>初始化dp[0]：背包容量为0时，有一种方法放满背包（什么都不放）</li><li>遍历顺序：求组合数，先便利物品，再遍历容量</li><li>遍历dp数组</li></ol><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230318210753861.png" alt="image-20230318210753861" style="zoom:50%;" /></p><p><strong>关于组合和排列的理解</strong>：先遍历物品后遍历背包是这样，比如，外层循环固定coins[1]，在内层循环遍历背包时，随着背包不断增加，coins[1]可以重复被添加进来，而由于外层循环固定了，因此coins[2]只能在下一次外层循环添加进不同大小的背包中，这么看的话，coins[i + 1]只能在coins[i]之后了；如果先遍历背包后遍历物品，那么外层循环先固定背包大小j，然后在大小为j的背包中循环遍历添加物品，然后在下次外层循环背包大小变为j+1，此时仍要执行内层循环遍历添加物品，也就会出现在上一轮外层循环中添加coins[2]的基础上还能再添加coins[1]的情况，那么就有了coins[1]在coins[2]之后的情况了(逆序)。</p><p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包。</strong></p><p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品。</strong></p><h3 id="组合总和-ⅳ"><a href="https://leetcode.cn/problems/combination-sum-iv/">377. 组合总和 Ⅳ</a></h3><ol type="1"><li>先举个例子，nums = [1, 2, 3]，target = 35.</li><li>假设用1，2，3拼凑出35的总组合个数为y。我们可以考虑三种情况：</li><li>（1）有效组合的末尾数字为1，这类组合的个数为 x1。我们把所有该类组合的末尾1去掉，那么不难发现，我们找到了一个子问题，x1即为在[1，2，3]中凑出35 - 1 = 34的总组合个数。因为我如果得到了和为34的所有组合，我只要在所有组合的最后面，拼接一个1，就得到了和为35且最后一个数字为1的组合个数了。</li><li>（2）有效组合的末尾数字为2，这类组合的个数为 x2。我们把所有该类组合的末尾2去掉，那么不难发现，我们找到了一个子问题，x2即为在[1，2，3]中凑出35 - 2 = 33的总组合个数。因为我如果得到了和为33的所有组合，我只要在所有组合的最后面，拼接一个2，就得到了和为35且最后一个数字为2的组合个数了。</li><li>（3）有效组合的末尾数字为3，这类组合的个数为 x3。我们把所有该类组合的末尾3去掉，那么不难发现，我们找到了一个子问题，x3即为在[1，2，3]中凑出35 - 3 = 32的总组合个数。因为我如果得到了和为32的所有组合，我只要在所有组合的最后面，拼接一个3，就得到了和为35且最后一个数字为3的组合个数了。</li><li>这样就简单了，y = x1 + x2 + x3。而x1，x2，x3又可以用同样的办法从子问题得到。状态转移方程get！</li></ol><p>全排列问题，转化为完全背包问题</p><ol type="1"><li>dp[j]：在背包容量为j时，放满背包的排列数</li><li>状态转移公式：dp[j] = dp[j] + dp[j - nums[i]]</li><li>初始化dp[0]：在背包容量为0时，放满背包的排列数量为1（什么都不放）</li><li>遍历顺序，排列问题，先遍历背包容量(物品可以逆序放入dp[j - nums[i]])，再遍历物品</li><li>打印dp数组</li></ol><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230318210708505.png" alt="image-20230318210708505" style="zoom:50%;" /></p><h3 id="爬楼梯-1"><a href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a></h3><p><strong>完全背包</strong> + 全排列问题，可以重复选择放入物品1与物品2，求放满容量为n的背包的排列数</p><ol type="1"><li>dp[j]：在背包容量为j时，放满背包的排列数</li><li>状态转移公式：dp[j] = dp[j] + dp[j - nums[i]]</li><li>初始化dp[0]：在背包容量为0时，放满背包的排列数量为1（什么都不放）</li><li>遍历顺序，排列问题，先遍历背包容量(物品可以逆序放入dp[j - nums[i]])，再遍历物品</li><li>打印dp数组</li></ol><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230318210647601.png" alt="image-20230318210647601" style="zoom:50%;" /></p><h3 id="零钱兑换"><a href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换</a></h3><p><strong>完全背包问题</strong></p><ol type="1"><li>dp[j]：背包容量为j时，凑满背包容量所需的<strong>最少硬币数</strong></li><li>状态转移公式：dp[j] = min(dp[j], dp[j - coins[i]] + 1)</li><li>初始化dp[0]：背包容量为0时，凑满背包容量所需的最少硬币数时0,其他初始化为Integer.MAX_VALUE</li><li>遍历顺序，无所谓</li><li>打印dp数组</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">coinChange</span><span class="hljs-params">(<span class="hljs-type">int</span>[] coins, <span class="hljs-type">int</span> amount)</span> &#123;<br>        <span class="hljs-comment">// dp[j]: 凑成整数j所需的最少的硬币书</span><br>        <span class="hljs-comment">// 状态转移方程：dp[j] = min(dp[j], dp[j - nums[i] + 1])</span><br>        <span class="hljs-comment">// 初始化：dp[0] = 0,其他初始化为1</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[amount + <span class="hljs-number">1</span>];<br>        Arrays.fill(dp, Integer.MAX_VALUE);<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; coins.length; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> coins[i]; j &lt;= amount; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (dp[j - coins[i]] != Integer.MAX_VALUE)<br>                    dp[j] = Math.min(dp[j], dp[j - coins[i]] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[amount] == Integer.MAX_VALUE ? -<span class="hljs-number">1</span> : dp[amount];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230318210620287.png" alt="image-20230318210620287" style="zoom:50%;" /></p><h3 id="完全平方数"><a href="https://leetcode.cn/problems/perfect-squares/">279. 完全平方数</a></h3><ol type="1"><li><p>dp[j]：装满容量为j的背包，至少要放多少个物品</p></li><li><p>状态转移公式：dp[j] = min(dp[j], dp[j - weights[i]] + 1)</p></li><li><p>初始化dp[0]:装满容量为0的背包，至少放0个物品；其他设为Integet.MAX_VALUE</p></li><li><p>遍历顺序：无所谓</p></li><li><p>打印dp数组</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numSquares</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// 完全背包问题</span><br>        <span class="hljs-comment">// 定义物品的weights数组，先找到小于等于n的最大完全平方数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">max_weight</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(Math.sqrt(n));  <br>        <span class="hljs-type">int</span>[] weights = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[max_weight];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= max_weight; i++)<br>            weights[i-<span class="hljs-number">1</span>] = i*i;    <br>        <span class="hljs-comment">// 1.dp[j]：装满容量为j的背包，至少要放多少个物品</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 2.状态转移公式：dp[j] = min(dp[j], dp[j - weights[i]] + 1)</span><br>        <span class="hljs-comment">// 3.初始化dp[0]:装满容量为0的背包，至少放0个物品；其他设为Integet.MAX_VALUE</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            dp[i] = Integer.MAX_VALUE;<br>        &#125;<br>        <span class="hljs-comment">// 4.遍历顺序：无所谓</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; weights.length; i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> weights[i]; j &lt;= n; j++) &#123;<br>                <span class="hljs-keyword">if</span>(dp[j - weights[i]] != Integer.MAX_VALUE)<br>                    dp[j] = Math.min(dp[j], dp[j - weights[i]] + <span class="hljs-number">1</span>);<br>            &#125;<br>           <span class="hljs-comment">// printDp(dp, i);</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>        <span class="hljs-comment">// 5.打印dp数组</span><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printDp</span><span class="hljs-params">(<span class="hljs-type">int</span>[] dp, <span class="hljs-type">int</span> i)</span> &#123;<br>        System.out.print(i + <span class="hljs-string">&quot;: &quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> maxValue : dp)&#123;<br>            System.out.print(maxValue + <span class="hljs-string">&quot;   &quot;</span>);<br>        &#125;<br>        System.out.println();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单词拆分"><a href="https://leetcode.cn/problems/word-break/">139. 单词拆分</a></h3><p><strong>背包问题</strong> + <strong>排列</strong>(“leetcode”由“leet”与“code”组成但不能反过来由“code”与“leet”组成 )的变种，建议不要完全抽象成背包问题，便于理解</p><ol type="1"><li>dp[j]：长度为j的字符串，<strong>可以被字典中的单词拆分</strong>。</li><li>状态转移公式：if([j, i] 这个区间的子串出现在字典里 &amp;&amp; dp[j]是true) 那么 dp[i] = true， 其中j&lt;i。</li><li>初始化dp[0]:dp[i]依赖于前面的dp[j]，所以dp[0]要初始化为true，不然全为false</li><li>遍历顺序：先遍历背包容量，再嵌套遍历物品</li><li>打印dp数组</li></ol><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230320095545766.png" alt="image-20230320095545766" style="zoom:50%;" /></p><h3 id="打家劫舍"><a href="https://leetcode.cn/problems/house-robber/">198. 打家劫舍</a></h3><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230327183302703.png" alt="image-20230327183302703" style="zoom:50%;" /></p><ol type="1"><li>dp[j]：偷窃从标号为0到j的房屋所能获得的最大价值</li><li>状态转移公式：dp[j] = max(dp[j - 1], dp[j - 2] + nums[j])</li><li>初始化：dp[0] = nums[0], dp[1] = max(nums[0], nums[1])</li><li>遍历顺序：单序列问题,dp[i] 是根据dp[i - 2] 和 dp[i - 1] 推导出来的，那么一定是从前到后遍历！</li><li>遍历dp数组</li></ol><h4 id="优化空间复杂度">优化空间复杂度</h4><p>根据状态转移公式dp[j] = max(dp[j - 1], dp[j - 2] + nums[j])，dp[j]只需要dp[j-1]以及dp[j-2]两个变量即可，可以把数组大小压缩到2。</p><h3 id="打家劫舍-ii"><a href="https://leetcode.cn/problems/house-robber-ii/">213. 打家劫舍 II</a></h3><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230328192555408.png" alt="image-20230328192555408" style="zoom:50%;" /></p><h3 id="分割等和子集"><a href="https://leetcode.cn/problems/partition-equal-subset-sum/">416. 分割等和子集</a></h3><ol type="1"><li>dp[j]：背包容量为j时，是否能用物品装满</li><li>状态转移方程：dp[j] = dp[j] || dp[j - nums[i]]</li><li>初始化：背包容量为0时，不把物品装进去即可装满，dp[0] = true</li><li>遍历顺序：一维滑动数组，零一背包，先遍历物品后遍历背包容量</li></ol><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230328164702918.png" alt="image-20230328164702918" style="zoom:50%;" /></p><h3 id="打家劫舍-iii"><a href="https://leetcode.cn/problems/house-robber-iii/">337. 打家劫舍 III</a></h3><h4 id="方法一hashmap">方法一：HashMap</h4><p>f：偷当前房屋能获得的最大价值；g：不偷当前房屋能获得的最大价值</p><ol type="1"><li>偷当前房屋f(cur) = cur.val + g(cur.left) + g(cur.right)</li><li>不偷当前房屋g(cur) = max(f(cur.left), g(cur.left)) + max(f(cur.right), g(cur.right))</li></ol><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230329142700228.png" alt="image-20230329142700228" style="zoom:50%;" /></p><h4 id="方法二morris-hashmap">方法二：Morris + HashMap</h4><p><strong>当作是练习题了！！</strong></p><p><strong>注意事项：</strong>在访问的时候，此时需要cur.right，而这个时候已经是逆序过的，cur.right实际上指向的是自己的父节点，所以再用一个hashmap存储cur真正的右节点（或者再逆序一遍）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    Map&lt;TreeNode, Integer&gt; f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    Map&lt;TreeNode, Integer&gt; g = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    Map&lt;TreeNode, TreeNode&gt; right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-comment">// f:偷当前节点能获得的最大价值</span><br>        <span class="hljs-comment">// g:不偷当前节点能获得的最大价值</span><br>       <span class="hljs-comment">//  f(cur) = cur.val + g(cur.left) + g(cur.right)</span><br>       <span class="hljs-comment">//  g(cur) = max(f(cur.left), g(cur.left)) + max(f(cur.right), g(cur.right))</span><br>       <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root, mostRight = <span class="hljs-literal">null</span>;<br>       <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>           mostRight = cur.left;<br>           <span class="hljs-keyword">if</span> (mostRight != <span class="hljs-literal">null</span>) &#123;<br>               <span class="hljs-keyword">while</span> (mostRight.right != <span class="hljs-literal">null</span> &amp;&amp; mostRight.right != cur)<br>                    mostRight = mostRight.right;<br>                <span class="hljs-keyword">if</span> (mostRight.right == <span class="hljs-literal">null</span>) &#123;<br>                    mostRight.right = cur;<br>                    cur = cur.left;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// mostRight.right = cur</span><br>                    mostRight.right = <span class="hljs-literal">null</span>;<br>                    visit(cur.left);<br>                &#125;<br>           &#125;<br>           cur = cur.right;<br>       &#125;<br>       visit(root);<br>       <span class="hljs-keyword">return</span> Math.max(f.getOrDefault(root, <span class="hljs-number">0</span>), g.getOrDefault(root, <span class="hljs-number">0</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(TreeNode cur)</span> &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">tail</span> <span class="hljs-operator">=</span> reverse(cur);<br>        cur = tail;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            f.put(cur, cur.val + g.getOrDefault(cur.left, <span class="hljs-number">0</span>) + g.getOrDefault(right.get(cur), <span class="hljs-number">0</span>));<br>            <span class="hljs-type">int</span> <span class="hljs-variable">maxLeft</span> <span class="hljs-operator">=</span> Math.max(f.getOrDefault(cur.left, <span class="hljs-number">0</span>), g.getOrDefault(cur.left, <span class="hljs-number">0</span>));<br>            <span class="hljs-type">int</span> <span class="hljs-variable">maxRight</span> <span class="hljs-operator">=</span> Math.max(f.getOrDefault(right.get(cur), <span class="hljs-number">0</span>), g.getOrDefault(right.get(cur), <span class="hljs-number">0</span>));<br>            g.put(cur, maxLeft + maxRight);<br>            <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-literal">null</span>) <br>                right.put(cur.right, cur);<br>            cur = cur.right;<br>        &#125;<br>        reverse(tail);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> TreeNode <span class="hljs-title function_">reverse</span><span class="hljs-params">(TreeNode cur)</span> &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> cur.right;<br>            cur.right = pre;<br>            pre = cur;<br>            cur = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230417165305163.png" alt="image-20230417165305163" style="zoom:50%;" /></p><h3 id="买卖股票的最佳时机"><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h3><h4 id="你根本没在dp">你根本没在dp！</h4><h4 id="方法一暴力迭代">方法一：暴力迭代</h4><p>超时咯</p><figure><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230330094627247.png" alt="image-20230330094627247" /><figcaption aria-hidden="true">image-20230330094627247</figcaption></figure><h4 id="方法二贪心">方法二：贪心</h4><p>从前往后遍历，使用minPrice记录最小值，使用maxProfit记录最大收益</p><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230330101656109.png" alt="image-20230330101656109" style="zoom:50%;" /></p><h4 id="方法三dp">方法三：DP</h4><p><strong>DP数组的定义十分重要！</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> prices.length;<br>        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span> || prices == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 1.dp[0][j]:第j天持有股票(之前买入或者当前买入)所拥有的最大价值，dp[1][j]：第j天不持有股票(之前卖出或者当前卖出)所拥有的最大价值</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>][len];<br>        <span class="hljs-comment">// 2.状态转移方程：dp[0][j] = max(dp[0][j-1], -price[j]); dp[1][j] = max(dp[1][j-1], price[j] + dp[0][j - 1])</span><br>        <span class="hljs-comment">// 3.初始化：dp[0][0]必须买入，初始化为-price[0]；dp[1][0]不能卖出任何股票，初始化为0</span><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">// 4.遍历顺序：dp[j]由dp[j-1]决定，所以从前往后遍历</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; len; ++j) &#123;<br>            dp[<span class="hljs-number">0</span>][j] = Math.max(dp[<span class="hljs-number">0</span>][j - <span class="hljs-number">1</span>], -prices[j]);<br>            dp[<span class="hljs-number">1</span>][j] = Math.max(dp[<span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>], prices[j] + dp[<span class="hljs-number">0</span>][j - <span class="hljs-number">1</span>]); <span class="hljs-comment">// 不能当天买入当天卖出所以是dp[0][j - 1]</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">1</span>][len - <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 5.打印dp数组</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230330105858903.png" alt="image-20230330105858903" style="zoom:50%;" /></p><h3 id="买卖股票的最佳时机-ii"><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-comment">// 1.dp[0][j]:在第j天持有(之前买入，当前买入)股票时拥有的最大现金;dp[1][j]在第j天不持有(之前卖出，当前卖出)股票拥有的最大现金</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> prices.length;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>][len];<br>        <span class="hljs-comment">// 2.状态转移方程：dp[0][j] = max(dp[0][j - 1], dp[1][j - 1] - price[j]); dp[1][j] = max(dp[1][j - 1], dp[0][j - 1] + price[j])</span><br>        <span class="hljs-comment">// 3.初始化：dp[0][0] = -price[0];dp[1][0] = 0;可以当天出售</span><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">// 4.遍历顺序</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; len; ++j) &#123;<br>            dp[<span class="hljs-number">0</span>][j] = Math.max(dp[<span class="hljs-number">0</span>][j - <span class="hljs-number">1</span>], dp[<span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] - prices[j]);<br>            dp[<span class="hljs-number">1</span>][j] = Math.max(dp[<span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>], dp[<span class="hljs-number">0</span>][j - <span class="hljs-number">1</span>] + prices[j]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">1</span>][len - <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 5.打印dp数组</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230330112546180.png" alt="image-20230330112546180" style="zoom:50%;" /></p><h3 id="不同的二叉搜索树"><a href="https://leetcode.cn/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= i; ++j) &#123;<br>                dp[i] += dp[j - <span class="hljs-number">1</span>] * dp[i - j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230418104137551.png" alt="image-20230418104137551" style="zoom:50%;" /></p><h4 id="优化空间..">优化空间..</h4><h3 id="买卖股票的最佳时机-iii"><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">123. 买卖股票的最佳时机 III</a></h3><h3 id="二叉树中的最长交错路径"><a href="https://leetcode.cn/problems/longest-zigzag-path-in-a-binary-tree/">1372. 二叉树中的最长交错路径</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>        <span class="hljs-comment">// f(cur)：以cur结尾，且cur是左子树的最大长度</span><br>        <span class="hljs-comment">// g(cur)：以cur结尾，且cur是右子树的最大长度</span><br>        Map&lt;TreeNode, Integer&gt; f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Map&lt;TreeNode, Integer&gt; g = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Queue&lt;TreeNode[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestZigZag</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-comment">// f.put(root, 0);</span><br>        <span class="hljs-comment">// g.put(root, 0);</span><br>        queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>[]&#123;root, <span class="hljs-literal">null</span>&#125;);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            TreeNode[] sonFather = queue.poll();<br>            f.put(sonFather[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>);<br>            g.put(sonFather[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">if</span>(sonFather[<span class="hljs-number">1</span>] != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (sonFather[<span class="hljs-number">1</span>].left == sonFather[<span class="hljs-number">0</span>])<br>                    f.put(sonFather[<span class="hljs-number">0</span>], g.get(sonFather[<span class="hljs-number">1</span>]) + <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span> (sonFather[<span class="hljs-number">1</span>].right == sonFather[<span class="hljs-number">0</span>])<br>                    g.put(sonFather[<span class="hljs-number">0</span>], f.get(sonFather[<span class="hljs-number">1</span>]) + <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (sonFather[<span class="hljs-number">0</span>].left != <span class="hljs-literal">null</span>) <br>                queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>[]&#123;sonFather[<span class="hljs-number">0</span>].left, sonFather[<span class="hljs-number">0</span>]&#125;);<br>            <span class="hljs-keyword">if</span> (sonFather[<span class="hljs-number">0</span>].right != <span class="hljs-literal">null</span>) <br>                queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>[]&#123;sonFather[<span class="hljs-number">0</span>].right, sonFather[<span class="hljs-number">0</span>]&#125;);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>        <span class="hljs-keyword">for</span> (TreeNode node : f.keySet()) &#123;<br>            max = Math.max(max, Math.max(f.get(node), g.get(node)));<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230418131120198.png" alt=" " style="zoom:50%;" /></p><h3 id="最长递增子序列"><a href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></h3><ol type="1"><li>dp[i]：以nums[i]结尾的最长递增子序列的长度</li><li>从前往后，在i的左开区间进行比较所有的j(j &lt; i)，如果nums[j]&lt;nums[i]，那么dp[i] = max(dp[i], dp[j] + 1)</li><li>初始化：令dp数组所有元素为1，最短序列是本身</li><li>遍历顺序：第二层从前往后，从后往前都可以，只要把i之前的元素全部遍历了就行</li><li>要注意的是，要输出的答案不是dp[dp.length-1]，而是dp数组中的最大值，比如序列为01234512，输出的是结果是dp[5]；所以可以用一个全局变量记录dp数组中的最大值</li><li>时间复杂度：<span class="math inline">\(O(n^2)\)</span></li><li>空间复杂度：<span class="math inline">\(O(n)\)</span></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Arrays.fill(dp, <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxLenOfSubsequence</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (nums[i] &gt; nums[j]) &#123;<br>                    dp[i] = Math.max(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>            maxLenOfSubsequence = Math.max(maxLenOfSubsequence, dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxLenOfSubsequence;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230418142354562.png" alt="image-20230418142354562" style="zoom:50%;" /></p><h3 id="最长连续递增序列"><a href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/">674. 最长连续递增序列</a></h3><h4 id="方法一dp-2">方法一：DP</h4><ol type="1"><li>dp[i]：以nums[i]结尾的最长连续递增子序列的长度</li><li>当当前数字nums[i]大于nums[i-1]，令dp[i] = dp[i - 1] + 1</li><li>初始化：令dp数组所有元素为1，最短序列是本身</li><li>时间复杂度：<span class="math inline">\(O(n)\)</span></li><li>空间复杂度：<span class="math inline">\(O(n)\)</span></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findLengthOfLCIS</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Arrays.fill(dp, <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxLength</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; nums[i - <span class="hljs-number">1</span>]) &#123;<br>                dp[i] = dp[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            &#125;<br>            maxLength = Math.max(maxLength, dp[i]);<br>        &#125;<br>        <span class="hljs-comment">// for (int i = 0; i &lt; dp.length; ++i) &#123;</span><br>        <span class="hljs-comment">//     System.out.print(dp[i] + &quot; &quot;);</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-keyword">return</span> maxLength;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230418144730307.png" alt="image-20230418144730307" style="zoom:50%;" /></p><h4 id="方法二dp-滑动数组">方法二：DP + 滑动数组</h4><p><strong>注意：当nums[i] &lt;= nums[i - 1]时，需要把dp[i%2]重置为1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findLengthOfLCIS</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>        Arrays.fill(dp, <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxLength</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; nums[i - <span class="hljs-number">1</span>]) &#123;<br>                dp[i % <span class="hljs-number">2</span>] = dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>] + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                dp[i % <span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;<br>            &#125;<br>            maxLength = Math.max(maxLength, dp[i % <span class="hljs-number">2</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxLength;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230430213308440.png" alt="image-20230430213308440" style="zoom:50%;" /></p><h3 id="最长重复子数组warning"><a href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/">718. 最长重复子数组</a>:warning:</h3><h4 id="方法一暴力">方法一：暴力</h4><ol type="1"><li>时间复杂度：<span class="math inline">\(O(m^2n)\)</span></li><li>空间复杂度：<span class="math inline">\(O(1)\)</span></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findLength</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums1.length; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; nums2.length; ++j) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">count1</span> <span class="hljs-operator">=</span> i, count2 = j;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">while</span> (count1 &lt; nums1.length &amp;&amp; count2 &lt; nums2.length &amp;&amp; nums1[count1] == nums2[count2]) &#123;<br>                    ++counter;<br>                    ++count1;<br>                    ++count2;<br>                &#125;<br>                res = Math.max(res, counter);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230418155756679.png" alt="image-20230418155756679" style="zoom:50%;" /></p><h4 id="方法二dp">方法二：DP</h4><ol type="1"><li>dp[i][j]:以nums1[i - 1]结尾与以nums2[j - 1]结尾时的最长重复子数组</li><li>状态转移公式：当nums1[i - 1] == nums2[j - 1]时，dp[i][j] = dp[i - 1][j - 1] + 1<br /></li><li>初始化：m为nums1的长度，n为nums2的长度，初始化(m + 1) * (n + 1)的二维数组，第一行第一列初始化为0，因为任一数组为空，就不会有重复子数组</li><li>注意事项：输出结果是dp数组中的最大值，因为最长的重复子数组不一定是在两数组的结尾处，可以在循环内比较</li><li>时间复杂度：<span class="math inline">\(O(mn)\)</span></li><li>空间复杂度：<span class="math inline">\(O(mn)\)</span></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findLength</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> nums1.length, n = nums2.length;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (nums1[i - <span class="hljs-number">1</span>] == nums2[j - <span class="hljs-number">1</span>]) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                    result = Math.max(result, dp[i][j]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230418164535723.png" alt="image-20230418164535723" style="zoom:50%;" /></p><p>滚动数组缩减空间复杂度</p><ol type="1"><li><p>dp数组为第二个数组的长度加一</p></li><li><p>不相等时要把dp[j]赋0，不然之后会出错</p></li><li><p><strong>此时遍历第二个数组的时候，就要从后向前遍历，这样避免重复覆盖</strong>。</p><p>比如nums1 = [1, 2, 3, 1],nums2 = [1,6,8,1,3,1,2,3]</p><p>i = 1时候，dp数组为[1,0,0,1,0,1,0,0]</p><p>i = 2时候，dp数组为[0,0,0,0,0,0,1,0]</p><p>i = 3时候，dp数组为[0,0,0,0,1,0,0,2]</p><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230418180633319.png" alt="image-20230418180633319" style="zoom:50%;" /></p><p>i=3时，如果第二层for循环j从前往后遍历，那么dp倒数第二个位置会因为3!=2，被赋0，进而导致dp最后一个位置是1而不是2</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findLength</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums2.length + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= nums1.length; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> nums2.length; j &gt; <span class="hljs-number">0</span>; --j) &#123;<br>                <span class="hljs-keyword">if</span> (nums1[i - <span class="hljs-number">1</span>] == nums2[j - <span class="hljs-number">1</span>]) &#123;<br>                    dp[j] = dp[j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    dp[j] = <span class="hljs-number">0</span>;<br>                &#125;<br>                res = Math.max(res, dp[j]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230418175604367.png" alt="image-20230418175604367" style="zoom:50%;" /></p><h4 id="方法三滑动窗口">方法三：滑动窗口</h4><h3 id="不同路径"><a href="https://leetcode.cn/problems/unique-paths/">62. 不同路径</a></h3><h4 id="方法一dp-omn">方法一：DP O(mn)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// dp[i][j]:走到i,j位置的路径数</span><br>        <span class="hljs-comment">// 状态转移方程：dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>            dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; ++j) &#123;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125; <br>        <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230515153943754.png" alt="image-20230515153943754" style="zoom:50%;" /></p><h4 id="方法二dp滚动数组-on-2行">方法二：DP+滚动数组 O(n) 2行</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// dp[i][j]:走到i,j位置的路径数</span><br>        <span class="hljs-comment">// 状态转移方程：dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; ++i) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>            dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; ++j) &#123;<br>                dp[i % <span class="hljs-number">2</span>][j] = dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][j] + dp[i % <span class="hljs-number">2</span>][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125; <br>        <span class="hljs-keyword">return</span> dp[(m - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方法三dp滚动数组-on-1行">方法三：DP+滚动数组 O(n) 1行</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// dp[i][j]:走到i,j位置的路径数</span><br>        <span class="hljs-comment">// 状态转移方程：dp[j] = dp[j] + dp[j - 1]</span><br>        <span class="hljs-comment">// 初始化：全部初始化为1</span><br>        <span class="hljs-comment">// 遍历顺序：dp[j]依赖dp[j - 1]，所以从左往右遍历</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Arrays.fill(dp, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; ++j) &#123;<br>                dp[j] += dp[j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125; <br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230515161257738.png" alt="image-20230515161257738" style="zoom:50%;" /></p><h3 id="不同路径-ii"><a href="https://leetcode.cn/problems/unique-paths-ii/">63. 不同路径 II</a></h3><h4 id="方法一dp-3">方法一：DP</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePathsWithObstacles</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] obstacleGrid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> obstacleGrid.length, n = obstacleGrid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (obstacleGrid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j)  &#123;<br>            <span class="hljs-keyword">if</span> (obstacleGrid[<span class="hljs-number">0</span>][j] == <span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">break</span>;<br>            dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (obstacleGrid[i][j] == <span class="hljs-number">1</span>)<br>                    <span class="hljs-keyword">continue</span>;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230515163651187.png" alt="image-20230515163651187" style="zoom:50%;" /></p><h3 id="整数拆分warning"><a href="https://leetcode.cn/problems/integer-break/">343. 整数拆分</a>:warning:</h3><h4 id="方法一dp-4">方法一：DP</h4><figure><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230515170354808.png" alt="image-20230515170354808" /><figcaption aria-hidden="true">image-20230515170354808</figcaption></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">integerBreak</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// dp[j]:j拆分为多个数的最大乘积</span><br>    <br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; i; ++j) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i - j;<br>                dp[i] = Math.max(dp[i], Math.max(k * j, dp[k] * j));<br>            &#125;        <br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230515170235440.png" alt="image-20230515170235440" style="zoom:50%;" />　　</p><h3 id="不同的二叉搜索树warning"><a href="https://leetcode.cn/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a>:warning:</h3><h3 id="剑指-offer-ii-102.-加减的目标值"><a href="https://leetcode.cn/problems/YaVDxD/">剑指 Offer II 102. 加减的目标值</a></h3><h4 id="方法一dp-5">方法一：DP</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findTargetSumWays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> Arrays.stream(nums).sum();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">diff</span> <span class="hljs-operator">=</span> sum - target;<br>        <span class="hljs-keyword">if</span> (diff % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> || diff &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        target = diff / <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// dp[j]:装满容量为j的方法数</span><br>        <span class="hljs-comment">// dp[0] = 1,装满容量为0的背包有一种</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[target + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> target; j &gt;= nums[i]; --j) &#123;<br>                dp[j] += dp[j - nums[i]];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[target];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230516155420333.png" alt="image-20230516155420333" style="zoom:50%;" /></p><h3 id="树形dp">树形DP</h3><p><a href="https://www.bilibili.com/video/BV13g41157hK?p=15&amp;vd_source=d0a01265c4f3d5026b4e06c76cce4fe9">左神shi'p</a></p><h4 id="树形dp题目">树形DP题目</h4><p><a href="https://www.luogu.com.cn/problem/P1352#submit">没有上司的舞会</a></p><p><a href="https://leetcode.cn/problems/house-robber-iii/">337. 打家劫舍 III</a></p><p><a href="https://leetcode.cn/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a></p><p><a href="https://leetcode.cn/problems/longest-zigzag-path-in-a-binary-tree/">1372. 二叉树中的最长交错路径</a></p><h2 id="binary-tree">Binary Tree</h2><h3 id="二叉树的前序遍历"><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></h3><h4 id="方法一递归">方法一：递归</h4><p>假设树上一共有<em>n</em> 个节点。</p><p><strong>时间复杂度</strong>：遍历了整棵树，<span class="math inline">\(O(n)\)</span></p><p><strong>空间复杂度</strong>：和递归使用的栈大小相关，递归层数不超过n(一叉树)，<span class="math inline">\(O(n)\)</span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        dfs(root, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; result)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span>;<br>        result.add(root.val);<br>        dfs(root.left, result);<br>        dfs(root.right, result);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230417103559244.png" alt="image-20230417103559244" style="zoom:50%;" /></p><h4 id="方法二非递归">方法二：非递归</h4><p>假设树上一共有<em>n</em> 个节点。</p><p><strong>时间复杂度</strong>：遍历了整棵树，<span class="math inline">\(O(n)\)</span></p><p><strong>空间复杂度</strong>：和递归使用的栈大小相关，递归层数不超过n(一叉树)，<span class="math inline">\(O(n)\)</span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span> || !stack.isEmpty()) &#123;<br>            <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>                result.add(cur.val);<br>                stack.push(cur);<br>                cur = cur.left;<br>            &#125;<br>            cur = stack.pop();<br>            cur = cur.right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230417104835424.png" alt="image-20230417104835424" style="zoom:50%;" /></p><h4 id="方法三morris前序遍历">方法三：Morris前序遍历</h4><p>morris遍历利用树的大量空闲指针，实现空间开销的极限缩减。</p><p><strong>时间复杂度</strong>：<span class="math inline">\(O(n)\)</span>，其中n是二叉树的节点数。没有左子树的节点只被访问一次，有左子树的节点被访问两次</p><p><strong>空间复杂度</strong>：<span class="math inline">\(O(1)\)</span>，只操作已存在的指针（树的空闲指针），因此只需要常数的额外空间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root, mostRight = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            mostRight = cur.left;<br>            <span class="hljs-keyword">if</span> (mostRight != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">while</span> (mostRight.right != <span class="hljs-literal">null</span> &amp;&amp; mostRight.right != cur) <br>                    mostRight = mostRight.right;<br>                <span class="hljs-keyword">if</span> (mostRight.right == <span class="hljs-literal">null</span>) &#123;<br>                    result.add(cur.val);<br>                    mostRight.right = cur;<br>                    cur = cur.left;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// mostRight.right == cur</span><br>                    mostRight.right = <span class="hljs-literal">null</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// cur.left == null</span><br>                result.add(cur.val);<br>            &#125;<br>            cur = cur.right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230417105948516.png" alt="image-20230417105948516" style="zoom:50%;" /></p><h3 id="二叉树的中序遍历"><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h3><h4 id="方法一递归-1">方法一：递归</h4><p><strong>时间复杂度</strong>：<span class="math inline">\(O(n)\)</span>，其中n为树的节点数</p><p><strong>空间复杂度</strong>：<span class="math inline">\(O(n)\)</span>，和递归使用的栈大小相关，递归层数不超过n(一叉树)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        dfs(root, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; result)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">null</span>) &#123;<br>            dfs(root.left, result);<br>            result.add(root.val);<br>            dfs(root.right, result);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230417111200608.png" alt="image-20230417111200608" style="zoom:50%;" /></p><h4 id="方法二非递归-1">方法二：非递归</h4><p><strong>时间复杂度</strong>：<span class="math inline">\(O(n)\)</span>，其中n为树的节点数</p><p><strong>空间复杂度</strong>：<span class="math inline">\(O(n)\)</span>，和递归使用的栈大小相关，递归层数不超过n(一叉树)</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span> || !stack.isEmpty()) &#123;<br>            <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>                stack.push(cur);<br>                cur = cur.left;<br>            &#125;<br>            cur = stack.pop();<br>            res.add(cur.val);<br>            cur = cur.right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230417111602240.png" alt="image-20230417111602240" style="zoom:50%;" /></p><h4 id="方法三morris中序遍历">方法三：Morris中序遍历</h4><p>morris遍历利用树的大量空闲指针，实现空间开销的极限缩减。</p><p><strong>时间复杂度</strong>：<span class="math inline">\(O(n)\)</span>，其中n是二叉树的节点数。没有左子树的节点只被访问一次，有左子树的节点被访问两次</p><p><strong>空间复杂度</strong>：<span class="math inline">\(O(1)\)</span>，只操作已存在的指针（树的空闲指针），因此只需要常数的额外空间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root, mostRight = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            mostRight = cur.left;<br>            <span class="hljs-keyword">if</span> (mostRight != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">while</span> (mostRight.right != <span class="hljs-literal">null</span> &amp;&amp; mostRight.right != cur)<br>                    mostRight = mostRight.right;<br>                <span class="hljs-keyword">if</span> (mostRight.right == <span class="hljs-literal">null</span>) &#123;<br>                    mostRight.right = cur;<br>                    cur = cur.left;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// mostRight == cur</span><br>                    mostRight.right = <span class="hljs-literal">null</span>;<br>                &#125;<br>            &#125;<br>            res.add(cur.val);<br>            cur = cur.right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二叉树的后序遍历"><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></h3><h4 id="方法一递归-2">方法一：递归</h4><h4 id="方法二非递归-2">方法二：非递归</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">postorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root, pre = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span> || !stack.isEmpty()) &#123;<br>            <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>                stack.push(cur);<br>                cur = cur.left;<br>            &#125;<br>            cur = stack.peek();<br>            <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-literal">null</span> &amp;&amp; cur.right != pre) &#123;<br>                cur = cur.right;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                stack.pop();<br>                res.add(cur.val);<br>                pre = cur;<br>                cur = <span class="hljs-literal">null</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230417114718154.png" alt="image-20230417114718154" style="zoom:50%;" /></p><h4 id="方法三morris后序遍历">方法三：Morris后序遍历</h4><p><strong>时间复杂度</strong>：<span class="math inline">\(O(n)\)</span>，其中n为树的节点数</p><p><strong>空间复杂度</strong>：<span class="math inline">\(O(n)\)</span>，和递归使用的栈大小相关，递归层数不超过n(一叉树)</p><ol type="1"><li>如果可以到达一个节点两次(有左子树)，第二次逆序打印左子树上的右边界</li><li>最后走出循环后，逆序打印根节点的右边界</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">postorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root, mostRight = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            mostRight = cur.left;<br>            <span class="hljs-keyword">if</span> (mostRight != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">while</span> (mostRight.right != <span class="hljs-literal">null</span> &amp;&amp; mostRight.right != cur)<br>                    mostRight = mostRight.right;<br>                <span class="hljs-keyword">if</span> (mostRight.right == <span class="hljs-literal">null</span>) &#123;<br>                    mostRight.right = cur;<br>                    cur = cur.left;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// mostRight.right = cur</span><br>                    mostRight.right = <span class="hljs-literal">null</span>;<br>                    visit(cur.left, res);<br>                &#125;<br>            &#125;<br>            cur = cur.right;<br>        &#125;<br>        visit(root, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(TreeNode cur, List&lt;Integer&gt; res)</span> &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">tail</span> <span class="hljs-operator">=</span> reverse(cur);<br>        cur = tail;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            res.add(cur.val);<br>            cur = cur.right;<br>        &#125;<br>        reverse(tail);<br>    &#125;<br>    <span class="hljs-keyword">private</span> TreeNode <span class="hljs-title function_">reverse</span><span class="hljs-params">(TreeNode cur)</span> &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> cur.right;<br>            cur.right = pre;<br>            pre = cur;<br>            cur = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230417121837135.png" alt="image-20230417121837135" style="zoom:50%;" /></p><h3 id="二叉树的层序遍历"><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h3><p>借助队列实现，<strong>关键在于通过queue.size来判断下一层的节点数！</strong></p><p><em>Queue.offer(null)的话，size为1！</em></p><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230320152504462.png" alt="image-20230320152504462" style="zoom:50%;" /></p><h3 id="翻转二叉树"><a href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树</a></h3><p>这道题目背后有一个让程序员心酸的故事，听说 Homebrew的作者Max Howell，就是因为没在白板上写出翻转二叉树，最后被Google拒绝了。（真假不做判断，权当一个乐子哈）</p><p>要求：左右子树交换位置</p><h4 id="方法一bfs层级遍历">方法一：<strong>bfs层级遍历</strong></h4><p><strong>时间复杂度</strong>：所有节点都需要入队，出队一次，所以是<span class="math inline">\(O(n)\)</span></p><p><strong>空间复杂度</strong>：在最坏的情况下，给定的树是满二叉树，所有叶节点(<span class="math inline">\(n/2 + 1\)</span>)都要入队，所以是<span class="math inline">\(O(n)\)</span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">invertTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> root;<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.offer(root);<br>        TreeNode cur;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            cur = queue.poll();<br>            reverse(cur);   <br>            <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-literal">null</span>)<br>                queue.offer(cur.left);<br>            <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-literal">null</span>)<br>                queue.offer(cur.right); <br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(TreeNode cur)</span> &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> cur.left;<br>        cur.left = cur.right;<br>        cur.right = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230320161332491.png" alt="image-20230320161332491" style="zoom:50%;" /></p><h4 id="方法二dfs">方法二：dfs</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">invertTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-comment">// 反转所有左子树和右子树，对这棵树的所有节点</span><br>        dfs(root);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125; <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span>;<br>        dfs(root.left);<br>        dfs(root.right);<br>        reverse(root);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> root.left;<br>        root.left = root.right;<br>        root.right = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230419090018170.png" alt="image-20230419090018170" style="zoom:50%;" /></p><h3 id="对称二叉树"><a href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树</a></h3><h4 id="方法一拷贝翻转判断高情商刷一道解三道低情商只会笨方法还是看看远方的复杂度吧">方法一：拷贝+翻转+判断(高情商：刷一道，解三道！低情商：只会笨方法？还是看看远方的复杂度吧)</h4><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230321093745686.png" alt="image-20230321093745686" style="zoom:50%;" /> 写了80行，一题三解！不分析复杂度了。。</p><h4 id="方法二bfs">方法二：BFS</h4><p>假设树上一共有<em>n</em> 个节点。</p><p><strong>时间复杂度</strong>：遍历了整棵树，<span class="math inline">\(O(n)\)</span></p><p><strong>空间复杂度</strong>：和使用的队列大小相关，在最坏的情况下，给定的树是满二叉树，所有叶节点(<span class="math inline">\(n/2 + 1\)</span>)都要入队，所以是<span class="math inline">\(O(n)\)</span></p><p><strong>注意：</strong>如果p,q都为空，continue！而不是return truel！！！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.offer(root.left);<br>        queue.offer(root.right);<br>        TreeNode p, q;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            p = queue.poll();<br>            q = queue.poll();<br>            <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span> &amp;&amp; q == <span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span> || q == <span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span> (p.val != q.val) <br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            queue.offer(p.left);<br>            queue.offer(q.right);<br>            queue.offer(p.right);<br>            queue.offer(q.left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230419101818857.png" alt="image-20230419101818857" style="zoom:50%;" /></p><h4 id="方法三dfs">方法三：DFS</h4><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230321100900158.png" alt="image-20230321100900158" style="zoom:50%;" /> YYDS</p><p>假设树上一共有<em>n</em> 个节点。</p><p><strong>时间复杂度</strong>：遍历了整棵树，<span class="math inline">\(O(n)\)</span></p><p><strong>空间复杂度</strong>：和递归使用的栈大小相关，递归层数不超过n(一叉树)，<span class="math inline">\(O(n)\)</span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">return</span> dfs(root.left, root.right);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode left, TreeNode right)</span> &#123;<br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">null</span> &amp;&amp; right == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">null</span> || right == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> (left.val == right.val) &amp;&amp; dfs(left.left, right.right) &amp;&amp; dfs(left.right, right.left);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="相同的树"><a href="https://leetcode.cn/problems/same-tree/">100. 相同的树</a></h3><p><strong>对称二叉树</strong>方法一中用到了这个笨方法，顺手做了吧。</p><h4 id="方法一dfs">方法一：DFS</h4><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230321102148975.png" alt="image-20230321102148975" style="zoom:50%;" /></p><p>假设树上一共有<span class="math inline">\(n\)</span>个节点</p><p><strong>时间复杂度</strong>：遍历了整棵树，<span class="math inline">\(O(n)\)</span></p><p><strong>空间复杂度</strong>：和递归使用的栈大小相关，递归层数不超过n，<span class="math inline">\(O(n)\)</span></p><h4 id="方法二bfs-1">方法二：BFS</h4><p>只是和<strong>对称二叉树</strong>BFS解法中的入队顺序改变一点。</p><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230321103126806.png" alt="image-20230321103126806" style="zoom:50%;" /></p><p>假设树上一共有<em>n</em> 个节点。</p><p><strong>时间复杂度</strong>：遍历了整棵树，<span class="math inline">\(O(n)\)</span></p><p><strong>空间复杂度</strong>：和使用的队列大小相关，在最坏的情况下，给定的树是满二叉树，所有叶节点(<span class="math inline">\(n/2 + 1\)</span>)都要入队，所以是<span class="math inline">\(O(n)\)</span></p><h3 id="二叉树的最大深度"><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h3><h4 id="方法一bfs">方法一：BFS</h4><ol type="1"><li><strong>时间复杂度</strong>：遍历整棵树，<span class="math inline">\(O(n)\)</span></li><li><strong>空间复杂度</strong>：和使用的队列大小相关，在最坏情况下，给定的二叉树是满二叉树，<span class="math inline">\(n/2 + 1\)</span>个叶节点要入队，所以是<span class="math inline">\(O(n)\)</span></li></ol><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230321110400024.png" alt="image-20230321110400024" style="zoom:50%;" /></p><h4 id="方法二dfs-1">方法二：DFS</h4><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230321111653023.png" alt="image-20230321111653023" style="zoom:50%;" /></p><p>假设树上一共有<span class="math inline">\(n\)</span>个节点</p><p><strong>时间复杂度</strong>：遍历了整棵树，<span class="math inline">\(O(n)\)</span></p><p><strong>空间复杂度</strong>：和递归使用的栈大小相关，递归层数不超过n，<span class="math inline">\(O(n)\)</span></p><h3 id="n-叉树的最大深度"><a href="https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/">559. N 叉树的最大深度</a></h3><p>同上题<strong>二叉树的最大深度</strong>，只是在遍历子节点的时候不同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; cur.children.size(); i++) &#123;<br>    <span class="hljs-keyword">if</span> (cur.children.get(i) != <span class="hljs-literal">null</span>)<br>        queue.offer(cur.children.get(i));<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230321142849628.png" alt="image-20230321142849628" style="zoom:50%;" /></p><h3 id="二叉树的最小深度"><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></h3><p><strong>最小深度是从根节点到最近叶子节点的最短路径上的节点数量</strong></p><h4 id="方法一dfs-1">方法一：DFS</h4><ol type="1"><li>首先递归左子树和右子树</li><li>如果左子树为空，那么返回右子树的高度 + 1；如果右子树为空， 那么返回左子树的高度 + 1</li><li>如果左右子树都不为空，那么返回他们最小高度 + 1</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftDepth</span> <span class="hljs-operator">=</span> minDepth(root.left);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rightDepth</span> <span class="hljs-operator">=</span> minDepth(root.right);<br>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> rightDepth + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (root.right == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> leftDepth + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> Math.min(leftDepth, rightDepth) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230321144735136.png" alt="image-20230321144735136" style="zoom:50%;" /></p><h4 id="方法二bfs-2">方法二：BFS</h4><ol type="1"><li><strong>通过队列的size知道这是第几层，上一层加入队列节点的个数就是队列的size，在得到size的同时，将记录最小深度的变量minDepth加一</strong></li><li><strong>遍历到第一个叶子节点的当前层数就是二叉树的最小深度</strong></li><li><strong>时间复杂度</strong>：遍历整棵树，<span class="math inline">\(O(n)\)</span></li><li><strong>空间复杂度</strong>：和使用的队列大小相关，在最坏情况下，给定的二叉树是满二叉树，<span class="math inline">\(n/2 + 1\)</span>个叶节点要入队，所以是<span class="math inline">\(O(n)\)</span></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.offer(root);<br>        TreeNode cur;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">minDepth</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>            ++minDepth;<br>            <span class="hljs-keyword">while</span> (size-- &gt; <span class="hljs-number">0</span>) &#123;<br>                cur = queue.poll();<br>                <span class="hljs-keyword">if</span> (cur.left == <span class="hljs-literal">null</span> &amp;&amp; cur.right == <span class="hljs-literal">null</span>)<br>                    <span class="hljs-keyword">return</span> minDepth;<br>                <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-literal">null</span>) <br>                    queue.offer(cur.left);<br>                <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-literal">null</span>)<br>                    queue.offer(cur.right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> minDepth;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230321150754544.png" alt="image-20230321150754544" style="zoom:50%;" /></p><h3 id="完全二叉树的节点个数"><a href="https://leetcode.cn/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数</a></h3><h4 id="方法一bfs-1">方法一：BFS</h4><p><strong>在每层开始遍历时，记录节点个数的变量加上队列里元素个数</strong></p><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230321155140257.png" alt="image-20230321155140257" style="zoom:50%;" /></p><h4 id="方法二dfs-2">方法二：DFS</h4><ol type="1"><li>边界：如果是空节点，返回0</li><li>递归左子树和右子树+1(当前节点)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countNodes</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">return</span> dfs(root);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + dfs(root.left) + dfs(root.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230420180940972.png" alt="image-20230420180940972" style="zoom:50%;" /></p><h3 id="平衡二叉树"><a href="https://leetcode.cn/problems/balanced-binary-tree/">110. 平衡二叉树</a></h3><h4 id="方法一先序dfs">方法一：先序DFS</h4><ol type="1"><li>终止条件：如果root为空，返回true</li><li>首先求当前节点左右子树高度是否&lt;=1，再判断递归左子树和右子树</li><li>时间复杂度：<span class="math inline">\(O(n^2)\)</span></li><li>空间复杂度：<span class="math inline">\(O(n)\)</span></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBalanced</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> Math.abs(height(root.left) - height(root.right)) &lt;= <span class="hljs-number">1</span> &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">height</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> Math.max(height(root.left), height(root.right)) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方法二后序dfswarning">方法二：后序DFS:warning:</h4><ol type="1"><li>只需遍历所有节点一次</li><li>时间复杂度<span class="math inline">\(O(n)\)</span></li><li>空间复杂度<span class="math inline">\((n)\)</span></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBalanced</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">return</span> height(root) &gt;= <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">height</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftHeight</span> <span class="hljs-operator">=</span> height(root.left);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rightHeight</span> <span class="hljs-operator">=</span> height(root.right);<br>        <span class="hljs-keyword">if</span> (leftHeight == -<span class="hljs-number">1</span> || rightHeight == -<span class="hljs-number">1</span> || Math.abs(leftHeight - rightHeight) &gt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> Math.max(leftHeight, rightHeight) + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二叉树的所有路径warning"><a href="https://leetcode.cn/problems/binary-tree-paths/">257. 二叉树的所有路径</a>:warning:</h3><h4 id="方法一bfs-2">方法一：BFS</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">binaryTreePaths</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;String&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        Queue&lt;Object&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.offer(root);<br>        queue.offer(String.valueOf(root.val));<br>        TreeNode cur;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            cur = (TreeNode)queue.poll();<br>            path = (String)queue.poll();<br>            <span class="hljs-keyword">if</span> (cur.left == <span class="hljs-literal">null</span> &amp;&amp; cur.right == <span class="hljs-literal">null</span>) &#123;<br>                result.add(path);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-literal">null</span>) &#123;<br>                queue.offer(cur.left);<br>                queue.offer(path + <span class="hljs-string">&quot;-&gt;&quot;</span> + String.valueOf(cur.left.val));<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-literal">null</span>) &#123;<br>                queue.offer(cur.right);<br>                queue.offer(path + <span class="hljs-string">&quot;-&gt;&quot;</span> + String.valueOf(cur.right.val));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230422150351347.png" alt="image-20230422150351347" style="zoom:50%;" /></p><h4 id="方法二dfs-3">方法二：DFS</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;String&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">binaryTreePaths</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        dfs(root, <span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, String path)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span>;<br>        path += String.valueOf(root.val);<br>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>) &#123;<br>            result.add(path);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            path += <span class="hljs-string">&quot;-&gt;&quot;</span>;<br>            dfs(root.left, path);<br>            dfs(root.right, path);<br>        &#125;<br>    &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230422180747250.png" alt="image-20230422180747250" style="zoom:50%;" /></p><h3 id="左叶子之和"><a href="https://leetcode.cn/problems/sum-of-left-leaves/">404. 左叶子之和</a></h3><h4 id="warning方法一dfs">:warning:方法一：DFS</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumOfLeftLeaves</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> dfs(root);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (root.left != <span class="hljs-literal">null</span>) &#123;<br>            sum += isLeaf(root.left) ? root.left.val : dfs(root.left);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root.right != <span class="hljs-literal">null</span>) &#123;<br>            sum += dfs(root.right);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isLeaf</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">return</span> root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230422182643053.png" alt="image-20230422182643053" style="zoom:50%;" /></p><h3 id="找树左下角的值"><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/">513. 找树左下角的值</a></h3><h4 id="warning方法一dfs-1">:warning:方法一：DFS</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">curHeight</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">curValue</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findBottomLeftValue</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        dfs(root, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> curValue;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> height)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span>;<br>        ++height;<br>        dfs(root.left, height);<br>        dfs(root.right, height);<br>        <span class="hljs-keyword">if</span> (height &gt; curHeight) &#123;<br>            curHeight = height;<br>            curValue = root.val;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230422184658045.png" alt="image-20230422184658045" style="zoom:50%;" /></p><h4 id="方法二bfs-3">方法二：BFS</h4><p><strong>从右往左层次遍历，最后一个访问的节点就是树左下角的值！</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findBottomLeftValue</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        TreeNode cur;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.offer(root);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            cur = queue.poll();<br>            <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-literal">null</span>) &#123;<br>                queue.offer(cur.right);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-literal">null</span>) &#123;<br>                queue.offer(cur.left);<br>            &#125;<br>            res = cur.val;<br>        &#125;   <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230422183521606.png" alt="image-20230422183521606" style="zoom:50%;" /></p><h3 id="路径总和"><a href="https://leetcode.cn/problems/path-sum/">112. 路径总和</a></h3><h4 id="方法一bfs-3">方法一：BFS</h4><ol type="1"><li>初始化一个Object类型队列，用于存放节点与节点的值，首先把根节点和根节点的值offer进队列</li><li>开始while循环，循环的执行条件是队列不为空<ol type="1"><li>首先按顺序取出节点和节点的值，注意这里需要强转</li><li>判断当前节点是否为根节点且节点的值是否为目标值，如果满足，直接return true</li><li>如果左子树不为空，先将左子树节点offer进队列，再将左子树的值加上poll出的当前节点的值offer进队列</li><li>如果右子树不为空，先将右子树节点offer进队列，再将右子树的值加上poll出的当前节点的值offer进队列</li></ol></li><li>如果有这么一条路径，那么在while循环中就会return true，不会执行到这；如果没有满足条件的路径，则返回false</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasPathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        Queue&lt;Object&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.offer(root);<br>        queue.offer(root.val);<br>        TreeNode cur;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            cur = (TreeNode)queue.poll();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)queue.poll();<br>            <span class="hljs-keyword">if</span> (cur.left == <span class="hljs-literal">null</span> &amp;&amp; cur.right == <span class="hljs-literal">null</span> &amp;&amp; val == targetSum) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-literal">null</span>) &#123;<br>                queue.offer(cur.left);<br>                queue.offer(val + cur.left.val);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-literal">null</span>) &#123;<br>                queue.offer(cur.right);<br>                queue.offer(val + cur.right.val);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="C:\Users\ning\AppData\Roaming\Typora\typora-user-images\image-20230422190735533.png" alt="image-20230422190735533" style="zoom:50%;" /></p><p>|:warning::warning:方法二：DFS</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasPathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>) <br>            <span class="hljs-keyword">return</span> targetSum == root.val;<br>        <span class="hljs-keyword">return</span> hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230422192822798.png" alt="image-20230422192822798" style="zoom:50%;" /></p><h3 id="路径总和-ii"><a href="https://leetcode.cn/problems/path-sum-ii/">113. 路径总和 II</a></h3><h4 id="方法一bfs-4">方法一：BFS</h4><ol type="1"><li>使用队列存放当前节点和累加节点值</li><li>使用HashMap记录每个节点的父节点</li><li>当节点满足是叶节点且累加值等于targetSum时，通过HashMap，从该叶子节点遍历到根节点记录到list中，最后把list反转</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <br>            <span class="hljs-keyword">return</span> res;<br>        Queue&lt;Object&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.offer(root);<br>        queue.offer(root.val);<br>        TreeNode cur;<br>        Map&lt;TreeNode, TreeNode&gt; sonFather = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            cur = (TreeNode)queue.poll();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> (Integer)queue.poll();<br>            <span class="hljs-keyword">if</span> (cur.left == <span class="hljs-literal">null</span> &amp;&amp; cur.right == <span class="hljs-literal">null</span> &amp;&amp; val == targetSum) &#123;<br>                res.add(getPath(cur, sonFather));<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-literal">null</span>) &#123;<br>                queue.offer(cur.left);<br>                queue.offer(val + cur.left.val);<br>                sonFather.put(cur.left, cur);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(cur.right != <span class="hljs-literal">null</span>) &#123;<br>                queue.offer(cur.right);<br>                queue.offer(val + cur.right.val);<br>                sonFather.put(cur.right, cur);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> List&lt;Integer&gt; <span class="hljs-title function_">getPath</span><span class="hljs-params">(TreeNode node, Map&lt;TreeNode, TreeNode&gt; sonFather)</span> &#123;<br>        List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        path.add(node.val);<br>        <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">null</span>) &#123;<br>            node = sonFather.get(node);<br>            path.add(node.val);<br>        &#125;<br>        Collections.reverse(path);<br>        <span class="hljs-keyword">return</span> path;<br>    &#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230422200402264.png" alt="image-20230422200402264" style="zoom:50%;" /></p><h4 id="warning方法二dfs">:warning:方法二：DFS</h4><ol type="1"><li>使用双端队列，每次dfs将当前节点值放入双端队列队尾，并让targetSum减去当前节点元素</li><li>如果当前节点是叶子节点且targetSum等于0，那么说明这条路径满足条件，将path加入结果</li><li><strong>每次dfs完左右，再将双端队列最后一个元素移除！！！</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>        dfs(root, targetSum);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <br>            <span class="hljs-keyword">return</span>;<br>        path.offerLast(root.val);<br>        targetSum -= root.val;<br>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span> &amp;&amp; targetSum == <span class="hljs-number">0</span>) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(path));<br>        &#125;<br>        dfs(root.left, targetSum);<br>        dfs(root.right, targetSum);<br>        path.pollLast();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230423090544509.png" alt="image-20230423090544509" style="zoom:50%;" /></p><h4 id="star方法三回溯其实方法二也是回溯">:star:方法三：回溯(其实方法二也是回溯)</h4><ol type="1"><li>递归终止条件是：节点为空</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> res;<br>        dfs(root, targetSum);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span>;<br>        path.add(root.val);<br>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span> &amp;&amp; targetSum == root.val) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>(path));<br>        &#125;<br>        dfs(root.left, targetSum - root.val);<br>        dfs(root.right, targetSum - root.val);<br>        path.removeLast();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230425181031967.png" alt="image-20230425181031967" style="zoom:50%;" /></p><h3 id="star106.-从中序与后序遍历序列构造二叉树">:star:<a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a></h3><ol type="1"><li>草稿构造一棵二叉树，写出中序和后序序列</li><li>确定好边界条件：左闭右闭</li><li>后序序列最后一个元素是根，通过HashMap找到根节点下标</li><li>根节点左边的长度为lenOfLeft，那么先序序列和后序序列的前lenOfLeft为根节点的左子树</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] inorder, <span class="hljs-type">int</span>[] postorder)</span> &#123;<br>        <span class="hljs-keyword">if</span> (postorder == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; inorder.length; ++i) &#123;<br>            map.put(inorder[i], i);<br>        &#125;<br>        <span class="hljs-comment">// [start, end - 1]左闭右闭</span><br>        <span class="hljs-keyword">return</span> dfs(inorder, <span class="hljs-number">0</span>, inorder.length - <span class="hljs-number">1</span>, postorder, <span class="hljs-number">0</span>, postorder.length - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">private</span> TreeNode <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] inorder, <span class="hljs-type">int</span> inStart, <span class="hljs-type">int</span> inEnd, <span class="hljs-type">int</span>[] postorder, <span class="hljs-type">int</span> postStart, <span class="hljs-type">int</span> postEnd)</span> &#123;<br>        <span class="hljs-keyword">if</span> (inStart &gt; inEnd || postStart &gt; postEnd) <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// 找到postorder最后一个元素的下标，也就是根节点</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">rootValue</span> <span class="hljs-operator">=</span> postorder[postEnd];<br>        <span class="hljs-comment">// 找到inorder中根节点的位置</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">rootIdx</span> <span class="hljs-operator">=</span> map.get(rootValue);<br>        <span class="hljs-comment">// 构造树节点</span><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(rootValue);<br>        <span class="hljs-comment">// 根据inorder切割左子树的大小，那么剩下的就是右子树</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">lenOfLeft</span> <span class="hljs-operator">=</span> rootIdx - inStart;<br>        <span class="hljs-comment">// 按照根节点切割成左子树和右子树</span><br>        root.left = dfs(inorder, inStart, rootIdx - <span class="hljs-number">1</span>, postorder, postStart, postStart + lenOfLeft - <span class="hljs-number">1</span>);<br>        root.right = dfs(inorder, rootIdx + <span class="hljs-number">1</span>, inEnd, postorder, postStart + lenOfLeft, postEnd - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230423101045441.png" alt="image-20230423101045441" style="zoom:50%;" /></p><h3 id="从前序与中序遍历序列构造二叉树"><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h3><p><strong>注意：int lenOfLeft = rootIdx - inStart; ！！！！！！！！</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] inorder)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> inorder.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; ++i)<br>            map.put(inorder[i], i);<br>        <span class="hljs-comment">// [)左闭右开</span><br>        <span class="hljs-keyword">return</span> dfs(inorder, <span class="hljs-number">0</span>, length, preorder, <span class="hljs-number">0</span>, length);<br>    &#125;<br>    <span class="hljs-keyword">private</span> TreeNode <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] inorder, <span class="hljs-type">int</span> inStart, <span class="hljs-type">int</span> inEnd, <span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span> preStart, <span class="hljs-type">int</span> preEnd)</span> &#123;<br>        <span class="hljs-keyword">if</span> (inStart &gt;= inEnd || preStart &gt;= preEnd)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// 找到根节点</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">rootVal</span> <span class="hljs-operator">=</span> preorder[preStart];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rootIdx</span> <span class="hljs-operator">=</span> map.get(rootVal);<br>        <span class="hljs-comment">// 中序遍历中根节点左边的长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">lenOfLeft</span> <span class="hljs-operator">=</span> rootIdx - inStart;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(rootVal);<br>        root.left = dfs(inorder, inStart, rootIdx, preorder, preStart + <span class="hljs-number">1</span>, preStart + <span class="hljs-number">1</span> + lenOfLeft);<br>        root.right = dfs(inorder, rootIdx + <span class="hljs-number">1</span>, inEnd, preorder, preStart + <span class="hljs-number">1</span> + lenOfLeft, preEnd);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230423105616607.png" alt="image-20230423105616607" style="zoom:50%;" /></p><h3 id="star654.-最大二叉树">:star:<a href="https://leetcode.cn/problems/maximum-binary-tree/">654. 最大二叉树</a></h3><h4 id="方法一dfs-2">方法一：DFS</h4><p>思路同<a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">constructMaximumBinaryTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, nums.length, nums);<br>    &#125;<br>    <span class="hljs-keyword">private</span> TreeNode <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (start &gt;= end)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> start;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxValue</span> <span class="hljs-operator">=</span> nums[start];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; end; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (maxValue &lt; nums[i]) &#123;<br>                maxValue = nums[i];<br>                index = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(maxValue);<br>        root.left = dfs(start, index, nums);<br>        root.right = dfs(index + <span class="hljs-number">1</span>, end, nums);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230423201644238.png" alt="image-20230423201644238" style="zoom:50%;" /></p><h3 id="合并二叉树"><a href="https://leetcode.cn/problems/merge-two-binary-trees/">617. 合并二叉树</a></h3><p><strong>解题思路</strong>：当树1当前节点的左子树或右子树为空，而树2当前节点左子树或右子树不为空时：使用parentQueue存储树1树2的当前节点parent1，parent2，在遍历到下一层时，使用parent1来指向parent2的左子树或者右子树。</p><p><strong>Debug</strong>：如果cur1左子树为空，cur2左子树不为空，将cur1,cur2加入trashQueue；同理右子树。<strong>如果cur1左右子树都为空，cur2左右子树都不为空，将cur1,cur2加入parentQueue两次！！不然之后poll的时候空指针！！</strong></p><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230322110219397.png" alt="image-20230322110219397" style="zoom:50%;" /></p><h4 id="warning方法二dfs-1">:warning:方法二：DFS</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">mergeTrees</span><span class="hljs-params">(TreeNode root1, TreeNode root2)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root1 == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> root2;<br>        <span class="hljs-keyword">if</span> (root2 == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> root1;<br>        root1.val += root2.val;<br>        root1.left = mergeTrees(root1.left, root2.left);<br>        root1.right = mergeTrees(root1.right, root2.right);<br>        <span class="hljs-keyword">return</span> root1;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230423202828168.png" alt="image-20230423202828168" style="zoom:50%;" /></p><h3 id="二叉搜索树中的搜索"><a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索</a></h3><h4 id="方法一dfs-3">方法一：DFS</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">searchBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (cur.val == val) &#123;<br>                <span class="hljs-keyword">return</span> cur;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur.val &lt; val) &#123;<br>                cur = cur.right;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                cur = cur.left;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230423203436314.png" alt="image-20230423203436314" style="zoom:50%;" /></p><h3 id="star98.-验证二叉搜索树">:star:<a href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h3><h4 id="方法一中序遍历">方法一：中序遍历</h4><p>中序遍历二叉搜索树应该是升序的，只需要一个记录上一个节点的值的遍历preVal，并与当前节点比较，如果当前节点的值<strong>小于等于</strong>preVal(cur.val应该严格&gt;preVal不能等于)，则返回false;否则，遍历完所有节点返回true。</p><p>假设树有n个节点</p><p><strong>时间复杂度</strong>：遍历所有节点，<span class="math inline">\(O(n)\)</span></p><p><strong>空间复杂度</strong>：和使用的栈相关，在最坏情况(每个节点都只有一个子节点)下，树的高度为n，都需要压栈，所以为<span class="math inline">\(O(n)\)</span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">preVal</span> <span class="hljs-operator">=</span> Long.MIN_VALUE;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root;<br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span> || !stack.isEmpty()) &#123;<br>            <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>                stack.push(cur);<br>                cur = cur.left;<br>            &#125;<br>            cur = stack.pop();<br>            <span class="hljs-keyword">if</span> (cur.val &lt;= preVal)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            preVal = cur.val;<br>            cur = cur.right; <br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="war方法二递归">:war:方法二：递归</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> dfs(TreeNode root, <span class="hljs-type">long</span>.MIN_VALUE, <span class="hljs-type">long</span>.MAX_VALUE)<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">long</span> pre, <span class="hljs-type">long</span> post)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (root.val &lt;= pre || root.val &gt;= post)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">return</span> dfs(root.left, pre, root.val) &amp;&amp; dfs(root.right, root.val, post);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方法三morris中序遍历-1">方法三：Morris中序遍历</h4><p>Morris遍历利用叶子节点的左右空指针，实现空间开销的极限缩减。</p><h5 id="morris遍历的实现原则">morris遍历的实现原则</h5><p><strong>记作当前节点为cur。</strong></p><ol type="1"><li><p>如果cur无左孩子，cur向右移动（cur=cur.right）</p></li><li><p>如果cur有左孩子，找到cur左子树上最右的节点，记为mostright</p></li><li><ol type="1"><li>如果mostright的right指针指向空，让其指向cur，cur向左移动（cur=cur.left）</li><li>如果mostright的right指针指向cur，让其指向空，cur向右移动（cur=cur.right）</li></ol></li></ol><p>实现以上的原则，即实现了morris遍历。</p><h5 id="morris遍历的实质">morris遍历的实质</h5><blockquote><p>建立一种机制，对<strong>于没有左子树的节点只到达一次，对于有左子树的节点会到达两次</strong></p></blockquote><h5 id="morris中序遍历">Morris中序遍历</h5><ol type="1"><li>如果可以到达一个节点两次(有左子树)，第二次访问</li><li>如果可以到达一个节点一次(无左子树)，直接访问</li></ol><h5 id="举个例子">举个例子</h5><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230417094750640.png" alt="image-20230417094750640" style="zoom:50%;" /></p><ol type="1"><li><p>从根节点5开始遍历，令cur = 根节点5，找到mostRight为节点1</p></li><li><p>节点1的右子树为空，将节点1的右子树指向节点5，并让cur移动到左子树(节点1)</p></li><li><p>开始遍历节点1，由于节点一无左子树，直接访问，比较节点一与preValue(初始化为最小值)，</p><p>1 &lt; Long.MIN_VALUE，将节点1的val赋值给preValue</p></li><li><p>将cur(1)移动到右子树，此时cur为之前访问过的根节点5，继续找到cur(5)左子树的最右节点1，发现节点1的右子树为当前节点cur(5)，将节点1的右子树还原为空</p></li><li><p>此时是第二次到达节点5，比较节点5与preValue(1)，并将5赋值给preValue，cur向右子树移动，此时cur到达节点4</p></li><li><p>找到cur(4)左子树的最右节点3，将节点3的右子树指向cur(4)，cur向左子树移动，此时cur到达节点3</p></li><li><p>由于节点3无左子树，直接比较节点3与preValue(5)的值，3&lt;5，返回false。</p></li></ol><p>可以发现中序遍历的顺序是：15346</p><p>Morris中序遍历到达的节点顺序是：5<strong>15</strong>4<strong>346</strong>，其中5和4有左子树，在到底5和4的第二次时作比较。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root, mostRight = <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">preValue</span> <span class="hljs-operator">=</span> Long.MIN_VALUE;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            mostRight = cur.left;<br>            <span class="hljs-keyword">if</span> (mostRight != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">while</span> (mostRight.right != <span class="hljs-literal">null</span> &amp;&amp; mostRight.right != cur) <br>                    mostRight = mostRight.right;<br>                <span class="hljs-keyword">if</span> (mostRight.right == <span class="hljs-literal">null</span>) &#123;<br>                    mostRight.right = cur;<br>                    cur = cur.left;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mostRight.right == cur) &#123;<br>                    mostRight.right = <span class="hljs-literal">null</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cur.val &lt;= preValue) <br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            preValue = cur.val;<br>            cur = cur.right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>时间复杂度</strong>：遍历所有节点，<span class="math inline">\(O(n)\)</span></p><p><strong>空间复杂度</strong>：Morris遍历利用叶子节点的左右空指针，实现空间开销的极限缩减，<span class="math inline">\(O(1)\)</span></p><h3 id="二叉搜索树的最小绝对差"><a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">530. 二叉搜索树的最小绝对差</a></h3><h4 id="方法一中序遍历-1">方法一：中序遍历</h4><p>使用中序遍历二叉搜索树得到的结果是升序的。</p><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230322155627326.png" alt="image-20230322155627326" style="zoom:50%;" /></p><h4 id="starwarning方法二双指针">:star::warning:方法二：双指针</h4><p><strong>双指针的思想真的很重要！！！</strong></p><ol type="1"><li>初始化全局变量：pre节点初始化为空；diff存储相邻节点差值，初始化为整型最大值</li><li>中序遍历过程：第一次遍历，pre是空的，还没遇到第二个节点也就没有相邻节点之间的差值；</li><li>把当前节点(root)赋给pre，那么下一个root就是中序遍历顺序pre的下一个节点</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    TreeNode pre;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">diff</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMinimumDifference</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        dfs(root);<br>        <span class="hljs-keyword">return</span> diff;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span>;<br>        dfs(root.left);<br>        <span class="hljs-keyword">if</span> (pre != <span class="hljs-literal">null</span>)<br>            diff = Math.min(diff, root.val - pre.val);<br>        pre = root; <br>        dfs(root.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230425185335018.png" alt="image-20230425185335018" style="zoom:50%;" /></p><h4 id="section"></h4><h3 id="二叉搜索树中的众数"><a href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/">501. 二叉搜索树中的众数</a></h3><p>老样子，中序遍历</p><p>遍历的过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (preVal == cur.val) &#123;<br>++counter;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>counter = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (!modes.contains(cur.val) &amp;&amp; counter == maxCounter) &#123;<br>modes.add(cur.val);<br>&#125;<br><br><span class="hljs-keyword">if</span> (counter &gt; maxCounter) &#123;<br>    maxCounter = counter;<br>    modes.removeAll(modes);<br>    modes.add(cur.val);<br>&#125;<br>preVal = cur.val;<br>cur = cur.right;<br></code></pre></td></tr></table></figure><h3 id="二叉树的最近公共祖先"><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h3><h4 id="方法一用hashmap存储所有父节点用hashset标记是否访问过从p开始向上遍历并标记访问过的父节点再从q开始向上遍历如果当前节点被访问过那么这个节点就是最近公共祖先">方法一：用HashMap存储所有父节点，用HashSet标记是否访问过；从p开始向上遍历，并标记访问过的父节点，再从q开始向上遍历，如果当前节点被访问过，那么这个节点就是最近公共祖先。</h4><p><strong>注意：对于p，先设置visisted，再向上移；对于q，先判断当前节点是不是已经被visited，再向上移。</strong>如果p,q任意一者先向上移再操作，都会导致在，p或q是最近公共节点时，返回的却是p或q的父节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>        Map&lt;TreeNode, TreeNode&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Set&lt;TreeNode&gt; visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        dfs(root, map);<br>        <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span>) &#123;<br>            visited.add(p);<br>            p = map.get(p);<br>        &#125;<br>        <span class="hljs-keyword">while</span> (q != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (visited.contains(q)) &#123;<br>                <span class="hljs-keyword">return</span> q;<br>            &#125;<br>            q = map.get(q);<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, Map&lt;TreeNode, TreeNode&gt; map)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (root.left != <span class="hljs-literal">null</span>) &#123;<br>            map.put(root.left, root);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root.right != <span class="hljs-literal">null</span>) &#123;<br>            map.put(root.right, root);<br>        &#125;<br>        dfs(root.left, map);<br>        dfs(root.right, map);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230427092729299.png" alt="image-20230427092729299" style="zoom:50%;" /></p><h4 id="warning方法二dfs-2">:warning:方法二：DFS</h4><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/solution/236-er-cha-shu-de-zui-jin-gong-gong-zu-xian-hou-xu/">题解</a></p><p>可以不判断非p,q的叶节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>        <span class="hljs-keyword">return</span> dfs(root, p, q);<br>    &#125;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span> || root == p || root == q)<br>            <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> dfs(root.left, p, q);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> dfs(root.right, p, q);<br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> right;<br>        <span class="hljs-keyword">if</span> (right == <span class="hljs-literal">null</span>) <br>            <span class="hljs-keyword">return</span> left;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二叉搜索树的最近公共祖先"><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先</a></h3><h4 id="递归考虑三种情况">递归：考虑三种情况</h4><ol type="1"><li>p,q是root：return root</li><li>p,q在root两侧，(p.val &lt; root.val &amp;&amp; q.val &gt; root.val) || (p.val &gt; root.val &amp;&amp; q.val &lt; root.val)， return root</li><li>p,q在root同一侧 (p.val &lt; root &amp;&amp; q.val &lt; root.val) || (p.val &gt; root.val &amp;&amp; q.val &gt; root.val)<ol type="1"><li>p.val &lt; root &amp;&amp; q.val &lt; root.val: return dfs(left, p, q)</li><li>p.val &gt; root.val &amp;&amp; q.val &gt; root.val: return dfs(right, p, q)</li></ol></li></ol><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230323103301262.png" alt="image-20230323103301262" style="zoom:50%;" /></p><h4 id="方法一dfs-4">方法一：DFS</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) <br>            <span class="hljs-keyword">return</span> lowestCommonAncestor(root.left, p, q);<br>        <span class="hljs-keyword">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val)<br>            <span class="hljs-keyword">return</span> lowestCommonAncestor(root.right, p, q);        <br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230427101509170.png" alt="image-20230427101509170" style="zoom:50%;" /></p><h3 id="二叉搜索树中的插入操作"><a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">701. 二叉搜索树中的插入操作</a></h3><p><strong>要点是：如何记录要插入节点的父节点</strong></p><h4 id="方法一栈">方法一：栈</h4><ol type="1"><li>从根节点开始遍历，用栈存储每个遍历过的节点，大于向右小于向左；循环结束，判断插入最后一个被遍历的节点(栈中最顶层节点)，判断大于小于，插入，结束。</li><li>遍历过程把所有元素放进栈，空节点跳出循环后，栈顶元素就是要插入节点的父节点</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">insertIntoBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(val);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root;<br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            stack.push(cur);<br>            <span class="hljs-keyword">if</span> (val &lt; cur.val) &#123;<br>                cur = cur.left;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                cur = cur.right;<br>            &#125;<br>        &#125;<br>        cur = stack.pop();<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(val);<br>        <span class="hljs-keyword">if</span> (cur.val &gt; val) &#123;<br>            cur.left =  newNode;<br>        &#125; <br>        <span class="hljs-keyword">else</span> &#123;<br>            cur.right = newNode;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方法二双指针">方法二：双指针</h4><p>用pre指针指向上一个节点，有两个要注意的地方</p><ol type="1"><li>初始化pre指针时，不能初始化为null，如果根节点没有左子树，而要插入的节点小于根节点，<strong>要插入的节点会成为根节点的左子树</strong>，这种情况判断一次就会跳出while循环，此时pre还是null，<strong>所以要把pre初始化为根节点</strong></li><li>在while循环中，用pre=cur记录cur的上一个节点，但是，最后cur等于空的时候，pre再记录cur就没有意义了，所以<strong>加上if (cur != null)判断条件</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">insertIntoBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(val);<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root, pre = root;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (cur.val &gt; val)<br>                cur = cur.left;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur.val &lt; val)<br>                cur= cur.right;<br>            <span class="hljs-keyword">if</span> (cur != <span class="hljs-literal">null</span>)<br>                pre = cur;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (val &gt; pre.val)<br>            pre.right = res;<br>        <span class="hljs-keyword">else</span>  <br>            pre.left = res;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方法三dfs-1">方法三：DFS</h4><p>当时想出来了，但是卡在怎么插入这个点上<strong>，其实这里已经用root.left或者root.right来接收 new TreeNode(val)了。</strong>==构造树==！！！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">insertIntoBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(val);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (val &lt; root.val) &#123;<br>            root.left = insertIntoBST(root.left, val);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            root.right = insertIntoBST(root.right, val);<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="x450.-删除二叉搜索树中的节点">x<a href="https://leetcode.cn/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点</a></h3><p><strong>解题思路</strong>：</p><ol type="1"><li><p>如果目标节点大于当前节点值，则去右子树中删除；</p></li><li><p>如果目标节点小于当前节点值，则去左子树中删除；</p></li><li><p>如果目标节点就是当前节点，分为以下三种情况：</p><ol type="1"><li>其无左子：其右子顶替其位置，删除了该节点；</li><li>其无右子：其左子顶替其位置，删除了该节点；</li><li>其左右子节点都有：其左子树转移到其右子树的最左节点的左子树上，然后右子树顶替其位置，由此删除了该节点。</li></ol></li></ol><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230323142204001.png" alt="image-20230323142204001" style="zoom:50%;" /></p><p>写了快100行，重构一下代码。。</p><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230323142217741.png" alt="image-20230323142217741" style="zoom:50%;" /></p><h4 id="方法一迭代">方法一：迭代</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">deleteNode</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root, pre = root;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (cur.val == key) &#123;<br>                <span class="hljs-keyword">if</span> (cur.left == <span class="hljs-literal">null</span> &amp;&amp; cur.right == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 叶子节点</span><br>                    <span class="hljs-keyword">if</span> (pre.val &lt; key) <br>                        pre.right = <span class="hljs-literal">null</span>;<br>                    <span class="hljs-keyword">else</span> <br>                        pre.left = <span class="hljs-literal">null</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (cur.left !=  <span class="hljs-literal">null</span> &amp;&amp; cur.right != <span class="hljs-literal">null</span>) &#123;<br>                     <span class="hljs-comment">// 找到要删除节点右子树上的最左节点，再把要删除节点左子树挂上去</span><br>                        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> cur.left, right = cur.right;<br>                        cur = cur.right;<br>                        <span class="hljs-keyword">while</span> (cur.left != <span class="hljs-literal">null</span>) <br>                            cur = cur.left;<br>                        cur.left = left;<br>                        <span class="hljs-keyword">if</span> (pre.val &lt; key) <br>                            pre.right = right;<br>                        <span class="hljs-keyword">else</span> <br>                            pre.left = right;                        <br>                    &#125;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur.left == <span class="hljs-literal">null</span> &amp;&amp; cur.right != <span class="hljs-literal">null</span>) &#123;<br>                        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> cur.right;<br>                        <span class="hljs-keyword">if</span> (pre.val &lt; key)<br>                            pre.right = right;<br>                        <span class="hljs-keyword">else</span> <br>                            pre.left = right;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-literal">null</span> &amp;&amp; cur.right == <span class="hljs-literal">null</span>) &#123;<br>                        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> cur.left;<br>                        <span class="hljs-keyword">if</span> (pre.val &lt; key)<br>                            pre.right = left;<br>                        <span class="hljs-keyword">else</span> <br>                            pre.left = left;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur.val &lt; key) &#123;<br>                pre = cur;<br>                cur = cur.right;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                pre = cur;<br>                cur = cur.left;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root.val == key) &#123;<br>            <span class="hljs-keyword">return</span> root.left == <span class="hljs-literal">null</span> ? root.right : root.left;            <br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230427114811046.png" alt="image-20230427114811046" style="zoom:50%;" /></p><h4 id="star方法二dfs">:star:方法二：DFS</h4><p><strong>注意代码注释部分是完全冗余的！</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">deleteNode</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">if</span> (key &lt; root.val)<br>            root.left = deleteNode(root.left, key);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &gt; root.val)<br>            root.right = deleteNode(root.right, key);<br>        <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//(key == root.val) &#123;</span><br>            <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> root.right;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.left != <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> root.left;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root.right;<br>                <span class="hljs-keyword">while</span> (cur.left != <span class="hljs-literal">null</span>) <br>                    cur = cur.left;<br>                cur.left = root.left;<br>                <span class="hljs-keyword">return</span> root.right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// if (root.val == key) &#123;</span><br>        <span class="hljs-comment">//     if (root.left == null &amp;&amp; root.right == null)</span><br>        <span class="hljs-comment">//         return null;</span><br>        <span class="hljs-comment">//     else &#123;</span><br>        <span class="hljs-comment">//         return root.left == null ? root.right : root.left;</span><br>        <span class="hljs-comment">//     &#125;</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230427121231313.png" alt="image-20230427121231313" style="zoom:50%;" /></p><h3 id="warning669.-修剪二叉搜索树">:warning:<a href="https://leetcode.cn/problems/trim-a-binary-search-tree/">669. 修剪二叉搜索树</a></h3><p>借上一题的思路直接速通了</p><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230323144126141.png" alt="image-20230323144126141" style="zoom:50%;" /></p><h3 id="将有序数组转换为二叉搜索树"><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树</a></h3><h4 id="方法一二分dfs左闭右闭">方法一：二分DFS[左闭右闭]</h4><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230323150830325.png" alt="image-20230323150830325" style="zoom:50%;" /></p><h4 id="方法二dfs左闭右开开区间元素在record的数值要--闭区间元素在record的位置要开区间元素和闭区间元素都为a所以s的下标1以b开始的子串ba也是变位词">方法二：DFS[左闭右开)]，开区间元素在record的数值要--，闭区间元素在record的位置要++，开区间元素和闭区间元素都为‘a’，所以s的下标1以‘b’开始的子串“ba”也是变位词！</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">findAnagrams</span><span class="hljs-params">(String s, String p)</span> &#123;<br>        List&lt;Integer&gt; index = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (s.length() &lt; p.length())<br>            <span class="hljs-keyword">return</span> index;<br>        <span class="hljs-type">int</span>[] record = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; p.length(); ++i) &#123;<br>            ++record[p.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>];<br>            --record[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (areZeros(record)) &#123;<br>            index.add(<span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> p.length(); i &lt; s.length(); ++i) &#123;<br>            ++record[s.charAt(i - p.length()) - <span class="hljs-string">&#x27;a&#x27;</span>];<br>            --record[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>];<br>            <span class="hljs-keyword">if</span> (areZeros(record)) &#123;<br>                index.add(i - p.length() + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> index;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">areZeros</span><span class="hljs-params">(<span class="hljs-type">int</span>[] record)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> element : record)<br>            <span class="hljs-keyword">if</span> (element != <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230413180235628.png" alt="image-20230413180235628" style="zoom:50%;" /></p><h4 id="尽可能使字符串相等warning"><a href="https://leetcode.cn/problems/get-equal-substrings-within-budget/">1208. 尽可能使字符串相等</a>:warning:</h4><h4 id="方法一滑动窗口">方法一：滑动窗口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">equalSubstring</span><span class="hljs-params">(String s, String t, <span class="hljs-type">int</span> maxCost)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span>[] diff = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            diff[i] = Math.abs(s.charAt(i) - t.charAt(i));<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, start = <span class="hljs-number">0</span>, sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; end &lt; n; ++end) &#123;<br>            sum += diff[end];<br>            <span class="hljs-keyword">while</span> (maxCost &lt; sum) &#123;<br>                sum -= diff[start++];<br>            &#125;<br>            res = Math.max(res, end - start + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230519140212424.png" alt="image-20230519140212424" style="zoom:50%;" /></p><h3 id="string补充知识">String补充知识</h3><h4 id="string与char数组stringbuilder之间相互转换">String与char数组，StringBuilder之间相互转换</h4><p>将String转换为char数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">codeString</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-type">char</span>[] charArray = str.toCharArray();<br></code></pre></td></tr></table></figure><p>将char数组转换为String：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">codechar[] charArray = &#123;<span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>&#125;;<br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(charArray);<br></code></pre></td></tr></table></figure><p>将String转换为StringBuilder：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.</span><br><span class="hljs-type">codeString</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(str);<br><span class="hljs-comment">//2.</span><br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>sb.append(str);<br></code></pre></td></tr></table></figure><p>将StringBuilder转换为String：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">codeStringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>sb.append(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> sb.toString();<br></code></pre></td></tr></table></figure><p>将char数组转换为StringBuilder：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">codechar[] charArray = &#123;<span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>&#125;;<br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>sb.append(charArray);<br></code></pre></td></tr></table></figure><p>将StringBuilder转换为char数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">codeStringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-type">char</span>[] charArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[sb.length()];<br>sb.getChars(<span class="hljs-number">0</span>, sb.length(), charArray, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>需要注意的是，在将String转换为char数组或char时，如果字符串为空，或者字符串中的字符数量为0，则可能会导致越界异常或其他异常。因此，在进行这些转换操作时，需要进行有效性检查和异常处理。</p><p>单个字符char转换为String</p><p>在Java中，将单个字符（char）转换为字符串（String）有以下两种方法：</p><p>1.使用字符串连接符</p><p>您可以使用字符串连接符"+"来连接一个空字符串和单个字符，从而将其转换为字符串。例如：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">arduinoCopy codechar c</span> = <span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-attribute">String s</span> = <span class="hljs-string">&quot;&quot;</span> + c;<br></code></pre></td></tr></table></figure><p>在上面的代码中，首先创建一个空字符串，然后使用字符串连接符将其与字符"c"连接起来，从而将字符"c"转换为字符串。现在，字符串<code>s</code>将包含字符"c"的字符串。</p><p>2.使用String.valueOf()方法</p><p>另一种将单个字符转换为字符串的方法是使用String类的<code>valueOf()</code>方法。例如：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">arduinoCopy codechar c = <span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-type">String</span> s = <span class="hljs-type">String</span>.<span class="hljs-built_in">valueOf</span>(c);<br></code></pre></td></tr></table></figure><p>在上面的代码中，将字符"c"传递给<code>valueOf()</code>方法，并将返回的字符串分配给变量<code>s</code>。</p><p>无论使用哪种方法，您都可以将单个字符转换为字符串，从而可以对其进行各种字符串操作。</p><h4 id="stringbuilder的append可以是char或者string">StringBuilder的append可以是char或者String</h4><p>StringBuilder的append()方法可以接受char类型和String类型的参数。append()方法的作用是在StringBuilder对象的末尾追加指定的字符序列，这可以是char、String、StringBuilder或其他CharSequence实例。</p><p>以下是使用StringBuilder的append()方法追加char和String类型参数的示例代码：</p><p>追加char类型参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">codeStringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span>;<br>sb.append(c);<br></code></pre></td></tr></table></figure><p>追加String类型参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">codeStringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>sb.append(str);<br></code></pre></td></tr></table></figure><p>需要注意的是，使用append()方法追加char类型参数时，会自动将char类型转换为String类型。因此，如果需要在StringBuilder中追加一个char类型的字符，可以直接使用append()方法，而不需要先将其转换为String类型。</p><h3 id="kmp算法">KMP算法</h3><p><a href="https://www.zhihu.com/question/21923021/answer/281346746">生成next数组讲得很透彻</a></p><h2 id="array">Array</h2><h3 id="二分查找"><a href="https://leetcode.cn/problems/binary-search/">704. 二分查找</a></h3><h4 id="方法一左闭右开">方法一：左闭右开</h4><ol type="1"><li>区间：[left, right)</li><li>初始化：right = nums.length</li><li>while循环终止条件应为left &lt; right（右开，right不能等于left）</li><li>当nums[mid] &lt; target时，nums[0]~nums[mid]都小于target，此时有效的有边界是mid - 1，又因为右边界是开区间，所以另right = mid</li><li>时间复杂度：<span class="math inline">\(O(logn)\)</span>，由于每次查找都会将查找范围缩小一半，因此二分查找的时间复杂度是<span class="math inline">\(O(logn)\)</span>，其中 <em>n</em> 是数组的长度</li><li>空间复杂度：<span class="math inline">\(O(1)\)</span></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length;<br>        <span class="hljs-comment">// [left, right)</span><br>        <span class="hljs-keyword">while</span>(left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + ((right - left) &gt;&gt; <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (nums[mid] == target)<br>                <span class="hljs-keyword">return</span> mid;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target)<br>                left = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <br>                right = mid;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方法二左闭右闭">方法二：左闭右闭</h4><ol type="1"><li>区间：[left, right]</li><li>初始化：right = nums.length - 1</li><li>while循环终止条件应为left &lt;= right</li><li>当nums[mid] &lt; target时，nums[0]~nums[mid]都小于target，另right = mid - 1</li><li>时间复杂度：<span class="math inline">\(O(logn)\)</span>，由于每次查找都会将查找范围缩小一半，因此二分查找的时间复杂度是<span class="math inline">\(O(logn)\)</span>，其中 <em>n</em> 是数组的长度</li><li>空间复杂度：<span class="math inline">\(O(1)\)</span></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> right - ((right - left) &gt;&gt; <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (nums[mid] &gt; target) <br>                right = mid - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target)<br>                left = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <br>                <span class="hljs-keyword">return</span> mid;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="移除元素"><a href="https://leetcode.cn/problems/remove-element/">27. 移除元素</a></h3><h4 id="方法一暴力-1">方法一：暴力</h4><ol type="1"><li>每当发现一个数相等，那么从当前数组的下一个数开始，全部往前移一位。</li><li><strong>注意</strong>：因为移位后，下一个要访问的数组元素j会到当前i的位置，然后for循环结束i自增，会错过访j，所以移位后要--i。</li><li>时间复杂度：<span class="math inline">\(O(n^2)\)</span></li><li>空间复杂度：<span class="math inline">\(O(1)\)</span></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">newLen</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span> (newLen == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; newLen; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] == val) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; newLen; j++) &#123;<br>                    nums[j - <span class="hljs-number">1</span>] = nums[j];<br>                &#125;<br>                --newLen;<br>                --i;<br>            &#125;<br>         &#125;<br><br>        <span class="hljs-keyword">return</span> newLen;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方法二双指针-1">方法二：双指针</h4><ol type="1"><li>初始化慢指针为0</li><li>for循环遍历快指针，当nums[fast] != val时，令nums[slow] = nums[fast]，slow指针往后移。也就是说，如果快指针找到了val，那么慢指针停在val位置，之后快指针遍历到非val的位置时，将该非val数据覆盖到慢指针的指向数组位置的数据。</li><li>最后返回慢指针(慢指针大小代表新数组的大小)</li><li>时间复杂度：<span class="math inline">\(O(n)\)</span></li><li>空间复杂度：<span class="math inline">\(O(1)\)</span></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; fast &lt; nums.length; ++fast) &#123;<br>            <span class="hljs-keyword">if</span> (nums[fast] != val) &#123;<br>                nums[slow] = nums[fast];<br>                ++slow;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方法三相向双指针">方法三：相向双指针</h4><p><strong>避免了需要保留的元素的重复赋值操作</strong>。</p><ol type="1"><li><p>初始化：left=0, right=nums.length-1，左闭右闭区间，所以while语句的执行条件是</p><p>left &lt;= right(如果没有等于，left会少后移一次)</p></li><li><p>循环：当nums[left]不等于val时，left指针后移；当nums[left]等于val时，将nums[right]赋值给nums[left]，right指针前移；如果赋值过来的元素恰好也等于val，可以继续把右指针 right指向的元素的值赋值过来，直到左指针指向的元素的值不等于 val为止。</p></li><li><p>时间复杂度：<span class="math inline">\(O(n)\)</span></p></li><li><p>空间复杂度：<span class="math inline">\(O(1)\)</span></p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// [left, right]</span><br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-keyword">if</span> (nums[left] == val) &#123;<br>                nums[left] = nums[right];<br>                --right;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                ++left;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="有序数组的平方"><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977. 有序数组的平方</a></h3><h4 id="双指针">双指针</h4><p>left,right指针指向数组两端，将较大的平方数放入result数组里。</p><ol type="1"><li>时间复杂度：<span class="math inline">\(O(n)\)</span></li><li>空间复杂度：<span class="math inline">\(O(n)\)</span></li></ol><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230406132631275.png" alt="image-20230406132631275" style="zoom:50%;" /></p><h3 id="长度最小的子数组"><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a></h3><h4 id="numsi先执行自增操作还是数组寻址操作">nums[++i]先执行自增操作还是数组寻址操作?</h4><p>在Java中，表达式<code>nums[++i]</code>中的<code>++i</code>是先自增还是先寻址是有规定的。按照Java的运算符优先级规定，前置自增运算符<code>++i</code>的优先级高于数组下标运算符<code>[]</code>，因此在执行这个表达式时，先进行<code>++i</code>自增运算，然后再进行数组下标运算，即先自增再寻址。</p><p>因此，<code>nums[++i]</code>相当于先将变量<code>i</code>自增1，然后使用自增后的<code>i</code>作为数组下标去访问<code>nums</code>数组中的元素。如果<code>i</code>的初始值为0，那么<code>nums[++i]</code>将访问<code>nums[1]</code>位置上的元素，而不是<code>nums[0]</code>。如果数组<code>nums</code>越界，将会抛出<code>ArrayIndexOutOfBoundsException</code>异常。</p><h4 id="numsi先执行自增操作还是数组寻址操作-1">nums[i++]先执行自增操作还是数组寻址操作?</h4><p>在这种情况下，nums[i++]实际上会先执行数组寻址操作，然后再对i进行自增操作。这是因为数组寻址操作的优先级比自增操作的优先级高。</p><p>具体来说，这个表达式会先使用i的当前值来计算nums数组中第i个元素的地址，然后将地址作为结果返回，接着才会将i的值加1。</p><h4 id="int-a-i-是先赋值还是先自增">int a = ++i 是先赋值还是先自增</h4><p>这行代码会先自增变量 i 的值，然后将自增后的结果赋值给变量 a。所以，变量 a 的值等于自增后的变量 i 的值。这个过程中，变量 i 的值会被修改，而变量 a 的值则是这个修改后的值。</p><p>可以将这行代码拆分成两步：</p><ol type="1"><li>i = i + 1； // 自增 i 的值</li><li>a = i； // 将自增后的 i 的值赋值给 a</li></ol><p>所以，最终变量 a 的值等于自增后的变量 i 的值。</p><h4 id="int-a-i-是先赋值还是先自增-1">int a = i++ 是先赋值还是先自增</h4><p>这行代码会先将变量 i 的值赋值给变量 a，然后再将变量 i 的值自增。所以，变量 a 的值等于变量 i 的值，而变量 i 的值会被自增。</p><p>可以将这行代码拆分成两步：</p><ol type="1"><li>a = i； // 将 i 的值赋值给 a</li><li>i = i + 1； // 自增 i 的值</li></ol><p>所以，最终变量 a 的值等于变量 i 的初始值，而变量 i 的值则是初始值加一。</p><h4 id="while--index-先---后比较index0">while(--index) 先-- 后比较index&gt;0</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><span class="hljs-keyword">while</span> (--index &gt; <span class="hljs-number">0</span>) &#123;<br>    System.out.print(index);<br>&#125;<br></code></pre></td></tr></table></figure><p>stdout</p><p>1</p><h4 id="whileindex---先比较-后--">while(index--) 先比较 后--</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><span class="hljs-keyword">while</span> (index-- &gt; <span class="hljs-number">0</span>) &#123;<br>    System.out.print(index);<br>&#125;<br></code></pre></td></tr></table></figure><p>stdout</p><p>10</p><h4 id="system.out.print--index-先---后打印">System.out.print(--index) 先-- 后打印</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><span class="hljs-keyword">while</span> (index &gt; <span class="hljs-number">0</span>) &#123;<br>    System.out.print(--index);<br>&#125;<br></code></pre></td></tr></table></figure><p>stdout</p><p>10</p><h4 id="滑动窗口">滑动窗口</h4><ol type="1"><li><p>注意：为了确保有些案例，sum一直小于target，最后输出判断：如果</p><p>result == Integer.MAX_VALUE，就输出0。</p></li><li><p>result记录最小的长度</p></li><li><p>时间复杂度：<span class="math inline">\(O(n)\)</span></p></li><li><p>空间复杂度：<span class="math inline">\(O(1)\)</span></p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, result = Integer.MAX_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i) &#123;<br>            ++counter;<br>            sum += nums[i];<br>            <span class="hljs-keyword">while</span> (sum &gt;= target) &#123;<br>                result = Math.min(result, counter);<br>                sum -= nums[i - (--counter)];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result == Integer.MAX_VALUE ? <span class="hljs-number">0</span> : result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230418152625221.png" alt="image-20230418152625221" style="zoom:50%;" /></p><h3 id="螺旋矩阵-ii"><a href="https://leetcode.cn/problems/spiral-matrix-ii/">59. 螺旋矩阵 II</a></h3><ol type="1"><li><p>遍历顺序：从左到右(左闭右开)，从上到下(上闭下开)，从右到左(右闭左开)，从下到上(下闭上开)</p><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230406151317898.png" alt="image-20230406151317898" style="zoom: 25%;" /></p></li><li><p>思路见代码注释部分</p></li><li><p>时间复杂度：<span class="math inline">\(O(n^2)\)</span></p></li><li><p>空间复杂度：<span class="math inline">\(O(1)\)</span></p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] generateMatrix(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-comment">// 用笔画一个n=5的矩阵作为例子</span><br>        <span class="hljs-comment">// 遍历顺序：从左到右(左闭右开)，从上到下(上闭下开)，从右到左(右闭左开)，从下到上(下闭上开)</span><br>        <span class="hljs-comment">// 建立n行n列的矩阵</span><br>        <span class="hljs-type">int</span>[][] matrix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-comment">// 遍历次数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">traverseTime</span> <span class="hljs-operator">=</span> n / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> i, j;<br>        <span class="hljs-comment">// 写入数组的数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// cur:当前遍历伦茨</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; cur &lt; traverseTime; ++cur) &#123;<br>            <span class="hljs-comment">// 从左到右(左闭右开)</span><br>            <span class="hljs-keyword">for</span> (j = cur; j &lt; n - cur - <span class="hljs-number">1</span>; ++j) &#123;<br>                matrix[cur][j] = data++;<br>            &#125;<br>            <span class="hljs-comment">// 从上到下(上闭下开)</span><br>            <span class="hljs-keyword">for</span> (i = cur; i &lt; n - cur - <span class="hljs-number">1</span>; ++i) &#123;<br>                matrix[i][j] = data++;<br>            &#125;<br>            <span class="hljs-comment">// 从右到左(右闭左开)</span><br>            <span class="hljs-keyword">for</span> (; j &gt; cur; --j) &#123;<br>                matrix[i][j] = data++;<br>            &#125;<br>            <span class="hljs-comment">// 从下到上(下闭上开)</span><br>            <span class="hljs-keyword">for</span> (; i &gt; cur; --i) &#123;<br>                matrix[i][j] = data++;<br>            &#125;<br>            <span class="hljs-comment">// debug</span><br>            <span class="hljs-comment">// for (int a = 0; a &lt; n; ++a) &#123;</span><br>            <span class="hljs-comment">//     for (int b = 0; b &lt; n; ++b) &#123;</span><br>            <span class="hljs-comment">//         System.out.print(matrix[a][b]);</span><br>            <span class="hljs-comment">//     &#125;</span><br>            <span class="hljs-comment">// &#125;</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)<br>            matrix[traverseTime][traverseTime] = n * n;<br>        <span class="hljs-keyword">return</span> matrix;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230406150937452.png" alt="image-20230406150937452" style="zoom:50%;" /></p><h3 id="区域和检索---数组不可变"><a href="https://leetcode.cn/problems/range-sum-query-immutable/">303. 区域和检索 - 数组不可变</a></h3><h4 id="方法一暴力-2">方法一：暴力</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumArray</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] nums;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NumArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-built_in">this</span>.nums = nums;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumRange</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> left; i &lt;= right; ++i) &#123;<br>            sum += nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your NumArray object will be instantiated and called as such:</span><br><span class="hljs-comment"> * NumArray obj = new NumArray(nums);</span><br><span class="hljs-comment"> * int param_1 = obj.sumRange(left,right);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230511104924605.png" alt="image-20230511104924605" style="zoom:50%;" /></p><h4 id="方法二前缀和">方法二：前缀和</h4><ol type="1"><li><p>建立一个长度为n+1的数组preSum</p></li><li><p>初始化preSum[0] = 0;</p></li><li><p>preSum[i]表示数组nums从下标0到下标i-1的和</p><figure><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230511111212882.png" alt="image-20230511111212882" /><figcaption aria-hidden="true">image-20230511111212882</figcaption></figure></li><li><p>区间[left,right]的和为preSum[right + 1] - preSum[left];</p><p>preSum[right + 1]表示数组从下标0到right的和，preSum[left]表示数组从下标0到left-1的和</p></li><li><p>将前缀和数组preSum的长度设为n+1的目标是为了方便计算sumRange(left, right)时，不需要对left=0的情况做特殊处理</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumArray</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] preSum;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NumArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        preSum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; preSum.length; ++i) &#123;<br>            preSum[i] = preSum[i - <span class="hljs-number">1</span>] + nums[i - <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumRange</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-keyword">return</span> preSum[right + <span class="hljs-number">1</span>] - preSum[left];<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your NumArray object will be instantiated and called as such:</span><br><span class="hljs-comment"> * NumArray obj = new NumArray(nums);</span><br><span class="hljs-comment"> * int param_1 = obj.sumRange(left,right);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230511110351502.png" alt="image-20230511110351502" style="zoom: 50%;" /></p><h4 id="前缀和前缀和数组为n需要对left0时做特殊处理">前缀和：前缀和数组为n，需要对left=0时做特殊处理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumArray</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] preSum;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NumArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        preSum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        preSum[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; preSum.length; ++i) &#123;<br>            preSum[i] = preSum[i - <span class="hljs-number">1</span>] + nums[i];<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumRange</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> preSum[right];<br>        &#125;<br>        <span class="hljs-keyword">return</span> preSum[right] - preSum[left - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your NumArray object will be instantiated and called as such:</span><br><span class="hljs-comment"> * NumArray obj = new NumArray(nums);</span><br><span class="hljs-comment"> * int param_1 = obj.sumRange(left,right);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230511112006002.png" alt="image-20230511112006002" style="zoom:50%;" /></p><h3 id="二维区域和检索---矩阵不可变"><a href="https://leetcode.cn/problems/range-sum-query-2d-immutable/">304. 二维区域和检索 - 矩阵不可变</a></h3><h4 id="方法一前缀和warning">方法一：前缀和:warning:</h4><p><strong>需要重刷！</strong></p><p><a href="https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-48c1d/xiao-er-me-03265/">题解</a></p><figure><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230511124326460.png" alt="image-20230511124326460" /><figcaption aria-hidden="true">image-20230511124326460</figcaption></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumMatrix</span> &#123;<br>    <span class="hljs-type">int</span>[][] preSum;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NumMatrix</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        preSum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[matrix.length + <span class="hljs-number">1</span>][matrix[<span class="hljs-number">0</span>].length + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= matrix.length; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= matrix[<span class="hljs-number">0</span>].length; ++j) &#123;<br>                preSum[i][j] = matrix[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + preSum[i - <span class="hljs-number">1</span>][j] + preSum[i][j - <span class="hljs-number">1</span>] - preSum[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;        <br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumRegion</span><span class="hljs-params">(<span class="hljs-type">int</span> row1, <span class="hljs-type">int</span> col1, <span class="hljs-type">int</span> row2, <span class="hljs-type">int</span> col2)</span> &#123;<br>        <span class="hljs-keyword">return</span> preSum[row2 + <span class="hljs-number">1</span>][col2 + <span class="hljs-number">1</span>] - preSum[row2 + <span class="hljs-number">1</span>][col1] - preSum[row1][col2 + <span class="hljs-number">1</span>] + preSum[row1][col1];<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your NumMatrix object will be instantiated and called as such:</span><br><span class="hljs-comment"> * NumMatrix obj = new NumMatrix(matrix);</span><br><span class="hljs-comment"> * int param_1 = obj.sumRegion(row1,col1,row2,col2);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230511124011443.png" alt="image-20230511124011443" style="zoom:50%;" /></p><h3 id="航班预订统计"><a href="https://leetcode.cn/problems/corporate-flight-bookings/">1109. 航班预订统计</a></h3><h2 id="linkedlist">LinkedList</h2><h3 id="移除链表元素"><a href="https://leetcode.cn/problems/remove-linked-list-elements/">203. 移除链表元素</a></h3><h4 id="解题思路在面对链表树有关创建删除操作使用dummyhead能省去不少边界判定的功夫">解题思路：在面对链表、树有关创建、删除操作，使用dummyHead！能省去不少边界判定的功夫。</h4><ol type="1"><li>初始化：dummyHead指向head，dummyHead赋值给pre，head赋值给cur</li><li>当cur的值等于所求val，pre指向cur的下一个节点</li><li>当cur的值不等于val，pre移动到cur，cur往后移一位</li><li>返回dummyHead的下一个节点。</li></ol><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230407173513851.png" alt="image-20230407173513851" style="zoom:50%;" /></p><h3 id="设计链表"><a href="https://leetcode.cn/problems/design-linked-list/">707. 设计链表</a></h3><h4 id="注意事项dummyhead-size"><strong>注意事项：DummyHead + size</strong></h4><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230407211111582.png" alt="image-20230407211111582" style="zoom:50%;" /></p><h3 id="反转链表"><a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></h3><p>用笔模拟一下指针pre，cur，next的过程</p><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230407213816337.png" alt="image-20230407213816337" style="zoom:50%;" /></p><ol type="1"><li><p>时间复杂度：<span class="math inline">\(O(n^2)\)</span></p></li><li><p>空间复杂度：<span class="math inline">\(O(1)\)</span></p></li></ol><h3 id="两两交换链表中的节点"><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></h3><h4 id="注意要点用纸和笔模拟一下指针precurnext的过程记得创建dummyhead">注意要点：用纸和笔模拟一下指针pre，cur，next的过程，记得创建dummyHead</h4><ol type="1"><li><p>时间复杂度：<span class="math inline">\(O(n)\)</span></p></li><li><p>空间复杂度：<span class="math inline">\(O(1)\)</span></p></li></ol><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230408115746409.png" alt=" " style="zoom:50%;" /></p><h3 id="删除链表的倒数第-n-个结点"><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h3><ol type="1"><li>使用dummyHead，从dummyHead，找到倒数第N个节点的前一个节点node，需要走链表长度size - N步，即可把node指向下一个节点的下一个节点即可完成删除操作。<br /></li><li>但是链表的长度是未知的，可以先遍历一遍链表的长度，求出size，再走size-N步完成删除操作。</li><li>也可以使用快慢指针，fast与slow的起始点都为dummyHead，fast先走N步，再让fast与slow一起右移，当fast走到最后一个节点时(fast.next == null时)，slow右移了size - N步，到达倒数第N个节点的上一个节点，即可完成删除操作。</li><li>时间复杂度：<span class="math inline">\(O(n)\)</span></li><li>空间复杂度：<span class="math inline">\(O(1)\)</span></li></ol><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230408131407107.png" alt="image-20230408131407107" style="zoom:50%;" /></p><h3 id="面试题-02.07.-链表相交"><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/">面试题 02.07. 链表相交</a></h3><h4 id="方法一hashset">方法一：HashSet</h4><ol type="1"><li>用指针A,B分别指向两个链表头</li><li>开始循环，循环的终止条件为A,B都为空，每次循环先将A,B指向的节点放入HashSet，再向后移</li><li>当遍历到某个已经存入HashSet的节点时，这个节点就是相交节点；否则没有相交节点</li><li>时间复杂度：<span class="math inline">\(O(m + n)\)</span>，其中m，n分别为两个链表的长度</li><li>空间复杂度：<span class="math inline">\(O(m + n)\)</span></li></ol><h4 id="方法二双指针-2">方法二：双指针</h4><p><strong>解题思路</strong>：A,B分别指向headA,headB，如果有公共节点，设公共节点长度为c，链表A和B长度分别为a,b。向右遍历，如何为空，则指向另一个链表的头。如果两个链表相交，则A向右移动了a+c+b步，B向右移动了b+c+a时相交，返回A；如果两个链表不相交，则A向右移动了a+b步，B向右移动了b+a步，都为空，退出循环返回null。</p><ol type="1"><li>用指针A,B分别指向两个链表头headA,headB</li><li>开始循环，循环的条件是A和B不都为空，如果A为空，则A指向headB，否则向后移；如果B为空，则B指向headA，否则向后移</li><li>开始循环，循环的终止条件为A,B都为空，每次循环先将A,B指向的节点放入HashSet，再向后移</li><li>当遍历到某个已经存入HashSet的节点时，这个节点就是相交节点；否则没有相交节点</li><li>时间复杂度：<span class="math inline">\(O(m + n)\)</span>，其中m，n分别为两个链表的长度</li><li>空间复杂度：<span class="math inline">\(O(m + n)\)</span></li></ol><p>一个错误代码实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> &#123;<br>        <span class="hljs-keyword">if</span> (headA == <span class="hljs-literal">null</span> || headB == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pA</span> <span class="hljs-operator">=</span> headA, pB = headB;<br>        <span class="hljs-keyword">while</span> (pA != <span class="hljs-literal">null</span> || pB != <span class="hljs-literal">null</span>) &#123;<br>            pA = pA == <span class="hljs-literal">null</span> ? headB : pA.next;<br>            pB = pB == <span class="hljs-literal">null</span> ? headA : pB.next;<br>            <span class="hljs-keyword">if</span> (pA == pB)<br>                <span class="hljs-keyword">return</span> pA;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>错误如下，当两个链表只有公共部分节点1时，上述代码没有先判断，先向右移，结果指向A,B都为空，返回空。</p><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230408141854779.png" alt="image-20230408141854779" style="zoom:50%;" /></p><p>所以解决方案是把判断AB相等的语句放在指针移动上面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> &#123;<br>        <span class="hljs-keyword">if</span> (headA == <span class="hljs-literal">null</span> || headB == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pA</span> <span class="hljs-operator">=</span> headA, pB = headB;<br>        <span class="hljs-keyword">while</span> (pA != <span class="hljs-literal">null</span> || pB != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (pA == pB)<br>                <span class="hljs-keyword">return</span> pA;<br>            pA = pA == <span class="hljs-literal">null</span> ? headB : pA.next;<br>            pB = pB == <span class="hljs-literal">null</span> ? headA : pB.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>成功</p><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230408142109879.png" alt="image-20230408142109879" style="zoom:50%;" /></p><h6 id="优化">优化</h6><ol type="1"><li>当A,B只有公共部分时，直接返回结果</li><li>当A,B有自己的部分也相交时<ol type="1"><li>当A,B公共部分前面节点数量相同时，遍历到相交节点直接返回结果</li><li>当A,B公共部分前面节点数量不同时，遍历a+b+c步也会相交，返回结果</li></ol></li><li>当A,B不相交时，遍历完a+ 1(null) + b + 1(null) 步后，A和B都为null，返回的A为null，表示不相交</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> &#123;<br>        <span class="hljs-keyword">if</span> (headA == <span class="hljs-literal">null</span> || headB == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pA</span> <span class="hljs-operator">=</span> headA, pB = headB;<br>        <span class="hljs-keyword">while</span> (pA != pB) &#123;<br>            pA = pA == <span class="hljs-literal">null</span> ? headB : pA.next;<br>            pB = pB == <span class="hljs-literal">null</span> ? headA : pB.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pA;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="环形链表-ii"><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h4><p><strong>解题思路：</strong>快慢指针，慢指针走一步，快指针走两步，如果有环，快指针总能在环中追上慢指针。当快指针和慢指针指向同一节点时，把快节点指向头节点，慢节点不动，快慢指针一起走，再次相遇时，指向的节点就是入环的第一个节点。</p><ol type="1"><li>时间复杂度：<span class="math inline">\(O(m + n)\)</span>，其中m，n分别为两个链表的长度</li><li>空间复杂度：<span class="math inline">\(O(m + n)\)</span></li></ol><hr /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">detectCycle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head.next.next, slow = head.next;<br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>) &#123;<br>            fast = fast.next.next;<br>            slow = slow.next;<br>            <span class="hljs-keyword">if</span> (fast == slow) &#123;<br>                fast = head;<br>                <span class="hljs-keyword">while</span> (fast != slow) &#123;<br>                    fast = fast.next;<br>                    slow = slow.next;<br>                &#125;<br>            <span class="hljs-keyword">return</span> fast;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230408150523230.png" alt="image-20230408150523230" style="zoom:50%;" /></p><h3 id="剑指-offer-ii-026.-重排链表"><a href="https://leetcode.cn/problems/LGjMqU/">剑指 Offer II 026. 重排链表</a></h3><h4 id="方法一翻转合并">方法一：翻转合并</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reorderList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head, fast = head.next;<br>        <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>) &#123;<br>            fast = fast.next.next;<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> cur;<br>        fast = mid.next;<br>        mid.next = <span class="hljs-literal">null</span>;<br>        fast = reverse(fast);<br>        cur = head;<br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">next1</span> <span class="hljs-operator">=</span> cur.next, next2 = fast.next;<br>            cur.next = fast;<br>            fast.next = next1;<br>            cur = next1;<br>            fast = next2;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> ListNode <span class="hljs-title function_">reverse</span><span class="hljs-params">(ListNode cur)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>, next = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            next = cur.next;<br>            cur.next = pre;<br>            pre = cur;<br>            cur = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230518161042144.png" alt="image-20230518161042144" style="zoom:50%;" /></p><h3 id="剑指-offer-ii-025.-链表中的两数相加"><a href="https://leetcode.cn/problems/lMSNwu/">剑指 Offer II 025. 链表中的两数相加</a></h3><h4 id="方法一翻转三次">方法一：翻转三次</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">addTwoNumbers</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>        l1 = reverse(l1);<br>        l2 = reverse(l2);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> addReversedList(l1, l2);<br>        <span class="hljs-keyword">return</span> reverse(res);<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> ListNode <span class="hljs-title function_">addReversedList</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">carry</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-literal">null</span> || l2 != <span class="hljs-literal">null</span>) &#123;<br>            l1 = l1 == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : l1;<br>            l2 = l2 == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : l2;<br>            sum = (l1 == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : l1.val) + (l2 == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : l2.val) + carry;<br>            carry = sum &gt;= <span class="hljs-number">10</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>            sum = sum &gt;= <span class="hljs-number">10</span> ? sum - <span class="hljs-number">10</span> : sum;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(sum);<br>            cur.next = newNode;<br>            cur = cur.next;<br>            l1 = l1 == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : l1.next;<br>            l2 = l2 == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : l2.next;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (carry == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">1</span>);<br>            cur.next = newNode;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> ListNode <span class="hljs-title function_">reverse</span><span class="hljs-params">(ListNode cur)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>, next = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            next = cur.next;<br>            cur.next = pre;<br>            pre = cur;<br>            cur = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230518164308933.png" alt="image-20230518164308933" style="zoom:50%;" /></p><h4 id="方法二翻转两次最后一次不需要翻转">方法二：翻转两次(最后一次不需要翻转)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">addTwoNumbers</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>        l1 = reverse(l1);<br>        l2 = reverse(l2);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> addReversedList(l1, l2);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> ListNode <span class="hljs-title function_">addReversedList</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">carry</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-literal">null</span> || l2 != <span class="hljs-literal">null</span>) &#123;<br>            l1 = l1 == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : l1;<br>            l2 = l2 == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : l2;<br>            sum = (l1 == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : l1.val) + (l2 == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : l2.val) + carry;<br>            carry = sum &gt;= <span class="hljs-number">10</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>            sum = sum &gt;= <span class="hljs-number">10</span> ? sum - <span class="hljs-number">10</span> : sum;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(sum);<br>            cur = dummy.next;<br>            dummy.next = newNode;<br>            newNode.next = cur;<br><br>            l1 = l1 == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : l1.next;<br>            l2 = l2 == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : l2.next;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (carry == <span class="hljs-number">1</span>) &#123;<br>            cur = dummy.next;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">1</span>);<br>            dummy.next = newNode;<br>            newNode.next = cur;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> ListNode <span class="hljs-title function_">reverse</span><span class="hljs-params">(ListNode cur)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>, next = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            next = cur.next;<br>            cur.next = pre;<br>            pre = cur;<br>            cur = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230518164954170.png" alt="image-20230518164954170" style="zoom:50%;" /></p><h2 id="hash-table">Hash Table</h2><h3 id="有效的字母异位词"><a href="https://leetcode.cn/problems/valid-anagram/">242. 有效的字母异位词</a></h3><h4 id="方法一双hashmap记录词频">方法一：双HashMap记录词频</h4><ol type="1"><li>判断s与t的长度，若不相等，则一定不是字母异位词</li><li>建立两个HashMap&lt;Character, Integer&gt;</li><li>遍历字符串，将每个字符存入map中，并将值+1</li><li>如果map1与map2的size不相等，则一定不是字母异位词</li><li>遍历map1(我遍历的是字符串)，get字符串s，t的每一个字符出现了的次数，判断是否相同，如果不同，则一定不是字母异位词。</li><li>时间复杂度：<span class="math inline">\(O(n)\)</span>，其中n为第一个字符串的长度</li><li>空间复杂度：<span class="math inline">\(O(1)\)</span></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAnagram</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-keyword">if</span> (len != t.length())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <br>        Map&lt;Character, Integer&gt; map1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(), map2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">sChar</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-type">char</span> <span class="hljs-variable">tChar</span> <span class="hljs-operator">=</span> t.charAt(i);<br>            map1.put(sChar, map1.getOrDefault(sChar, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            map2.put(tChar, map2.getOrDefault(tChar, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sSize</span> <span class="hljs-operator">=</span> map1.get(s.charAt(i));<br>            <span class="hljs-type">int</span> <span class="hljs-variable">tSize</span> <span class="hljs-operator">=</span> map2.getOrDefault(s.charAt(i), <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">if</span> (sSize != tSize) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="C:\Users\ning\AppData\Roaming\Typora\typora-user-images\image-20230410091052990.png" alt="image-20230410091052990" style="zoom:50%;" /></p><h4 id="方法二数组">方法二：数组</h4><ol type="1"><li><strong>数组其实就是一个简单哈希表</strong>，而且这道题目中字符串只有小写字符，那么就可以定义一个数组，来记录字符串s里字符出现的次数。</li><li>定一个数组record，大小为26 ，初始化为0，因为字符a到字符z的ASCII也是26个连续的数值。</li><li>遍历第一个字符串s时，只需要将s.charAt(i) - ‘a’所在的元素+1，这样统计了字符串s中每个字符出现的次数。</li><li>同样，遍历第二个字符串t时，只需要将t.charAt(i) - ‘a’所在的元素-1。</li><li>如果record全部元素为0，那么s和t是字母异位词；否则不是。</li><li>时间复杂度：<span class="math inline">\(O(n)\)</span>，其中n为第一个字符串的长度</li><li>空间复杂度：<span class="math inline">\(O(1)\)</span>，只使用了常数大小的辅助数组。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAnagram</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-keyword">if</span> (s.length() != t.length())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span>[] record = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); ++i)  &#123;<br>            ++record[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>];<br>            --record[t.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; ++i) <br>            <span class="hljs-keyword">if</span> (record[i] != <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230410095746919.png" alt="image-20230410095746919" style="zoom:50%;" /></p><h3 id="两个数组的交集"><a href="https://leetcode.cn/problems/intersection-of-two-arrays/">349. 两个数组的交集</a></h3><h4 id="解题思路双hashset">解题思路：双HashSet</h4><ol type="1"><li>首先使用一个HashSet命名为set，记录第一个数组中不包含重复的所有元素</li><li>再用一个HashSet命名为intersection，遍历第二个数组，如果第二个数组中的元素在set中，则加入intersection中</li><li>最后将intersection转换为数组，并返回</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] intersection(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2) &#123;<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        Set&lt;Integer&gt; intersection = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums1.length; ++i)<br>            set.add(nums1[i]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums2.length; ++i) <br>            <span class="hljs-keyword">if</span> (set.contains(nums2[i]))<br>                intersection.add(nums2[i]);<br>        <span class="hljs-type">int</span>[] result  = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[intersection.size()];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> element : intersection) &#123;<br>            result[i++] = element;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230410102254619.png" alt="image-20230410102254619" style="zoom:50%;" /></p><h3 id="快乐数"><a href="https://leetcode.cn/problems/happy-number/">202. 快乐数</a></h3><p><strong>求和的过程中，sum会重复出现，用HashSet记录每一次求和，如果有重复，那么必定不是快乐数。</strong></p><p><strong>注意：</strong>sum += (n % 10) * (n % 10);+=的优先级高于%。</p><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230410105016176.png" alt="image-20230410105016176" style="zoom:50%;" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHappy</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (n != <span class="hljs-number">1</span> &amp;&amp; !set.contains(n)) &#123;<br>            set.add(n);<br>            n = getSum(n);<br>        &#125;<br>        <span class="hljs-keyword">return</span> n == <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSum</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) &#123;<br>            sum += (n % <span class="hljs-number">10</span>) * (n % <span class="hljs-number">10</span>);<br>            n /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230410104545810.png" alt="image-20230410104545810" style="zoom:50%;" /></p><h3 id="两数之和"><a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></h3><h4 id="方法一暴力-3">方法一：暴力</h4><p><strong>注意初始化int数组：new int[]{i, j};</strong></p><ol type="1"><li>时间复杂度：<span class="math inline">\(O(n^2)\)</span>，其中n为第一个字符串的长度</li><li>空间复杂度：<span class="math inline">\(O(1)\)</span>，只使用了常数大小的辅助数组。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">1</span>; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j  &lt; nums.length; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (nums[i] + nums[j] == target) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, j&#125;;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方法二hashmap">方法二：HashMap</h4><p><strong>解题思路</strong>：</p><ol type="1"><li>建立一个HashMap，key为数组的值，value为数组索引</li><li>遍历一遍，每次遍历判断哈希表中是否存在key为target-nums[i]，如果有，则这个key对应的value与i即为所求</li><li>时间复杂度：<span class="math inline">\(O(n)\)</span></li><li>空间复杂度：<span class="math inline">\(O(n)\)</span></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (map.containsKey(target - nums[i])) <br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;map.get(target - nums[i]), i&#125;;<br>            map.put(nums[i], i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230410113139219.png" alt="image-20230410113139219" style="zoom:50%;" /></p><h3 id="四数相加-ii"><a href="https://leetcode.cn/problems/4sum-ii/">454. 四数相加 II</a></h3><h4 id="解题思路">解题思路：</h4><ol type="1"><li>用HashMap用两层循环记录前两个数组每个元素之和为key，<code>和</code>出现的次数为value</li><li>再两次循环后两个数组，如果map.containsKey(- i - j)，那么- i - j与当前i + j之和为0，即为本题所求，则把result加上和为<code>- i - j</code>的数量</li><li>时间复杂度：<span class="math inline">\(O(n^2)\)</span>，两层循环</li><li>空间复杂度：<span class="math inline">\(O(n^2)\)</span>，在最坏情况下，前两个数组的元素各不相同，map占n * n</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fourSumCount</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2, <span class="hljs-type">int</span>[] nums3, <span class="hljs-type">int</span>[] nums4)</span> &#123;<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums1.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                map.put(nums1[i] + nums2[j], map.getOrDefault(nums1[i] + nums2[j], <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : nums3) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j : nums4) &#123;<br>                <span class="hljs-keyword">if</span> (map.containsKey(- i - j))<br>                    result += map.get(- i - j);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230411090436663.png" alt="image-20230411090436663" style="zoom:50%;" /></p><h3 id="赎金信"><a href="https://leetcode.cn/problems/ransom-note/">383. 赎金信</a></h3><h4 id="解题思路字母表">解题思路：字母表</h4><ol type="1"><li>如果ransomNote的长度大于magazine的长度，直接返回false</li><li>新建一个长度为26的字母表，以及一个HashMap，key为字母-‘a’，value为字母出现的次数，将magazine中的每个字符put进map</li><li>遍历ransomNote的所有字符i，如果map中key为字符i的value大于0，那么把这个value减一；如果map中key为字符i的value小于等于0，说明magazine不存在字符i或者字符i的个数小于ransomNote中字符i的个数，那么 <code>ransomNote</code> 能不能由 <code>magazine</code> 里面的字符构成，返回false</li><li>时间复杂度：<span class="math inline">\(O(n)\)</span>，两层循环</li><li>空间复杂度：<span class="math inline">\(O(1)\)</span>，只需要常数大小的辅助空间</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canConstruct</span><span class="hljs-params">(String ransomNote, String magazine)</span> &#123;<br>        <span class="hljs-keyword">if</span> (ransomNote.length() &gt; magazine.length())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">char</span>[] record = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">26</span>];<br>        Map&lt; Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; magazine.length(); ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> magazine.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            map.put(index, map.getOrDefault(index, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125; <br>           <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; ransomNote.length(); ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> ransomNote.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (map.getOrDefault(index, <span class="hljs-number">0</span>) &gt; <span class="hljs-number">0</span>) &#123;<br>                map.put(index, map.get(index) - <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230411092655653.png" alt="image-20230411092655653" style="zoom:50%;" /></p><h3 id="x15.-三数之和"><a href="https://leetcode.cn/problems/3sum/">x15. 三数之和</a></h3><p><strong>题目要求：</strong></p><ol type="1"><li>nums[i],nums[j],nums[k]中i,j,k各不相同</li><li>输出的nums[i],nums[j],nums[k]不能重复，如果结果集合中有{1,2,3}了，就不能再加入一个{1,2,3}</li><li><strong>不能有重复的三元组，但三元组内的元素是可以重复的！</strong>{0,0,0},{-1,-1,2}是允许的</li></ol><h4 id="方法一暴力-4">方法一：暴力</h4><ol type="1"><li><p><strong>注意</strong>：{1，2，3}和{3， 2， 1}是不同的元素！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">set.add(Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>));<br>set.add(Arrays.asList(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>));<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>[<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure></li><li><p>找到符合的元素先排序，如何hashset中不存在再加入list中。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">threeSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Set&lt;List&lt;Integer&gt;&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        List&lt;List&lt;Integer&gt;&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">2</span>; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j  &lt;nums.length - <span class="hljs-number">1</span>; ++j) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> j + <span class="hljs-number">1</span>; k &lt; nums.length; ++k) &#123;<br>                    <span class="hljs-keyword">if</span> (nums[i] + nums[j] + nums[k] == <span class="hljs-number">0</span>) &#123;<br>                        List&lt;Integer&gt; temp = Arrays.asList(nums[i], nums[j], nums[k]);<br>                        Collections.sort(temp);<br>                        <span class="hljs-keyword">if</span> (!set.contains(temp)) &#123;<br>                            set.add(temp);<br>                            list.add(temp);<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>超时</p><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230411100538160.png" alt="image-20230411100538160" style="zoom:50%;" /></p><h4 id="方法二排序-双指针">方法二：排序 + 双指针</h4><ol type="1"><li><strong>去重思路</strong></li><li><strong>边界判断</strong></li><li>时间复杂度：<span class="math inline">\(O(n^2)\)</span>，两层循环</li><li>空间复杂度：<span class="math inline">\(O(1)\)</span></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">threeSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        Arrays.sort(nums);<br>        <span class="hljs-comment">// window: [nums[i], left, right]</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">2</span>; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">// 去重</span><br>            <span class="hljs-comment">// 为什么不是nums[i] = nums[i + 1]?</span><br>            <span class="hljs-comment">// 比如&#123;-1，-1，2&#125;</span><br>            <span class="hljs-comment">// 如果是nums[i] = nums[i + 1]，那么&#123;-1，-1，2&#125;这个结果不会被选中</span><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) <br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>, right = nums.length - <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 只能选取数组中不同下标的三个数，所以left == right时会使用同一个数，不执行</span><br>            <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> nums[i] + nums[left] + nums[right];<br>                <span class="hljs-keyword">if</span> (sum &lt; <span class="hljs-number">0</span>)<br>                    ++left;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; <span class="hljs-number">0</span>)<br>                    --right;<br>                <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// sum == 0</span><br>                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));<br>                    <span class="hljs-comment">// 去重</span><br>                    <span class="hljs-comment">// 必须在添加完结果后去重，不然第一次的结果可能无法添加</span><br>                    <span class="hljs-keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>])<br>                        --right;<br>                    <span class="hljs-keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>])<br>                        ++left;<br>                    <span class="hljs-comment">// 为什么两个指针都移动？去重之后，只移动一个，结果必定不等于0</span><br>                    --right;<br>                    ++left;<br>                &#125; <br><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230411110927008.png" alt="image-20230411110927008" style="zoom:50%;" /></p><h3 id="四数之和"><a href="https://leetcode.cn/problems/4sum/">18. 四数之和</a></h3><ol type="1"><li><p><strong>注意事项</strong>：nums[i]的范围，如果4个数都等于<span class="math inline">\(10^9\)</span>，</p><p>那么将大于<span class="math inline">\(2^{31} - 1= 2147483648 &lt; 2.15 * 10^9\)</span>(int最大的正数)，所以要用long记录四数之和</p><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230411112910460.png" alt=" " style="zoom:50%;" /></p></li><li><p>在三数之和的基础上，再增加一层循环，</p><p>区间为[nums[i], nums[left], nums[right], nums[j]]</p></li><li><p>时间复杂度：<span class="math inline">\(O(n^3)\)</span>，三层循环</p></li><li><p>空间复杂度：<span class="math inline">\(O(n)\)</span>，排序使用了额外的数组存储数组nums的副本</p></li></ol><h4 id="剪枝">剪枝</h4><ol type="1"><li><p><strong>第一层循环中，如果最小的四数之和大于target，那么后面的数更大，break</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">\\ 第一层循环<br><span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span>) nums[i] + nums[i + <span class="hljs-number">1</span>] + nums[i + <span class="hljs-number">2</span>] + nums[i + <span class="hljs-number">1</span>] &gt; target)<br>    <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure></li><li><p><strong>第二层循环中，如果最大的四数之和小于target，那么前面的数更小，break</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">\\ 第二层循环<br><span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span>) nums[i] + nums[j] + nums[j - <span class="hljs-number">1</span>] + nums[j - <span class="hljs-number">2</span>] &lt; target)<br>    <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure></li></ol><p>完整代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">fourSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span> (length &lt; <span class="hljs-number">4</span>)<br>            <span class="hljs-keyword">return</span> result;<br>        Arrays.sort(nums);<br>        <span class="hljs-comment">// window: [nums[i], nums[left], nums[right], nums[j]]</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length - <span class="hljs-number">3</span>; ++i) &#123;<br>            <span class="hljs-comment">// 去重</span><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>])<br>                <span class="hljs-keyword">continue</span>;<br>            <br>            <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span>) nums[i] + nums[i + <span class="hljs-number">1</span>] + nums[i + <span class="hljs-number">2</span>] + nums[i + <span class="hljs-number">1</span>] &gt; target)<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">// 第4个数从尾开始遍历，举例&#123;-1, -1, 0, 2&#125;来确定j &gt; 2这个边界条件</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> length - <span class="hljs-number">1</span>; j &gt; <span class="hljs-number">2</span>; --j) &#123;<br>                <span class="hljs-comment">// 去重，如果使用nums[j] == nums[j - 1]判断，nums[j - 1]属于right的范围</span><br>                <span class="hljs-comment">// 那么&#123;-1，-1，1, 1&#125;这个结果不会被选中</span><br>                <span class="hljs-keyword">if</span> (j &lt; length - <span class="hljs-number">1</span> &amp;&amp; nums[j] == nums[j + <span class="hljs-number">1</span>])<br>                    <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span>) nums[i] + nums[j] + nums[j - <span class="hljs-number">1</span>] + nums[j - <span class="hljs-number">2</span>] &lt; target)<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>, right = j - <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">// 只能选取数组中不同下标的三个数，所以left == right时会使用同一个数，不执行</span><br>                <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>                    <span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> (<span class="hljs-type">long</span>) nums[i] + nums[left] + nums[right] + nums[j];<br>                    <span class="hljs-keyword">if</span> (sum &lt; target)<br>                        ++left;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; target)<br>                        --right;<br>                    <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// sum == target</span><br>                        result.add(Arrays.asList(nums[i], nums[left], nums[right], nums[j]));<br>                        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>])<br>                            ++left;<br>                        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>])<br>                            --right;<br>                        ++left;<br>                        --right;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230411121859458.png" alt="image-20230411121859458" style="zoom:50%;" /></p><h3 id="剑指-offer-ii-030.-插入删除和随机访问都是-o1-的容器"><a href="https://leetcode.cn/problems/FortPu/">剑指 Offer II 030. 插入、删除和随机访问都是 O(1) 的容器</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RandomizedSet</span> &#123;<br><br>    List&lt;Integer&gt; list;<br>    Map&lt;Integer, Integer&gt; map;<br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RandomizedSet</span><span class="hljs-params">()</span> &#123;<br>        list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Inserts a value to the set. Returns true if the set did not already contain the specified element. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span> (map.containsKey(val))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        list.add(val);<br>        map.put(val, list.size() - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Removes a value from the set. Returns true if the set contained the specified element. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!map.containsKey(val))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> map.get(val);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">lastVal</span> <span class="hljs-operator">=</span> list.get(list.size() - <span class="hljs-number">1</span>);<br>        list.set(index, lastVal);<br>        list.remove(list.size() - <span class="hljs-number">1</span>);<br>        map.put(lastVal ,index);<br>        map.remove(val);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Get a random element from the set. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getRandom</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>        <span class="hljs-keyword">return</span> list.get(random.nextInt(list.size()));<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your RandomizedSet object will be instantiated and called as such:</span><br><span class="hljs-comment"> * RandomizedSet obj = new RandomizedSet();</span><br><span class="hljs-comment"> * boolean param_1 = obj.insert(val);</span><br><span class="hljs-comment"> * boolean param_2 = obj.remove(val);</span><br><span class="hljs-comment"> * int param_3 = obj.getRandom();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230510160353588.png" alt="image-20230510160353588" style="zoom:50%;" /></p><h3 id="剑指-offer-ii-031.-最近最少使用缓存"><a href="https://leetcode.cn/problems/OrIXps/">剑指 Offer II 031. 最近最少使用缓存</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;<br>        <span class="hljs-type">int</span> key;<br>        <span class="hljs-type">int</span> val;<br>        ListNode pre;<br>        ListNode next;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">ListNode</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> val)</span> &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>            <span class="hljs-built_in">this</span>.key = key;<br>        &#125;<br>    &#125;<br>    ListNode head, tail;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;<br>    Map&lt;Integer, ListNode&gt; map;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LRUCache</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>        head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>);<br>        tail = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>);<br>        head.next = tail;<br>        tail.pre = head;<br>        map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!map.containsKey(key))<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        moveToTail(key);<br>        <span class="hljs-keyword">return</span> map.get(key).val;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-keyword">if</span> (map.containsKey(key)) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> map.get(key);<br>            node.val = value;<br>            map.put(key, node);<br>            moveToTail(key);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// do not exist</span><br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(key, value);<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.capacity != map.size()) &#123; <span class="hljs-comment">// not full</span><br>                insertAtTail(node);<br>                map.put(key, node);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// full</span><br>                <span class="hljs-type">ListNode</span> <span class="hljs-variable">toDelete</span> <span class="hljs-operator">=</span> head.next;<br>                delete(toDelete);<br>                map.remove(toDelete.key);<br>                insertAtTail(node);<br>                map.put(key, node);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveToTail</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> map.get(key);<br>        <span class="hljs-keyword">if</span> (node.next == tail)<br>            <span class="hljs-keyword">return</span>;<br>        delete(node);<br>        insertAtTail(node);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(ListNode node)</span> &#123;<br>        node.pre.next = node.next;<br>        node.next.pre = node.pre;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertAtTail</span><span class="hljs-params">(ListNode node)</span> &#123;<br>        node.pre = tail.pre;<br>        node.next = tail;<br>        node.pre.next = node;<br>        tail.pre = node;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your LRUCache object will be instantiated and called as such:</span><br><span class="hljs-comment"> * LRUCache obj = new LRUCache(capacity);</span><br><span class="hljs-comment"> * int param_1 = obj.get(key);</span><br><span class="hljs-comment"> * obj.put(key,value);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230510164346020.png" alt="image-20230510164346020" style="zoom:50%;" /></p><h2 id="stack-and-queue">Stack and Queue</h2><h3 id="用栈实现队列"><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></h3><p><strong>解题思路</strong>：使用两个栈，inStack,outStack来实现队列。</p><p>push：直接将元素push进inStack</p><p>pop：如果outStack不为空，则弹出outStack顶部元素；如果outStack为空，则将inStack中的元素全部弹入inStack，再弹出outStack顶部元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; inStack;<br>    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; outStack;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyQueue</span><span class="hljs-params">()</span> &#123;<br>        inStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        outStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    &#125;<br>    <br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        inStack.push(x);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (outStack.isEmpty()) &#123;<br>           pushIntoOut();<br>        &#125;<br>        <span class="hljs-keyword">return</span> outStack.pop();<br><br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (outStack.isEmpty()) <br>            pushIntoOut();<br>        <span class="hljs-keyword">return</span> outStack.peek();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">empty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> inStack.isEmpty() &amp;&amp; outStack.isEmpty();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pushIntoOut</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (!inStack.isEmpty()) &#123;<br>            outStack.push(inStack.pop());<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyQueue obj = new MyQueue();</span><br><span class="hljs-comment"> * obj.push(x);</span><br><span class="hljs-comment"> * int param_2 = obj.pop();</span><br><span class="hljs-comment"> * int param_3 = obj.peek();</span><br><span class="hljs-comment"> * boolean param_4 = obj.empty();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230414093413671.png" alt="image-20230414093413671" style="zoom:50%;" /></p><h3 id="用队列实现栈"><a href="https://leetcode.cn/problems/implement-stack-using-queues/">225. 用队列实现栈</a></h3><h4 id="方法一单队列">方法一：单队列</h4><p>push：直接将元素加入queue</p><p>pop()：首先将队列元素移除并重新加入queue.size() - 1次，这样底部的元素就在队列首部了，poll出来即可</p><p>peek()：首先将队列元素移除并重新加入queue.size() - 1次，这样底部的元素就在队列首部了，<strong>先用result接收queue.peek()，再将这个元素移除并重新加入，最后返回result</strong>，peek()操作是不能改变内部数据的！！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Queue&lt;Integer&gt; queue;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyStack</span><span class="hljs-params">()</span> &#123;<br>        queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        queue.offer(x);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        catchBottom();<br>        <span class="hljs-keyword">return</span> queue.poll();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>        catchBottom();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> queue.peek();<br>        queue.offer(queue.poll());<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">empty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> queue.isEmpty();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">catchBottom</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; queue.size() - <span class="hljs-number">1</span>; ++i) &#123;<br>            queue.offer(queue.poll());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230414095606813.png" alt="image-20230414095606813" style="zoom:50%;" /></p><h5 id="优化-1"><strong>优化</strong></h5><p><strong>在面对大量需要查看顶部元素业务的时候，每次都要重新出队入队n次，不如在push的时候就排好序，</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    queue.offer(x);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; queue.size() - <span class="hljs-number">1</span>; ++i) &#123;<br>        queue.offer(queue.poll());<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> queue.poll();<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> queue.peek();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方法二双队列">方法二：双队列</h4><p>push：先在辅助队列supportQueue中加入目标数据，再将主队列queue中的数据全部弹出并加入到supportQueue中，这个时候supportQueue就是先进后出的排列顺序，最后将queue和support交换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack</span> &#123;<br><br>    Queue&lt;Integer&gt; queue, supportQueue;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyStack</span><span class="hljs-params">()</span> &#123;<br>        queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        supportQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        supportQueue.offer(x);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            supportQueue.offer(queue.poll());<br>        &#125;<br>        Queue&lt;Integer&gt; temp = queue;<br>        queue = supportQueue;<br>        supportQueue = temp;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> queue.poll();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> queue.peek();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">empty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> queue.isEmpty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230414105115572.png" alt="image-20230414105115572" style="zoom:50%;" /></p><h3 id="有效的括号"><a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></h3><h4 id="方法一hashmap-stack">方法一：HashMap + Stack</h4><p><strong>注意事项：</strong>如果是左括号，直接push进栈</p><p>如果是右括号，如果栈为空那么匹配不了；如果右括号和栈顶部的左括号不匹配，也不满足</p><p>最后如果栈空，则是有效的括号；否则不是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String s)</span> &#123;<br>        Map&lt;Character, Character&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-string">&#x27;&#123;&#x27;</span>, <span class="hljs-string">&#x27;&#125;&#x27;</span>);<br>        map.put(<span class="hljs-string">&#x27;(&#x27;</span>, <span class="hljs-string">&#x27;)&#x27;</span>);<br>        map.put(<span class="hljs-string">&#x27;[&#x27;</span>, <span class="hljs-string">&#x27;]&#x27;</span>);<br>        Stack&lt;Character&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); ++i) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-keyword">if</span> (map.containsKey(c))<br>                stack.push(c);<br>            <span class="hljs-keyword">else</span> &#123;    <br>                <span class="hljs-keyword">if</span> (stack.isEmpty() || map.get(stack.pop()) != c) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack.isEmpty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230414114954260.png" alt="image-20230414114954260" style="zoom:50%;" /></p><h3 id="删除字符串中的所有相邻重复项"><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">1047. 删除字符串中的所有相邻重复项</a></h3><h4 id="方法一stringbuilder">方法一：StringBuilder</h4><p>如果当前字符和前一个字符相等，则删除当前字符；否则加入当前字符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">removeDuplicates</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); ++i) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-keyword">if</span> (sb.length() == <span class="hljs-number">0</span> || c != sb.charAt(index)) &#123;<br>                sb.append(c);<br>                ++index;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                sb.deleteCharAt(index);<br>                --index;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230414133222696.png" alt="image-20230414133222696" style="zoom:50%;" /></p><h3 id="逆波兰表达式求值"><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值</a></h3><p><strong>解题思路</strong>： 遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">evalRPN</span><span class="hljs-params">(String[] tokens)</span> &#123;<br>        Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; tokens.length; ++i) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> tokens[i];<br>            <span class="hljs-keyword">if</span> (isNumber(token)) <br>                stack.push(Integer.parseInt(token));<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> stack.pop(), a = stack.pop();<br>                <span class="hljs-keyword">switch</span> (token) &#123;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;+&quot;</span>:<br>                        stack.push(a + b);<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;-&quot;</span>:<br>                        stack.push(a - b);<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;*&quot;</span>:<br>                        stack.push(a * b);<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/&quot;</span>:<br>                        stack.push(a / b);<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">default</span>:<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack.pop();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isNumber</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">return</span> !(s.equals(<span class="hljs-string">&quot;+&quot;</span>) || s.equals(<span class="hljs-string">&quot;-&quot;</span>) || s.equals(<span class="hljs-string">&quot;*&quot;</span>) || s.equals(<span class="hljs-string">&quot;/&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230414143824186.png" alt="image-20230414143824186" style="zoom:50%;" /></p><p><strong>注意事项</strong>：</p><p>在Java中，<code>==</code>和<code>.equals()</code>都是用于比较两个对象是否相等的操作符。但是它们之间存在着不同的用法和含义。</p><p><code>==</code>用于比较两个对象的引用是否相等，也就是判断这两个对象是否是同一个对象。当比较两个基本数据类型的值时，它们的值相等时返回true；当比较两个引用类型的对象时，如果它们所指向的内存地址相同，也就是它们是同一个对象时，返回true；否则返回false。</p><p><code>.equals()</code>方法用于比较两个对象的内容是否相等。默认情况下，<code>.equals()</code>方法比较的是两个对象的引用是否相等，也就是使用<code>==</code>比较，但是我们可以通过重写<code>.equals()</code>方法来自定义比较规则，比如根据对象的属性值来比较是否相等。</p><p>对于字符串类型的变量来说，<code>==</code>和<code>.equals()</code>方法的区别如下：</p><ul><li><code>==</code>比较的是字符串对象的引用是否相等，也就是它们是否指向同一个内存地址。</li><li><code>.equals()</code>方法比较的是字符串对象的内容是否相等，也就是它们包含的字符序列是否相同。</li></ul><p>因为Java中字符串是一个特殊的对象类型，为了方便字符串的比较操作，Java中提供了一种特殊的机制，也就是"字符串常量池"，它可以缓存字符串对象，使得多个字符串对象可以共享同一个对象，也就是它们的引用相等。在这种情况下，<code>==</code>操作符会返回true。但是在其他情况下，如果不是使用相同的字符串字面量来创建字符串对象，<code>==</code>操作符会返回false，此时需要使用<code>.equals()</code>方法来进行字符串的内容比较。</p><h3 id="滑动窗口最大值"><a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></h3><h4 id="方法一暴力超时">方法一：暴力（超时）</h4><ol type="1"><li>时间复杂度：<span class="math inline">\(O(kn)\)</span></li><li>空间复杂度：<span class="math inline">\(O(n)\)</span>，存储结果的数组</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] maxSlidingWindow(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n - k + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (k &gt; n)<br>            <span class="hljs-keyword">return</span> result;<br>        <span class="hljs-comment">// [i, i + k)</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; result.length; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; i + k; ++j) &#123;<br>                max = Math.max(max, nums[j]);<br>            &#125;<br>            result[i] = max;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230414150733050.png" alt="image-20230414150733050" style="zoom:50%;" /></p><h4 id="方法二单调队列">方法二：单调队列</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] maxSlidingWindow(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length - k + <span class="hljs-number">1</span>;<br>        Deque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>            <span class="hljs-keyword">while</span> (!deque.isEmpty() &amp;&amp; nums[i] &gt; nums[deque.peekLast()]) &#123;<br>                deque.pollLast();<br>            &#125;<br>            deque.offerLast(i);<br>        &#125;<br>        <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        result[<span class="hljs-number">0</span>] = nums[deque.peekFirst()];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k; i &lt; nums.length; ++i) &#123;<br>            <span class="hljs-keyword">while</span> (!deque.isEmpty() &amp;&amp; nums[i] &gt; nums[deque.peekLast()]) &#123;<br>                deque.pollLast();<br>            &#125;<br>            deque.offerLast(i);<br>            <span class="hljs-comment">// 如果i的左区间在队首元素右边，则要移除队首元素; 用if就可以了(while也行)</span><br>            <span class="hljs-keyword">if</span> (deque.peekFirst() &lt;= i - k) &#123;<br>                deque.pollFirst();<br>            &#125;<br>            result[i - k + <span class="hljs-number">1</span>] = nums[deque.peekFirst()];<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230414162623319.png" alt="image-20230414162623319" style="zoom:50%;" /></p><h3 id="前-k-个高频元素"><a href="https://leetcode.cn/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] topKFrequent(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i) &#123;<br>            map.put(nums[i], map.getOrDefault(nums[i], <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;<span class="hljs-type">int</span>[]&gt;() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">int</span>[] m, <span class="hljs-type">int</span>[] n)</span> &#123;<br>                <span class="hljs-keyword">return</span> m[<span class="hljs-number">1</span>] - n[<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry: map.entrySet()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> entry.getKey(), count = entry.getValue();<br>            <span class="hljs-keyword">if</span> (queue.size() == k) &#123;<br>                <span class="hljs-keyword">if</span> (count &gt; queue.peek()[<span class="hljs-number">1</span>]) &#123;<br>                    queue.poll();<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;num, count&#125;);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;num, count&#125;);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>            result[i] = queue.poll()[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230414172344927.png" alt="image-20230414172344927" style="zoom:50%;" /></p><h3 id="优先级队列大根堆小根堆">优先级队列（大根堆、小根堆）</h3><p>Java中可以使用PriorityQueue类来创建优先级队列，它实现了一个基于优先级堆的无界优先级队列。</p><p>要创建一个大根堆，需要使用Comparator.reverseOrder()方法来创建一个反转自然顺序的比较器，示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">PriorityQueue&lt;Integer&gt; maxHeap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(Comparator.reverseOrder());<br>maxHeap.add(<span class="hljs-number">5</span>);<br>maxHeap.add(<span class="hljs-number">1</span>);<br>maxHeap.add(<span class="hljs-number">10</span>);<br>System.out.println(maxHeap.poll()); <span class="hljs-comment">// 输出10</span><br></code></pre></td></tr></table></figure><p>要创建一个小根堆，只需要使用默认的比较器即可，示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">PriorityQueue&lt;Integer&gt; minHeap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>minHeap.add(<span class="hljs-number">5</span>);<br>minHeap.add(<span class="hljs-number">1</span>);<br>minHeap.add(<span class="hljs-number">10</span>);<br>System.out.println(minHeap.poll()); <span class="hljs-comment">// 输出1</span><br></code></pre></td></tr></table></figure><p>在上述示例中，我们首先创建了一个空的优先级队列，然后使用add()方法向其中添加元素，使用poll()方法从队列中取出元素并删除。由于大根堆和小根堆的比较器不同，它们会按照不同的顺序取出元素。</p><p>除了示例中用到的add()和poll()方法之外，PriorityQueue类还提供了一些其他常用的方法，下面对一些常用方法进行补充说明：</p><p>offer(E e): 添加元素到队列中，如果队列已满则抛出异常。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lasso">arduinoCopy codePriorityQueue&lt;<span class="hljs-built_in">Integer</span>&gt; <span class="hljs-built_in">queue</span> = <span class="hljs-literal">new</span> PriorityQueue&lt;&gt;();<br><span class="hljs-built_in">queue</span>.offer(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>peek(): 获取但不删除队列的头部元素，如果队列为空则返回null。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lasso">arduinoCopy codePriorityQueue&lt;<span class="hljs-built_in">Integer</span>&gt; <span class="hljs-built_in">queue</span> = <span class="hljs-literal">new</span> PriorityQueue&lt;&gt;();<br><span class="hljs-built_in">queue</span>.offer(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">queue</span>.offer(<span class="hljs-number">2</span>);<br>System.out.println(<span class="hljs-built_in">queue</span>.peek()); <span class="hljs-comment">// 输出1</span><br></code></pre></td></tr></table></figure><p>remove(Object o): 从队列中删除指定的元素，如果队列中不存在该元素则返回false。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lasso">arduinoCopy codePriorityQueue&lt;<span class="hljs-built_in">Integer</span>&gt; <span class="hljs-built_in">queue</span> = <span class="hljs-literal">new</span> PriorityQueue&lt;&gt;();<br><span class="hljs-built_in">queue</span>.offer(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">queue</span>.offer(<span class="hljs-number">2</span>);<br><span class="hljs-built_in">queue</span>.offer(<span class="hljs-number">3</span>);<br>System.out.println(<span class="hljs-built_in">queue</span>.remove(<span class="hljs-number">2</span>)); <span class="hljs-comment">// 输出true</span><br>System.out.println(<span class="hljs-built_in">queue</span>.remove(<span class="hljs-number">4</span>)); <span class="hljs-comment">// 输出false</span><br>System.out.println(<span class="hljs-built_in">queue</span>); <span class="hljs-comment">// 输出[3, 1]</span><br></code></pre></td></tr></table></figure><p>size(): 返回队列中元素的数量。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lasso">arduinoCopy codePriorityQueue&lt;<span class="hljs-built_in">Integer</span>&gt; <span class="hljs-built_in">queue</span> = <span class="hljs-literal">new</span> PriorityQueue&lt;&gt;();<br><span class="hljs-built_in">queue</span>.offer(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">queue</span>.offer(<span class="hljs-number">2</span>);<br><span class="hljs-built_in">queue</span>.offer(<span class="hljs-number">3</span>);<br>System.out.println(<span class="hljs-built_in">queue</span>.size()); <span class="hljs-comment">// 输出3</span><br></code></pre></td></tr></table></figure><p>clear(): 删除队列中的所有元素。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lasso">arduinoCopy codePriorityQueue&lt;<span class="hljs-built_in">Integer</span>&gt; <span class="hljs-built_in">queue</span> = <span class="hljs-literal">new</span> PriorityQueue&lt;&gt;();<br><span class="hljs-built_in">queue</span>.offer(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">queue</span>.offer(<span class="hljs-number">2</span>);<br><span class="hljs-built_in">queue</span>.offer(<span class="hljs-number">3</span>);<br><span class="hljs-built_in">queue</span>.clear();<br>System.out.println(<span class="hljs-built_in">queue</span>); <span class="hljs-comment">// 输出[]</span><br></code></pre></td></tr></table></figure><p>还有一些其他的方法，如toArray()、contains()、addAll()等，可以参考Java官方文档进行学习。</p><h2 id="greedy">Greedy</h2><h3 id="分发饼干"><a href="https://leetcode.cn/problems/assign-cookies/">455. 分发饼干</a></h3><h4 id="方法一从小胃口开始喂小饼干">方法一：从小胃口开始喂小饼干</h4><ol type="1"><li>先把两个数组都升序排序，从左往右遍历</li><li>如果孩子满足度小于等于饼干满足度，那么++res，并让两个指针都往后移动一位</li><li>如果孩子满足度大于饼干满足度，使饼干的指针向后移动一位</li><li>直到任意一个指针超出数组范围为止</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findContentChildren</span><span class="hljs-params">(<span class="hljs-type">int</span>[] children, <span class="hljs-type">int</span>[] cookies)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Arrays.sort(children);<br>        Arrays.sort(cookies);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; children.length &amp;&amp; j &lt; cookies.length) &#123;<br>                <span class="hljs-keyword">if</span> (children[i] &lt;= cookies[j]) &#123;<br>                    ++res;<br>                    ++i;<br>                    ++j;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    ++j;                    <br>                &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230419130746268.png" alt="image-20230419130746268" style="zoom:50%;" /></p><h4 id="方法二从大胃口开始喂大饼干">方法二：从大胃口开始喂大饼干</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findContentChildren</span><span class="hljs-params">(<span class="hljs-type">int</span>[] children, <span class="hljs-type">int</span>[] cookies)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Arrays.sort(children);<br>        Arrays.sort(cookies);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> children.length - <span class="hljs-number">1</span>, j = cookies.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (children[i] &lt;= cookies[j]) &#123;<br>                ++res;<br>                --i;<br>                --j;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                --i;                    <br>            &#125;   <br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230419132114268.png" alt="image-20230419132114268" style="zoom:50%;" /></p><h3 id="摆动序列"><a href="https://leetcode.cn/problems/wiggle-subsequence/">376. 摆动序列</a></h3><h4 id="方法一排序删除连续重复元素dp不推荐">方法一：排序+删除连续重复元素+dp(不推荐)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">wiggleMaxLength</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 1.dp[i]:以nums[i]为结尾，最长的摆动序列</span><br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        list.add(nums[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] != nums[i - <span class="hljs-number">1</span>])<br>                list.add(nums[i]);<br>        &#125;<br>        Integer[] dummy = list.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[<span class="hljs-number">0</span>]);<br><br>        <span class="hljs-keyword">if</span> (dummy.length == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (dummy.length == <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[dummy.length];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// 2.状态转移方程：</span><br>        <span class="hljs-comment">// 1)nums[i] - nums[i - 1]与nums[i - 1] - nums[i- 2]异号：dp[i] = dp[i - 1] + 1</span><br>        <span class="hljs-comment">// 2)nums[i] - nums[i - 1]与nums[i - 1] - nums[i- 2]同号：dp[i] = dp[i - 1]</span><br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; dummy.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> ((dummy[i] - dummy[i - <span class="hljs-number">1</span>]) * (dummy[i - <span class="hljs-number">1</span>] - dummy[i - <span class="hljs-number">2</span>]) &lt; <span class="hljs-number">0</span>) &#123;<br>                dp[i] = dp[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((dummy[i] - dummy[i - <span class="hljs-number">1</span>]) * (dummy[i - <span class="hljs-number">1</span>] - dummy[i - <span class="hljs-number">2</span>]) &gt; <span class="hljs-number">0</span>) &#123;<br>                dp[i] = dp[i - <span class="hljs-number">1</span>];<br>            &#125;<br><br>            res = Math.max(res, dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230419144434630.png" alt="image-20230419144434630" style="zoom:50%;" /></p><h4 id="方法二贪心-1">方法二：贪心</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">wiggleMaxLength</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">preDiff</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, postDiff = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">1</span>; ++i) &#123;<br>            postDiff = nums[i + <span class="hljs-number">1</span>] - nums[i];<br>            <span class="hljs-keyword">if</span> ((preDiff &lt;= <span class="hljs-number">0</span> &amp;&amp; postDiff &gt; <span class="hljs-number">0</span>) || (preDiff &gt;= <span class="hljs-number">0</span> &amp;&amp; postDiff &lt; <span class="hljs-number">0</span>)) &#123;<br>                ++result;<br>                preDiff = postDiff;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="C:\Users\ning\AppData\Roaming\Typora\typora-user-images\image-20230505220242464.png" alt="image-20230505220242464" style="zoom:50%;" /></p><h4 id="方法三dp-1">方法三：DP</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">wiggleMaxLength</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-type">int</span>[] up = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n], down = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        up[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        down[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; nums[i - <span class="hljs-number">1</span>]) &#123;<br>                up[i] = Math.max(up[i - <span class="hljs-number">1</span>], down[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>                down[i] = down[i - <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] &lt; nums[i - <span class="hljs-number">1</span>]) &#123;<br>                up[i] = up[i - <span class="hljs-number">1</span>];<br>                down[i] = Math.max(down[i - <span class="hljs-number">1</span>], up[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                up[i] = up[i - <span class="hljs-number">1</span>];<br>                down[i] = down[i - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.max(up[n - <span class="hljs-number">1</span>], down[n - <span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230505225359864.png" alt="image-20230505225359864" style="zoom:50%;" /></p><h3 id="最大子数组和"><a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></h3><h4 id="方法一dp-6">方法一：DP</h4><ol type="1"><li>dp[i]：<strong>以nums[i]结尾的子数组的最大数组和</strong></li><li>状态转移方程：<ol type="1"><li>当dp[i - 1] &gt;= 0 时候，dp[i] = dp[i - 1] + nums[i]</li><li>当dp[i - 1] &lt; 0时候， dp[i] = nums[i]</li></ol></li><li>初始化：dp[0] = nums[0]</li><li>时间复杂度：<span class="math inline">\(O(n)\)</span></li><li>空间复杂度：<span class="math inline">\(O(n)\)</span></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">// dp[i]：以nums[i]结尾的子数组的最数组和</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> dp[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (dp[i - <span class="hljs-number">1</span>] &gt;= <span class="hljs-number">0</span>) &#123;<br>                dp[i] = dp[i - <span class="hljs-number">1</span>] + nums[i];<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// dp[i - 1] &lt; 0</span><br>                dp[i] = nums[i];<br>            &#125;<br>            res = Math.max(res, dp[i]);<br>        &#125;  <br>        <span class="hljs-keyword">return</span> res;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230419153618838.png" alt="image-20230419153618838" style="zoom:50%;" /></p><h4 id="方法二优化空间的dp">方法二：优化空间的DP</h4><p><strong>由于dp[i]只依赖dp[i - 1]，所以可以用一个长度为2的数组记录dp</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">// dp[i]：以nums[i]结尾的子数组的最数组和</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>] &gt;= <span class="hljs-number">0</span>) &#123;<br>                dp[i % <span class="hljs-number">2</span>] = dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>] + nums[i];<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// dp[i - 1] &lt; 0</span><br>                dp[i % <span class="hljs-number">2</span>] = nums[i];<br>            &#125;<br>            res = Math.max(res, dp[i % <span class="hljs-number">2</span>]);<br>        &#125;  <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="贪心">贪心</h4><ol type="1"><li>首先把记录结果的result初始化为最小值，以及count=0</li><li>遍历数组，count加上当前元素，如果count大于result，讲count值赋给result</li><li>如果count等于负数了，令count等于0，从下一个数开始重新计算</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i) &#123;<br>            count += nums[i];<br>            <span class="hljs-keyword">if</span> (count &gt; result) <br>                result = count;<br>            <span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">0</span>)<br>                count = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230419155937924.png" alt="image-20230419155937924" style="zoom:50%;" /></p><h3 id="买卖股票的最佳时机-ii-1"><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></h3><p><strong>只要下一天股票价格高于当天，那么就买入当前股票并在下一天卖出</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; prices.length - <span class="hljs-number">1</span>; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">diff</span> <span class="hljs-operator">=</span> prices[i + <span class="hljs-number">1</span>] - prices[i];<br>            <span class="hljs-keyword">if</span> (diff &gt; <span class="hljs-number">0</span>) &#123;<br>                res += diff;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230419161040019.png" alt="image-20230419161040019" style="zoom:50%;" /></p><h3 id="跳跃游戏"><a href="https://leetcode.cn/problems/jump-game/">55. 跳跃游戏</a></h3><h4 id="方法一贪心">方法一：贪心</h4><ol type="1"><li>初始化一个available数组，available[i]表示是否可以到底数组元素i</li><li>如果当前节点是可到达的，令i=0前往后遍历，把available数组从i+1开始，后nums[i]个元素都赋true</li><li>初始化：第一个元素是肯定能到达的，初始化为true</li><li>时间复杂度：<span class="math inline">\(O(n^2)\)</span>，最坏情况下，所有节点都刚好能到达数组倒数第二个元素，且倒数第二个元素的值为0，如[n - 2, n - 3, ..., 1, 0, 1]，需要遍历<span class="math inline">\(\frac{(n-1)(n-2)}{2}\)</span>次</li><li>空间复杂度：<span class="math inline">\(O(n)\)</span></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canJump</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">boolean</span>[] available = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n];<br>        available[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (available[i]) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; nums[i] + i + <span class="hljs-number">1</span>; ++j) &#123;<br>                    <span class="hljs-keyword">if</span> (j == n - <span class="hljs-number">1</span>)<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                    available[j] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> available[n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230419170117014.png" alt="image-20230419170117014" style="zoom:50%;" /></p><h4 id="方法二贪心优化空间复杂度">方法二：贪心（优化空间复杂度）</h4><p><strong>不必要用一个boolean数组来表示是否可以到达当前数组元素，可以用一个整数rightmost来判断</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canJump</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rightmost</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (i &lt;= rightmost) &#123;<br>                rightmost = Math.max(rightmost, i + nums[i]);<br>                <span class="hljs-keyword">if</span> (rightmost &gt;= n - <span class="hljs-number">1</span>)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;                <br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230419172725786.png" alt="image-20230419172725786" style="zoom:50%;" /></p><h3 id="跳跃游戏-ii"><a href="https://leetcode.cn/problems/jump-game-ii/">45. 跳跃游戏 II</a></h3><h4 id="方法一dp-7">方法一：dp</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">jump</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-comment">// 1.dp[i]：到达i的最小跳数</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Arrays.fill(dp, Integer.MAX_VALUE);<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; i + <span class="hljs-number">1</span> + nums[i]; ++j) &#123;<br>                dp[j] = Math.min(dp[j], dp[i] + <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span> (j == n - <span class="hljs-number">1</span>)<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;  <br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230419181353135.png" alt="image-20230419181353135" style="zoom:50%;" /></p><h4 id="方法二贪心-2">方法二：贪心</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">jump</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxDistance</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, end = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++i) &#123;<br>            maxDistance = Math.max(maxDistance, i + nums[i]);<br>            <span class="hljs-keyword">if</span> (i == end) &#123;<br>                end = maxDistance;<br>                ++result;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230420092238469.png" alt="image-20230420092238469" style="zoom:50%;" /></p><h3 id="k-次取反后最大化的数组和"><a href="https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/">1005. K 次取反后最大化的数组和</a></h3><ol type="1"><li>先创建一个小根堆，把数组所有元素都放进去</li><li>取反小根堆堆顶元素再放回小根堆，循环k次</li><li>时间复杂度：<span class="math inline">\(O(n)\)</span></li><li>空间复杂度：<span class="math inline">\(O(n)\)</span></li></ol><p>如果小根堆堆顶是负数<span class="math inline">\(x\)</span>，那么一定是最小的负数，取反后会是比较大的正数<span class="math inline">\(-x\)</span>；</p><p>如果小根堆堆顶是正数<span class="math inline">\(x\)</span>，那么是最小的正数，取反后是负数<span class="math inline">\(-x\)</span>，由于此时只有这一个负数，所以<span class="math inline">\(-x\)</span>是最小值，再放入堆顶，再取反又是最小的正数，循环到k为0为止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">largestSumAfterKNegations</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-comment">// 先创建一个小根堆，把数组所有元素都放进去</span><br>        <span class="hljs-comment">// 取反小根堆堆顶元素再放回小根堆，循环k次</span><br>        PriorityQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n : nums)<br>            queue.offer(n);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty() &amp;&amp; k &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> queue.poll();<br>            queue.offer(-<span class="hljs-number">1</span> * cur);<br>            --k;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            sum += queue.poll();<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230420094255341.png" alt="image-20230420094255341" style="zoom:50%;" /></p><h4 id="方法二优化方法一">方法二：优化方法一</h4><ol type="1"><li>先创建一个小根堆，把数组所有元素都放进去</li><li>首先小根堆弹出的元素<span class="math inline">\(x\)</span>如果是负数，就取反(最小的负数取反是比较大的正数),再放回小根堆</li><li>小根堆弹出的元素<span class="math inline">\(x\)</span>如果是是正数：此时<span class="math inline">\(k\)</span>值如果能被2整除，那么重复取反堆顶元素<span class="math inline">\(x\)</span>，最终<span class="math inline">\(x\)</span>不变，直接将<span class="math inline">\(x\)</span>加入堆中；如果<span class="math inline">\(k\)</span>值如果不能被2整除，那么将-x加入堆中</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">largestSumAfterKNegations</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-comment">// 先创建一个小根堆，把数组所有元素都放进去</span><br>        <span class="hljs-comment">// 要取反k次，首先小根堆弹出的元素x如果是负数，就取反(最小的负数取反是比较大的正数),再放回小根堆</span><br>        <span class="hljs-comment">// 小根堆弹出的元素x如果是是正数：此时k值如果能被2整除，那么重复取反堆顶元素x，最终x不变，直接将x加入堆中；如果k值如果不能被2整除，那么将-x加入堆中</span><br>        PriorityQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n : nums)<br>            queue.offer(n);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty() &amp;&amp; k &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> queue.poll();<br>            <span class="hljs-keyword">if</span> (cur &lt; <span class="hljs-number">0</span>) &#123;<br>                queue.offer(-<span class="hljs-number">1</span> * cur);<br>                --k;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// cur &gt;= 0</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">negPart</span> <span class="hljs-operator">=</span> k % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>                queue.offer(cur * negPart);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            sum += queue.poll();<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方法三贪心二刷">方法三：贪心(二刷)</h4><ol type="1"><li><p>首先将数组升序排序</p></li><li><p>进入for循环，<strong>注意循环的条件有两个，i &lt; nums.length || k &gt; 0</strong></p></li><li><p>当k==0时，说明已经翻转了k次，不需要继续执行程序了，break即可</p></li><li><p>if (i == nums.length)留到最后讲解</p></li><li><p>如果，nums[i] &lt;= 0，直接翻转即可；如果nums[i] &gt; 0，那么说明此时数组里已经没有负数了，那么需要找到最小的正数，并且将剩余需要翻转的次数都对这个数使用：最小的正数只可能是当前的数或者前一个位置的数，比如数组[-5, -4, -3, 2, 3, 5]，需要翻转四次，翻转四次后数组为[5, 4, 3, 2, 3, 5]，即负数部分翻转后是降序。如果k能被2整除，那么翻转k次后这个数还是保持不变；如果不能被2整除，翻转一次即可。最后break退出for循环</p></li><li><p>如果i == nums.length，但是k的次数还没用完，这种情况只可能是数组元素全为负的情况，如果有一个正数，k都会在</p><p>if (nums[i] &gt;= 0 &amp;&amp; i &gt; 0) 语句下被消化。这种情况下，一定是最后一个数最小，如果k不能被2整除，就nums[i - 1]翻转即可。比如数组为[-4, -3, -2]，需要翻转4次，翻转3次后数组为</p><p>[4, 3, 2]，此时i == nums.length，翻转2即可</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">largestSumAfterKNegations</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        Arrays.sort(nums);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length || k &gt; <span class="hljs-number">0</span>; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">if</span> (i == nums.length)<br>                 i--;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt;= <span class="hljs-number">0</span> &amp;&amp; i &gt; <span class="hljs-number">0</span>) &#123;<br>                i = nums[i] &gt; nums[i - <span class="hljs-number">1</span>] ? i - <span class="hljs-number">1</span> : i;<br>                <span class="hljs-keyword">if</span> (k % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>                    nums[i] *= -<span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            nums[i] *= -<span class="hljs-number">1</span>;<br>            --k;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Arrays.stream(nums).sum();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230508095011395.png" alt="image-20230508095011395" style="zoom:50%;" /></p><h3 id="加油站warning"><a href="https://leetcode.cn/problems/gas-station/">134. 加油站</a>:warning:</h3><h4 id="方法一贪心-1">方法一：贪心</h4><p><strong>首先如果总油量减去总消耗大于等于零那么一定可以跑完一圈</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">canCompleteCircuit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] gas, <span class="hljs-type">int</span>[] cost)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">curSum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">totalSum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; gas.length; i++) &#123;<br>            curSum += gas[i] - cost[i];<br>            totalSum += gas[i] - cost[i];<br>            <span class="hljs-keyword">if</span> (curSum &lt; <span class="hljs-number">0</span>) &#123;<br>                index = (i + <span class="hljs-number">1</span>) % gas.length ; <br>                curSum = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (totalSum &lt; <span class="hljs-number">0</span>) ? -<span class="hljs-number">1</span> : index;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230420114302981.png" alt="image-20230420114302981" style="zoom:50%;" /></p><h4 id="方法二最小累计值的下一站">方法二：最小累计值的下一站</h4><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230508115857758.png" alt="image-20230508115857758" style="zoom:50%;" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">canCompleteCircuit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] gas, <span class="hljs-type">int</span>[] cost)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rest</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">minDiff</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">minIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; gas.length; ++i) &#123;<br>            rest += gas[i] - cost[i];<br>            <span class="hljs-keyword">if</span> (rest &lt; minDiff) &#123;<br>                minDiff = rest;<br>                minIndex = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> rest &lt; <span class="hljs-number">0</span> ? -<span class="hljs-number">1</span> : (minIndex + <span class="hljs-number">1</span>) % gas.length;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230508114341620.png" alt="image-20230508114341620" style="zoom:50%;" /></p><h3 id="分发糖果"><a href="https://leetcode.cn/problems/candy/">135. 分发糖果</a></h3><p>先从左往右，再从右往左</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">candy</span><span class="hljs-params">(<span class="hljs-type">int</span>[] ratings)</span> &#123;<br>        <span class="hljs-type">int</span>[] candy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[ratings.length];<br>        Arrays.fill(candy, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; candy.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (ratings[i] &gt; ratings[i - <span class="hljs-number">1</span>]) <br>                candy[i] += candy[i - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> candy.length - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-keyword">if</span> (ratings[i - <span class="hljs-number">1</span>] &gt; ratings[i]) &#123;<br>                candy[i - <span class="hljs-number">1</span>] = Math.max(candy[i - <span class="hljs-number">1</span>], candy[i] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Arrays.stream(candy).sum();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230420134656982.png" alt="image-20230420134656982" style="zoom:50%;" /></p><h3 id="柠檬水找零"><a href="https://leetcode.cn/problems/lemonade-change/">860. 柠檬水找零</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">lemonadeChange</span><span class="hljs-params">(<span class="hljs-type">int</span>[] bills)</span> &#123;<br>        <span class="hljs-keyword">if</span> (bills[<span class="hljs-number">0</span>] != <span class="hljs-number">5</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">five</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, ten = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; bills.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (bills[i] == <span class="hljs-number">5</span>) &#123;<br>                ++five;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bills[i] == <span class="hljs-number">10</span>) &#123;<br>                <span class="hljs-keyword">if</span> (five &gt; <span class="hljs-number">0</span>) &#123;<br>                    --five;<br>                    ++ten;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (five &gt; <span class="hljs-number">0</span> &amp;&amp; ten &gt; <span class="hljs-number">0</span>) &#123;<br>                    --five;<br>                    --ten;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (five &gt;= <span class="hljs-number">3</span>) &#123;<br>                    five -= <span class="hljs-number">3</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230420143510176.png" alt="image-20230420143510176" style="zoom:50%;" /></p><h3 id="根据身高重建队列-warning"><a href="https://leetcode.cn/problems/queue-reconstruction-by-height/">406. 根据身高重建队列</a> :warning:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] reconstructQueue(<span class="hljs-type">int</span>[][] people) &#123;<br>        <span class="hljs-comment">// 先按照身高进行降序排序，再按照k进行升序排序</span><br>        Arrays.sort(people, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;<span class="hljs-type">int</span>[]&gt;() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">int</span>[] person1, <span class="hljs-type">int</span>[] person2)</span> &#123;<br>                <span class="hljs-keyword">if</span> (person1[<span class="hljs-number">0</span>] != person2[<span class="hljs-number">0</span>]) &#123;<br>                    <span class="hljs-keyword">return</span> person2[<span class="hljs-number">0</span>] - person1[<span class="hljs-number">0</span>];<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">return</span> person1[<span class="hljs-number">1</span>] - person2[<span class="hljs-number">1</span>];<br>                &#125;<br>            &#125;<br>        &#125;);<br>        List&lt;<span class="hljs-type">int</span>[]&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] person : people) &#123;<br>            list.add(person[<span class="hljs-number">1</span>], person);<br>        &#125;<br>        <span class="hljs-keyword">return</span> list.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[list.size()][]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230420153338251.png" alt="image-20230420153338251" style="zoom:50%;" /></p><h3 id="用最少数量的箭引爆气球"><a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/">452. 用最少数量的箭引爆气球</a></h3><p><strong>注意事项</strong>：</p><ol type="1"><li>compare方法用return p1[0] - p2[0]会越界！</li><li>从左往右遍历，如果左边气球的右边界大于等于右边气球的左边界，那么可以一箭双球，此时有可能有第三个气球和前面两个气球有重合，但是<strong>把第一个气球的右边界设置为重合气球右边界的最小值</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMinArrowShots</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] points)</span> &#123;<br>        Arrays.sort(points, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;<span class="hljs-type">int</span>[]&gt;() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">int</span>[] point1, <span class="hljs-type">int</span>[] point2)</span> &#123;<br>                <span class="hljs-keyword">return</span> Integer.compare(point1[<span class="hljs-number">0</span>], point2[<span class="hljs-number">0</span>]);<br>            &#125;<br>        &#125;);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">arrow</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">1</span>; j &lt; points.length; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (points[i][<span class="hljs-number">1</span>] &gt;= points[j][<span class="hljs-number">0</span>]) &#123;<br>                points[i][<span class="hljs-number">1</span>] = Math.min(points[i][<span class="hljs-number">1</span>], points[j][<span class="hljs-number">1</span>]);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                ++arrow;<br>                i = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> arrow;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230420161543557.png" alt="image-20230420161543557" style="zoom:50%;" /></p><h3 id="无重叠区间"><a href="https://leetcode.cn/problems/non-overlapping-intervals/">435. 无重叠区间</a></h3><h4 id="方法一">方法一：</h4><p>比较器按以下方法来，不然容易出错！！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">Arrays.sort(intervals, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;<span class="hljs-type">int</span>[]&gt;() &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">int</span>[] p1, <span class="hljs-type">int</span>[] p2)</span> &#123;<br>        <span class="hljs-keyword">if</span> (p1[<span class="hljs-number">0</span>] == p2[<span class="hljs-number">0</span>]) &#123;<br>            <span class="hljs-keyword">return</span> Integer.compare(p1[<span class="hljs-number">1</span>], p2[<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> Integer.compare(p1[<span class="hljs-number">0</span>], p2[<span class="hljs-number">0</span>]);<br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><ol type="1"><li>先定义比较器，如果p1, p2第一个元素不相等，则按照第一个元素升序排序；如果第一个元素相等，则按照第二个元素升序排序</li><li>双指针从前往后遍历，初始i=0，j=1</li><li>当intervals[i]与intervals[j]的第一个元素相等，那么必定要移除其中一个，由于比较器的排序，intervals[j]的区间更大，那么选择移除intervals[j]，答案只需要返回最少移除了多少个数，所以将表示删除元素个数的变量erase加一，让j后移即可</li><li>当intervals[i]与intervals[j]的第一个元素不相等时候，分两种情况讨论<ol type="1"><li>如果intervals[i]的第二个元素 &gt; intervals[j]的第一个元素，此时区间重合，删除第二个元素即可，将表示删除元素个数的变量erase加一；如果此时intervals[i]的第二个元素 &gt; intervals[j]的第二个元素，说明intervals[i]包含 intervals[j]，那么此时必定删除 intervals[i]，将i指向j表示删除 intervals[i]这个元素</li><li>如果intervals[i]的第二个元素 &lt;= intervals[j]的第一个元素，那么i与j之间的元素都不重复，将i移动到j的位置</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">eraseOverlapIntervals</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] intervals)</span> &#123;<br>        Arrays.sort(intervals, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;<span class="hljs-type">int</span>[]&gt;() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">int</span>[] p1, <span class="hljs-type">int</span>[] p2)</span> &#123;<br>                <span class="hljs-keyword">if</span> (p1[<span class="hljs-number">0</span>] == p2[<span class="hljs-number">0</span>]) &#123;<br>                    <span class="hljs-keyword">return</span> Integer.compare(p1[<span class="hljs-number">1</span>], p2[<span class="hljs-number">1</span>]);<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">return</span> Integer.compare(p1[<span class="hljs-number">0</span>], p2[<span class="hljs-number">0</span>]);<br>                &#125;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">erase</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, n = intervals.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">1</span>; j &lt; n; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (intervals[i][<span class="hljs-number">0</span>] == intervals[j][<span class="hljs-number">0</span>]) &#123;<br>                ++erase;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (intervals[i][<span class="hljs-number">1</span>] &gt; intervals[j][<span class="hljs-number">0</span>]) &#123;<br>                    ++erase;<br>                    <span class="hljs-keyword">if</span> (intervals[i][<span class="hljs-number">1</span>] &gt;= intervals[j][<span class="hljs-number">1</span>]) &#123;<br>                        i = j;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// intervals[i][1] &lt;= intervals[j][0]</span><br>                    i = j;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> erase;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230420170213502.png" alt="image-20230420170213502" style="zoom:50%;" /></p><h4 id="方法二右边界取最小的">方法二：右边界取最小的</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">eraseOverlapIntervals</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] intervals)</span> &#123;<br>        Arrays.sort(intervals, (a,b)-&gt; &#123;<br>            <span class="hljs-keyword">return</span> Integer.compare(a[<span class="hljs-number">0</span>],b[<span class="hljs-number">0</span>]);<br>        &#125;);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i &lt; intervals.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(intervals[i][<span class="hljs-number">0</span>] &lt; intervals[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>])&#123;<br>                ++count;<br>                intervals[i][<span class="hljs-number">1</span>] = Math.min(intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], intervals[i][<span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] is : intervals) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : is) &#123;<br>                System.out.print(i + <span class="hljs-string">&quot;,&quot;</span>);<br>            &#125;<br>            System.out.println();<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230421092251721.png" alt="image-20230421092251721" style="zoom:50%;" /></p><h4 id="二刷左边界升序排序">二刷：左边界升序排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">eraseOverlapIntervals</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] intervals)</span> &#123;<br>        Arrays.sort(intervals, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;<span class="hljs-type">int</span>[]&gt;() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span>[] b)</span> &#123;<br>                <span class="hljs-keyword">if</span> (a[<span class="hljs-number">0</span>] == b[<span class="hljs-number">0</span>])<br>                    <span class="hljs-keyword">return</span> Integer.compare(a[<span class="hljs-number">1</span>], b[<span class="hljs-number">1</span>]);<br>                <span class="hljs-keyword">else</span> <br>                    <span class="hljs-keyword">return</span> Integer.compare(a[<span class="hljs-number">0</span>], b[<span class="hljs-number">0</span>]);<br>            &#125;<br>        &#125;);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">1</span>; j &lt; intervals.length; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (intervals[i][<span class="hljs-number">1</span>] &gt; intervals[j][<span class="hljs-number">0</span>]) &#123;<br>                intervals[i][<span class="hljs-number">1</span>] = Math.min(intervals[i][<span class="hljs-number">1</span>], intervals[j][<span class="hljs-number">1</span>]);<br>                ++res;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                i = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230510141839941.png" alt="image-20230510141839941" style="zoom:50%;" /></p><h3 id="划分字母区间-warning"><a href="https://leetcode.cn/problems/partition-labels/">763. 划分字母区间</a> :warning:</h3><h4 id="方法一贪心-2">方法一：贪心</h4><ol type="1"><li>首先创建一个长度为26的整型数组，统计每次字符出现的最远位置</li><li>遍历字符串，不断更新右边界的值</li><li>当当前下标i与右边界相等时，那么就将right-i+1记录</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">partitionLabels</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span>[] ch = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); ++i) &#123;<br>            ch[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>] = i;<br>        &#125;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); ++i) &#123;<br>            right = Math.max(right, ch[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]);<br>            <span class="hljs-keyword">if</span> (i == right) &#123;<br>                res.add(right - left + <span class="hljs-number">1</span>);<br>                left = i + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;   <br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230421101328612.png" alt="image-20230421101328612" style="zoom:50%;" /></p><h3 id="合并区间"><a href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间</a></h3><h4 id="方法一-1">方法一：</h4><ol type="1"><li>遍历数组，如果后一个元素的左边界大于等于前一个元素的右边界，那么修改后一个元素的左边界为两元素左边界最小的值，修改后一个元素的右边界为两元素右边界最大的值</li><li>如果后一个元素左边界大于前一个元素的右边界，直接把前一个元素加入结果list中</li><li>最后再把最后一个元素(修改过)加入结果list中</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] merge(<span class="hljs-type">int</span>[][] intervals) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> intervals.length;<br>        Arrays.sort(intervals, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;<span class="hljs-type">int</span>[]&gt;() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">int</span>[] p1, <span class="hljs-type">int</span>[] p2)</span> &#123;<br>                <span class="hljs-keyword">return</span> Integer.compare(p1[<span class="hljs-number">0</span>], p2[<span class="hljs-number">0</span>]);<br>            &#125;<br>        &#125;);<br>        List&lt;<span class="hljs-type">int</span>[]&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (intervals[i + <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] &lt;= intervals[i][<span class="hljs-number">1</span>]) &#123;<br>                intervals[i + <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = Math.min(intervals[i + <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], intervals[i][<span class="hljs-number">0</span>]);<br>                intervals[i + <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = Math.max(intervals[i + <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], intervals[i][<span class="hljs-number">1</span>]); <br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;intervals[i][<span class="hljs-number">0</span>], intervals[i][<span class="hljs-number">1</span>]&#125;);<br>            &#125;<br>        &#125;<br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;intervals[n - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], intervals[n - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]&#125;);<br>        <span class="hljs-keyword">return</span> res.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[res.size()][]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230421105346150.png" alt="image-20230421105346150" style="zoom:50%;" /></p><h4 id="方法二射气球的思路">方法二：射气球的思路</h4><ol type="1"><li><p>首先将数组按照左边界升序排序</p></li><li><p>当intervals[i][1] &gt;= intervals[j][0]，那么这两个元素一定是要合并的，因为是intervals数组是按照左边界升序排序的，那么合并区间[a, b]的a一定是intervals[i][0]，将intervals[i][1]赋值为intervals[i][1]与intervals[j][1]的最大值</p></li><li><p>当intervals[i][1] &lt; intervals[j][0]，那么这个两个区间是不重合的，先把上一个重合区间加入结果集，再把j赋值给i，进行下一轮循环</p></li><li><p>当j == intervals.length - 1时候，</p><ol type="1"><li>如果intervals[i][1] &gt;= intervals[j][0]，那么会将intervals[i][1]取intervals[i][1]与intervals[j][1]的最大值</li><li>如果intervals[i][1] &lt; intervals[j][0]，那么会将之前的重合区间存入结果集，并将j赋值给i</li></ol><p>所以出循环，只需要把intervals[i]加入结果集就好！</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] merge(<span class="hljs-type">int</span>[][] intervals) &#123;<br>        Arrays.sort(intervals, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;<span class="hljs-type">int</span>[]&gt;() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span>[] b)</span> &#123;<br>                <span class="hljs-keyword">if</span> (a[<span class="hljs-number">0</span>] == b[<span class="hljs-number">0</span>])<br>                    <span class="hljs-keyword">return</span> Integer.compare(a[<span class="hljs-number">1</span>], b[<span class="hljs-number">1</span>]);<br>                <span class="hljs-keyword">else</span><br>                    <span class="hljs-keyword">return</span> Integer.compare(a[<span class="hljs-number">0</span>], b[<span class="hljs-number">0</span>]);<br>            &#125;<br>        &#125;);<br>        List&lt;<span class="hljs-type">int</span>[]&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; intervals.length; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (intervals[i][<span class="hljs-number">1</span>] &gt;= intervals[j][<span class="hljs-number">0</span>]) &#123;<br>                intervals[i][<span class="hljs-number">1</span>] = Math.max(intervals[i][<span class="hljs-number">1</span>], intervals[j][<span class="hljs-number">1</span>]);<br>            &#125;<br>            <span class="hljs-keyword">else</span>  &#123; <span class="hljs-comment">//  (intervals[i][1] &lt; intervals[j][0])</span><br>                res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;intervals[i][<span class="hljs-number">0</span>], intervals[i][<span class="hljs-number">1</span>]&#125;);<br>                i = j;<br>            &#125;<br>        &#125;<br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;intervals[i][<span class="hljs-number">0</span>], intervals[i][<span class="hljs-number">1</span>]&#125;);<br>        <span class="hljs-keyword">return</span> res.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[res.size()][]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230510145844887.png" alt="image-20230510145844887" style="zoom:50%;" /></p><h3 id="单调递增的数字"><a href="https://leetcode.cn/problems/monotone-increasing-digits/">738. 单调递增的数字</a></h3><ol type="1"><li><strong>从后往前遍历，如果有后一个数大于前一个数，那么就用flag记录后一个数的位置，循环结束后，从flag开始，把后面的数全部赋值‘9’</strong></li><li><strong>注意边界！！！</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">monotoneIncreasingDigits</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> String.valueOf(n);<br>        <span class="hljs-type">char</span>[] ch = str.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> ch.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> ch.length - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-keyword">if</span> (ch[i - <span class="hljs-number">1</span>] &gt; ch[i]) &#123;<br>                --ch[i - <span class="hljs-number">1</span>];<br>                flag = i;<br>            &#125;<br>        &#125;     <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> flag; i &lt; ch.length; ++i) &#123;<br>            ch[i] = <span class="hljs-string">&#x27;9&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Integer.parseInt(String.valueOf(ch));<br>    &#125;   <br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230421115750194.png" alt=" " style="zoom:50%;" /></p><h3 id="监控二叉树star"><a href="https://leetcode.cn/problems/binary-tree-cameras/">968. 监控二叉树</a>:star:</h3><h4 id="方法一贪心-3">方法一：贪心</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCameraCover</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-comment">// dfs后检查根节点是否被覆盖</span><br>        <span class="hljs-keyword">if</span> (dfs(root) == <span class="hljs-number">404</span>)<br>            ++result;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-comment">// state 404:未覆盖</span><br>        <span class="hljs-comment">// state 200:覆盖</span><br>        <span class="hljs-comment">// state 201:有监控</span><br>        <span class="hljs-comment">//叶节点的左右空孩子需要返回被覆盖，这样才不会在叶子节点上装监控</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">200</span>;<br>        <span class="hljs-comment">// post traversal</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftState</span> <span class="hljs-operator">=</span> dfs(root.left);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rightState</span> <span class="hljs-operator">=</span> dfs(root.right);<br>        <span class="hljs-comment">// 1.如果左右子树都被覆盖</span><br>        <span class="hljs-keyword">if</span> (leftState == <span class="hljs-number">200</span> &amp;&amp; rightState == <span class="hljs-number">200</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">404</span>;<br>        <span class="hljs-comment">// 2.如果左右子树至少有一个没被覆盖</span><br>        <span class="hljs-keyword">if</span> (leftState == <span class="hljs-number">404</span> || rightState == <span class="hljs-number">404</span>) &#123;<br>            ++result;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">201</span>;<br>        &#125;<br>        <span class="hljs-comment">// 3.如果左右子树至少有一个监控</span><br>        <span class="hljs-keyword">if</span> (leftState == <span class="hljs-number">201</span> || rightState == <span class="hljs-number">201</span>) <br>            <span class="hljs-keyword">return</span> <span class="hljs-number">200</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">666</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230511102457495.png" alt="image-20230511102457495" style="zoom:50%;" /></p><h2 id="backtracing">BackTracing</h2><h3 id="开始回溯前要知道的">开始回溯前要知道的</h3><p><a href="https://leetcode.cn/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/">详细讲解</a></p><figure><img src="https://pic.leetcode-cn.com/0bf18f9b86a2542d1f6aa8db6cc45475fce5aa329a07ca02a9357c2ead81eec1-image.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h5 id="注意"><strong>注意</strong></h5><p>如果递归终止条件是这个，那么结果回事全空</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (depth == len) &#123;<br>    res.add(path);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行 <code>main</code> 方法以后输出如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">[[], [], [], [], [], []]<br></code></pre></td></tr></table></figure><p>变量 <code>path</code> 所指向的列表 <strong>在深度优先遍历的过程中只有一份</strong> ，深度优先遍历完成以后，回到了根结点，成为空列表。</p><p>在 Java 中，参数传递是 <strong>值传递</strong>，对象类型变量在传参的过程中，复制的是变量的地址。这些地址被添加到 <code>res</code> 变量，但实际上指向的是同一块内存地址，因此我们会看到 6 个空的列表对象。解决的方法很简单，在 <code>res.add(path);</code> 这里做一次拷贝即可。</p><p>修改的部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (depth == len) &#123;<br>    res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="算法模板">算法模板</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(参数)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (终止条件) &#123;<br>        存放结果;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>        处理节点;<br>        <span class="hljs-built_in">backtracking</span>(路径，选择列表); <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="组合"><a href="https://leetcode.cn/problems/combinations/">77. 组合</a></h3><h4 id="方法一回溯">方法一：回溯</h4><ol type="1"><li>由于已知结果要存放的数组大小为k，所以res使用ArrayList</li><li>List没有removeLast方法，但是LinkedList中有！</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combine</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>        backtracing(n, k, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracing</span> <span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-keyword">if</span> (path.size() == k) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt;= n; ++i) &#123;<br>            path.add(i);<br>            backtracing(n, k, i + <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">// path.removeLast();</span><br>            path.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230424094647964.png" alt="image-20230424094647964" style="zoom:50%;" /></p><h4 id="方法二方法一剪枝">方法二：方法一+剪枝</h4><p>for循环横向遍历时候，i的执行条件为i &lt;= n - (k - path.size()) + 1</p><p>例如，当i = 2，path里已经有1，需要组合k=3个元素，n为4，那么 4 - (3 - 1) + 1 = 3，说明i最多等于3，组成path[1, 3, 4]，如果此时i = 4，那么就不能组成3个元素，只能组成[1,4]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combine</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>        backtracing(n, k, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracing</span> <span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-keyword">if</span> (path.size() == k) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt;= n - (k - path.size()) + <span class="hljs-number">1</span>; ++i) &#123;<br>            path.add(i);<br>            backtracing(n, k, i + <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">// path.removeLast();</span><br>            path.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230424094939069.png" alt="image-20230424094939069" style="zoom:50%;" /></p><h4 id="方法二选或不选">方法二：选或不选</h4><ol type="1"><li><p>防止底层扩容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;(k);<br></code></pre></td></tr></table></figure></li><li><p>若n=3，k=2,即从[1,2,3]中选两个数，如果当前什么都没选(k=2)，n - k + 1= 2，说明至少要从2开始，才能满足选两个数这个要求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">bound</span> <span class="hljs-operator">=</span> n - k + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (start &gt; bound)<br>    <span class="hljs-keyword">return</span>;<br></code></pre></td></tr></table></figure></li></ol><p>代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combine</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-comment">// 防止底层扩容</span><br>        Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;(k);<br>        backtracking(path, n, k, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(Deque&lt;Integer&gt; path, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 若n=3，k=2,即从[1,2,3]中选两个数，如果当前什么都没选(k=2)，n - k + 1= 2，</span><br>        <span class="hljs-comment">// 说明至少要从2开始，才能满足选两个数这个要求</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">bound</span> <span class="hljs-operator">=</span> n - k + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (start &gt; bound)<br>            <span class="hljs-keyword">return</span>;<br>        backtracking(path, n, k, start + <span class="hljs-number">1</span>);<br>        path.addLast(start);<br>        backtracking(path, n, k - <span class="hljs-number">1</span>, start + <span class="hljs-number">1</span>);<br>        path.removeLast();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="组合总和-iii"><a href="https://leetcode.cn/problems/combination-sum-iii/">216. 组合总和 III</a></h3><h4 id="方法一回溯剪枝">方法一：回溯+剪枝</h4><p>i那里的剪枝可以这么理解，假设从i开始取，则从i到n一共有n-i+1个元素，而当前还需要k-path.size()个元素，所以必须满足n-i+1&gt;=k-path.size()，移项就可以得到i&lt;=n+1-(k-path.size())</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum3</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n)</span> &#123;<br>        backtracking(k, n, <span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;(k));<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> start, Deque&lt;Integer&gt; path)</span> &#123;<br>        <span class="hljs-keyword">if</span> (path.size() == k) &#123;<br>            <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)<br>                res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt;= <span class="hljs-number">9</span> - (k - path.size()) + <span class="hljs-number">1</span>; ++i) &#123;<br>            path.add(i);<br>            backtracking(k, n - i, i + <span class="hljs-number">1</span>, path);<br>            path.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230424123751408.png" alt="image-20230424123751408" style="zoom:50%;" /></p><h4 id="方法二选或不选-1">方法二：选或不选</h4><p><strong>注意：int bound = 9 - k + 1;而不是9 - (k - path.size()) + 1</strong>，因为这里的递归终止条件是k==0，==k的语义是还剩多少元素没选！！！==</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum3</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n)</span> &#123;<br>        backtracking(k, n, <span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;(k));<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> start, Deque&lt;Integer&gt; path)</span> &#123;<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)<br>                res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">bound</span> <span class="hljs-operator">=</span> <span class="hljs-number">9</span> - k + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (start &gt; bound)<br>            <span class="hljs-keyword">return</span>;<br>        backtracking(k, n, start + <span class="hljs-number">1</span>, path);<br>        path.add(start);<br>        backtracking(k - <span class="hljs-number">1</span>, n - start, start + <span class="hljs-number">1</span>, path);<br>        path.removeLast();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230425125522905.png" alt="image-20230425125522905" style="zoom:50%;" /></p><h3 id="电话号码的字母组合"><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></h3><p><strong>注意边界条件！</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    String[] alphabet = &#123;<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;def&quot;</span>, <span class="hljs-string">&quot;ghi&quot;</span>, <span class="hljs-string">&quot;jkl&quot;</span>, <span class="hljs-string">&quot;mno&quot;</span>, <span class="hljs-string">&quot;pqrs&quot;</span>, <span class="hljs-string">&quot;tuv&quot;</span>, <span class="hljs-string">&quot;wxyz&quot;</span>&#125;;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">letterCombinations</span><span class="hljs-params">(String digits)</span> &#123;<br>        <span class="hljs-keyword">if</span> (digits == <span class="hljs-literal">null</span> || digits.length() == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> res;<br>        backtracing(digits, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracing</span><span class="hljs-params">(String digits, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-keyword">if</span> (path.length() == digits.length()) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> digits.charAt(start);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> alphabet[num - <span class="hljs-string">&#x27;0&#x27;</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; str.length(); ++i) &#123;<br>            path.append(str.charAt(i));<br>            backtracing(digits, start + <span class="hljs-number">1</span>);<br>            path.deleteCharAt(path.length() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230424134515914.png" alt="image-20230424134515914" style="zoom:50%;" /></p><h3 id="组合总和"><a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></h3><p>与前面两题不同的是，可以选取相同元素；以及组合不能重复，如[3，5]与[5，3]是同一个组合</p><p><strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong></p><p><a href="https://leetcode.cn/problems/combination-sum/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-2/">解析</a></p><h4 id="方法一回溯-1">方法一：回溯</h4><p>去重：遇到这一类相同元素不计算顺序的问题，我们在搜索的时候就需要 <strong>按某种顺序搜索</strong>。具体的做法是：每一次搜索的时候设置 <strong>下一轮搜索的起点</strong> <code>begin</code>，请看下图。</p><figure><img src="https://pic.leetcode-cn.com/1598091943-GPoHAJ-file_1598091940246" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>        backtracing(candidates, target, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracing</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-keyword">if</span> (target &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (target == <span class="hljs-number">0</span>) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; candidates.length; ++i) &#123;<br>            path.add(candidates[i]);<br>            backtracing(candidates, target - candidates[i], i);<br>            path.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230424143933670.png" alt="image-20230424143933670" style="zoom:50%;" /></p><h4 id="方法二回溯剪枝">方法二：回溯+剪枝</h4><p><strong>注意：</strong></p><ol type="1"><li><p>是i不是start！！！</p><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230425144819762.png" alt="image-20230425144819762" style="zoom:50%;" /></p></li><li><p>回溯前要排序！！！</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-comment">// 排序是剪枝的前提</span><br>        Arrays.sort(candidates);<br>        backtracing(candidates, target, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracing</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-keyword">if</span> (target == <span class="hljs-number">0</span>) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; candidates.length; ++i) &#123;<br>            <span class="hljs-comment">// 由于进入更深层的时候，小于 0 的部分被剪枝，因此递归终止条件值只判断等于 0 的情况</span><br>            <span class="hljs-keyword">if</span> (target - candidates[i] &lt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;<br>            path.add(candidates[i]);<br>            backtracing(candidates, target - candidates[i], i);<br>            path.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230424144256280.png" alt=" " style="zoom:50%;" /></p><h3 id="组合总和-ii"><a href="https://leetcode.cn/problems/combination-sum-ii/">40. 组合总和 II</a></h3><p><strong>树层去重，树枝不需要去重</strong></p><p><strong>去重和39题(上一题)以及三数之和差不多</strong></p><h4 id="方法一-2">方法一：</h4><p><strong>注意：if判断条件是i &gt; start， 不是i &gt; 0</strong></p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs crystal">这个避免重复当思想是在是太重要了。<br>这个方法最重要的作用是，可以让同一层级，不出现相同的元素。即<br>                  <span class="hljs-number">1</span><br>                 <span class="hljs-regexp">/ \</span><br><span class="hljs-regexp">                2   2  这种情况不会发生 但是却允许了不同层级之间的重复即：</span><br><span class="hljs-regexp">               /</span>     \<br>              <span class="hljs-number">5</span>       <span class="hljs-number">5</span><br>                例<span class="hljs-number">2</span><br>                  <span class="hljs-number">1</span><br>                 <span class="hljs-regexp">/</span><br><span class="hljs-regexp">                2      这种情况确是允许的</span><br><span class="hljs-regexp">               /</span><br>              <span class="hljs-number">2</span>  <br>                <br>为何会有这种神奇的效果呢？<br>首先 cur-<span class="hljs-number">1</span> == cur 是用于判定当前元素是否和之前元素相同的语句。这个语句就能砍掉例<span class="hljs-number">1</span>。<br>可是问题来了，如果把所有当前与之前一个元素相同的都砍掉，那么例二的情况也会消失。 <br>因为当第二个<span class="hljs-number">2</span>出现的时候，他就和前一个<span class="hljs-number">2</span>相同了。<br>                <br>那么如何保留例<span class="hljs-number">2</span>呢？<br>那么就用cur &gt; <span class="hljs-keyword">begin</span> 来避免这种情况，你发现例<span class="hljs-number">1</span>中的两个<span class="hljs-number">2</span>是处在同一个层级上的，<br>例<span class="hljs-number">2</span>的两个<span class="hljs-number">2</span>是处在不同层级上的。<br>在一个<span class="hljs-keyword">for</span>循环中，所有被遍历到的数都是属于一个层级的。我们要让一个层级中，<br>必须出现且只出现一个<span class="hljs-number">2</span>，那么就放过第一个出现重复的<span class="hljs-number">2</span>，但不放过后面出现的<span class="hljs-number">2</span>。<br>第一个出现的<span class="hljs-number">2</span>的特点就是 cur == <span class="hljs-keyword">begin</span>. 第二个出现的<span class="hljs-number">2</span> 特点是cur &gt; <span class="hljs-keyword">begin</span>.<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>        Arrays.sort(candidates);<br>        backtracing(candidates, target, <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracing</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-keyword">if</span> (target == <span class="hljs-number">0</span>) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; candidates.length; ++i) &#123;<br>            <span class="hljs-comment">// 剪枝</span><br>            <span class="hljs-keyword">if</span> (candidates[i] &gt; target)<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">// 去重</span><br>            <span class="hljs-keyword">if</span> (i &gt; start &amp;&amp; candidates[i] == candidates[i - <span class="hljs-number">1</span>])<br>                <span class="hljs-keyword">continue</span>;<br>            path.add(candidates[i]);<br>            backtracing(candidates, target - candidates[i], i + <span class="hljs-number">1</span>);<br>            path.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230424155818816.png" alt="image-20230424155818816" style="zoom: 50%;" /></p><h4 id="方法二used数组">方法二：used数组</h4><p>多debug</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>        Arrays.sort(candidates);<br>        <span class="hljs-type">boolean</span>[] used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[candidates.length];<br>        backtracking(candidates, used, target, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">boolean</span>[] used, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-keyword">if</span> (target == <span class="hljs-number">0</span>) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; candidates.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (target &lt; candidates[i])<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="hljs-number">1</span>] &amp;&amp; !used[i - <span class="hljs-number">1</span>])<br>                <span class="hljs-keyword">continue</span>;<br>            path.add(candidates[i]);<br>            used[i] = <span class="hljs-literal">true</span>;<br>            backtracking(candidates, used,  target - candidates[i], i + <span class="hljs-number">1</span>);<br>            used[i] = <span class="hljs-literal">false</span>;<br>            path.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230428153014536.png" alt="image-20230428153014536" style="zoom:50%;" /></p><h4 id="方法三选或不选">方法三：选或不选</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>        Arrays.sort(candidates);<br>        backtracking(candidates, <span class="hljs-literal">false</span>, target, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">boolean</span> choosePre, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-keyword">if</span> (target == <span class="hljs-number">0</span>) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (target &lt; <span class="hljs-number">0</span> || start == candidates.length)<br>            <span class="hljs-keyword">return</span>;<br>        backtracking(candidates, <span class="hljs-literal">false</span>, target, start + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (start &gt; <span class="hljs-number">0</span> &amp;&amp; !choosePre &amp;&amp; candidates[start] == candidates[start - <span class="hljs-number">1</span>])<br>            <span class="hljs-keyword">return</span>;<br>        path.add(candidates[start]);<br>        backtracking(candidates, <span class="hljs-literal">true</span>, target - candidates[start], start + <span class="hljs-number">1</span>);<br>        path.removeLast();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="分割回文串warning"><a href="https://leetcode.cn/problems/palindrome-partitioning/">131. 分割回文串</a>:warning:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;String&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    Deque&lt;String&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">partition</span><span class="hljs-params">(String s)</span> &#123;<br>        backtracking(s.toCharArray(), <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">char</span>[] ch, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-keyword">if</span> (start == ch.length) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; ch.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (isPalindrome(ch, start, i)) &#123;<br>                path.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(ch, start, i - start + <span class="hljs-number">1</span>));<br>                backtracking(ch, i + <span class="hljs-number">1</span>);<br>                path.removeLast();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(<span class="hljs-type">char</span>[] ch, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-keyword">while</span> (start &lt; end) &#123;<br>            <span class="hljs-keyword">if</span> (ch[start++] != ch[end--])<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="star93.-复原-ip-地址">:star:<a href="https://leetcode.cn/problems/restore-ip-addresses/">93. 复原 IP 地址</a></h3><p>重做</p><h4 id="方法一回溯-2">方法一：回溯</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure><h3 id="子集"><a href="https://leetcode.cn/problems/subsets/">78. 子集</a></h3><p><strong>以下两种方法的区别：</strong></p><ol type="1"><li>方法二有横向for循环，使用i进入递归方法</li><li>方法一有两个递归方法，分别表示选与不选，用start进入递归犯法</li></ol><h4 id="方法一选或不选">方法一：选或不选</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        backtracking(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-keyword">if</span> (start == nums.length) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        backtracking(nums, start + <span class="hljs-number">1</span>);<br>        path.add(nums[start]);<br>        backtracking(nums, start + <span class="hljs-number">1</span>);<br>        path.removeLast();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230425163311801.png" alt="image-20230425163311801" style="zoom:50%;" /></p><h4 id="方法二for循环横向顺序遍历">方法二：for循环横向顺序遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        backtracking(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start)</span> &#123;<br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>(path));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; nums.length; i++) &#123;<br>            path.add(nums[i]);<br>            backtracking(nums, i + <span class="hljs-number">1</span>);<br>            path.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230425163737735.png" alt="image-20230425163737735" style="zoom:50%;" /></p><h3 id="子集-ii"><a href="https://leetcode.cn/problems/subsets-ii/">90. 子集 II</a></h3><h4 id="方法一选或不选-1">方法一：选或不选</h4><p>如果前后两个数相等，如[1,2,2]，那么只有在第一个2被选择了，才能选择第二个2，不然会重复</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsetsWithDup</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Arrays.sort(nums);<br>        backtracking(nums, <span class="hljs-literal">false</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">boolean</span> choosePre, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-keyword">if</span> (start == nums.length) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        backtracking(nums, <span class="hljs-literal">false</span>, start + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (start &gt; <span class="hljs-number">0</span> &amp;&amp; !choosePre &amp;&amp; nums[start - <span class="hljs-number">1</span>] == nums[start])<br>            <span class="hljs-keyword">return</span>;<br>        path.add(nums[start]);<br>        backtracking(nums, <span class="hljs-literal">true</span>, start + <span class="hljs-number">1</span>);<br>        path.removeLast();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230428171902037.png" alt="image-20230428171902037" style="zoom:50%;" /></p><h4 id="方法二顺序递归">方法二：顺序递归</h4><p><strong>注意：if判断条件是i &gt; start， 不是i &gt; 0</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsetsWithDup</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Arrays.sort(nums);<br>        backtracking(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start)</span> &#123;<br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>(path));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; nums.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; start &amp;&amp; nums[i - <span class="hljs-number">1</span>] == nums[i])<br>                <span class="hljs-keyword">continue</span>;<br>            path.add(nums[i]);<br>            backtracking(nums, i + <span class="hljs-number">1</span>);<br>            path.removeLast();  <br>        &#125;     <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230429114756521.png" alt="image-20230429114756521" style="zoom:50%;" /></p><h3 id="递增子序列warning"><a href="https://leetcode.cn/problems/non-decreasing-subsequences/">491. 递增子序列</a>:warning:</h3><h4 id="方法一顺序dfs">方法一：顺序DFS</h4><p><strong>注意：HashSet的位置！！！每进入一层递归，就会在for循环前创建一个HashSet，这样可以保证树层去重，并且树枝不会qu'chong</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">findSubsequences</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        backtracking(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-keyword">if</span> (path.size() &gt;= <span class="hljs-number">2</span>)<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>(path));<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; nums.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> ((!path.isEmpty() &amp;&amp; nums[i] &lt; path.peekLast()))<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (set.contains(nums[i]))<br>                <span class="hljs-keyword">continue</span>;<br>            set.add(nums[i]);<br>            path.add(nums[i]);<br>            backtracking(nums, i + <span class="hljs-number">1</span>);<br>            path.pollLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230429182016324.png" alt="image-20230429182016324" style="zoom: 50%;" /></p><h3 id="全排列"><a href="https://leetcode.cn/problems/permutations/">46. 全排列</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-type">boolean</span>[] used;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permute</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[nums.length];<br>        backtracking(nums);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (path.size() == nums.length) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (!used[i]) &#123;<br>                path.add(nums[i]);<br>                used[i] = <span class="hljs-literal">true</span>;<br>                backtracking(nums);<br>                used[i] = <span class="hljs-literal">false</span>;<br>                path.pollLast();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230430161908436.png" alt="image-20230430161908436" style="zoom:50%;" /></p><h3 id="全排列-ii"><a href="https://leetcode.cn/problems/permutations-ii/">47. 全排列 II</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-type">boolean</span>[] used;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permuteUnique</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Arrays.sort(nums);<br>        used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[nums.length];<br>        backtracking(nums);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (path.size() == nums.length) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; !used[i - <span class="hljs-number">1</span>] &amp;&amp; nums[i - <span class="hljs-number">1</span>] == nums[i])<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (!used[i]) &#123;<br>                path.add(nums[i]);<br>                used[i] = <span class="hljs-literal">true</span>;<br>                backtracking(nums);<br>                used[i] = <span class="hljs-literal">false</span>;<br>                path.pollLast();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230430163444957.png" alt="image-20230430163444957" style="zoom:50%;" /></p><h3 id="n-皇后"><a href="https://leetcode.cn/problems/n-queens/">51. N 皇后</a></h3><h4 id="方法一二维数组存表盘">方法一：二维数组存表盘</h4><ol type="1"><li>时间复杂度<span class="math inline">\(O(n^n)\)</span></li><li>空间复杂度<span class="math inline">\(O(n^2)\)</span></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;String&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">solveNQueens</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">char</span>[][] chessboard = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span>[] row : chessboard)<br>            Arrays.fill(row, <span class="hljs-string">&#x27;.&#x27;</span>);<br>        backtracking(<span class="hljs-number">0</span>, chessboard, n);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">char</span>[][] chessboard, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (row == n) &#123;<br>            res.add(toList(chessboard));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; col &lt; n; ++col) &#123;<br>            <span class="hljs-keyword">if</span> (isValid(row, col, chessboard, n)) &#123;<br>                chessboard[row][col] = <span class="hljs-string">&#x27;Q&#x27;</span>;<br>                backtracking(row + <span class="hljs-number">1</span>, chessboard, n);<br>                chessboard[row][col] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, <span class="hljs-type">char</span>[][] chessboard, <span class="hljs-type">int</span> n)</span> &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; row; ++i)<br>        <span class="hljs-keyword">if</span> (chessboard[i][col] == <span class="hljs-string">&#x27;Q&#x27;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> row - <span class="hljs-number">1</span>, j = col - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>; --i, --j) &#123;<br>            <span class="hljs-keyword">if</span> (chessboard[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> row - <span class="hljs-number">1</span>, j = col + <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; n; --i, ++j)<br>            <span class="hljs-keyword">if</span> (chessboard[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">private</span> List&lt;String&gt; <span class="hljs-title function_">toList</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] chessboard)</span> &#123;<br>        List&lt;String&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span>[] ch : chessboard) &#123;<br>            path.add(String.copyValueOf(ch));<br>        &#125;<br>        <span class="hljs-keyword">return</span> path;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230504144435692.png" alt="image-20230504144435692" style="zoom:50%;" /></p><h4 id="方法二一维数组存储每行皇后的列信息">方法二：一维数组存储每行皇后的列信息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;String&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-type">int</span>[] chessboard;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">solveNQueens</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        chessboard = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        backtracking(<span class="hljs-number">0</span>, n);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (row == n) &#123;<br>            res.add(generatePath(n));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; col &lt; n; ++col) &#123;<br>            <span class="hljs-keyword">if</span> (isValid(row, col, n)) &#123;<br>                chessboard[row] = col;<br>                backtracking(row + <span class="hljs-number">1</span>, n);<br>                chessboard[row] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; row; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (chessboard[i] == col || Math.abs(col - chessboard[i]) == Math.abs(row - i))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">private</span> List&lt;String&gt; <span class="hljs-title function_">generatePath</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        List&lt;String&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (j == chessboard[i])<br>                    sb.append(<span class="hljs-string">&#x27;Q&#x27;</span>);<br>                <span class="hljs-keyword">else</span> <br>                    sb.append(<span class="hljs-string">&#x27;.&#x27;</span>);<br>            &#125;<br>            path.add(sb.toString());<br>        &#125;<br>        <span class="hljs-keyword">return</span> path;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方法三位运算加速">方法三：位运算加速</h4><h3 id="路径总和-ii-1"><a href="https://leetcode.cn/problems/path-sum-ii/">113. 路径总和 II</a></h3><h2 id="graph">Graph</h2><h3 id="所有可能的路径"><a href="https://leetcode.cn/problems/all-paths-from-source-to-target/">797. 所有可能的路径</a></h3><p><a href="https://leetcode.cn/problems/number-of-islands/solution/dao-yu-lei-wen-ti-de-tong-yong-jie-fa-dfs-bian-li-/">优质题解</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">allPathsSourceTarget</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] graph)</span> &#123;<br>        path.offerLast(<span class="hljs-number">0</span>);<br>        backtracking(<span class="hljs-number">0</span>, graph);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span>[][] graph)</span> &#123;<br>        <span class="hljs-keyword">if</span> (start == graph.length - <span class="hljs-number">1</span>) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : graph[start]) &#123;<br>            path.offerLast(x);<br>            backtracking(x, graph);<br>            path.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230504162550393.png" alt="image-20230504162550393" style="zoom:50%;" /></p><h3 id="岛屿数量"><a href="https://leetcode.cn/problems/number-of-islands/">200. 岛屿数量</a></h3><h4 id="方法一dfs-5">方法一：DFS</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numIslands</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; row &lt; grid.length; ++row) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; col &lt; grid[<span class="hljs-number">0</span>].length; ++col) &#123;<br>                <span class="hljs-keyword">if</span> (grid[row][col] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                    ++res;<br>                    dfs(row, col, grid);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, <span class="hljs-type">char</span>[][] grid)</span> &#123;<br>        <span class="hljs-keyword">if</span> (row &lt; <span class="hljs-number">0</span> || row &gt; grid.length - <span class="hljs-number">1</span> || col &lt; <span class="hljs-number">0</span> || col &gt; grid[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span> || grid[row][col] != <span class="hljs-string">&#x27;1&#x27;</span>) <br>            <span class="hljs-keyword">return</span>;<br>        grid[row][col] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>        dfs(row - <span class="hljs-number">1</span>, col, grid);<br>        dfs(row + <span class="hljs-number">1</span>, col, grid);<br>        dfs(row, col - <span class="hljs-number">1</span>, grid);<br>        dfs(row, col + <span class="hljs-number">1</span>, grid);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230504175718301.png" alt="image-20230504175718301" style="zoom:50%;" /></p><h4 id="方法二bfs-4">方法二：BFS</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numIslands</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] grid)</span> &#123;<br>        Queue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                    ++res;<br>                    grid[i][j] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, j&#125;);<br>                    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>                        <span class="hljs-type">int</span>[] coor = queue.poll();<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> coor[<span class="hljs-number">0</span>], col = coor[<span class="hljs-number">1</span>];<br>                        <span class="hljs-keyword">if</span> (row - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; grid[row - <span class="hljs-number">1</span>][col] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                            queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;row -<span class="hljs-number">1</span>, col&#125;);<br>                            grid[row - <span class="hljs-number">1</span>][col] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">if</span> (row + <span class="hljs-number">1</span> &lt; m &amp;&amp; grid[row + <span class="hljs-number">1</span>][col] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                            queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;row + <span class="hljs-number">1</span>, col&#125;);<br>                            grid[row + <span class="hljs-number">1</span>][col] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">if</span> (col - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; grid[row][col - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                            queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;row, col - <span class="hljs-number">1</span>&#125;);<br>                            grid[row][col - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">if</span> (col + <span class="hljs-number">1</span> &lt; n &amp;&amp; grid[row][col + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                            queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;row, col + <span class="hljs-number">1</span>&#125;);<br>                            grid[row][col + <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;        <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230504182457481.png" alt="image-20230504182457481" style="zoom:50%;" /></p><h4 id="方法三不修改输入数据的dfsf">方法三：不修改输入数据的DFSF</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numIslands</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">boolean</span>[][] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[grid.length][grid[<span class="hljs-number">0</span>].length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; row &lt; grid.length; ++row) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; col &lt; grid[<span class="hljs-number">0</span>].length; ++col) &#123;<br>                <span class="hljs-keyword">if</span> (!visited[row][col] &amp;&amp; grid[row][col] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                    ++res;<br>                    dfs(row, col, grid, visited);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, <span class="hljs-type">char</span>[][] grid, <span class="hljs-type">boolean</span>[][] visited)</span> &#123;<br>        <span class="hljs-keyword">if</span> (row &gt;= <span class="hljs-number">0</span> &amp;&amp; col &gt;= <span class="hljs-number">0</span> &amp;&amp; row &lt; grid.length &amp;&amp; col &lt; grid[<span class="hljs-number">0</span>].length &amp;&amp; !visited[row][col] &amp;&amp; grid[row][col] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>            visited[row][col] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;&#125;;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir :  dirs) &#123;<br>                dfs(row + dir[<span class="hljs-number">0</span>], col + dir[<span class="hljs-number">1</span>], grid, visited);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="岛屿的最大面积"><a href="https://leetcode.cn/problems/max-area-of-island/">695. 岛屿的最大面积</a></h3><h4 id="方法一dfs-6">方法一：DFS</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxAreaOfIsland</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; grid.length; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; grid[<span class="hljs-number">0</span>].length; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>) &#123;<br>                    size = <span class="hljs-number">0</span>;<br>                    dfs(i, j, grid);<br>                    System.out.println(res);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || i == grid.length || j == grid[<span class="hljs-number">0</span>].length || grid[i][j] != <span class="hljs-number">1</span>) <br>            <span class="hljs-keyword">return</span>;<br>        grid[i][j] = <span class="hljs-number">2</span>;<br>        res = Math.max(res, ++size);<br>        dfs(i - <span class="hljs-number">1</span>, j, grid);<br>        dfs(i + <span class="hljs-number">1</span>, j, grid);<br>        dfs(i, j - <span class="hljs-number">1</span>, grid);<br>        dfs(i, j + <span class="hljs-number">1</span>, grid);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230504193543595.png" alt="image-20230504193543595" style="zoom:50%;" /></p><h4 id="不修改输入的dfs">不修改输入的DFS</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxAreaOfIsland</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">boolean</span>[][] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[grid.length][grid[<span class="hljs-number">0</span>].length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; grid.length; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; grid[<span class="hljs-number">0</span>].length; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (!visited[i][j] &amp;&amp; grid[i][j] == <span class="hljs-number">1</span>) &#123;<br>                    res = Math.max(res, dfs(i, j, grid, visited));<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span>[][] grid, <span class="hljs-type">boolean</span>[][] visited)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || i == grid.length || j == grid[<span class="hljs-number">0</span>].length || grid[i][j] != <span class="hljs-number">1</span> || visited[i][j]) <br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        visited[i][j] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>            res += dfs(i + dir[<span class="hljs-number">0</span>], j + dir[<span class="hljs-number">1</span>], grid, visited);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方法三dfs标准写法">方法三：DFS标准写法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxAreaOfIsland</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length, n = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>) &#123;<br>                    res = Math.max(res, dfs(i, j, grid));<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;           <br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        grid[i][j] = <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], col = j + dir[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (isValid(row, col, grid.length, grid[<span class="hljs-number">0</span>].length) &amp;&amp; grid[row][col] == <span class="hljs-number">1</span>) &#123;<br>                grid[row][col] = <span class="hljs-number">2</span>;<br>                res += dfs(row, col, grid);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">return</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &lt; n);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最大人工岛warningstar"><a href="https://leetcode.cn/problems/making-a-large-island/">827. 最大人工岛</a>:warning::star:</h3><p><a href="https://leetcode.cn/problems/making-a-large-island/solution/java-jie-fa-by-nettee/">优质题解</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">largestIsland</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        Map&lt;Integer, Integer&gt; idToArea = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length, n = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>) &#123;<br>                    idToArea.put(id, getSingleArea(i, j, grid, id));<br>                    ++id;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                res = Math.max(res, dfs(i, j, grid, idToArea));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span>[][] grid, Map&lt;Integer,Integer&gt; idToArea)</span> &#123;<br>        <span class="hljs-comment">// if (i &lt; 0 || j &lt; 0 || i == grid.length || j == grid[0].length)</span><br>        <span class="hljs-comment">//     return 0;</span><br>        <span class="hljs-keyword">if</span> (grid[i][j] &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> idToArea.get(grid[i][j]);<br>        &#125;<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>            <span class="hljs-keyword">if</span> (i + dir[<span class="hljs-number">0</span>] &lt; <span class="hljs-number">0</span> || j + dir[<span class="hljs-number">1</span>] &lt; <span class="hljs-number">0</span> || i + dir[<span class="hljs-number">0</span>] == grid.length || j + dir[<span class="hljs-number">1</span>] == grid[<span class="hljs-number">0</span>].length)<br>                <span class="hljs-keyword">continue</span>;<br>            set.add(grid[i + dir[<span class="hljs-number">0</span>]][j + dir[<span class="hljs-number">1</span>]]);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> element : set) &#123;<br>            res += idToArea.getOrDefault(element, <span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSingleArea</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span>[][] grid, <span class="hljs-type">int</span> id)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || i == grid.length || j == grid.length || grid[i][j] != <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        grid[i][j] = id;<br>        <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>            res += getSingleArea(i + dir[<span class="hljs-number">0</span>], j + dir[<span class="hljs-number">1</span>], grid, id);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="二刷">二刷</h4><p>注意hashmap与hashset的使用细节</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">largestIsland</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; grid.length; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; grid[<span class="hljs-number">0</span>].length; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>) &#123;<br>                    map.put(id, getArea(i, j, grid, id));<br>                    ++id;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; grid.length; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; grid[<span class="hljs-number">0</span>].length; ++j) &#123;<br>                res = Math.max(res, dfs(i, j, grid, map));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span>[][] grid, Map&lt;Integer, Integer&gt; map)</span> &#123;<br>        <span class="hljs-keyword">if</span> (grid[i][j] &gt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> map.get(grid[i][j]);<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], col = j + dir[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (isValid(row, col, grid)) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> grid[row][col];<br>                set.add(id);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> id : set) &#123;<br>            res += map.getOrDefault(id, <span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getArea</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span>[][] grid, <span class="hljs-type">int</span> id)</span> &#123;<br>        grid[i][j] = id;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], col = j + dir[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (isValid(row, col, grid) &amp;&amp; grid[row][col] == <span class="hljs-number">1</span>) &#123;<br>                grid[row][col] = id;<br>                res += getArea(row, col, grid, id);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-keyword">return</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; grid.length &amp;&amp; j &lt; grid[<span class="hljs-number">0</span>].length);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="岛屿的周长"><a href="https://leetcode.cn/problems/island-perimeter/">463. 岛屿的周长</a></h3><h4 id="方法一dfs-7">方法一：DFS</h4><p>岛屿的上下左右如果是水域或者超出边界，那么周长加一</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">islandPerimeter</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; grid.length; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; grid[<span class="hljs-number">0</span>].length; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>) &#123;<br>                    grid[i][j] = <span class="hljs-number">2</span>;<br>                    <span class="hljs-keyword">return</span> dfs(i, j, grid);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], col = j + dir[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (isValid(row, col, grid) &amp;&amp; grid[row][col] == <span class="hljs-number">1</span>) &#123;<br>                grid[row][col] = <span class="hljs-number">2</span>;<br>                res += dfs(row, col, grid);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (!isValid(row, col, grid) || grid[row][col] == <span class="hljs-number">0</span>)<br>                    ++res;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-keyword">return</span> !(i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || i == grid.length || j == grid[<span class="hljs-number">0</span>].length);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230505110513862.png" alt="image-20230505110513862" style="zoom:50%;" /></p><h3 id="飞地的数量warning"><a href="https://leetcode.cn/problems/number-of-enclaves/">1020. 飞地的数量</a>:warning:</h3><p>遇到一个陆地，只会返回numEnclaves进入dfs返回的值，因为相连的陆地在grid中会被修改，numEnclaves循环中不会再次fang'wen</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numEnclaves</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; grid.length; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; grid[<span class="hljs-number">0</span>].length; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>) &#123;<br>                    grid[i][j] = <span class="hljs-number">2</span>;<br>                    res += dfs(i, j, grid);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], col = j + dir[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (!isValid(row, col, grid)) &#123;<br>                grid[i][j] = <span class="hljs-number">3</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (grid[row][col] == <span class="hljs-number">1</span>) &#123;<br>                grid[row][col] = <span class="hljs-number">2</span>;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> dfs(row, col, grid);<br>                <span class="hljs-keyword">if</span> (ans == <span class="hljs-number">0</span>) &#123;<br>                    grid[i][j] = <span class="hljs-number">3</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <br>                    res += ans;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> grid[i][j] == <span class="hljs-number">3</span> ? <span class="hljs-number">0</span> : res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; grid.length &amp;&amp; j &lt; grid[<span class="hljs-number">0</span>].length;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230505115024363.png" alt="image-20230505115024363" style="zoom:50%;" /></p><h3 id="被围绕的区域"><a href="https://leetcode.cn/problems/surrounded-regions/">130. 被围绕的区域</a></h3><ol type="1"><li><strong>从边界(第一行，最后一行以及第一列和最后一列)找到O，这些O肯定不会被围绕，把这些O都标记为#</strong></li><li>把其他位置的O全部赋值为X，将#还原为O</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">solve</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> board.length, n = board[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">if</span> (m &lt;= <span class="hljs-number">2</span> || n &lt;= <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i += m - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;O&#x27;</span>) &#123;<br>                    board[i][j] = <span class="hljs-string">&#x27;#&#x27;</span>;<br>                    dfs(i, j, board);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j += n - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>                <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;O&#x27;</span>) &#123;<br>                    board[i][j] = <span class="hljs-string">&#x27;#&#x27;</span>;<br>                    dfs(i, j, board);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;O&#x27;</span>)<br>                    board[i][j] = <span class="hljs-string">&#x27;X&#x27;</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;#&#x27;</span>)<br>                    board[i][j] = <span class="hljs-string">&#x27;O&#x27;</span>;                <br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">char</span>[][] board)</span> &#123;<br>        <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][] &#123;&#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], col = j + dir[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (isValid(row, col, board) &amp;&amp; board[row][col] == <span class="hljs-string">&#x27;O&#x27;</span>) &#123;<br>                board[row][col] = <span class="hljs-string">&#x27;#&#x27;</span>;<br>                dfs(row, col, board);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">char</span>[][] board)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; board[<span class="hljs-number">0</span>].length &amp;&amp; i &lt; board.length;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="太平洋大西洋水流问题star"><a href="https://leetcode.cn/problems/pacific-atlantic-water-flow/">417. 太平洋大西洋水流问题</a>:star:</h3><h4 id="方法一dfs-8">方法一：DFS</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">pacificAtlantic</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] heights)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> heights.length, n = heights[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">boolean</span>[][] pacific = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n], atlantic = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) <br>            dfs(<span class="hljs-number">0</span>, j, heights, pacific);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; ++i)<br>            dfs(i, <span class="hljs-number">0</span>, heights, pacific);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j)<br>            dfs(m - <span class="hljs-number">1</span>, j, heights, atlantic);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m - <span class="hljs-number">1</span>; ++i)<br>            dfs(i, n - <span class="hljs-number">1</span>, heights, atlantic);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (pacific[i][j] &amp;&amp; atlantic[i][j]) &#123;<br>                    List&lt;Integer&gt; temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(<span class="hljs-number">2</span>);<br>                    temp.add(i);<br>                    temp.add(j);<br>                    res.add(temp);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;   <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span>[][] heights, <span class="hljs-type">boolean</span>[][] ocean)</span> &#123;<br>        <span class="hljs-keyword">if</span> (ocean[i][j])<br>            <span class="hljs-keyword">return</span>;<br>        ocean[i][j] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], col = j + dir[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (isValid(row, col, heights) &amp;&amp; heights[row][col] &gt;= heights[i][j])<br>                dfs(row, col, heights, ocean);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span>[][] heights)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; heights.length &amp;&amp; j &lt; heights[<span class="hljs-number">0</span>].length;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230509151119008.png" alt="image-20230509151119008" style="zoom:50%;" /></p><h3 id="单词接龙"><a href="https://leetcode.cn/problems/word-ladder/">127. 单词接龙</a></h3><h4 id="方法一单向广度优先搜索">方法一：单向广度优先搜索</h4><ol type="1"><li><p>需要两个队列存储邻居，第一个队列存储的邻居neighbor1距离beginWord的距离是d，将neighbor1的邻居neighbor2存储在queue2中，neighbor2距离beginWord的距离是d + 1</p></li><li><p>每当把访问完所有queue1中的neighbor1，并且将neighbor2加入到queue2中，那么需要访问新一轮邻居，于是把queue1指向queue2(queue2赋值给queue1)，queue2再新开辟一段空间，<strong>此时length(距离)需要加一</strong></p></li><li><p>开始时需要使用一个HashSet，并将单词表直接放进去，Set&lt;String&gt; set = new HashSet&lt;&gt;(wordList)。函数getNeibours用于找到当前单词所有可能的邻居单词(只有一个字母不同)，对比set中的单词表，如果set中有对应的邻居单词x，则把x加入queue1，并且从set中移除x(如果不移除x，则会重复计算，比如hot的邻居有lot,如果不移除lot，那么下次，如下图</p><figure><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230509162229556.png" alt="image-20230509162229556" /><figcaption aria-hidden="true">image-20230509162229556</figcaption></figure></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ladderLength</span><span class="hljs-params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> &#123;<br>        Queue&lt;String&gt; queue1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        Queue&lt;String&gt; queue2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(wordList);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        queue1.offer(beginWord);<br>        <span class="hljs-keyword">while</span> (!queue1.isEmpty()) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">word</span> <span class="hljs-operator">=</span> queue1.poll();<br>            <span class="hljs-keyword">if</span> (word.equals(endWord))<br>                <span class="hljs-keyword">return</span> length;<br>            List&lt;String&gt; neibours = getNeibours(word);<br>            <span class="hljs-keyword">for</span> (String str : neibours) &#123;<br>                <span class="hljs-keyword">if</span> (set.contains(str)) &#123;<br>                    queue2.offer(str);<br>                    set.remove(str);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (queue1.isEmpty()) &#123;<br>                ++length;<br>                queue1 = queue2;<br>                queue2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">getNeibours</span><span class="hljs-params">(String word)</span> &#123;<br>        List&lt;String&gt; neibours = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">char</span>[] ch = word.toCharArray();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; ch.length; ++i) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">original</span> <span class="hljs-operator">=</span> ch[i];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span>; j &lt;= <span class="hljs-string">&#x27;z&#x27;</span>; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (j != original) &#123;<br>                    ch[i] = j;<br>                    neibours.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(ch));<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// backtracking</span><br>            ch[i] = original;<br>        &#125;<br>        <span class="hljs-keyword">return</span> neibours;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230509160526312.png" alt="image-20230509160526312" style="zoom:50%;" /></p><h3 id="剑指-offer-ii-109.-开密码锁"><a href="https://leetcode.cn/problems/zlDJc7/">剑指 Offer II 109. 开密码锁</a></h3><p><strong>注意visited的位置！！！同上一题，在入队时就在visited加入该邻居，避免之后的重复访问</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">openLock</span><span class="hljs-params">(String[] deadends, String target)</span> &#123;<br>        Set&lt;String&gt; deadSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(Arrays.asList(deadends)), visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">init</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;0000&quot;</span>;<br>        <span class="hljs-keyword">if</span> (deadSet.contains(init) || deadSet.contains(target)) <br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        visited.add(init);<br>        Queue&lt;String&gt; queue1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(), queue2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue1.offer(init);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!queue1.isEmpty()) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> queue1.poll();<br>            <span class="hljs-keyword">if</span> (code.equals(target))<br>                <span class="hljs-keyword">return</span> res;<br>            List&lt;String&gt; neibors = getNeibors(code);<br>            <span class="hljs-keyword">for</span> (String neibor : neibors) &#123;<br>                <span class="hljs-keyword">if</span> (!deadSet.contains(neibor) &amp;&amp; !visited.contains(neibor)) &#123;<br>                    queue2.offer(neibor);<br>                    visited.add(neibor);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (queue1.isEmpty()) &#123;<br>                ++res;<br>                queue1 = queue2;<br>                queue2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">getNeibors</span><span class="hljs-params">(String code)</span> &#123;<br>        List&lt;String&gt; neibors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; code.length(); ++i) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> code.charAt(i);<br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(code);<br>            <span class="hljs-comment">// down</span><br>            <span class="hljs-type">char</span> <span class="hljs-variable">changed</span> <span class="hljs-operator">=</span> cur == <span class="hljs-string">&#x27;0&#x27;</span> ? <span class="hljs-string">&#x27;9&#x27;</span> : (<span class="hljs-type">char</span>) (cur - <span class="hljs-number">1</span>);<br>            sb.setCharAt(i, changed);<br>            neibors.add(sb.toString());<br>            <span class="hljs-comment">// up</span><br>            changed = cur == <span class="hljs-string">&#x27;9&#x27;</span> ? <span class="hljs-string">&#x27;0&#x27;</span> : (<span class="hljs-type">char</span>) (cur + <span class="hljs-number">1</span>);<br>            sb.setCharAt(i, changed);<br>            neibors.add(sb.toString());<br>        &#125;<br>        <span class="hljs-keyword">return</span> neibors;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230509182826126.png" alt="image-20230509182826126" style="zoom:50%;" /></p><h3 id="剑指-offer-ii-106.-二分图warning"><a href="https://leetcode.cn/problems/vEAB3K/">剑指 Offer II 106. 二分图</a>:warning:</h3><h4 id="方法一dfs-9">方法一：DFS</h4><p><strong>染色法需要二刷</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">UNCOLORED</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">RED</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">BLUE</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] colorArray;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBipartite</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] graph)</span> &#123;<br>        colorArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[graph.length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; graph.length &amp;&amp; res; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (colorArray[i] == UNCOLORED) &#123;<br>                dfs(i, graph, RED);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span>[][] graph, <span class="hljs-type">int</span> color)</span> &#123;<br>        colorArray[i] = color;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">neighborColor</span> <span class="hljs-operator">=</span> color == RED ? BLUE : RED;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> neibor : graph[i]) &#123;<br>            <span class="hljs-keyword">if</span> (colorArray[neibor] == UNCOLORED) &#123;<br>                dfs(neibor, graph, neighborColor);<br>                <span class="hljs-keyword">if</span> (!res)<br>                    <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (colorArray[neibor] == neighborColor) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                res = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230512141330516.png" alt="image-20230512141330516" style="zoom:50%;" /></p><h4 id="方法二bfs-5">方法二：BFS</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">UNCOLORED</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">RED</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">BLUE</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] colorArray;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBipartite</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] graph)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> graph.length;<br>        colorArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[graph.length];<br>        Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (colorArray[i] == UNCOLORED) &#123;<br>                queue.offer(i);<br>                colorArray[i] = RED;<br>                <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> queue.poll();<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">neiborColor</span> <span class="hljs-operator">=</span> colorArray[cur] == RED ? BLUE : RED;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> neibor : graph[cur]) &#123;<br>                        <span class="hljs-keyword">if</span> (colorArray[neibor] == UNCOLORED) &#123;<br>                            queue.offer(neibor);<br>                            colorArray[neibor] = neiborColor;<br>                        &#125;<br>                        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (colorArray[neibor] != neiborColor)<br>                            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;        <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230512143824018.png" alt="image-20230512143824018" style="zoom:50%;" /></p><h3 id="剑指-offer-ii-107.-矩阵中的距离"><a href="https://leetcode.cn/problems/2bCMpM/">剑指 Offer II 107. 矩阵中的距离</a></h3><h4 id="方法一bfs-5">方法一：BFS</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] updateMatrix(<span class="hljs-type">int</span>[][] mat) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> mat.length, n = mat[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[][] dist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-type">boolean</span>[][] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n];<br>        Queue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; mat.length; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; mat[i].length; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (mat[i][j] == <span class="hljs-number">0</span>) &#123;<br>                    visited[i][j] = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-comment">// dist[i][j] = 0;</span><br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, j&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span>[] pos = queue.poll();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">distance</span> <span class="hljs-operator">=</span> dist[pos[<span class="hljs-number">0</span>]][pos[<span class="hljs-number">1</span>]];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> pos[<span class="hljs-number">0</span>] + dir[<span class="hljs-number">0</span>], col = pos[<span class="hljs-number">1</span>] + dir[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span> (isValid(row, col, m, n) &amp;&amp; !visited[row][col]) &#123;<br>                    visited[row][col] = <span class="hljs-literal">true</span>;<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;row, col&#125;);<br>                    dist[row][col] = distance + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dist;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &lt; n;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230513143656362.png" alt="image-20230513143656362" style="zoom:50%;" /></p><h3 id="剑指-offer-ii-111.-计算除法warning"><a href="https://leetcode.cn/problems/vlzXQL/">剑指 Offer II 111. 计算除法</a>:warning:</h3><h4 id="方法一bfs-6">方法一：BFS</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span>[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, <span class="hljs-type">double</span>[] values, List&lt;List&lt;String&gt;&gt; queries) &#123;<br>        <span class="hljs-type">double</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[queries.size()];<br>        Map&lt;String, Map&lt;String, Double&gt;&gt; graph = buildGraph(equations, values);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; queries.size(); ++i) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">from</span> <span class="hljs-operator">=</span> queries.get(i).get(<span class="hljs-number">0</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">to</span> <span class="hljs-operator">=</span> queries.get(i).get(<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (!graph.containsKey(from) || !graph.containsKey(to))<br>                res[i] = -<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> &#123;<br>                Set&lt;String&gt; visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>                res[i] = dfs(graph, visited, from, to);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;    <br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(Map&lt;String, Map&lt;String, Double&gt;&gt; graph, Set&lt;String&gt; visited, String from, String to)</span> &#123;<br>        <span class="hljs-keyword">if</span> (from.equals(to)) <br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span>;<br>        visited.add(from);<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;String, Double&gt; entry: graph.get(from).entrySet()) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> entry.getKey();<br>            <span class="hljs-type">double</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> entry.getValue();<br>            <span class="hljs-keyword">if</span> (!visited.contains(key)) &#123;<br>                <span class="hljs-type">double</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> dfs(graph, visited, key, to);<br>                <span class="hljs-keyword">if</span> (res != -<span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">return</span> res * val;<br>                &#125;<br>            &#125;<br>        &#125;<br>        visited.remove(from);<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1.0</span>;<br>    &#125;<br>    <span class="hljs-keyword">private</span> Map&lt;String, Map&lt;String, Double&gt;&gt; <span class="hljs-title function_">buildGraph</span><span class="hljs-params">(List&lt;List&lt;String&gt;&gt; equations, <span class="hljs-type">double</span>[] values)</span> &#123;<br>        Map&lt;String, Map&lt;String, Double&gt;&gt; graph = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; equations.size(); ++i) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">var1</span> <span class="hljs-operator">=</span> equations.get(i).get(<span class="hljs-number">0</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">var2</span> <span class="hljs-operator">=</span> equations.get(i).get(<span class="hljs-number">1</span>);<br>            graph.putIfAbsent(var1, <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;());<br>            graph.get(var1).put(var2, values[i]);<br>            graph.putIfAbsent(var2, <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;());<br>            graph.get(var2).putIfAbsent(var1, <span class="hljs-number">1.0</span> / values[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> graph;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230513165232508.png" alt="image-20230513165232508" style="zoom:50%;" /></p><h3 id="剑指-offer-ii-112.-最长递增路径star"><a href="https://leetcode.cn/problems/fpTFWP/">剑指 Offer II 112. 最长递增路径</a>:star:</h3><h4 id="方法一dfs-10">方法一：DFS</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-type">int</span>[][] path;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestIncreasingPath</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, m = matrix.length, n = matrix[<span class="hljs-number">0</span>].length;<br>        path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">dist</span> <span class="hljs-operator">=</span> dfs(i, j, m, n, matrix);<br>                res = Math.max(res, dist);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-keyword">if</span> (path[i][j] != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> path[i][j];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], col = j + dir[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (isValid(row, col, m, n) &amp;&amp; matrix[row][col] &gt; matrix[i][j]) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">dist</span> <span class="hljs-operator">=</span> dfs(row, col, m, n, matrix);<br>                max = Math.max(max, dist + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;        <br>        path[i][j] = max;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &lt; n;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230513175541175.png" alt="image-20230513175541175" style="zoom:50%;" /></p><h3 id="剑指-offer-ii-113.-课程顺序"><a href="https://leetcode.cn/problems/QA2IGt/">剑指 Offer II 113. 课程顺序</a></h3><h4 id="方法一拓扑排序">方法一：拓扑排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] findOrder(<span class="hljs-type">int</span> numCourses, <span class="hljs-type">int</span>[][] prerequisites) &#123;<br>        Map&lt;Integer, List&lt;Integer&gt;&gt; graph = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numCourses; ++i)<br>            graph.put(i, <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;());<br>        <span class="hljs-type">int</span>[] inDegrees = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[numCourses];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; prerequisites.length; ++i) &#123;<br>            ++inDegrees[prerequisites[i][<span class="hljs-number">0</span>]];<br>            graph.get(prerequisites[i][<span class="hljs-number">1</span>]).add(prerequisites[i][<span class="hljs-number">0</span>]);<br>        &#125;<br>        List&lt;Integer&gt; order = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numCourses; ++i)<br>            <span class="hljs-keyword">if</span> (inDegrees[i] == <span class="hljs-number">0</span>)<br>                queue.offer(i);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>            order.add(node);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> next : graph.get(node)) &#123;<br>                <span class="hljs-keyword">if</span> (--inDegrees[next] == <span class="hljs-number">0</span>) &#123;<br>                    queue.offer(next);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> order.size() == numCourses ? order.stream().mapToInt(Integer::intValue).toArray() : <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="C:\Users\ning\AppData\Roaming\Typora\typora-user-images\image-20230513205516894.png" alt="image-20230513205516894" style="zoom:50%;" /></p><h3 id="剑指-offer-ii-114.-外星文字典"><a href="https://leetcode.cn/problems/Jf1JuT/">剑指 Offer II 114. 外星文字典</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">alienOrder</span><span class="hljs-params">(String[] words)</span> &#123;<br>        Map&lt;Character, Set&lt;Character&gt;&gt; graph = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Map&lt;Character, Integer&gt; inDegrees = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (String word : words) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : word.toCharArray()) &#123;<br>                graph.putIfAbsent(ch, <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;());<br>                inDegrees.putIfAbsent(ch, <span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; words.length; ++i) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">word1</span> <span class="hljs-operator">=</span> words[i - <span class="hljs-number">1</span>];<br>            <span class="hljs-type">String</span> <span class="hljs-variable">word2</span> <span class="hljs-operator">=</span> words[i];<br>            <span class="hljs-keyword">if</span> (word1.startsWith(word2) &amp;&amp; !word1.equals(word2))<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; word1.length() &amp;&amp; j &lt; word2.length(); ++j) &#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">ch1</span> <span class="hljs-operator">=</span> word1.charAt(j);<br>                <span class="hljs-type">char</span> <span class="hljs-variable">ch2</span> <span class="hljs-operator">=</span> word2.charAt(j);<br>                <span class="hljs-keyword">if</span> (ch1 != ch2) &#123;<br>                    <span class="hljs-keyword">if</span> (!graph.get(ch1).contains(ch2)) &#123;<br>                        graph.get(ch1).add(ch2);<br>                        inDegrees.put(ch2, inDegrees.get(ch2) + <span class="hljs-number">1</span>);<br>                    &#125;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        Queue&lt;Character&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;Character, Integer&gt; entry : inDegrees.entrySet()) &#123;<br>            <span class="hljs-keyword">if</span> (entry.getValue() == <span class="hljs-number">0</span>) &#123;<br>                queue.offer(entry.getKey());<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> queue.poll();<br>            res.append(ch);<br>            Set&lt;Character&gt; nexts = graph.get(ch);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> next : nexts) &#123;<br>                inDegrees.put(next, inDegrees.get(next) - <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span> (inDegrees.get(next) == <span class="hljs-number">0</span>)<br>                    queue.offer(next);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res.length() == graph.size() ? res.toString() : <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230514152639854.png" alt="image-20230514152639854" style="zoom:50%;" /></p><h3 id="剑指-offer-ii-115.-重建序列"><a href="https://leetcode.cn/problems/ur2n8P/">剑指 Offer II 115. 重建序列</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">sequenceReconstruction</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span>[][] sequences)</span> &#123;<br>        Map&lt;Integer, Set&lt;Integer&gt;&gt; graph = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Map&lt;Integer, Integer&gt; inDegrees = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] sequence : sequences) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : sequence) &#123;<br>                graph.putIfAbsent(num, <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;());<br>                inDegrees.put(num, <span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; sequences.length; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; sequences[i].length; ++j) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">num1</span> <span class="hljs-operator">=</span> sequences[i][j - <span class="hljs-number">1</span>], num2 = sequences[i][j];<br>                <span class="hljs-keyword">if</span> (!graph.get(num1).contains(num2)) &#123;<br>                    graph.get(num1).add(num2);<br>                    inDegrees.put(num2, inDegrees.get(num2) + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : inDegrees.entrySet()) &#123;<br>            <span class="hljs-keyword">if</span> (entry.getValue() == <span class="hljs-number">0</span>) &#123;<br>                queue.offer(entry.getKey());<br>            &#125;<br>        &#125;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (queue.size() == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> queue.poll();<br>            res.add(num);<br>            Set&lt;Integer&gt; nexts = graph.get(num);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> next : nexts) &#123;<br>                inDegrees.put(next, inDegrees.get(next) - <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span> (inDegrees.get(next) == <span class="hljs-number">0</span>)<br>                    queue.offer(next);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span>[] resToArr = res.stream().mapToInt(Integer::intValue).toArray();<br>        <span class="hljs-keyword">return</span> Arrays.equals(resToArr, nums);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="C:\Users\ning\AppData\Roaming\Typora\typora-user-images\image-20230514170017608.png" alt="image-20230514170017608" style="zoom:50%;" /></p><h3 id="剑指-offer-ii-116.-省份数量"><a href="https://leetcode.cn/problems/bLyHh0/">剑指 Offer II 116. 省份数量</a></h3><h4 id="方法一dfs-11">方法一：DFS</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findCircleNum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] isConnected)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> isConnected.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (!visited[i]) &#123;<br>                visited[i] = <span class="hljs-literal">true</span>;<br>                dfs(i, n, visited, isConnected);<br>                ++res;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> n, <span class="hljs-type">boolean</span>[] visited, <span class="hljs-type">int</span>[][] isConnected)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (isConnected[i][j] == <span class="hljs-number">1</span> &amp;&amp; !visited[j]) &#123;<br>                visited[j] = <span class="hljs-literal">true</span>;<br>                dfs(j, n, visited, isConnected);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="C:\Users\ning\AppData\Roaming\Typora\typora-user-images\image-20230514183621868.png" alt="image-20230514183621868" style="zoom:50%;" /></p><h4 id="方法二bfs-6">方法二：BFS</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findCircleNum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] isConnected)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> isConnected.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n];<br>        Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (!visited[i]) &#123;<br>                ++res;<br>                queue.offer(i);<br>                <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">province</span> <span class="hljs-operator">=</span> queue.poll();<br>                    visited[province] = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                        <span class="hljs-keyword">if</span> (isConnected[province][j] == <span class="hljs-number">1</span> &amp;&amp; !visited[j]) &#123;<br>                            visited[j] = <span class="hljs-literal">true</span>;<br>                            queue.offer(j);<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230515092815433.png" alt="image-20230515092815433" style="zoom:50%;" /></p><h4 id="方法三并查集">方法三：并查集</h4><p><a href="https://zhuanlan.zhihu.com/p/93647900">并查集的讲解</a></p><ol type="1"><li>findFather一定要return fathers[i]，而不是return i，因为当0的father是1的时候，return 1 而不是return 0！</li><li>两层for循环第二层j = i + 1，因为首先j = i的话，是遍历两个相同的节点没意义；其次，i之前的节点在之前就已经合并过了，所以不需要再遍历了</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findCircleNum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] isConnected)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> isConnected.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> n;<br>        <span class="hljs-type">int</span>[] fathers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            fathers[i] = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (isConnected[i][j] == <span class="hljs-number">1</span> &amp;&amp; union(i, j, fathers)) &#123;<br>                    --res;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span>[] fathers)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">fatherOfI</span> <span class="hljs-operator">=</span> findFather(i, fathers);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">fatherOfJ</span> <span class="hljs-operator">=</span> findFather(j, fathers);<br>        <span class="hljs-keyword">if</span> (fatherOfI != fatherOfJ) &#123;<br>            fathers[fatherOfI] = fatherOfJ;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span>  <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findFather</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span>[] fathers)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i != fathers[i])<br>            fathers[i] = findFather(fathers[i], fathers);<br>        <span class="hljs-keyword">return</span> fathers[i];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="C:\Users\ning\AppData\Roaming\Typora\typora-user-images\image-20230515095537722.png" alt="image-2023051509 5537722" style="zoom:50%;" /></p><h3 id="剑指-offer-ii-117.-相似的字符串"><a href="https://leetcode.cn/problems/H6lPxb/">剑指 Offer II 117. 相似的字符串</a></h3><h4 id="方法一并查集">方法一：并查集</h4><ol type="1"><li>判断是否是相似字符串的函数isAnalogical之前用的蠢方法，还要拷贝再交换，直接判断不同字符num的个数就行<ol type="1"><li>如果num==0，那么相似</li><li>由于题目给出的字符串数组中，所有字符串互为 <strong>字母异位词</strong>(字母顺序不同)，所以num == 2时，是交换了两个字符，如果num &gt; 2，就不符合题意了</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numSimilarGroups</span><span class="hljs-params">(String[] strs)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> strs.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> n;<br>        <span class="hljs-type">int</span>[] fathers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            fathers[i] = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> strs[i], str2 = strs[j];<br>                <span class="hljs-keyword">if</span> (isAnalogical(str1, str2) &amp;&amp; union(i, j, fathers)) &#123;<br>                    --res;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span>[] fathers)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">fatherOfI</span> <span class="hljs-operator">=</span> findFather(i, fathers);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">fatherOfJ</span> <span class="hljs-operator">=</span> findFather(j, fathers);<br>        <span class="hljs-keyword">if</span> (fatherOfI != fatherOfJ) &#123;<br>            fathers[fatherOfI] = fatherOfJ;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findFather</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span>[] fathers)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i != fathers[i])<br>            fathers[i] = findFather(fathers[i], fathers);<br>        <span class="hljs-keyword">return</span> fathers[i];<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAnalogical</span><span class="hljs-params">(String a, String b)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; a.length(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (a.charAt(i) != b.charAt(i)) &#123;<br>                num++;<br>                <span class="hljs-keyword">if</span> (num &gt; <span class="hljs-number">2</span>) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230515111701411.png" alt="image-20230515111701411" style="zoom:50%;" /></p><h3 id="剑指-offer-ii-118.-多余的边"><a href="https://leetcode.cn/problems/7LpjUW/">剑指 Offer II 118. 多余的边</a></h3><h4 id="方法一并查集-1">方法一：并查集</h4><figure><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230515135402396.png" alt="image-20230515135402396" /><figcaption aria-hidden="true">image-20230515135402396</figcaption></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] findRedundantConnection(<span class="hljs-type">int</span>[][] edges) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> edges.length;<br>        <span class="hljs-type">int</span>[] fathers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            fathers[i] = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] edge : edges) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">node1</span> <span class="hljs-operator">=</span> edge[<span class="hljs-number">0</span>], node2 = edge[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (!union(node1, node2, fathers))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;node1, node2&#125;;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span>[] fathers)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">fatherOfI</span> <span class="hljs-operator">=</span> findFather(i, fathers);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">fatherOfJ</span> <span class="hljs-operator">=</span> findFather(j, fathers);<br>        <span class="hljs-keyword">if</span> (fatherOfI != fatherOfJ) &#123;<br>            fathers[fatherOfI] = fatherOfJ;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findFather</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span>[] fathers)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i != fathers[i])<br>            fathers[i] = findFather(fathers[i], fathers);<br>        <span class="hljs-keyword">return</span> fathers[i];<br>    &#125;<br>&#125;           <br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230515135336208.png" alt="image-20230515135336208" style="zoom:50%;" /></p><h3 id="剑指-offer-ii-119.-最长连续序列"><a href="https://leetcode.cn/problems/WhsWhI/">剑指 Offer II 119. 最长连续序列</a></h3><h4 id="方法一暴力-5">方法一：暴力</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestConsecutive</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        Arrays.sort(nums);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : nums)<br>            System.out.print(i + <span class="hljs-string">&quot; &quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, cur = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] == nums[i - <span class="hljs-number">1</span>])<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (nums[i] - nums[i - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span>) &#123;<br>                ++cur;<br>                res = Math.max(res, cur);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                cur = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230515140831174.png" alt="image-20230515140831174" style="zoom:50%;" /></p><h4 id="方法二并查集">方法二：并查集</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestConsecutive</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Map&lt;Integer, Integer&gt; fathers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(), count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            fathers.put(num, num);<br>            count.put(num, <span class="hljs-number">1</span>);<br>            set.add(num);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-keyword">if</span> (set.contains(num + <span class="hljs-number">1</span>)) &#123;<br>                union(num, num + <span class="hljs-number">1</span>, fathers, count);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (set.contains(num - <span class="hljs-number">1</span>)) &#123;<br>                union(num, num - <span class="hljs-number">1</span>, fathers, count);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> val : count.values()) &#123;<br>            res = Math.max(res, val);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, Map&lt;Integer, Integer&gt; fathers, Map&lt;Integer, Integer&gt; count)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">fatherOfI</span> <span class="hljs-operator">=</span> findFather(i, fathers);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">fatherOfJ</span> <span class="hljs-operator">=</span> findFather(j, fathers);<br>        <span class="hljs-keyword">if</span> (fatherOfI != fatherOfJ) &#123;<br>            fathers.put(fatherOfI, fatherOfJ);<br>            count.put(fatherOfJ, count.get(fatherOfI) + count.get(fatherOfJ));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findFather</span><span class="hljs-params">(<span class="hljs-type">int</span> i, Map&lt;Integer, Integer&gt; fathers)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">fatherOfI</span> <span class="hljs-operator">=</span> fathers.get(i);<br>        <span class="hljs-keyword">if</span> (i != fatherOfI) &#123;<br>            fathers.put(i, findFather(fatherOfI, fathers));<br>        &#125;<br>        <span class="hljs-keyword">return</span> fathers.get(i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230515152018466.png" alt="image-20230515152018466" style="zoom:50%;" /></p><h2 id="binary-search">Binary Search</h2><h3 id="剑指-offer-ii-068.-查找插入位置"><a href="https://leetcode.cn/problems/N6YdxV/">剑指 Offer II 068. 查找插入位置</a></h3><h4 id="方法一-3">方法一：</h4><ol type="1"><li><p>如果nums中有target，那么会被找到并被返回</p></li><li><p>如果nums中没有target，那么有三种情况，这个数应该被插入道</p><ol type="1"><li>第一个位置</li><li>最后一个位置</li><li>中间</li></ol><p>这三种情况的索引都是退出循环后的left！！！</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">searchInsert</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> right - ((right - left) &gt;&gt; <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (nums[mid] == target)<br>                <span class="hljs-keyword">return</span> mid;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) <br>                right = mid - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法二">方法二：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">searchInsert</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> right - ((right - left) &gt;&gt; <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (nums[mid] &gt;= target) &#123;<br>                <span class="hljs-keyword">if</span> (mid == <span class="hljs-number">0</span> || nums[mid - <span class="hljs-number">1</span>] &lt; target)<br>                    <span class="hljs-keyword">return</span> mid;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums.length;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="heap">Heap</h2><h3 id="剑指-offer-ii-059.-数据流的第-k-大数值"><a href="https://leetcode.cn/problems/jBjn9C/">剑指 Offer II 059. 数据流的第 K 大数值</a></h3><h4 id="方法一小根堆">方法一：小根堆</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">KthLargest</span> &#123;<br><br>    <span class="hljs-keyword">private</span> PriorityQueue&lt;Integer&gt; queue;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">KthLargest</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>        size = k;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            add(num);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        queue.offer(val);<br>        <span class="hljs-keyword">if</span> (queue.size() &gt;  size) &#123;<br>            queue.poll();<br>        &#125;<br>        <span class="hljs-keyword">return</span> queue.peek();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your KthLargest object will be instantiated and called as such:</span><br><span class="hljs-comment"> * KthLargest obj = new KthLargest(k, nums);</span><br><span class="hljs-comment"> * int param_1 = obj.add(val);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230515190222119.png" alt="image-20230515190222119" style="zoom:50%;" /></p><h4 id="方法二小根堆另一种写法">方法二：小根堆另一种写法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">KthLargest</span> &#123;<br><br>    <span class="hljs-keyword">private</span> PriorityQueue&lt;Integer&gt; queue;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> k;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">KthLargest</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>        <span class="hljs-built_in">this</span>.k = k;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            add(num);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span> (queue.size() &lt; k) &#123;<br>            queue.offer(val);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (queue.size() == k &amp;&amp; queue.peek() &lt; val) &#123;<br>            queue.poll();<br>            queue.offer(val);<br>        &#125;<br>        <span class="hljs-keyword">return</span> queue.peek();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your KthLargest object will be instantiated and called as such:</span><br><span class="hljs-comment"> * KthLargest obj = new KthLargest(k, nums);</span><br><span class="hljs-comment"> * int param_1 = obj.add(val);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230515192704724.png" alt="image-20230515192704724" style="zoom:50%;" /></p><h3 id="剑指-offer-ii-060.-出现频率最高的-k-个数字"><a href="https://leetcode.cn/problems/g5c51o/">剑指 Offer II 060. 出现频率最高的 k 个数字</a></h3><h4 id="方法一小根堆-1">方法一：小根堆</h4><ol type="1"><li>小根堆的比较方式</li><li>小根堆的类型是Map.Entry</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] topKFrequent(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        Map&lt;Integer, Integer&gt; count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            count.put(num, count.getOrDefault(num, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; minHeap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(<br>                (e1, e2) -&gt; e1.getValue() - e2.getValue());<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : count.entrySet()) &#123;<br>            <span class="hljs-keyword">if</span> (minHeap.size() &lt; k) &#123;<br>                minHeap.offer(entry);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (entry.getValue() &gt; minHeap.peek().getValue()) &#123;<br>                minHeap.poll();<br>                minHeap.offer(entry);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!minHeap.isEmpty()) <br>            res[i++] = minHeap.poll().getKey();<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230516095717058.png" alt="image-20230516095717058" style="zoom:50%;" /></p><h3 id="剑指-offer-ii-061.-和最小的-k-个数对"><a href="https://leetcode.cn/problems/qn8gGX/">剑指 Offer II 061. 和最小的 k 个数对</a></h3><h4 id="方法一大根堆">方法一：大根堆</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">kSmallestPairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2, <span class="hljs-type">int</span> k)</span> &#123;<br>        PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; maxHeap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(<br>                (o1, o2) -&gt; o2[<span class="hljs-number">0</span>] + o2[<span class="hljs-number">1</span>] - o1[<span class="hljs-number">0</span>] - o1[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; Math.min(k, nums1.length); ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; Math.min(k, nums2.length); ++j) &#123;<br>                <span class="hljs-keyword">if</span> (maxHeap.size() &lt; k)<br>                    maxHeap.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;nums1[i], nums2[j]&#125;);<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (maxHeap.peek()[<span class="hljs-number">0</span>] + maxHeap.peek()[<span class="hljs-number">1</span>] &gt; nums1[i] + nums2[j]) &#123;<br>                    maxHeap.poll();<br>                    maxHeap.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;nums1[i], nums2[j]&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (!maxHeap.isEmpty()) &#123;<br>            <span class="hljs-type">int</span>[] temp = maxHeap.poll();<br>            res.add(Arrays.asList(temp[<span class="hljs-number">0</span>], temp[<span class="hljs-number">1</span>]));<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230516101216749.png" alt="image-20230516101216749" style="zoom:50%;" /></p><h2 id="排序">排序</h2><h3 id="快速排序">快速排序</h3><p>边界问题：end &gt; start。当start == end的时候，已经是排序好的一个数，不需要在进行partition</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] sortArray(<span class="hljs-type">int</span>[] nums) &#123;<br>        quickSort(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-keyword">if</span> (end &gt; start) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">pivot</span> <span class="hljs-operator">=</span> partition(nums, start, end);<br>            quickSort(nums, start, pivot - <span class="hljs-number">1</span>);<br>            quickSort(nums, pivot + <span class="hljs-number">1</span>, end);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">partition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(end - start + <span class="hljs-number">1</span>) + start;<br>        swap(nums, random, end);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">small</span> <span class="hljs-operator">=</span> start - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; end; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &lt; nums[end]) &#123;<br>                ++small;<br>                swap(nums, small, i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 没有小于pivot的数了</span><br>        ++small;<br>        swap(nums, small, end);<br>        <span class="hljs-keyword">return</span> small;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> random, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-keyword">if</span> (random != end) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[end];<br>            nums[end] = nums[random];<br>            nums[random] = temp;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>&#125;;<br>        <span class="hljs-type">int</span>[] clone = nums.clone();<br>        <span class="hljs-type">QuickSort</span> <span class="hljs-variable">quickSort</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">QuickSort</span>();<br>        quickSort.sortArray(nums);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums)<br>            System.out.print(num + <span class="hljs-string">&quot; &quot;</span>);<br>        System.out.println();<br>        Arrays.sort(clone);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> cl : clone)<br>            System.out.print(cl + <span class="hljs-string">&quot; &quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="剑指-offer-ii-076.-数组中的第-k-大的数字"><a href="https://leetcode.cn/problems/xx4gT2/">剑指 Offer II 076. 数组中的第 k 大的数字</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findKthLargest</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> nums.length - k;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, end = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pivot</span> <span class="hljs-operator">=</span> partition(nums, start, end);<br>        <span class="hljs-keyword">while</span> (pivot != target) &#123;<br>            <span class="hljs-keyword">if</span> (pivot &gt; target) &#123;<br>                end = pivot - <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                start = pivot + <span class="hljs-number">1</span>;<br>            &#125;<br>            pivot = partition(nums, start, end);<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[pivot];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">partition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start , <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(end - start + <span class="hljs-number">1</span>) + start;<br>        swap(nums, random, end);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">small</span> <span class="hljs-operator">=</span> start - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; end; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &lt; nums[end]) &#123;<br>                ++small;<br>                swap(nums, small, i);<br>            &#125;<br>        &#125;<br>        ++small;<br>        swap(nums, small, end);<br>        <span class="hljs-keyword">return</span> small;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> index1, <span class="hljs-type">int</span> index2)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index1 != index2) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[index1];<br>            nums[index1] = nums[index2];<br>            nums[index2] = temp;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230516114230333.png" alt="image-20230516114230333" style="zoom:50%;" /></p><h2 id="前缀树">前缀树</h2><h3 id="剑指-offer-ii-062.-实现前缀树"><a href="https://leetcode.cn/problems/QC3q1f/">剑指 Offer II 062. 实现前缀树</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TrieNode</span> &#123;<br>        TrieNode[] children;<br>        <span class="hljs-type">boolean</span> isWord;<br><br>        <span class="hljs-keyword">public</span>  <span class="hljs-title function_">TrieNode</span><span class="hljs-params">()</span> &#123;<br>            children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>[<span class="hljs-number">26</span>];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> TrieNode root;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Trie</span><span class="hljs-params">()</span> &#123;<br>        root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>();<br>    &#125;<br><br>    <span class="hljs-comment">/** Inserts a word into the trie. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">TrieNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : word.toCharArray()) &#123;<br>            <span class="hljs-keyword">if</span> (cur.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">null</span>) &#123;<br>                cur.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>();<br>            &#125;<br>            cur = cur.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        cur.isWord = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/** Returns if the word is in the trie. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">search</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">TrieNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : word.toCharArray()) &#123;<br>            <span class="hljs-keyword">if</span> (cur.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            cur = cur.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> cur.isWord;<br>    &#125;<br><br>    <span class="hljs-comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">startsWith</span><span class="hljs-params">(String prefix)</span> &#123;<br>        <span class="hljs-type">TrieNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : prefix.toCharArray()) &#123;<br>            <span class="hljs-keyword">if</span> (cur.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            cur = cur.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230517105800114.png" alt="image-20230517105800114" style="zoom:50%;" /></p><h3 id="剑指-offer-ii-063.-替换单词"><a href="https://leetcode.cn/problems/UhWRSj/">剑指 Offer II 063. 替换单词</a></h3><h4 id="方法一前缀树">方法一：前缀树</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TrieNode</span> &#123;<br>        <span class="hljs-keyword">private</span> TrieNode[] children;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> isWord;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">TrieNode</span><span class="hljs-params">()</span> &#123;<br>            children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>[<span class="hljs-number">26</span>];<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">replaceWords</span><span class="hljs-params">(List&lt;String&gt; dictionary, String sentence)</span> &#123;<br>        <span class="hljs-type">TrieNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> buildTrie(dictionary);<br>        String[] words = sentence.split(<span class="hljs-string">&quot; &quot;</span>);<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; words.length; ++i) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">prefix</span> <span class="hljs-operator">=</span> findPrefix(root, words[i]);<br>            <span class="hljs-keyword">if</span> (!prefix.isEmpty()) &#123;<br>                words[i] = prefix;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> String.join(<span class="hljs-string">&quot; &quot;</span>, words);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">findPrefix</span><span class="hljs-params">(TrieNode root, String word)</span> &#123;<br>        <span class="hljs-type">TrieNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : word.toCharArray()) &#123;<br>            <span class="hljs-keyword">if</span> (cur.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">null</span> || cur.isWord)<br>                <span class="hljs-keyword">break</span>;<br>            sb.append(ch);<br>            cur = cur.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> cur.isWord == <span class="hljs-literal">true</span> ? sb.toString() : <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> TrieNode <span class="hljs-title function_">buildTrie</span><span class="hljs-params">(List&lt;String&gt; dictionary)</span> &#123;<br>        <span class="hljs-type">TrieNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>();<br>        <span class="hljs-keyword">for</span> (String str : dictionary) &#123;<br>            <span class="hljs-type">TrieNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : str.toCharArray()) &#123;<br>                <span class="hljs-keyword">if</span> (cur.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">null</span>)<br>                    cur.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>();<br>                cur = cur.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>];<br>            &#125;<br>            cur.isWord = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230517152321077.png" alt="image-20230517152321077" style="zoom:50%;" /></p><h3 id="剑指-offer-ii-064.-神奇的字典warning"><a href="https://leetcode.cn/problems/US1pGT/">剑指 Offer II 064. 神奇的字典</a>:warning:</h3><h4 id="方法一前缀树-1">方法一：前缀树</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MagicDictionary</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TrieNode</span> &#123;<br>        <span class="hljs-keyword">private</span> TrieNode[] children;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> isWord;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">TrieNode</span><span class="hljs-params">()</span> &#123;<br>            children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>[<span class="hljs-number">26</span>];<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-keyword">private</span> TrieNode root;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MagicDictionary</span><span class="hljs-params">()</span> &#123;<br>        root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildDict</span><span class="hljs-params">(String[] dictionary)</span> &#123;<br>        <span class="hljs-keyword">for</span> (String str : dictionary) &#123;<br>            <span class="hljs-type">TrieNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : str.toCharArray()) &#123;<br>                <span class="hljs-keyword">if</span> (cur.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">null</span>)<br>                    cur.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>();<br>                cur = cur.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>];<br>            &#125;<br>            cur.isWord = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">search</span><span class="hljs-params">(String searchWord)</span> &#123;<br>        <span class="hljs-keyword">return</span> dfs(root, searchWord, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TrieNode root, String searchWord, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> modifiedNum)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (root.isWord &amp;&amp; index == searchWord.length() &amp;&amp; modifiedNum == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (modifiedNum &lt;= <span class="hljs-number">1</span> &amp;&amp; index &lt; searchWord.length()) &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">found</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">26</span> &amp;&amp; !found; ++j) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> j == searchWord.charAt(index) - <span class="hljs-string">&#x27;a&#x27;</span> ? modifiedNum : modifiedNum + <span class="hljs-number">1</span>;<br>                found = dfs(root.children[j], searchWord, index + <span class="hljs-number">1</span>, next);<br>            &#125;<br>            <span class="hljs-keyword">return</span> found;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MagicDictionary object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MagicDictionary obj = new MagicDictionary();</span><br><span class="hljs-comment"> * obj.buildDict(dictionary);</span><br><span class="hljs-comment"> * boolean param_2 = obj.search(searchWord);</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//leetcode submit region end(Prohibit modification and deletion)</span><br><br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230517162222403.png" alt="image-20230517162222403" style="zoom:50%;" /></p><h3 id="剑指-offer-ii-065.-最短的单词编码warningstar"><a href="https://leetcode.cn/problems/iSwD2y/">剑指 Offer II 065. 最短的单词编码</a>:warning::star:</h3><h4 id="方法一前缀树-2">方法一：前缀树</h4><p><strong>这种DFS技巧非常重要！！！</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TrieNode</span> &#123;<br>        <span class="hljs-keyword">private</span> TrieNode[] children;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> isEnd;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">TrieNode</span><span class="hljs-params">()</span> &#123;<br>            children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>[<span class="hljs-number">26</span>];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumLengthEncoding</span><span class="hljs-params">(String[] words)</span> &#123;<br>        <span class="hljs-type">TrieNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> buildTree(words);<br>        dfs(root, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TrieNode root, <span class="hljs-type">int</span> length)</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isLeaf</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (TrieNode child : root.children) &#123;<br>            <span class="hljs-keyword">if</span> (child != <span class="hljs-literal">null</span>) &#123;<br>                isLeaf = <span class="hljs-literal">false</span>;<br>                dfs(child, length + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (isLeaf)<br>            res += length;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> TrieNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(String[] words)</span> &#123;<br>        <span class="hljs-type">TrieNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; words.length; ++i) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">word</span> <span class="hljs-operator">=</span> words[i];<br>            <span class="hljs-type">TrieNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> word.length() - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; --j) &#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> word.charAt(j);<br>                <span class="hljs-keyword">if</span> (cur.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">null</span>)<br>                    cur.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>();<br>                cur = cur.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>];<br>            &#125;<br>            cur.isEnd = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230517174243394.png" alt="image-20230517174243394" style="zoom:50%;" /></p><h3 id="剑指-offer-ii-066.-单词之和"><a href="https://leetcode.cn/problems/z1R5dt/">剑指 Offer II 066. 单词之和</a></h3><h4 id="方法一前缀树-3">方法一：前缀树</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MapSum</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TrieNode</span> &#123;<br>        <span class="hljs-keyword">private</span> TrieNode[] children;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> val;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">TrieNode</span><span class="hljs-params">()</span> &#123;<br>            children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>[<span class="hljs-number">26</span>];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> TrieNode root;<br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MapSum</span><span class="hljs-params">()</span> &#123;<br>        root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String key, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">TrieNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : key.toCharArray()) &#123;<br>            <span class="hljs-keyword">if</span> (cur.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">null</span>)<br>                cur.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>();<br>            cur = cur.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        cur.val = val;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(String prefix)</span> &#123;<br>        <span class="hljs-type">TrieNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : prefix.toCharArray()) &#123;<br>            <span class="hljs-keyword">if</span> (cur.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            cur = cur.children[ch - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dfs(cur);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TrieNode cur)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> cur.val;<br>        <span class="hljs-keyword">for</span> (TrieNode child : cur.children) &#123;<br>            <span class="hljs-keyword">if</span> (child != <span class="hljs-literal">null</span>)<br>                sum += dfs(child);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MapSum</span> <span class="hljs-variable">mapSum</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MapSum</span>();<br>        mapSum.insert(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-number">3</span>);<br>        mapSum.sum(<span class="hljs-string">&quot;ap&quot;</span>);<br>        mapSum.insert(<span class="hljs-string">&quot;app&quot;</span>, <span class="hljs-number">2</span>);<br>        mapSum.sum(<span class="hljs-string">&quot;ap&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MapSum object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MapSum obj = new MapSum();</span><br><span class="hljs-comment"> * obj.insert(key,val);</span><br><span class="hljs-comment"> * int param_2 = obj.sum(prefix);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230517181655506.png" alt="image-20230517181655506" style="zoom:50%;" /></p><h3 id="剑指-offer-ii-067.-最大的异或"><a href="https://leetcode.cn/problems/ms70jA/">剑指 Offer II 067. 最大的异或</a></h3><h4 id="方法一前缀树-4">方法一：前缀树</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TrieNode</span> &#123;<br>        <span class="hljs-keyword">private</span> TrieNode[] children;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">TrieNode</span><span class="hljs-params">()</span> &#123;<br>            children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>[<span class="hljs-number">2</span>];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMaximumXOR</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">TrieNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> buildTrie(nums);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-type">TrieNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">xor</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">31</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">bit</span> <span class="hljs-operator">=</span> (num &gt;&gt; i) &amp; <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (cur.children[<span class="hljs-number">1</span> - bit] != <span class="hljs-literal">null</span>) &#123;<br>                    cur = cur.children[<span class="hljs-number">1</span> - bit];<br>                    xor = (xor &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    cur = cur.children[bit];<br>                    xor = xor &lt;&lt; <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>            max = Math.max(max, xor);<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> TrieNode <span class="hljs-title function_">buildTrie</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">TrieNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-type">TrieNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">31</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">bit</span> <span class="hljs-operator">=</span> (num &gt;&gt; i) &amp; <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (cur.children[bit] == <span class="hljs-literal">null</span>) &#123;<br>                    cur.children[bit] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>();<br>                &#125;<br>                cur = cur.children[bit];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/image-20230517145848750.png" alt="image-20230517145848750" style="zoom:50%;" /></p><h2 id="tips">tips</h2><h3 id="新建数组时赋值">新建数组时赋值</h3><p>int[] array = new int[]{3, 4}；</p><h3 id="链表转数组">链表转数组</h3><h4 id="方法一-4">方法一：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] intArray = linkedList.stream().mapToInt(Integer::intValue).toArray();<br></code></pre></td></tr></table></figure><p>这行代码可以分解为以下几个部分：</p><ol type="1"><li><code>linkedList.stream()</code>: 将LinkedList转换为Stream。</li><li><code>mapToInt(Integer::intValue)</code>: 将Stream中的每一个元素转换为int类型。<ul><li><code>Integer::intValue</code>是一个方法引用，表示调用Integer对象的<code>intValue()</code>方法，将其转换为对应的int值。</li></ul></li><li><code>toArray()</code>: 将转换后的元素放到一个int数组中。<ul><li><code>toArray()</code>的作用是将Stream中的所有元素转换为一个数组，返回值是一个<code>int[]</code>类型的数组。</li></ul></li></ol><p>综上所述，<code>int[] intArray = linkedList.stream().mapToInt(Integer::intValue).toArray();</code>的语义是将LinkedList中的所有元素转换为int类型，并将其放入一个int数组中。在这个过程中，我们使用了Java 8引入的Stream API，它提供了许多方便的操作，可以简化代码的编写和调试。</p><h4 id="方法二-1">方法二：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">res.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[res.size()][]);<br></code></pre></td></tr></table></figure><h3 id="创建长度二维数组其中一维数组的长度不确定">创建长度二维数组，其中一维数组的长度不确定</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">3</span>&#125;, &#123;&#125;&#125;<br></code></pre></td></tr></table></figure><h3 id="char转intstring转int">char转int，String转int</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 将字符转换为整数</span><br><span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;8&#x27;</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> Character.getNumericValue(c); <span class="hljs-comment">// num = 8</span><br><br><span class="hljs-comment">// 将字符串转换为整数</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123&quot;</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">num2</span> <span class="hljs-operator">=</span> Integer.parseInt(str); <span class="hljs-comment">// num2 = 123</span><br></code></pre></td></tr></table></figure><h3 id="string转int时什么时候用parseint什么时候用valueof">String转int时，什么时候用parseInt什么时候用valueOf</h3><p>在Java中，parseInt和valueOf都可以将字符串转换为整数。parseInt方法将字符串转换为基本数据类型int，而valueOf方法将字符串转换为对象类型Integer。因此，使用哪个方法取决于你要使用返回的数据类型。</p><p>如果你只需要一个基本数据类型int，那么使用parseInt是最好的选择，因为它会返回一个原始类型，不会产生额外的对象开销。</p><p>例如：</p><p>java Copy code String str = "123"; int num = Integer.parseInt(str);</p><p>如果你需要一个对象类型Integer，则使用valueOf方法是最好的选择。valueOf方法返回一个Integer对象，这在某些情况下非常有用。</p><p>例如：</p><p>java Copy code String str = "123"; Integer num = Integer.valueOf(str);</p><p>总之，如果你只需要一个基本数据类型，那么使用parseInt方法，否则使用valueOf方法。</p><h3 id="使用scanner.nextline读取行末的换行符">使用scanner.nextLine()读取行末的换行符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>       <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>       <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>       scanner.nextLine();<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>           <span class="hljs-type">String</span> <span class="hljs-variable">word</span> <span class="hljs-operator">=</span> scanner.nextLine();<br>           System.out.println(<span class="hljs-string">&quot;word: &quot;</span> + word);<br>           <span class="hljs-type">Main</span> <span class="hljs-variable">main</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Main</span>();<br>           <span class="hljs-type">String</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> main.process(word);<br>           System.out.println(ans);<br>       &#125;<br></code></pre></td></tr></table></figure><p>这段代码首先从标准输入中读取一个整数n，然后通过调用scanner.nextLine()读取掉n后面的换行符。接下来，通过for循环n次，读取n行字符串，每次读取一行字符串后，调用process方法进行处理，最后将处理结果打印到标准输出中。</p><p>需要注意的是，在使用Scanner读取完整行时，由于nextInt只读取整数，因此需要在nextInt后面调用nextLine读取行末的换行符。这样做是为了防止接下来的nextLine方法误读取行末的换行符。</p><h3 id="创建长度不同的二维数组">创建长度不同的二维数组</h3><p>在Java中，可以创建长度不同的二维数组。以下是创建长度不同的二维数组的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[][] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>][];<br>arr[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>arr[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<br>arr[<span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">4</span>];<br></code></pre></td></tr></table></figure><p>在这个示例中，我们创建了一个3 x n的二维数组，其中n的长度不同。第一行有两个元素，第二行有三个元素，第三行有四个元素。我们可以通过以下方式访问数组的元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">arr[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>arr[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>arr[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">3</span>;<br>arr[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">4</span>;<br>arr[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">5</span>;<br>arr[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">6</span>;<br>arr[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">7</span>;<br>arr[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">8</span>;<br>arr[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] = <span class="hljs-number">9</span>;<br></code></pre></td></tr></table></figure><p>请注意，当您创建长度不同的二维数组时，每行的长度必须在运行时确定。因此，您必须在运行时动态地为每行分配内存空间。</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">1</span><br><span class="hljs-number">8</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span><br><span class="hljs-number">0</span><br><span class="hljs-number">0</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="数组拷贝ch.clone与arrays.copyof的区别">数组拷贝：ch.clone与Arrays.copyOf的区别</h3><p>对基础类型的拷贝都是值传递的拷贝(深拷贝)，对对象的拷贝都是拷贝的引用(浅拷贝)</p><h1 id="笔试面试">笔试面试</h1><h2 id="小红书">5.8小红书</h2><h3 id="第一题.">第一题.</h3><h3 id="第二题.">第二题.</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs tex">最大最小值<br>        时间限制： 1000MS<br>        内存限制： 65536KB<br>        题目描述：<br>        有一个长度为n的序列，其中第i个元素ai，你现在可以对这个序列进行最多k次操作，每次可选择一个连续的区间将其中的元素删掉，但剩余的元素个数必须大于0。 现在想让剩余元素的最小值尽可能大，求上述情况下的最大值。<br><br><br><br>        输入描述<br>        第一行两个正整数n和k，分别表示初始序列中元素的个数以及最多的操作次数。<br><br>        接下来1行，n个正整数，其中第i个数为ai。<br><br>        对于所有数据，1&lt;=n&lt;=10<span class="hljs-built_in">^</span>5，0&lt;=k&lt;=10<span class="hljs-built_in">^</span>5，1&lt;=ai &lt;=10<span class="hljs-built_in">^</span>6。<br><br>        输出描述<br>        输出仅包含一个正整数，表示答案。<br><br><br>        样例输入<br>        8 1<br>        58 57 86 89 25 26 61 42<br>        样例输出<br>        58<br></code></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">这道题是要求给定一个序列，你可以进行最多k次操作，每次操作可以删除序列中的某个连续区间，但是最后删除后剩余元素的最小值尽可能大。你需要输出这个最大的最小值。<br><br>举个例子，对于样例输入 [58, 57, 86, 89, 25, 26, 61, 42]，可以进行1次操作，比如删除区间[86,89]，剩下的序列为[58, 57, 25, 26, 61, 42]，此时剩余元素的最小值为25，最大的最小值就是25。你需要编写一个程序来自动寻找最大的最小值。<br></code></pre></td></tr></table></figure><h3 id="第三题.">第三题.</h3><h2 id="微众银行">5.10 微众银行</h2><h3 id="第一题">第一题</h3><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/Snipaste_2023-05-10_19-14-07.jpg" alt="Snipaste_2023-05-10_19-14-07" style="zoom:50%;" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs java">```<br><br><br><br>![<span class="hljs-number">1</span>](https:<span class="hljs-comment">//leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/1.jpg) </span><br><br>### 第二题<br><br>![第二题](https:<span class="hljs-comment">//leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/第二题.jpg) </span><br><br>```java<br><span class="hljs-keyword">package</span> 面试题.微众银行暑期实习.第<span class="hljs-number">2</span>题;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.Array;<br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Main</span> <span class="hljs-variable">main</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Main</span>();<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        scanner.nextLine();<br>        <span class="hljs-type">long</span>[] energy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n], score = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            energy[i] = scanner.nextLong();<br>        &#125;<br>        scanner.nextLine();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            score[i] = scanner.nextLong();<br>        &#125;<br>        <span class="hljs-type">long</span>[] res = main.process(n, k, energy, score);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> i : res)<br>            System.out.print(i + <span class="hljs-string">&quot; &quot;</span>);<br>    &#125;<br>    Queue&lt;Long&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span>[] process(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">long</span>[] energy, <span class="hljs-type">long</span>[] score) &#123;<br>        <span class="hljs-type">long</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n];<br>        Map&lt;Long, Long&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            map.put(energy[i], score[i]);<br>        &#125;<br>        <span class="hljs-type">long</span>[] oriEnery = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            oriEnery[i] = energy[i];<br>        Arrays.sort(energy);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> map.get(energy[i]);<br>            queue.offer(s);<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> map.get(energy[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; k; ++i) &#123;<br>            res[i] = sum;<br>            sum += map.get(energy[i]);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k; i &lt; n; ++i) &#123;<br>            res[i] = getKMax();<br>            <span class="hljs-type">long</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> map.get(energy[i]);<br>            <span class="hljs-keyword">if</span> (s &gt; queue.peek()) &#123;<br>                queue.poll();<br>                queue.offer(s);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">long</span>[] res2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n]; <span class="hljs-comment">//resAsOriginalSequence</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> oriEnery[i];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (; index &lt; n; ++index) &#123;<br>                <span class="hljs-keyword">if</span> (energy[index] == e)<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>            res2[i] = res[index];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res2;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getKMax</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Queue&lt;Long&gt; queue2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> queue.poll();<br>            sum += temp;<br>            queue2.offer(temp);<br>        &#125;<br>        queue = queue2;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/第二题AC.jpg" /></p><h3 id="第三题">第三题</h3><figure><img src="https://leopold-bucket.oss-cn-guangzhou.aliyuncs.com/img/第三题.jpg" alt="第三题" /><figcaption aria-hidden="true">第三题</figcaption></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Algorithms</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
